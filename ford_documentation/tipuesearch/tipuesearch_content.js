var tipuesearch = {"pages":[{"title":" Quest ","text":"Quest","tags":"home","loc":"index.html"},{"title":"GeomWrap – Quest ","text":"type, public :: GeomWrap Inherits type~~geomwrap~~InheritsGraph type~geomwrap GeomWrap type~bonds_t bonds_t type~geomwrap->type~bonds_t Bonds type~hamiltonian_t Hamiltonian_t type~geomwrap->type~hamiltonian_t Hamilt type~lattice_t lattice_t type~geomwrap->type~lattice_t Lattice type~pairing pairing type~geomwrap->type~pairing Pairs type~recip_lattice_t recip_lattice_t type~geomwrap->type~recip_lattice_t RecipLattice, GammaLattice type~symm_operations symm_operations type~geomwrap->type~symm_operations SymmOp Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( lattice_t ), public :: Lattice type( recip_lattice_t ), public :: RecipLattice type( recip_lattice_t ), public :: GammaLattice type( Hamiltonian_t ), public :: Hamilt type( bonds_t ), public :: Bonds type( symm_operations ), public :: SymmOp type( pairing ), public :: Pairs","tags":"","loc":"type/geomwrap.html"},{"title":"Hamiltonian_t – Quest ","text":"type, public :: Hamiltonian_t Inherited by type~~hamiltonian_t~~InheritedByGraph type~hamiltonian_t Hamiltonian_t type~geomwrap GeomWrap type~geomwrap->type~hamiltonian_t Hamilt Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: nJsites integer, public :: nUsites integer, public :: ntsites integer, public :: maxneig integer, public, pointer :: tnneig (:) integer, public, pointer :: Unneig (:) integer, public, pointer :: Jnneig (:) integer, public, pointer :: tsite (:) integer, public, pointer :: Usite (:) integer, public, pointer :: Jsite (:) integer, public, pointer :: tneig (:,:) integer, public, pointer :: Uneig (:,:) integer, public, pointer :: Jneig (:,:) integer, public, pointer :: tckb (:,:) real(kind=8), public :: mu_up real(kind=8), public :: mu_dn real(kind=8), public, pointer :: Uv (:,:) real(kind=8), public, pointer :: Jv (:,:) real(kind=8), public, pointer :: Uvalue (:) real(kind=8), public, pointer :: muupvalue (:) real(kind=8), public, pointer :: mudnvalue (:) complex(kind=16), public, pointer :: hopup (:,:) complex(kind=16), public, pointer :: hopdn (:,:) complex(kind=16), public, pointer :: tupvalue (:) complex(kind=16), public, pointer :: tdnvalue (:) complex(kind=16), public, pointer :: phase (:) integer, public :: nhopclass integer, public :: nlocclass integer, public, pointer :: mylocclass (:) integer, public, pointer :: myhopclass (:,:) integer, public :: nplink integer, public, pointer :: plink (:,:) real(kind=wp), public, pointer :: tlink (:,:) logical, public :: constructed logical, public :: neig_found logical, public :: analyzed","tags":"","loc":"type/hamiltonian_t.html"},{"title":"CCS – Quest ","text":"type, public :: CCS Inherited by type~~ccs~~InheritedByGraph type~ccs CCS type~struct Struct type~struct->type~ccs T, B, ckb type~tdm2 TDM2 type~tdm2->type~ccs Bond type~hubbard Hubbard type~hubbard->type~struct S type~hubbard~2 Hubbard type~hubbard~2->type~struct S Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: nnz integer, public, pointer :: A (:) integer, public, pointer :: row (:) integer, public, pointer :: cstart (:)","tags":"","loc":"type/ccs.html"},{"title":"Struct – Quest ","text":"type, public :: Struct Inherits type~~struct~~InheritsGraph type~struct Struct type~ccs CCS type~struct->type~ccs T, B, ckb Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~struct~~InheritedByGraph type~struct Struct type~hubbard Hubbard type~hubbard->type~struct S type~hubbard~2 Hubbard type~hubbard~2->type~struct S Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: nSite integer, public :: nCell character(len=gname_len), public :: name integer, public, pointer :: dim (:) integer, public :: n_t type( CCS ), public :: T integer, public :: nClass integer, public, pointer :: D (:,:) integer, public, pointer :: F (:) integer, public :: nGroup integer, public, pointer :: map (:) integer, public, pointer :: gf_phase (:,:) integer, public, pointer :: chi_phase (:,:) integer, public :: n_b type( CCS ), public :: B integer, public :: nClass_b integer, public, pointer :: class_b (:,:) integer, public, pointer :: size_b (:) type( CCS ), public :: ckb integer, public :: nckb real(kind=wp), public, pointer :: W (:,:) integer, public :: nWave integer, public :: nirrep integer, public, pointer :: wrepr (:) integer, public :: nwclass integer, public, pointer :: wclass (:) character(len=label_len), public, pointer :: clabel (:) character(len=label_len), public, pointer :: wlabel (:) real(kind=wp), public, pointer :: P (:) real(kind=wp), public, pointer :: FT (:,:) logical, public :: checklist (N_CHECKLIST)","tags":"","loc":"type/struct.html"},{"title":"Param – Quest ","text":"type, public :: Param Inherited by type~~param~~InheritedByGraph type~param Param type~param->type~param next type~config config type~config->type~param record Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: id character(len=slen), public :: pname integer, public :: ptype logical, public :: isArray logical, public :: isSet character(len=slen), public :: defaultval type( Param ), public, pointer :: next integer, public :: ival real(kind=wp), public :: rval integer, public, pointer :: iptr (:) real(kind=wp), public, pointer :: rptr (:)","tags":"","loc":"type/param.html"},{"title":"config – Quest ","text":"type, public :: config Inherits type~~config~~InheritsGraph type~config config type~param Param type~config->type~param record type~param->type~param next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( Param ), public, pointer :: record (:) integer, public :: nParam logical, public :: hasDef = .false.","tags":"","loc":"type/config.html"},{"title":"kbonds_t – Quest ","text":"type, public :: kbonds_t Components Type Visibility Attributes Name Initial integer, public :: nak integer, public :: nbonds integer, public :: nmomenta integer, public, pointer :: map_symm_ak (:,:) integer, public, pointer :: map_symm_bak (:,:,:) integer, public, pointer :: class_size (:,:) integer, public, pointer :: myclass (:,:,:) integer, public, pointer :: nclass (:) integer, public, pointer :: bond_origin (:,:) integer, public, pointer :: bond_target (:,:) integer, public, pointer :: bmap (:,:,:) real(kind=wp), public, pointer :: ksum (:,:)","tags":"","loc":"type/kbonds_t.html"},{"title":"TDM2 – Quest ","text":"type, public :: TDM2 Inherits type~~tdm2~~InheritsGraph type~tdm2 TDM2 type~ccs CCS type~tdm2->type~ccs Bond Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=wp), public, pointer :: Pair (:,:,:) real(kind=wp), public, pointer :: Apair (:,:,:) real(kind=wp), public, pointer :: Bpair (:,:,:) real(kind=wp), public, pointer :: Npair (:,:,:) integer, public :: n integer, public :: nClass integer, public :: nB integer, public :: nWave integer, public :: L integer, public :: itvl real(kind=wp), public :: dtau type( CCS ), public, pointer :: Bond integer, public, pointer :: D (:,:,:) integer, public, pointer :: SD (:,:) real(kind=wp), public, pointer :: Wave (:,:) real(kind=wp), public, pointer :: T (:,:) integer, public :: ldt character(len=label_len), public, pointer :: label (:)","tags":"","loc":"type/tdm2.html"},{"title":"Hubbard – Quest ","text":"type, public :: Hubbard Inherits type~~hubbard~~InheritsGraph type~hubbard Hubbard type~g_fun G_fun type~hubbard->type~g_fun G_up, G_dn type~matb matB type~hubbard->type~matb B_up, B_dn type~phy0 Phy0 type~hubbard->type~phy0 P0 type~phy2 Phy2 type~hubbard->type~phy2 P2 type~seqb SeqB type~hubbard->type~seqb SB_up, SB_dn type~struct Struct type~hubbard->type~struct S type~wspace WSpace type~hubbard->type~wspace WS type~seqb->type~matb B type~ccs CCS type~struct->type~ccs T, B, ckb Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: L integer, public :: n_U real(kind=wp), public, pointer :: U (:) integer, public :: n_t real(kind=wp), public, pointer :: t_up (:) real(kind=wp), public, pointer :: t_dn (:) integer, public :: n_mu real(kind=wp), public, pointer :: mu_up (:) real(kind=wp), public, pointer :: mu_dn (:) real(kind=wp), public :: dtau integer, public, pointer :: HSF (:,:) real(kind=wp), public, pointer :: CHSF (:,:) integer, public :: HSFtype logical, public :: outputHSF logical, public :: continuous real(kind=wp), public :: delta1 real(kind=wp), public :: delta2 real(kind=wp), public, pointer :: lambda (:) integer, public :: n_start integer, public :: n_end type( Struct ), public :: S type( matB ), public :: B_up type( SeqB ), public :: SB_up type( matB ), public :: B_dn type( SeqB ), public :: SB_dn type( G_fun ), public :: G_up type( G_fun ), public :: G_dn real(kind=wp), public, pointer :: V_up (:,:) real(kind=wp), public, pointer :: V_dn (:,:) integer, public :: idum integer, public :: seed (4) real(kind=wp), public, pointer :: explook (:,:) logical, public :: comp_dn logical, public :: neg_u integer, public :: nWarm integer, public :: nPass integer, public :: nTry real(kind=wp), public :: gamma integer, public :: nAccept integer, public :: nReject integer, public :: nAcceptGlobal integer, public :: nRejectGlobal type( Phy0 ), public :: P0 type( Phy2 ), public :: P2 integer, public :: nMeas integer, public :: tausk logical, public :: meas2 type( WSpace ), public :: WS integer, public :: OUT_UNIT","tags":"","loc":"type/hubbard.html"},{"title":"recip_lattice_t – Quest ","text":"type, public :: recip_lattice_t Inherited by type~~recip_lattice_t~~InheritedByGraph type~recip_lattice_t recip_lattice_t type~geomwrap GeomWrap type~geomwrap->type~recip_lattice_t RecipLattice, GammaLattice Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: ndim integer, public :: nkpts real(kind=8), public, pointer :: klist (:,:) real(kind=8), public :: kpoint (rdim) real(kind=8), public :: ktwist (rdim) real(kind=8), public :: kcs (rdim,rdim) real(kind=8), public :: ks (rdim,rdim) real(kind=8), public :: kc (rdim,rdim) ** rows of these matrices are the vectors integer, public :: nmomenta real(kind=8), public, pointer :: ksum (:,:) integer, public, pointer :: kmate (:,:) integer, public :: nclass_k integer, public, pointer :: myclass_k (:) integer, public, pointer :: class_size_k (:) integer, public, pointer :: class_repr_k (:) complex(kind=16), public, pointer :: FourierC (:,:) logical, public :: initialized logical, public :: constructed logical, public :: analyzed","tags":"","loc":"type/recip_lattice_t.html"},{"title":"matB – Quest ","text":"type, public :: matB Inherited by type~~matb~~InheritedByGraph type~matb matB type~gtau Gtau type~gtau->type~matb B_up, B_dn type~hubbard Hubbard type~hubbard->type~matb B_up, B_dn type~seqb SeqB type~hubbard->type~seqb SB_up, SB_dn type~hubbard~2 Hubbard type~hubbard~2->type~matb B_up, B_dn type~hubbard~2->type~seqb SB_up, SB_dn type~seqb->type~matb B Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: n real(kind=wp), public, pointer :: K (:,:) real(kind=wp), public, pointer :: B (:,:) real(kind=wp), public, pointer :: Bi (:,:) real(kind=wp), public, pointer :: rtB (:,:) real(kind=wp), public, pointer :: rtBi (:,:) character(len=12), public :: name logical, public :: exactb","tags":"","loc":"type/matb.html"},{"title":"symm_operations – Quest ","text":"type, public :: symm_operations Inherited by type~~symm_operations~~InheritedByGraph type~symm_operations symm_operations type~geomwrap GeomWrap type~geomwrap->type~symm_operations SymmOp Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: ntotsymm integer, public :: nsymm integer, public :: ntransl integer, public, pointer :: map_symm (:,:) integer, public, pointer :: map_symm_k (:,:) integer, public, pointer :: map_symm_g (:,:) integer, public, pointer :: map_symm_b (:,:) integer, public, pointer :: map_symm_p (:,:) integer, public, pointer :: translback (:) integer, public, pointer :: translate (:,:) integer, public, pointer :: valid_symm (:) real(kind=8), public, pointer :: symmangle (:) real(kind=8), public, pointer :: symmpoint (:,:) real(kind=8), public, pointer :: symmaxis (:,:) character(len=1), public, pointer :: symmlabel (:) logical, public :: initialized logical, public :: lattice_mapped logical, public :: recip_lattice_mapped logical, public :: bonds_mapped logical, public :: addTimeRev","tags":"","loc":"type/symm_operations.html"},{"title":"Hubbard – Quest ","text":"type, public :: Hubbard Inherits type~~hubbard~2~~InheritsGraph type~hubbard~2 Hubbard type~g_fun G_fun type~hubbard~2->type~g_fun G_up, G_dn type~matb matB type~hubbard~2->type~matb B_up, B_dn type~phy0 Phy0 type~hubbard~2->type~phy0 P0 type~phy2 Phy2 type~hubbard~2->type~phy2 P2 type~seqb SeqB type~hubbard~2->type~seqb SB_up, SB_dn type~struct Struct type~hubbard~2->type~struct S type~wspace WSpace type~hubbard~2->type~wspace WS type~seqb->type~matb B type~ccs CCS type~struct->type~ccs T, B, ckb Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: L integer, public :: n_U real(kind=wp), public, pointer :: U (:) integer, public :: n_t real(kind=wp), public, pointer :: t_up (:) real(kind=wp), public, pointer :: t_dn (:) integer, public :: n_mu real(kind=wp), public, pointer :: mu_up (:) real(kind=wp), public, pointer :: mu_dn (:) real(kind=wp), public :: dtau integer, public, pointer :: HSF (:,:) real(kind=wp), public, pointer :: CHSF (:,:) integer, public :: HSFtype logical, public :: outputHSF logical, public :: continuous real(kind=wp), public :: delta1 real(kind=wp), public :: delta2 real(kind=wp), public, pointer :: lambda (:) integer, public :: n_start integer, public :: n_end real(kind=wp), public :: omega type( Struct ), public :: S type( matB ), public :: B_up type( SeqB ), public :: SB_up type( matB ), public :: B_dn type( SeqB ), public :: SB_dn type( G_fun ), public :: G_up type( G_fun ), public :: G_dn real(kind=wp), public, pointer :: V_up (:,:) real(kind=wp), public, pointer :: V_dn (:,:) integer, public :: idum integer, public :: seed (4) real(kind=wp), public, pointer :: explook (:,:) logical, public :: comp_dn logical, public :: neg_u integer, public :: nWarm integer, public :: nPass integer, public :: nTry real(kind=wp), public :: gamma integer, public :: nAccept integer, public :: nReject integer, public :: nAcceptGlobal integer, public :: nRejectGlobal integer, public :: nAcceptGlobal2 integer, public :: nRejectGlobal2 type( Phy0 ), public :: P0 type( Phy2 ), public :: P2 integer, public :: nMeas integer, public :: tausk logical, public :: meas2 type( WSpace ), public :: WS integer, public :: OUT_UNIT","tags":"","loc":"type/hubbard~2.html"},{"title":"matB – Quest ","text":"type, public :: matB Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: m integer, public, pointer :: A (:,:) real(kind=wp), public, pointer :: sinht (:) real(kind=wp), public, pointer :: cosht (:) real(kind=wp), public, pointer :: exptaumu (:) real(kind=wp), public, pointer :: work (:) character(len=12), public :: name logical, public :: exactb","tags":"","loc":"type/matb~2.html"},{"title":"MPI_SIMOR – Quest ","text":"type, public :: MPI_SIMOR Components Type Visibility Attributes Name Initial integer, public :: level integer, public :: rank integer, public :: size integer, public :: aggr_rank integer, public :: meas_rank integer, public :: gfun_rank integer, public :: aggr_size integer, public :: meas_size integer, public :: gfun_size integer, public :: aggr_root integer, public :: meas_root integer, public :: gfun_root integer, public :: aggr_comm integer, public :: meas_comm integer, public :: gfun_comm","tags":"","loc":"type/mpi_simor.html"},{"title":"SeqB – Quest ","text":"type, public :: SeqB Inherits type~~seqb~~InheritsGraph type~seqb SeqB type~matb matB type~seqb->type~matb B Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~seqb~~InheritedByGraph type~seqb SeqB type~hubbard Hubbard type~hubbard->type~seqb SB_up, SB_dn type~hubbard~2 Hubbard type~hubbard~2->type~seqb SB_up, SB_dn Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: L integer, public :: nOrth type( matB ), public, pointer :: B real(kind=wp), public, pointer :: U (:,:) real(kind=wp), public, pointer :: D (:) real(kind=wp), public, pointer :: T (:,:) real(kind=wp), public, pointer :: W1 (:,:) real(kind=wp), public, pointer :: W2 (:,:) real(kind=wp), public, pointer :: W3 (:,:) real(kind=wp), public, pointer :: rw (:) real(kind=wp), public, pointer :: tau (:) integer, public, pointer :: piv (:) integer, public, pointer :: lw (:)","tags":"","loc":"type/seqb.html"},{"title":"Gtau – Quest ","text":"type, public :: Gtau Inherits type~~gtau~~InheritsGraph type~gtau Gtau type~matb matB type~gtau->type~matb B_up, B_dn Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: L integer, public :: nb integer, public :: nnb integer, public :: it_up integer, public :: i0_up integer, public :: it_dn integer, public :: i0_dn integer, public :: north integer, public :: which integer, public :: sfc real(kind=wp), public, pointer :: upt0 (:,:) real(kind=wp), public, pointer :: up0t (:,:) real(kind=wp), public, pointer :: dnt0 (:,:) real(kind=wp), public, pointer :: dn0t (:,:) real(kind=wp), public, pointer :: up00 (:,:) real(kind=wp), public, pointer :: uptt (:,:) real(kind=wp), public, pointer :: dn00 (:,:) real(kind=wp), public, pointer :: dntt (:,:) real(kind=wp), public, pointer :: A_up (:,:) real(kind=wp), public, pointer :: A_dn (:,:) integer, public, pointer :: itau_up (:) integer, public, pointer :: itau_dn (:) type( matB ), public, pointer :: B_up type( matB ), public, pointer :: B_dn real(kind=wp), public, pointer :: V_up (:,:) real(kind=wp), public, pointer :: V_dn (:,:) real(kind=wp), public, pointer :: P (:) logical, public :: comp_dn logical, public :: neg_u real(kind=wp), public, pointer :: sgnup real(kind=wp), public, pointer :: sgndn integer, public :: lw integer, public, pointer :: IW (:) real(kind=wp), public, pointer :: W1 (:) real(kind=wp), public, pointer :: W2 (:,:) real(kind=wp), public, pointer :: W3 (:,:) logical, public :: g0_stored = .false. real(kind=wp), public, pointer :: e0up (:) real(kind=wp), public, pointer :: e0dn (:) real(kind=wp), public, pointer :: U0up (:,:) real(kind=wp), public, pointer :: U0dn (:,:)","tags":"","loc":"type/gtau.html"},{"title":"bonds_t – Quest ","text":"type, public :: bonds_t Inherited by type~~bonds_t~~InheritedByGraph type~bonds_t bonds_t type~geomwrap GeomWrap type~geomwrap->type~bonds_t Bonds Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: ntotbond integer, public, pointer :: bond_label (:) integer, public, pointer :: bond_origin (:) integer, public, pointer :: bond_target (:) real(kind=wp), public, pointer :: xxbond (:,:) integer, public :: nclass_b integer, public, pointer :: myclass_b (:,:) integer, public, pointer :: class_size_b (:) logical, public :: initialized logical, public :: analyzed","tags":"","loc":"type/bonds_t.html"},{"title":"pairing – Quest ","text":"type, public :: pairing Inherited by type~~pairing~~InheritedByGraph type~pairing pairing type~geomwrap GeomWrap type~geomwrap->type~pairing Pairs Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: nwave integer, public :: nbond integer, public, pointer :: nbondv (:) integer, public, pointer :: bond_origin (:,:) integer, public, pointer :: bond_end (:,:) integer, public, pointer :: bond_map (:) integer, public, pointer :: pair_map (:) integer, public, pointer :: bond_number (:,:) real(kind=wp), public, pointer :: bond_wgt (:,:) character(len=20), public, pointer :: wave_label (:) integer, public, pointer :: myclass_p (:,:) integer, public :: nclass_p integer, public, pointer :: class_size_p (:) logical, public :: initialized","tags":"","loc":"type/pairing.html"},{"title":"Phy0 – Quest ","text":"type, public :: Phy0 Inherited by type~~phy0~~InheritedByGraph type~phy0 Phy0 type~hubbard Hubbard type~hubbard->type~phy0 P0 type~hubbard~2 Hubbard type~hubbard~2->type~phy0 P0 Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: nClass integer, public :: nBin integer, public :: nMeas integer, public :: avg integer, public :: err integer, public :: cnt integer, public :: idx integer, public :: n real(kind=wp), public :: beta real(kind=wp), public, pointer :: meas (:,:) real(kind=wp), public, pointer :: sign (:,:) integer, public :: IARR (0:narrays+1) integer, public :: IARRFT (1:narrays+1) integer, public :: IARREV (1:narrays+1) real(kind=wp), public, pointer :: AllProp (:,:) real(kind=wp), public, pointer :: AllPropFT (:,:) real(kind=wp), public, pointer :: AllPropEigVal (:,:) complex(kind=16), public, pointer :: AllPropEigVec (:,:,:,:) real(kind=wp), public, pointer :: G_fun (:,:) real(kind=wp), public, pointer :: Gf_up (:,:) real(kind=wp), public, pointer :: Gf_dn (:,:) real(kind=wp), public, pointer :: SpinXX (:,:) real(kind=wp), public, pointer :: SpinZZ (:,:) real(kind=wp), public, pointer :: AveSpin (:,:) real(kind=wp), public, pointer :: Den0 (:,:) real(kind=wp), public, pointer :: Den1 (:,:) real(kind=wp), public, pointer :: Pair (:,:) real(kind=wp), public, pointer :: up (:) real(kind=wp), public, pointer :: dn (:) logical, public :: compSAF logical, public :: init logical, public :: initFT","tags":"","loc":"type/phy0.html"},{"title":"G_fun – Quest ","text":"type, public :: G_fun Inherited by type~~g_fun~~InheritedByGraph type~g_fun G_fun type~hubbard Hubbard type~hubbard->type~g_fun G_up, G_dn type~hubbard~2 Hubbard type~hubbard~2->type~g_fun G_up, G_dn Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: L real(kind=wp), public :: sgn real(kind=wp), public, pointer :: G (:,:) logical, public :: owns_G real(kind=wp), public, pointer :: V (:,:) integer, public :: ilb real(kind=wp), public :: det integer, public, pointer :: pvt (:) real(kind=wp), public, pointer :: tmp (:,:) integer, public :: nWrap integer, public :: wps integer, public :: lastwr integer, public :: maxwrap integer, public :: fixwrap real(kind=wp), public :: difflim real(kind=wp), public :: errrate integer, public :: redo integer, public :: noredo integer, public :: nBlk integer, public :: blkSz real(kind=wp), public, pointer :: U (:,:) real(kind=wp), public, pointer :: W (:,:) integer, public :: nModify real(kind=wp), public, pointer :: GS (:,:) real(kind=wp), public, pointer :: WS (:,:) logical, public :: sxx","tags":"","loc":"type/g_fun.html"},{"title":"Phy2 – Quest ","text":"type, public :: Phy2 Inherited by type~~phy2~~InheritedByGraph type~phy2 Phy2 type~hubbard Hubbard type~hubbard->type~phy2 P2 type~hubbard~2 Hubbard type~hubbard~2->type~phy2 P2 Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: nb integer, public :: nWave integer, public :: nBin integer, public :: idx integer, public :: cnt integer, public :: ncell integer, public :: avg integer, public :: err real(kind=wp), public, pointer :: sgn (:) real(kind=wp), public, pointer :: M1 (:,:) real(kind=wp), public, pointer :: M2 (:,:) real(kind=wp), public, pointer :: M3 (:,:) real(kind=wp), public, pointer :: M4 (:,:) real(kind=wp), public, pointer :: M5 (:,:) real(kind=wp), public, pointer :: T (:,:) integer, public :: ldt integer, public :: nData logical, public :: compute logical, public :: connected logical, public :: diagonalize = .false.","tags":"","loc":"type/phy2.html"},{"title":"WSpace – Quest ","text":"type, public :: WSpace Inherited by type~~wspace~~InheritedByGraph type~wspace WSpace type~hubbard Hubbard type~hubbard->type~wspace WS type~hubbard~2 Hubbard type~hubbard~2->type~wspace WS Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: lw (5) real(kind=wp), public, pointer :: R1 (:,:) real(kind=wp), public, pointer :: R2 (:,:) real(kind=wp), public, pointer :: R3 (:,:) real(kind=wp), public, pointer :: R4 (:,:) real(kind=wp), public, pointer :: R5 (:) real(kind=wp), public, pointer :: R6 (:) real(kind=wp), public, pointer :: R7 (:) real(kind=wp), public, pointer :: R8 (:,:) integer, public, pointer :: I1 (:) integer, public, pointer :: I2 (:)","tags":"","loc":"type/wspace.html"},{"title":"tdmarray – Quest ","text":"type, public :: tdmarray Inherited by type~~tdmarray~~InheritedByGraph type~tdmarray tdmarray type~tdm1 TDM1 type~tdm1->type~tdmarray properties Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: nclass integer, public :: nk integer, public :: np integer, public, pointer :: D (:,:) integer, public, pointer :: F (:) integer, public, pointer :: phase (:,:) complex(kind=wp), public, pointer :: ftk (:,:) complex(kind=wp), public, pointer :: ftw (:,:) real(kind=wp), public, pointer :: values (:,:,:) complex(kind=wp), public, pointer :: valuesk (:,:,:) real(kind=wp), public, pointer :: tlink (:,:) character(len=label_len), public, pointer :: clabel (:)","tags":"","loc":"type/tdmarray.html"},{"title":"TDM1 – Quest ","text":"type, public :: TDM1 Inherits type~~tdm1~~InheritsGraph type~tdm1 TDM1 type~tdmarray tdmarray type~tdm1->type~tdmarray properties Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: L integer, public :: nbin integer, public :: avg integer, public :: err integer, public :: idx integer, public :: tmp integer, public :: cnt logical, public :: compute = .false. real(kind=wp), public :: dtau real(kind=wp), public, pointer :: sgn (:) type( tdmarray ), public, pointer :: properties (:) complex(kind=wp), public, pointer :: ftwfer (:,:) complex(kind=wp), public, pointer :: ftwbos (:,:)","tags":"","loc":"type/tdm1.html"},{"title":"lattice_t – Quest ","text":"type, public :: lattice_t Inherited by type~~lattice_t~~InheritedByGraph type~lattice_t lattice_t type~geomwrap GeomWrap type~geomwrap->type~lattice_t Lattice Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: nsites integer, public :: natom integer, public :: ncell integer, public :: ndim integer, public :: sc (rdim,rdim) real(kind=8), public :: ac (rdim,rdim) real(kind=8), public :: scc (rdim,rdim) real(kind=8), public, pointer :: pos (:,:) real(kind=8), public, pointer :: cartpos (:,:) real(kind=8), public, pointer :: xat (:,:) real(kind=8), public, pointer :: phase (:) real(kind=8), public, pointer :: translation (:,:) columns of these matrices are the vectors integer, public :: nclass integer, public, pointer :: myclass (:,:) integer, public, pointer :: class_size (:) real(kind=8), public, pointer :: class_label (:,:) integer, public, pointer :: gf_phase (:,:) character(len=3), public, pointer :: olabel (:) logical, public :: initialized logical, public :: constructed logical, public :: analyzed","tags":"","loc":"type/lattice_t.html"},{"title":"DQMC_Geom_Fill – Quest","text":"public  subroutine DQMC_Geom_Fill(gwrap, gfile, cfg, SOP) Arguments Type Intent Optional Attributes Name type( GeomWrap ), intent(inout) :: gwrap character(len=60), intent(in) :: gfile type( config ), intent(inout) :: cfg integer, intent(in) :: SOP Calls proc~~dqmc_geom_fill~~CallsGraph proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~analyze_input DQMC_GEOM_PARAM::analyze_input proc~dqmc_geom_fill->proc~analyze_input proc~assign_gf_phase DQMC_LATT::assign_gf_phase proc~dqmc_geom_fill->proc~assign_gf_phase proc~assign_phase DQMC_LATT::assign_phase proc~dqmc_geom_fill->proc~assign_phase proc~construct_bond_classes DQMC_SYMM::construct_bond_classes proc~dqmc_geom_fill->proc~construct_bond_classes proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~dqmc_geom_fill->proc~construct_hamilt proc~construct_lattice DQMC_LATT::construct_lattice proc~dqmc_geom_fill->proc~construct_lattice proc~construct_lattice_classes DQMC_SYMM::construct_lattice_classes proc~dqmc_geom_fill->proc~construct_lattice_classes proc~construct_pair_classes DQMC_SYMM::construct_pair_classes proc~dqmc_geom_fill->proc~construct_pair_classes proc~construct_pairs DQMC_BONDS::construct_pairs proc~dqmc_geom_fill->proc~construct_pairs proc~construct_recip_lattice DQMC_RECLATT::construct_recip_lattice proc~dqmc_geom_fill->proc~construct_recip_lattice proc~construct_recip_lattice_classes DQMC_SYMM::construct_recip_lattice_classes proc~dqmc_geom_fill->proc~construct_recip_lattice_classes proc~count_hop_class DQMC_HAMILT::count_hop_class proc~dqmc_geom_fill->proc~count_hop_class proc~count_local_classes DQMC_HAMILT::count_local_classes proc~dqmc_geom_fill->proc~count_local_classes proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_geom_fill->proc~dqmc_error proc~dqmc_fill_fourierc DQMC_RECLATT::DQMC_Fill_FourierC proc~dqmc_geom_fill->proc~dqmc_fill_fourierc proc~init_lattice DQMC_LATT::init_lattice proc~dqmc_geom_fill->proc~init_lattice proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~dqmc_geom_fill->proc~init_recip_latt proc~map_symm_bonds DQMC_SYMM::map_symm_bonds proc~dqmc_geom_fill->proc~map_symm_bonds proc~map_symm_lattice DQMC_SYMM::map_symm_lattice proc~dqmc_geom_fill->proc~map_symm_lattice proc~map_symm_pairs DQMC_SYMM::map_symm_pairs proc~dqmc_geom_fill->proc~map_symm_pairs proc~map_symm_recip_lattice DQMC_SYMM::map_symm_recip_lattice proc~dqmc_geom_fill->proc~map_symm_recip_lattice proc~read_bonds DQMC_BONDS::read_bonds proc~dqmc_geom_fill->proc~read_bonds proc~read_symm DQMC_SYMM::read_symm proc~dqmc_geom_fill->proc~read_symm proc~convert_to_fractional DQMC_LATT::convert_to_fractional proc~assign_phase->proc~convert_to_fractional proc~get_det DQMC_Util::get_det proc~assign_phase->proc~get_det proc~get_inverse DQMC_Util::get_inverse proc~assign_phase->proc~get_inverse proc~move_to_record DQMC_Util::move_to_record proc~assign_phase->proc~move_to_record interface~cfg_get DQMC_Cfg::CFG_Get proc~construct_hamilt->interface~cfg_get proc~dqmc_hamilt_groupckb DQMC_HAMILT::dqmc_hamilt_groupckb proc~construct_hamilt->proc~dqmc_hamilt_groupckb proc~find_neighbors DQMC_HAMILT::find_neighbors proc~construct_hamilt->proc~find_neighbors proc~hoptowho DQMC_LATT::hoptowho proc~construct_hamilt->proc~hoptowho proc~construct_hamilt->proc~move_to_record proc~construct_lattice->proc~get_inverse proc~construct_pairs->proc~hoptowho proc~construct_pairs->proc~move_to_record proc~closer_to_zero DQMC_RECLATT::closer_to_zero proc~construct_recip_lattice->proc~closer_to_zero proc~construct_recip_lattice->proc~get_inverse proc~init_lattice->proc~convert_to_fractional proc~count_atom DQMC_LATT::count_atom proc~init_lattice->proc~count_atom proc~init_lattice->proc~get_det proc~init_lattice->proc~get_inverse proc~init_lattice->proc~move_to_record proc~init_recip_latt->interface~cfg_get proc~init_recip_latt->proc~get_inverse proc~map_symm_bonds->proc~get_inverse proc~map_symm_bonds->proc~hoptowho proc~apply_point_symm DQMC_SYMM::apply_point_symm proc~map_symm_lattice->proc~apply_point_symm proc~map_symm_lattice->proc~get_inverse proc~map_symm_recip_lattice->proc~apply_point_symm proc~map_symm_recip_lattice->proc~get_inverse proc~read_bonds->proc~move_to_record proc~count_symmetry DQMC_SYMM::count_symmetry proc~read_symm->proc~count_symmetry proc~read_symm->proc~move_to_record proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI interface~cfg_get->proc~dqmc_config_geti proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI interface~cfg_get->proc~dqmc_config_getpi proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR interface~cfg_get->proc~dqmc_config_getpr proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR interface~cfg_get->proc~dqmc_config_getr proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS interface~cfg_get->proc~dqmc_config_gets proc~count_atom->proc~move_to_record proc~count_symmetry->proc~move_to_record proc~hoptowho->proc~get_inverse proc~dqmc_config_geti->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_geti->proc~dqmc_find_param proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_config_geti->proc~dqmc_warning proc~dqmc_config_getpi->proc~dqmc_error proc~dqmc_config_getpi->proc~dqmc_find_param proc~dqmc_config_getpi->proc~dqmc_warning proc~dqmc_config_getpr->proc~dqmc_error proc~dqmc_config_getpr->proc~dqmc_find_param proc~dqmc_config_getpr->proc~dqmc_warning proc~dqmc_config_getr->proc~dqmc_error proc~dqmc_config_getr->proc~dqmc_find_param proc~dqmc_config_getr->proc~dqmc_warning proc~dqmc_config_gets->proc~dqmc_error proc~dqmc_config_gets->proc~dqmc_find_param proc~dqmc_config_gets->proc~dqmc_warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_geom_fill~~CalledByGraph proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_geom_fill.html"},{"title":"DQMC_Geom_Init – Quest","text":"public  subroutine DQMC_Geom_Init(gwrap, S, cfg) Arguments Type Intent Optional Attributes Name type( GeomWrap ), intent(in) :: gwrap type( Struct ), intent(inout) :: S type( config ), intent(inout) :: cfg Calls proc~~dqmc_geom_init~~CallsGraph proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init interface~cfg_set DQMC_Cfg::CFG_Set proc~dqmc_geom_init->interface~cfg_set proc~dqmc_ccs_compress DQMC_STRUCT::DQMC_CCS_Compress proc~dqmc_geom_init->proc~dqmc_ccs_compress proc~group_hopping DQMC_HAMILT::group_hopping proc~dqmc_geom_init->proc~group_hopping proc~dqmc_config_seti DQMC_Cfg::DQMC_Config_SetI interface~cfg_set->proc~dqmc_config_seti proc~dqmc_config_setpi DQMC_Cfg::DQMC_Config_SetPI interface~cfg_set->proc~dqmc_config_setpi proc~dqmc_config_setpr DQMC_Cfg::DQMC_Config_SetPR interface~cfg_set->proc~dqmc_config_setpr proc~dqmc_config_setr DQMC_Cfg::DQMC_Config_SetR interface~cfg_set->proc~dqmc_config_setr proc~dqmc_config_sets DQMC_Cfg::DQMC_Config_SetS interface~cfg_set->proc~dqmc_config_sets proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_ccs_compress->proc~dqmc_error proc~dqmc_config_seti->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_seti->proc~dqmc_find_param proc~dqmc_config_setpi->proc~dqmc_error proc~dqmc_config_setpi->proc~dqmc_find_param proc~dqmc_config_setpr->proc~dqmc_error proc~dqmc_config_setpr->proc~dqmc_find_param proc~dqmc_config_setr->proc~dqmc_error proc~dqmc_config_setr->proc~dqmc_find_param proc~dqmc_config_sets->proc~dqmc_error proc~dqmc_config_sets->proc~dqmc_find_param Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_geom_init~~CalledByGraph proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_geom_init.html"},{"title":"DQMC_Print_HeaderFT – Quest","text":"public  subroutine DQMC_Print_HeaderFT(Gwrap, OPT, applytwist) Uses DQMC_MPI proc~~dqmc_print_headerft~~UsesGraph proc~dqmc_print_headerft DQMC_GEOM_WRAP::DQMC_Print_HeaderFT module~dqmc_mpi DQMC_MPI proc~dqmc_print_headerft->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( GeomWrap ), intent(in) :: Gwrap integer, intent(in) :: OPT logical, intent(in) :: applytwist Called by proc~~dqmc_print_headerft~~CalledByGraph proc~dqmc_print_headerft DQMC_GEOM_WRAP::DQMC_Print_HeaderFT program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_print_headerft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_print_headerft.html"},{"title":"free_hamilt – Quest","text":"public  subroutine free_hamilt(hamilt) Arguments Type Intent Optional Attributes Name type( Hamiltonian_t ), intent(inout) :: hamilt","tags":"","loc":"proc/free_hamilt.html"},{"title":"construct_hamilt – Quest","text":"public  subroutine construct_hamilt(hamilt, lattice, recip_lattice, cfg) Arguments Type Intent Optional Attributes Name type( Hamiltonian_t ), intent(out) :: hamilt type( lattice_t ), intent(in), target :: lattice type( recip_lattice_t ), intent(in) :: recip_lattice type( config ), intent(inout) :: cfg Calls proc~~construct_hamilt~~CallsGraph proc~construct_hamilt DQMC_HAMILT::construct_hamilt interface~cfg_get DQMC_Cfg::CFG_Get proc~construct_hamilt->interface~cfg_get proc~dqmc_hamilt_groupckb DQMC_HAMILT::dqmc_hamilt_groupckb proc~construct_hamilt->proc~dqmc_hamilt_groupckb proc~find_neighbors DQMC_HAMILT::find_neighbors proc~construct_hamilt->proc~find_neighbors proc~hoptowho DQMC_LATT::hoptowho proc~construct_hamilt->proc~hoptowho proc~move_to_record DQMC_Util::move_to_record proc~construct_hamilt->proc~move_to_record proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI interface~cfg_get->proc~dqmc_config_geti proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI interface~cfg_get->proc~dqmc_config_getpi proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR interface~cfg_get->proc~dqmc_config_getpr proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR interface~cfg_get->proc~dqmc_config_getr proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS interface~cfg_get->proc~dqmc_config_gets proc~get_inverse DQMC_Util::get_inverse proc~hoptowho->proc~get_inverse proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_geti->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_geti->proc~dqmc_find_param proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_config_geti->proc~dqmc_warning proc~dqmc_config_getpi->proc~dqmc_error proc~dqmc_config_getpi->proc~dqmc_find_param proc~dqmc_config_getpi->proc~dqmc_warning proc~dqmc_config_getpr->proc~dqmc_error proc~dqmc_config_getpr->proc~dqmc_find_param proc~dqmc_config_getpr->proc~dqmc_warning proc~dqmc_config_getr->proc~dqmc_error proc~dqmc_config_getr->proc~dqmc_find_param proc~dqmc_config_getr->proc~dqmc_warning proc~dqmc_config_gets->proc~dqmc_error proc~dqmc_config_gets->proc~dqmc_find_param proc~dqmc_config_gets->proc~dqmc_warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~construct_hamilt~~CalledByGraph proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~construct_hamilt program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_hamilt.html"},{"title":"find_neighbors – Quest","text":"public  subroutine find_neighbors(hamilt) Arguments Type Intent Optional Attributes Name type( Hamiltonian_t ), intent(inout) :: hamilt Called by proc~~find_neighbors~~CalledByGraph proc~find_neighbors DQMC_HAMILT::find_neighbors proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->proc~find_neighbors proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~construct_hamilt program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/find_neighbors.html"},{"title":"count_hop_class – Quest","text":"public  subroutine count_hop_class(lattice, hamilt) Arguments Type Intent Optional Attributes Name type( lattice_t ) :: lattice type( Hamiltonian_t ) :: hamilt Called by proc~~count_hop_class~~CalledByGraph proc~count_hop_class DQMC_HAMILT::count_hop_class proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~count_hop_class program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/count_hop_class.html"},{"title":"count_local_classes – Quest","text":"public  subroutine count_local_classes(lattice, hamilt) Arguments Type Intent Optional Attributes Name type( lattice_t ), intent(in) :: lattice type( Hamiltonian_t ), intent(inout) :: hamilt Called by proc~~count_local_classes~~CalledByGraph proc~count_local_classes DQMC_HAMILT::count_local_classes proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~count_local_classes program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/count_local_classes.html"},{"title":"dqmc_hamilt_groupckb – Quest","text":"public  subroutine dqmc_hamilt_groupckb(hamilt) Arguments Type Intent Optional Attributes Name type( Hamiltonian_t ), intent(inout) :: hamilt Called by proc~~dqmc_hamilt_groupckb~~CalledByGraph proc~dqmc_hamilt_groupckb DQMC_HAMILT::dqmc_hamilt_groupckb proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->proc~dqmc_hamilt_groupckb proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~construct_hamilt program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hamilt_groupckb.html"},{"title":"group_hopping – Quest","text":"public  subroutine group_hopping(hamilt, n, nt, tmap, tupvalue, tdnvalue) Arguments Type Intent Optional Attributes Name type( Hamiltonian_t ), intent(in) :: hamilt integer, intent(in) :: n integer, intent(out) :: nt integer, intent(out) :: tmap (n,n) real(kind=8), intent(inout), pointer :: tupvalue (:) real(kind=8), intent(inout), pointer :: tdnvalue (:) Called by proc~~group_hopping~~CalledByGraph proc~group_hopping DQMC_HAMILT::group_hopping proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init proc~dqmc_geom_init->proc~group_hopping program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/group_hopping.html"},{"title":"DQMC_CCS_Free – Quest","text":"public  subroutine DQMC_CCS_Free(sparA) Arguments Type Intent Optional Attributes Name type( CCS ), intent(inout) :: sparA Called by proc~~dqmc_ccs_free~~CalledByGraph proc~dqmc_ccs_free DQMC_STRUCT::DQMC_CCS_Free proc~dqmc_struct_free DQMC_STRUCT::DQMC_Struct_Free proc~dqmc_struct_free->proc~dqmc_ccs_free proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free->proc~dqmc_struct_free proc~dqmc_hub_free~2 DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free~2->proc~dqmc_struct_free proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_free program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_free program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_free program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_ccs_free.html"},{"title":"DQMC_CCS_Print – Quest","text":"public  subroutine DQMC_CCS_Print(sparA, OPT) Arguments Type Intent Optional Attributes Name type( CCS ), intent(in) :: sparA integer, intent(in) :: OPT Called by proc~~dqmc_ccs_print~~CalledByGraph proc~dqmc_ccs_print DQMC_STRUCT::DQMC_CCS_Print proc~dqmc_geom_print DQMC_STRUCT::DQMC_Geom_Print proc~dqmc_geom_print->proc~dqmc_ccs_print program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_ccs_print.html"},{"title":"DQMC_CCS_Compress – Quest","text":"public  subroutine DQMC_CCS_Compress(n, nnz, A, sparA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: nnz integer, intent(in) :: A (:,:) type( CCS ), intent(inout) :: sparA Calls proc~~dqmc_ccs_compress~~CallsGraph proc~dqmc_ccs_compress DQMC_STRUCT::DQMC_CCS_Compress proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_ccs_compress->proc~dqmc_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_ccs_compress~~CalledByGraph proc~dqmc_ccs_compress DQMC_STRUCT::DQMC_CCS_Compress proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init proc~dqmc_geom_init->proc~dqmc_ccs_compress proc~dqmc_geom_read_def DQMC_STRUCT::DQMC_Geom_Read_Def proc~dqmc_geom_read_def->proc~dqmc_ccs_compress proc~dqmc_init_2dperl DQMC_2DPERL::DQMC_Init_2DPerl proc~dqmc_init_2dperl->proc~dqmc_ccs_compress proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_init_2dperl program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_init program~dqmc_ggeom->proc~dqmc_geom_read_def program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_init_2dperl program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_ccs_compress.html"},{"title":"DQMC_CCS_Fill – Quest","text":"public  subroutine DQMC_CCS_Fill(n, A, sparA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(inout) :: A (:,:) type( CCS ), intent(in) :: sparA Called by proc~~dqmc_ccs_fill~~CalledByGraph proc~dqmc_ccs_fill DQMC_STRUCT::DQMC_CCS_Fill proc~dqmc_b_init~2 DQMC_CheckerBoard::DQMC_B_Init proc~dqmc_b_init~2->proc~dqmc_ccs_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_ccs_fill.html"},{"title":"DQMC_Struct_Free – Quest","text":"public  subroutine DQMC_Struct_Free(S) Arguments Type Intent Optional Attributes Name type( Struct ), intent(inout) :: S Calls proc~~dqmc_struct_free~~CallsGraph proc~dqmc_struct_free DQMC_STRUCT::DQMC_Struct_Free proc~dqmc_ccs_free DQMC_STRUCT::DQMC_CCS_Free proc~dqmc_struct_free->proc~dqmc_ccs_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_struct_free~~CalledByGraph proc~dqmc_struct_free DQMC_STRUCT::DQMC_Struct_Free proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free->proc~dqmc_struct_free proc~dqmc_hub_free~2 DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free~2->proc~dqmc_struct_free proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_free program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_free program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_free program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_struct_free.html"},{"title":"DQMC_Geom_Read_Def – Quest","text":"public  subroutine DQMC_Geom_Read_Def(S, gfile, tableFormat) Arguments Type Intent Optional Attributes Name type( Struct ), intent(inout) :: S character(len=*), intent(in) :: gfile logical, intent(out) :: tableFormat Calls proc~~dqmc_geom_read_def~~CallsGraph proc~dqmc_geom_read_def DQMC_STRUCT::DQMC_Geom_Read_Def proc~dqmc_ccs_compress DQMC_STRUCT::DQMC_CCS_Compress proc~dqmc_geom_read_def->proc~dqmc_ccs_compress proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_geom_read_def->proc~dqmc_error proc~dqmc_geom_discover_f DQMC_STRUCT::DQMC_Geom_Discover_F proc~dqmc_geom_read_def->proc~dqmc_geom_discover_f proc~dqmc_geom_discover_map DQMC_STRUCT::DQMC_Geom_Discover_Map proc~dqmc_geom_read_def->proc~dqmc_geom_discover_map proc~dqmc_readln DQMC_Cfg::DQMC_ReadLn proc~dqmc_geom_read_def->proc~dqmc_readln proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_geom_read_def->proc~dqmc_warning proc~dqmc_ccs_compress->proc~dqmc_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_geom_read_def~~CalledByGraph proc~dqmc_geom_read_def DQMC_STRUCT::DQMC_Geom_Read_Def program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_read_def Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_geom_read_def.html"},{"title":"DQMC_Geom_Discover_F – Quest","text":"public  subroutine DQMC_Geom_Discover_F(n, D, F) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: D (:,:) integer, intent(inout) :: F (:) Called by proc~~dqmc_geom_discover_f~~CalledByGraph proc~dqmc_geom_discover_f DQMC_STRUCT::DQMC_Geom_Discover_F proc~dqmc_geom_read_def DQMC_STRUCT::DQMC_Geom_Read_Def proc~dqmc_geom_read_def->proc~dqmc_geom_discover_f program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_read_def Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_geom_discover_f.html"},{"title":"DQMC_Geom_Discover_Map – Quest","text":"public  subroutine DQMC_Geom_Discover_Map(n, D, F, Map, idx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: D (:,:) integer, intent(inout) :: F (:) integer, intent(inout) :: Map (:) integer, intent(out) :: idx Called by proc~~dqmc_geom_discover_map~~CalledByGraph proc~dqmc_geom_discover_map DQMC_STRUCT::DQMC_Geom_Discover_Map proc~dqmc_geom_read_def DQMC_STRUCT::DQMC_Geom_Read_Def proc~dqmc_geom_read_def->proc~dqmc_geom_discover_map program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_read_def Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_geom_discover_map.html"},{"title":"DQMC_Geom_Print – Quest","text":"public  subroutine DQMC_Geom_Print(S, OPT) Arguments Type Intent Optional Attributes Name type( Struct ), intent(in) :: S integer, intent(in) :: OPT Calls proc~~dqmc_geom_print~~CallsGraph proc~dqmc_geom_print DQMC_STRUCT::DQMC_Geom_Print proc~dqmc_ccs_print DQMC_STRUCT::DQMC_CCS_Print proc~dqmc_geom_print->proc~dqmc_ccs_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_geom_print~~CalledByGraph proc~dqmc_geom_print DQMC_STRUCT::DQMC_Geom_Print program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_geom_print.html"},{"title":"DQMC_Find_Param – Quest","text":"public  function DQMC_Find_Param(cfg, pname) result(id) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: pname Return Value integer Called by proc~~dqmc_find_param~~CalledByGraph proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI proc~dqmc_config_geti->proc~dqmc_find_param proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI proc~dqmc_config_getpi->proc~dqmc_find_param proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR proc~dqmc_config_getpr->proc~dqmc_find_param proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR proc~dqmc_config_getr->proc~dqmc_find_param proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS proc~dqmc_config_gets->proc~dqmc_find_param proc~dqmc_config_isset DQMC_Cfg::DQMC_Config_isSet proc~dqmc_config_isset->proc~dqmc_find_param proc~dqmc_config_seti DQMC_Cfg::DQMC_Config_SetI proc~dqmc_config_seti->proc~dqmc_find_param proc~dqmc_config_setpi DQMC_Cfg::DQMC_Config_SetPI proc~dqmc_config_setpi->proc~dqmc_find_param proc~dqmc_config_setpr DQMC_Cfg::DQMC_Config_SetPR proc~dqmc_config_setpr->proc~dqmc_find_param proc~dqmc_config_setr DQMC_Cfg::DQMC_Config_SetR proc~dqmc_config_setr->proc~dqmc_find_param proc~dqmc_config_sets DQMC_Cfg::DQMC_Config_SetS proc~dqmc_config_sets->proc~dqmc_find_param proc~dqmc_read_config DQMC_Cfg::DQMC_Read_Config proc~dqmc_read_config->proc~dqmc_find_param interface~cfg_get DQMC_Cfg::CFG_Get interface~cfg_get->proc~dqmc_config_geti interface~cfg_get->proc~dqmc_config_getpi interface~cfg_get->proc~dqmc_config_getpr interface~cfg_get->proc~dqmc_config_getr interface~cfg_get->proc~dqmc_config_gets interface~cfg_set DQMC_Cfg::CFG_Set interface~cfg_set->proc~dqmc_config_seti interface~cfg_set->proc~dqmc_config_setpi interface~cfg_set->proc~dqmc_config_setpr interface~cfg_set->proc~dqmc_config_setr interface~cfg_set->proc~dqmc_config_sets proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_read_config proc~dqmc_comp_2dperl->interface~cfg_get proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_config_isset proc~dqmc_hub_config->interface~cfg_get proc~dqmc_hub_config->interface~cfg_set proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_config_isset proc~dqmc_hub_config~2->interface~cfg_get proc~dqmc_hub_config~2->interface~cfg_set program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_read_config program~dqmc_ggeom->interface~cfg_get program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init program~dqmc_ggeom->proc~dqmc_geom_init proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill program~dqmc_ggeom->proc~dqmc_geom_fill proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->interface~cfg_get proc~dqmc_geom_init->interface~cfg_set proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~init_recip_latt->interface~cfg_get program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl proc~dqmc_geom_fill->proc~construct_hamilt proc~dqmc_geom_fill->proc~init_recip_latt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_find_param.html"},{"title":"DQMC_Config_isSet – Quest","text":"public  function DQMC_Config_isSet(cfg, name) result(isSet) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name Return Value logical Calls proc~~dqmc_config_isset~~CallsGraph proc~dqmc_config_isset DQMC_Cfg::DQMC_Config_isSet proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_isset->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_isset->proc~dqmc_find_param Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_config_isset~~CalledByGraph proc~dqmc_config_isset DQMC_Cfg::DQMC_Config_isSet proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->proc~dqmc_config_isset proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_config_isset proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_config_isset.html"},{"title":"DQMC_ReadLn – Quest","text":"public  subroutine DQMC_ReadLn(str, IPT, status) Arguments Type Intent Optional Attributes Name character(len=llen), intent(inout) :: str integer, intent(in) :: IPT integer, intent(inout) :: status Called by proc~~dqmc_readln~~CalledByGraph proc~dqmc_readln DQMC_Cfg::DQMC_ReadLn proc~dqmc_geom_read_def DQMC_STRUCT::DQMC_Geom_Read_Def proc~dqmc_geom_read_def->proc~dqmc_readln proc~dqmc_read_def DQMC_Cfg::DQMC_Read_Def proc~dqmc_read_def->proc~dqmc_readln proc~dqmc_read_config DQMC_Cfg::DQMC_Read_Config proc~dqmc_read_config->proc~dqmc_read_def program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_read_def program~dqmc_ggeom->proc~dqmc_read_config proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_read_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_readln.html"},{"title":"DQMC_Default_Def – Quest","text":"public  subroutine DQMC_Default_Def(cfg) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg Called by proc~~dqmc_default_def~~CalledByGraph proc~dqmc_default_def DQMC_Cfg::DQMC_Default_Def proc~dqmc_read_config DQMC_Cfg::DQMC_Read_Config proc~dqmc_read_config->proc~dqmc_default_def proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_read_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_read_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_default_def.html"},{"title":"DQMC_Config_Free – Quest","text":"public  subroutine DQMC_Config_Free(cfg) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg Called by proc~~dqmc_config_free~~CalledByGraph proc~dqmc_config_free DQMC_Cfg::DQMC_Config_Free proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_config_free program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_config_free program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_config_free.html"},{"title":"DQMC_Read_Def – Quest","text":"public  subroutine DQMC_Read_Def(cfg, IPT) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg integer, intent(in) :: IPT Calls proc~~dqmc_read_def~~CallsGraph proc~dqmc_read_def DQMC_Cfg::DQMC_Read_Def proc~dqmc_readln DQMC_Cfg::DQMC_ReadLn proc~dqmc_read_def->proc~dqmc_readln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_read_def~~CalledByGraph proc~dqmc_read_def DQMC_Cfg::DQMC_Read_Def proc~dqmc_read_config DQMC_Cfg::DQMC_Read_Config proc~dqmc_read_config->proc~dqmc_read_def proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_read_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_read_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_read_def.html"},{"title":"DQMC_Print_Def – Quest","text":"public  subroutine DQMC_Print_Def(cfg, OPT) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg integer, intent(in) :: OPT","tags":"","loc":"proc/dqmc_print_def.html"},{"title":"DQMC_Read_Config – Quest","text":"public  subroutine DQMC_Read_Config(cfg) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg Calls proc~~dqmc_read_config~~CallsGraph proc~dqmc_read_config DQMC_Cfg::DQMC_Read_Config proc~dqmc_default_def DQMC_Cfg::DQMC_Default_Def proc~dqmc_read_config->proc~dqmc_default_def proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_read_config->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_read_config->proc~dqmc_find_param proc~dqmc_open_file DQMC_Util::DQMC_open_file proc~dqmc_read_config->proc~dqmc_open_file proc~dqmc_read_def DQMC_Cfg::DQMC_Read_Def proc~dqmc_read_config->proc~dqmc_read_def proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_read_config->proc~dqmc_warning proc~dqmc_readln DQMC_Cfg::DQMC_ReadLn proc~dqmc_read_def->proc~dqmc_readln Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_read_config~~CalledByGraph proc~dqmc_read_config DQMC_Cfg::DQMC_Read_Config proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_read_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_read_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_read_config.html"},{"title":"DQMC_Config_SetI – Quest","text":"public  subroutine DQMC_Config_SetI(cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name integer, intent(in) :: value Calls proc~~dqmc_config_seti~~CallsGraph proc~dqmc_config_seti DQMC_Cfg::DQMC_Config_SetI proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_seti->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_seti->proc~dqmc_find_param Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_config_seti~~CalledByGraph proc~dqmc_config_seti DQMC_Cfg::DQMC_Config_SetI interface~cfg_set DQMC_Cfg::CFG_Set interface~cfg_set->proc~dqmc_config_seti proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init proc~dqmc_geom_init->interface~cfg_set proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->interface~cfg_set proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->interface~cfg_set proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_init program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_config_seti.html"},{"title":"DQMC_Config_SetR – Quest","text":"public  subroutine DQMC_Config_SetR(cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name real(kind=wp), intent(in) :: value Calls proc~~dqmc_config_setr~~CallsGraph proc~dqmc_config_setr DQMC_Cfg::DQMC_Config_SetR proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_setr->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_setr->proc~dqmc_find_param Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_config_setr~~CalledByGraph proc~dqmc_config_setr DQMC_Cfg::DQMC_Config_SetR interface~cfg_set DQMC_Cfg::CFG_Set interface~cfg_set->proc~dqmc_config_setr proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init proc~dqmc_geom_init->interface~cfg_set proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->interface~cfg_set proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->interface~cfg_set proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_init program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_config_setr.html"},{"title":"DQMC_Config_SetPR – Quest","text":"public  subroutine DQMC_Config_SetPR(cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name integer, intent(in) :: n real(kind=wp), intent(in) :: value (n) Calls proc~~dqmc_config_setpr~~CallsGraph proc~dqmc_config_setpr DQMC_Cfg::DQMC_Config_SetPR proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_setpr->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_setpr->proc~dqmc_find_param Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_config_setpr~~CalledByGraph proc~dqmc_config_setpr DQMC_Cfg::DQMC_Config_SetPR interface~cfg_set DQMC_Cfg::CFG_Set interface~cfg_set->proc~dqmc_config_setpr proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init proc~dqmc_geom_init->interface~cfg_set proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->interface~cfg_set proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->interface~cfg_set proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_init program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_config_setpr.html"},{"title":"DQMC_Config_SetPI – Quest","text":"public  subroutine DQMC_Config_SetPI(cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name integer, intent(in) :: n integer, intent(in) :: value (n) Calls proc~~dqmc_config_setpi~~CallsGraph proc~dqmc_config_setpi DQMC_Cfg::DQMC_Config_SetPI proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_setpi->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_setpi->proc~dqmc_find_param Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_config_setpi~~CalledByGraph proc~dqmc_config_setpi DQMC_Cfg::DQMC_Config_SetPI interface~cfg_set DQMC_Cfg::CFG_Set interface~cfg_set->proc~dqmc_config_setpi proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init proc~dqmc_geom_init->interface~cfg_set proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->interface~cfg_set proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->interface~cfg_set proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_init program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_config_setpi.html"},{"title":"DQMC_Config_SetS – Quest","text":"public  subroutine DQMC_Config_SetS(cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name character(len=*), intent(in) :: value Calls proc~~dqmc_config_sets~~CallsGraph proc~dqmc_config_sets DQMC_Cfg::DQMC_Config_SetS proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_sets->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_sets->proc~dqmc_find_param Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_config_sets~~CalledByGraph proc~dqmc_config_sets DQMC_Cfg::DQMC_Config_SetS interface~cfg_set DQMC_Cfg::CFG_Set interface~cfg_set->proc~dqmc_config_sets proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init proc~dqmc_geom_init->interface~cfg_set proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->interface~cfg_set proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->interface~cfg_set proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_init program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_config_sets.html"},{"title":"DQMC_Config_GetI – Quest","text":"public  subroutine DQMC_Config_GetI(cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name integer, intent(out) :: value Calls proc~~dqmc_config_geti~~CallsGraph proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_geti->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_geti->proc~dqmc_find_param proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_config_geti->proc~dqmc_warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_config_geti~~CalledByGraph proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI interface~cfg_get DQMC_Cfg::CFG_Get interface~cfg_get->proc~dqmc_config_geti proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->interface~cfg_get proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->interface~cfg_get proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->interface~cfg_get proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->interface~cfg_get proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~init_recip_latt->interface~cfg_get program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~cfg_get program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill program~dqmc_ggeom->proc~dqmc_geom_fill proc~dqmc_geom_fill->proc~construct_hamilt proc~dqmc_geom_fill->proc~init_recip_latt program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_config_geti.html"},{"title":"DQMC_Config_GetR – Quest","text":"public  subroutine DQMC_Config_GetR(cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name real(kind=wp), intent(out) :: value Calls proc~~dqmc_config_getr~~CallsGraph proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_getr->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_getr->proc~dqmc_find_param proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_config_getr->proc~dqmc_warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_config_getr~~CalledByGraph proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR interface~cfg_get DQMC_Cfg::CFG_Get interface~cfg_get->proc~dqmc_config_getr proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->interface~cfg_get proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->interface~cfg_get proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->interface~cfg_get proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->interface~cfg_get proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~init_recip_latt->interface~cfg_get program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~cfg_get program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill program~dqmc_ggeom->proc~dqmc_geom_fill proc~dqmc_geom_fill->proc~construct_hamilt proc~dqmc_geom_fill->proc~init_recip_latt program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_config_getr.html"},{"title":"DQMC_Config_GetPR – Quest","text":"public  subroutine DQMC_Config_GetPR(cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name integer, intent(out) :: n real(kind=wp), intent(inout), pointer :: value (:) Calls proc~~dqmc_config_getpr~~CallsGraph proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_getpr->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_getpr->proc~dqmc_find_param proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_config_getpr->proc~dqmc_warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_config_getpr~~CalledByGraph proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR interface~cfg_get DQMC_Cfg::CFG_Get interface~cfg_get->proc~dqmc_config_getpr proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->interface~cfg_get proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->interface~cfg_get proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->interface~cfg_get proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->interface~cfg_get proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~init_recip_latt->interface~cfg_get program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~cfg_get program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill program~dqmc_ggeom->proc~dqmc_geom_fill proc~dqmc_geom_fill->proc~construct_hamilt proc~dqmc_geom_fill->proc~init_recip_latt program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_config_getpr.html"},{"title":"DQMC_Config_GetPI – Quest","text":"public  subroutine DQMC_Config_GetPI(cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name integer, intent(out) :: n integer, intent(inout), pointer :: value (:) Calls proc~~dqmc_config_getpi~~CallsGraph proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_getpi->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_getpi->proc~dqmc_find_param proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_config_getpi->proc~dqmc_warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_config_getpi~~CalledByGraph proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI interface~cfg_get DQMC_Cfg::CFG_Get interface~cfg_get->proc~dqmc_config_getpi proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->interface~cfg_get proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->interface~cfg_get proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->interface~cfg_get proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->interface~cfg_get proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~init_recip_latt->interface~cfg_get program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~cfg_get program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill program~dqmc_ggeom->proc~dqmc_geom_fill proc~dqmc_geom_fill->proc~construct_hamilt proc~dqmc_geom_fill->proc~init_recip_latt program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_config_getpi.html"},{"title":"DQMC_Config_GetS – Quest","text":"public  subroutine DQMC_Config_GetS(cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name character(len=slen) :: value Calls proc~~dqmc_config_gets~~CallsGraph proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_gets->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_gets->proc~dqmc_find_param proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_config_gets->proc~dqmc_warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_config_gets~~CalledByGraph proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS interface~cfg_get DQMC_Cfg::CFG_Get interface~cfg_get->proc~dqmc_config_gets proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->interface~cfg_get proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->interface~cfg_get proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->interface~cfg_get proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->interface~cfg_get proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~init_recip_latt->interface~cfg_get program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~cfg_get program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill program~dqmc_ggeom->proc~dqmc_geom_fill proc~dqmc_geom_fill->proc~construct_hamilt proc~dqmc_geom_fill->proc~init_recip_latt program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_config_gets.html"},{"title":"CFG_Set – Quest","text":"public interface CFG_Set Calls interface~~cfg_set~~CallsGraph interface~cfg_set DQMC_Cfg::CFG_Set proc~dqmc_config_seti DQMC_Cfg::DQMC_Config_SetI interface~cfg_set->proc~dqmc_config_seti proc~dqmc_config_setpi DQMC_Cfg::DQMC_Config_SetPI interface~cfg_set->proc~dqmc_config_setpi proc~dqmc_config_setpr DQMC_Cfg::DQMC_Config_SetPR interface~cfg_set->proc~dqmc_config_setpr proc~dqmc_config_setr DQMC_Cfg::DQMC_Config_SetR interface~cfg_set->proc~dqmc_config_setr proc~dqmc_config_sets DQMC_Cfg::DQMC_Config_SetS interface~cfg_set->proc~dqmc_config_sets proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_seti->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_seti->proc~dqmc_find_param proc~dqmc_config_setpi->proc~dqmc_error proc~dqmc_config_setpi->proc~dqmc_find_param proc~dqmc_config_setpr->proc~dqmc_error proc~dqmc_config_setpr->proc~dqmc_find_param proc~dqmc_config_setr->proc~dqmc_error proc~dqmc_config_setr->proc~dqmc_find_param proc~dqmc_config_sets->proc~dqmc_error proc~dqmc_config_sets->proc~dqmc_find_param Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~cfg_set~~CalledByGraph interface~cfg_set DQMC_Cfg::CFG_Set proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init proc~dqmc_geom_init->interface~cfg_set proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->interface~cfg_set proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->interface~cfg_set proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_init program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine DQMC_Config_SetI (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name integer, intent(in) :: value public  subroutine DQMC_Config_SetR (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name real(kind=wp), intent(in) :: value public  subroutine DQMC_Config_SetS (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name character(len=*), intent(in) :: value public  subroutine DQMC_Config_SetPR (cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name integer, intent(in) :: n real(kind=wp), intent(in) :: value (n) public  subroutine DQMC_Config_SetPI (cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name integer, intent(in) :: n integer, intent(in) :: value (n)","tags":"","loc":"interface/cfg_set.html"},{"title":"CFG_Get – Quest","text":"public interface CFG_Get Calls interface~~cfg_get~~CallsGraph interface~cfg_get DQMC_Cfg::CFG_Get proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI interface~cfg_get->proc~dqmc_config_geti proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI interface~cfg_get->proc~dqmc_config_getpi proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR interface~cfg_get->proc~dqmc_config_getpr proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR interface~cfg_get->proc~dqmc_config_getr proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS interface~cfg_get->proc~dqmc_config_gets proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_geti->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_geti->proc~dqmc_find_param proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_config_geti->proc~dqmc_warning proc~dqmc_config_getpi->proc~dqmc_error proc~dqmc_config_getpi->proc~dqmc_find_param proc~dqmc_config_getpi->proc~dqmc_warning proc~dqmc_config_getpr->proc~dqmc_error proc~dqmc_config_getpr->proc~dqmc_find_param proc~dqmc_config_getpr->proc~dqmc_warning proc~dqmc_config_getr->proc~dqmc_error proc~dqmc_config_getr->proc~dqmc_find_param proc~dqmc_config_getr->proc~dqmc_warning proc~dqmc_config_gets->proc~dqmc_error proc~dqmc_config_gets->proc~dqmc_find_param proc~dqmc_config_gets->proc~dqmc_warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~cfg_get~~CalledByGraph interface~cfg_get DQMC_Cfg::CFG_Get proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->interface~cfg_get proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->interface~cfg_get proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->interface~cfg_get proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->interface~cfg_get proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~init_recip_latt->interface~cfg_get program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~cfg_get program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill program~dqmc_ggeom->proc~dqmc_geom_fill proc~dqmc_geom_fill->proc~construct_hamilt proc~dqmc_geom_fill->proc~init_recip_latt program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine DQMC_Config_GetI (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name integer, intent(out) :: value public  subroutine DQMC_Config_GetR (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name real(kind=wp), intent(out) :: value public  subroutine DQMC_Config_GetS (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name character(len=slen) :: value public  subroutine DQMC_Config_GetPR (cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name integer, intent(out) :: n real(kind=wp), intent(inout), pointer :: value (:) public  subroutine DQMC_Config_GetPI (cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name integer, intent(out) :: n integer, intent(inout), pointer :: value (:)","tags":"","loc":"interface/cfg_get.html"},{"title":"init_kbonds – Quest","text":"public  subroutine init_kbonds(symm, lattice, reclatt, kbonds) Uses DQMC_LATT DQMC_SYMM proc~~init_kbonds~~UsesGraph proc~init_kbonds DQMC_KBONDS::init_kbonds module~dqmc_latt DQMC_LATT proc~init_kbonds->module~dqmc_latt module~dqmc_symm DQMC_SYMM proc~init_kbonds->module~dqmc_symm module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_latt->module~dqmc_geom_param module~dqmc_util DQMC_Util module~dqmc_latt->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_symm->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( symm_operations ), intent(in) :: symm type( lattice_t ), intent(in) :: lattice type( recip_lattice_t ), intent(in) :: reclatt type( kbonds_t ), intent(inout) :: kbonds","tags":"","loc":"proc/init_kbonds.html"},{"title":"construct_kbonds – Quest","text":"public  subroutine construct_kbonds(reclatt, kbonds) Arguments Type Intent Optional Attributes Name type( recip_lattice_t ), intent(in) :: reclatt type( kbonds_t ), intent(inout) :: kbonds","tags":"","loc":"proc/construct_kbonds.html"},{"title":"map_symm_kbond – Quest","text":"public  subroutine map_symm_kbond(kbonds) Arguments Type Intent Optional Attributes Name type( kbonds_t ), intent(inout) :: kbonds","tags":"","loc":"proc/map_symm_kbond.html"},{"title":"construct_kbond_classes – Quest","text":"public  subroutine construct_kbond_classes(kbonds) Arguments Type Intent Optional Attributes Name type( kbonds_t ), intent(inout) :: kbonds","tags":"","loc":"proc/construct_kbond_classes.html"},{"title":"DQMC_TDM2_Init – Quest","text":"public  subroutine DQMC_TDM2_Init(n, L, nBin, T2, S, T) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: L integer, intent(in) :: nBin type( TDM2 ), intent(inout) :: T2 type( Struct ), intent(in), target :: S real(kind=wp), intent(in), target :: T (:,:)","tags":"","loc":"proc/dqmc_tdm2_init.html"},{"title":"DQMC_TDM2_Free – Quest","text":"public  subroutine DQMC_TDM2_Free(T2) Arguments Type Intent Optional Attributes Name type( TDM2 ), intent(inout) :: T2","tags":"","loc":"proc/dqmc_tdm2_free.html"},{"title":"DQMC_TDM2_Meas – Quest","text":"public  subroutine DQMC_TDM2_Meas(T2, upt0, up0t, dnt0, dn0t, ti) Arguments Type Intent Optional Attributes Name type( TDM2 ), intent(inout) :: T2 real(kind=wp), intent(in) :: upt0 (:,:) real(kind=wp), intent(in) :: up0t (:,:) real(kind=wp), intent(in) :: dnt0 (:,:) real(kind=wp), intent(in) :: dn0t (:,:) integer, intent(in) :: ti Calls proc~~dqmc_tdm2_meas~~CallsGraph proc~dqmc_tdm2_meas DQMC_TDM2::DQMC_TDM2_Meas proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_tdm2_meas->proc~dqmc_phy2_pair Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm2_meas.html"},{"title":"DQMC_TDM2_Acc – Quest","text":"public  subroutine DQMC_TDM2_Acc(T2, sgn) Arguments Type Intent Optional Attributes Name type( TDM2 ), intent(inout) :: T2 real(kind=wp), intent(in) :: sgn Calls proc~~dqmc_tdm2_acc~~CallsGraph proc~dqmc_tdm2_acc DQMC_TDM2::DQMC_TDM2_Acc blas_daxpy blas_daxpy proc~dqmc_tdm2_acc->blas_daxpy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm2_acc.html"},{"title":"DQMC_TDM2_Avg – Quest","text":"public  subroutine DQMC_TDM2_Avg(T2, gnl, idx, factor) Arguments Type Intent Optional Attributes Name type( TDM2 ), intent(inout) :: T2 real(kind=wp), intent(in) :: gnl (:,:) integer, intent(in) :: idx real(kind=wp), intent(in) :: factor Calls proc~~dqmc_tdm2_avg~~CallsGraph proc~dqmc_tdm2_avg DQMC_TDM2::DQMC_TDM2_Avg proc~dqmc_wave_avg DQMC_Phy2::DQMC_Wave_Avg proc~dqmc_tdm2_avg->proc~dqmc_wave_avg blas_ddot blas_ddot proc~dqmc_wave_avg->blas_ddot blas_dgemm blas_dgemm proc~dqmc_wave_avg->blas_dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm2_avg.html"},{"title":"DQMC_Hub_Config – Quest","text":"public  subroutine DQMC_Hub_Config(Hub, cfg) Uses DQMC_MPI proc~~dqmc_hub_config~~UsesGraph proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config module~dqmc_mpi DQMC_MPI proc~dqmc_hub_config->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub type( config ), intent(inout) :: cfg Calls proc~~dqmc_hub_config~~CallsGraph proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config interface~cfg_get DQMC_Cfg::CFG_Get proc~dqmc_hub_config->interface~cfg_get interface~cfg_set DQMC_Cfg::CFG_Set proc~dqmc_hub_config->interface~cfg_set proc~dqmc_config_isset DQMC_Cfg::DQMC_Config_isSet proc~dqmc_hub_config->proc~dqmc_config_isset proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_hub_config->proc~dqmc_warning proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI interface~cfg_get->proc~dqmc_config_geti proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI interface~cfg_get->proc~dqmc_config_getpi proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR interface~cfg_get->proc~dqmc_config_getpr proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR interface~cfg_get->proc~dqmc_config_getr proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS interface~cfg_get->proc~dqmc_config_gets proc~dqmc_config_seti DQMC_Cfg::DQMC_Config_SetI interface~cfg_set->proc~dqmc_config_seti proc~dqmc_config_setpi DQMC_Cfg::DQMC_Config_SetPI interface~cfg_set->proc~dqmc_config_setpi proc~dqmc_config_setpr DQMC_Cfg::DQMC_Config_SetPR interface~cfg_set->proc~dqmc_config_setpr proc~dqmc_config_setr DQMC_Cfg::DQMC_Config_SetR interface~cfg_set->proc~dqmc_config_setr proc~dqmc_config_sets DQMC_Cfg::DQMC_Config_SetS interface~cfg_set->proc~dqmc_config_sets proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_isset->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_isset->proc~dqmc_find_param proc~dqmc_hub_init->proc~dqmc_warning proc~dqmc_b_init DQMC_MATB::DQMC_B_Init proc~dqmc_hub_init->proc~dqmc_b_init proc~dqmc_hub_init->proc~dqmc_error proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_init->proc~dqmc_gfun_clone proc~dqmc_gfun_init DQMC_GFun::DQMC_GFun_Init proc~dqmc_hub_init->proc~dqmc_gfun_init proc~dqmc_hub_init_vmat DQMC_Hubbard::DQMC_Hub_Init_Vmat proc~dqmc_hub_init->proc~dqmc_hub_init_vmat proc~dqmc_hub_input_hsf DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_init->proc~dqmc_hub_input_hsf proc~dqmc_phy0_init DQMC_Phy0::DQMC_Phy0_Init proc~dqmc_hub_init->proc~dqmc_phy0_init proc~dqmc_phy2_init DQMC_Phy2::DQMC_Phy2_Init proc~dqmc_hub_init->proc~dqmc_phy2_init proc~dqmc_seqb_init DQMC_SEQB::DQMC_SeqB_Init proc~dqmc_hub_init->proc~dqmc_seqb_init proc~dqmc_wspace_allocate DQMC_WSpace::DQMC_WSpace_Allocate proc~dqmc_hub_init->proc~dqmc_wspace_allocate proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_init->proc~ran0 proc~ran1 DQMC_Util::ran1 proc~dqmc_hub_init->proc~ran1 proc~dqmc_b_expinit DQMC_MATB::DQMC_B_ExpInit proc~dqmc_b_init->proc~dqmc_b_expinit proc~dqmc_config_geti->proc~dqmc_warning proc~dqmc_config_geti->proc~dqmc_error proc~dqmc_config_geti->proc~dqmc_find_param proc~dqmc_config_getpi->proc~dqmc_warning proc~dqmc_config_getpi->proc~dqmc_error proc~dqmc_config_getpi->proc~dqmc_find_param proc~dqmc_config_getpr->proc~dqmc_warning proc~dqmc_config_getpr->proc~dqmc_error proc~dqmc_config_getpr->proc~dqmc_find_param proc~dqmc_config_getr->proc~dqmc_warning proc~dqmc_config_getr->proc~dqmc_error proc~dqmc_config_getr->proc~dqmc_find_param proc~dqmc_config_gets->proc~dqmc_warning proc~dqmc_config_gets->proc~dqmc_error proc~dqmc_config_gets->proc~dqmc_find_param proc~dqmc_config_seti->proc~dqmc_error proc~dqmc_config_seti->proc~dqmc_find_param proc~dqmc_config_setpi->proc~dqmc_error proc~dqmc_config_setpi->proc~dqmc_find_param proc~dqmc_config_setpr->proc~dqmc_error proc~dqmc_config_setpr->proc~dqmc_find_param proc~dqmc_config_setr->proc~dqmc_error proc~dqmc_config_setr->proc~dqmc_find_param proc~dqmc_config_sets->proc~dqmc_error proc~dqmc_config_sets->proc~dqmc_find_param blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right proc~dqmc_hub_input_hsf->proc~dqmc_error lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_wspace_allocate->lapack_dgeqp3 lapack_dgetri lapack_dgetri proc~dqmc_wspace_allocate->lapack_dgetri lapack_dorgqr lapack_dorgqr proc~dqmc_wspace_allocate->lapack_dorgqr lapack_dormqr lapack_dormqr proc~dqmc_wspace_allocate->lapack_dormqr lapack_dsyev lapack_dsyev proc~dqmc_wspace_allocate->lapack_dsyev dlarnv dlarnv proc~ran0->dlarnv proc~ran1->dlarnv proc~dqmc_b_expinit->proc~dqmc_error proc~dqmc_b_expinit->lapack_dsyev blas_dgemm blas_dgemm proc~dqmc_b_expinit->blas_dgemm blas_dscal blas_dscal proc~dqmc_b_expinit->blas_dscal dexp dexp proc~dqmc_b_expinit->dexp proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_computeg->proc~dqmc_error proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->blas_dgemm proc~dqmc_multb_left->blas_dscal proc~dqmc_multb_left->dexp proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->lapack_dgeqp3 proc~dqmc_udtd->lapack_dorgqr proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_config~~CalledByGraph proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_config.html"},{"title":"DQMC_Hub_Init – Quest","text":"public  subroutine DQMC_Hub_Init(Hub, U, t_up, t_dn, mu_up, mu_dn, L, n_t, n_U, n_mu, dtau, HSF_IPT, nWarm, nPass, nMeas, nTry, nBin, ntausk, seed, nOrth, nWrap, fixw, errrate, difflim, gamma, accept, reject, delta1, delta2, ssxx, HSFtype) Uses DQMC_MPI proc~~dqmc_hub_init~~UsesGraph proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init module~dqmc_mpi DQMC_MPI proc~dqmc_hub_init->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub real(kind=wp), intent(in) :: U (:) real(kind=wp), intent(in) :: t_up (:) real(kind=wp), intent(in) :: t_dn (:) real(kind=wp), intent(in) :: mu_up (:) real(kind=wp), intent(in) :: mu_dn (:) integer, intent(in) :: L integer, intent(in) :: n_t integer, intent(in) :: n_U integer, intent(in) :: n_mu real(kind=wp), intent(in) :: dtau integer, intent(in) :: HSF_IPT integer, intent(in) :: nWarm integer, intent(in) :: nPass integer, intent(in) :: nMeas integer, intent(in) :: nTry integer, intent(in) :: nBin integer, intent(in) :: ntausk integer, intent(in) :: seed integer, intent(in) :: nOrth integer, intent(in) :: nWrap integer, intent(in) :: fixw real(kind=wp), intent(in) :: errrate real(kind=wp), intent(in) :: difflim real(kind=wp), intent(in) :: gamma integer, intent(in) :: accept integer, intent(in) :: reject real(kind=wp), intent(in) :: delta1 real(kind=wp), intent(in) :: delta2 integer, intent(in) :: ssxx integer, intent(in) :: HSFtype Calls proc~~dqmc_hub_init~~CallsGraph proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_b_init DQMC_MATB::DQMC_B_Init proc~dqmc_hub_init->proc~dqmc_b_init proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_hub_init->proc~dqmc_error proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_init->proc~dqmc_gfun_clone proc~dqmc_gfun_init DQMC_GFun::DQMC_GFun_Init proc~dqmc_hub_init->proc~dqmc_gfun_init proc~dqmc_hub_init_vmat DQMC_Hubbard::DQMC_Hub_Init_Vmat proc~dqmc_hub_init->proc~dqmc_hub_init_vmat proc~dqmc_hub_input_hsf DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_init->proc~dqmc_hub_input_hsf proc~dqmc_phy0_init DQMC_Phy0::DQMC_Phy0_Init proc~dqmc_hub_init->proc~dqmc_phy0_init proc~dqmc_phy2_init DQMC_Phy2::DQMC_Phy2_Init proc~dqmc_hub_init->proc~dqmc_phy2_init proc~dqmc_seqb_init DQMC_SEQB::DQMC_SeqB_Init proc~dqmc_hub_init->proc~dqmc_seqb_init proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_hub_init->proc~dqmc_warning proc~dqmc_wspace_allocate DQMC_WSpace::DQMC_WSpace_Allocate proc~dqmc_hub_init->proc~dqmc_wspace_allocate proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_init->proc~ran0 proc~ran1 DQMC_Util::ran1 proc~dqmc_hub_init->proc~ran1 proc~dqmc_b_expinit DQMC_MATB::DQMC_B_ExpInit proc~dqmc_b_init->proc~dqmc_b_expinit blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right proc~dqmc_hub_input_hsf->proc~dqmc_error lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_wspace_allocate->lapack_dgeqp3 lapack_dgetri lapack_dgetri proc~dqmc_wspace_allocate->lapack_dgetri lapack_dorgqr lapack_dorgqr proc~dqmc_wspace_allocate->lapack_dorgqr lapack_dormqr lapack_dormqr proc~dqmc_wspace_allocate->lapack_dormqr lapack_dsyev lapack_dsyev proc~dqmc_wspace_allocate->lapack_dsyev dlarnv dlarnv proc~ran0->dlarnv proc~ran1->dlarnv proc~dqmc_b_expinit->proc~dqmc_error proc~dqmc_b_expinit->lapack_dsyev blas_dgemm blas_dgemm proc~dqmc_b_expinit->blas_dgemm blas_dscal blas_dscal proc~dqmc_b_expinit->blas_dscal dexp dexp proc~dqmc_b_expinit->dexp proc~dqmc_computeg->proc~dqmc_error proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->blas_dgemm proc~dqmc_multb_left->blas_dscal proc~dqmc_multb_left->dexp proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->lapack_dgeqp3 proc~dqmc_udtd->lapack_dorgqr proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_init~~CalledByGraph proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->proc~dqmc_hub_init program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_init.html"},{"title":"DQMC_Hub_Free – Quest","text":"public  subroutine DQMC_Hub_Free(Hub) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub Calls proc~~dqmc_hub_free~~CallsGraph proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_b_free DQMC_MATB::DQMC_B_Free proc~dqmc_hub_free->proc~dqmc_b_free proc~dqmc_gfun_free DQMC_GFun::DQMC_Gfun_Free proc~dqmc_hub_free->proc~dqmc_gfun_free proc~dqmc_phy0_free DQMC_Phy0::DQMC_Phy0_Free proc~dqmc_hub_free->proc~dqmc_phy0_free proc~dqmc_phy2_free DQMC_Phy2::DQMC_Phy2_Free proc~dqmc_hub_free->proc~dqmc_phy2_free proc~dqmc_seqb_free DQMC_SEQB::DQMC_SeqB_Free proc~dqmc_hub_free->proc~dqmc_seqb_free proc~dqmc_struct_free DQMC_STRUCT::DQMC_Struct_Free proc~dqmc_hub_free->proc~dqmc_struct_free proc~dqmc_wspace_free DQMC_WSpace::DQMC_WSpace_Free proc~dqmc_hub_free->proc~dqmc_wspace_free proc~dqmc_ccs_free DQMC_STRUCT::DQMC_CCS_Free proc~dqmc_struct_free->proc~dqmc_ccs_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_free~~CalledByGraph proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_free program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_free program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_free program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_free.html"},{"title":"DQMC_Hub_Output_HSF – Quest","text":"public  subroutine DQMC_Hub_Output_HSF(Hub, restore, slice, OPT) Uses DQMC_MPI proc~~dqmc_hub_output_hsf~~UsesGraph proc~dqmc_hub_output_hsf DQMC_Hubbard::DQMC_Hub_Output_HSF module~dqmc_mpi DQMC_MPI proc~dqmc_hub_output_hsf->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in) :: Hub logical, intent(in) :: restore integer, intent(in) :: slice integer, intent(in) :: OPT Called by proc~~dqmc_hub_output_hsf~~CalledByGraph proc~dqmc_hub_output_hsf DQMC_Hubbard::DQMC_Hub_Output_HSF proc~dqmc_hub_outputparam DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_outputparam->proc~dqmc_hub_output_hsf proc~dqmc_hub_print DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_print->proc~dqmc_hub_outputparam program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_outputparam proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_print program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_output_hsf.html"},{"title":"DQMC_Hub_Input_HSF – Quest","text":"public  subroutine DQMC_Hub_Input_HSF(Hub, restore, slice, IPT) Uses DQMC_MPI proc~~dqmc_hub_input_hsf~~UsesGraph proc~dqmc_hub_input_hsf DQMC_Hubbard::DQMC_Hub_Input_HSF module~dqmc_mpi DQMC_MPI proc~dqmc_hub_input_hsf->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub logical, intent(in) :: restore integer, intent(out) :: slice integer, intent(in) :: IPT Calls proc~~dqmc_hub_input_hsf~~CallsGraph proc~dqmc_hub_input_hsf DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_hub_input_hsf->proc~dqmc_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_input_hsf~~CalledByGraph proc~dqmc_hub_input_hsf DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_hub_input_hsf program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_input_hsf proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_input_hsf.html"},{"title":"DQMC_Hub_OutputParam – Quest","text":"public  subroutine DQMC_Hub_OutputParam(Hub, OPT) Uses DQMC_MPI proc~~dqmc_hub_outputparam~~UsesGraph proc~dqmc_hub_outputparam DQMC_Hubbard::DQMC_Hub_OutputParam module~dqmc_mpi DQMC_MPI proc~dqmc_hub_outputparam->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in) :: Hub integer, intent(in) :: OPT Calls proc~~dqmc_hub_outputparam~~CallsGraph proc~dqmc_hub_outputparam DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_output_hsf DQMC_Hubbard::DQMC_Hub_Output_HSF proc~dqmc_hub_outputparam->proc~dqmc_hub_output_hsf proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_hub_outputparam->proc~dqmc_warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_outputparam~~CalledByGraph proc~dqmc_hub_outputparam DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_print DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_print->proc~dqmc_hub_outputparam program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_outputparam proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_print program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_outputparam.html"},{"title":"DQMC_Hub_Print – Quest","text":"public  subroutine DQMC_Hub_Print(Hub, OPT) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in) :: Hub integer, intent(in) :: OPT Calls proc~~dqmc_hub_print~~CallsGraph proc~dqmc_hub_print DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_outputparam DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_print->proc~dqmc_hub_outputparam proc~dqmc_phy0_print DQMC_Phy0::DQMC_Phy0_Print proc~dqmc_hub_print->proc~dqmc_phy0_print proc~dqmc_phy2_print DQMC_Phy2::DQMC_Phy2_Print proc~dqmc_hub_print->proc~dqmc_phy2_print proc~dqmc_hub_output_hsf DQMC_Hubbard::DQMC_Hub_Output_HSF proc~dqmc_hub_outputparam->proc~dqmc_hub_output_hsf proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_hub_outputparam->proc~dqmc_warning proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray proc~dqmc_phy0_print->proc~dqmc_print_realarray proc~dqmc_phy2_print->proc~dqmc_print_realarray Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_print~~CalledByGraph proc~dqmc_hub_print DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_print program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_print.html"},{"title":"DQMC_Hub_Sweep – Quest","text":"public  subroutine DQMC_Hub_Sweep(Hub, nMeas0) Uses DQMC_MPI proc~~dqmc_hub_sweep~~UsesGraph proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep module~dqmc_mpi DQMC_MPI proc~dqmc_hub_sweep->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout), target :: Hub integer, intent(in) :: nMeas0 Calls proc~~dqmc_hub_sweep~~CallsGraph proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate proc~dqmc_hub_sweep->proc~dqmc_applyupdate proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_sweep->proc~dqmc_getg_2nd_order proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_sweep->proc~dqmc_gfun_copyup proc~dqmc_gfun_getjj DQMC_GFun::DQMC_Gfun_Getjj proc~dqmc_hub_sweep->proc~dqmc_gfun_getjj proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_sweep->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_sweep->proc~dqmc_phy2_meas proc~dqmc_syncwraps DQMC_GFun::DQMC_SyncWraps proc~dqmc_hub_sweep->proc~dqmc_syncwraps proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG proc~dqmc_hub_sweep->proc~dqmc_updateg proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps proc~dqmc_hub_sweep->proc~dqmc_updatewraps proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_sweep->proc~ran0 blas_dgemm blas_dgemm proc~dqmc_applyupdate->blas_dgemm blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right blas_ddot blas_ddot proc~dqmc_gfun_getjj->blas_ddot blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair proc~dqmc_updateg->proc~dqmc_applyupdate blas_dgemv blas_dgemv proc~dqmc_updateg->blas_dgemv blas_dscal blas_dscal proc~dqmc_updateg->blas_dscal dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_multb_left->blas_dgemm proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_sweep~~CalledByGraph proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_sweep.html"},{"title":"DQMC_Hub_Sweep2 – Quest","text":"public  subroutine DQMC_Hub_Sweep2(Hub, numTry) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: numTry Calls proc~~dqmc_hub_sweep2~~CallsGraph proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_sweep2->proc~dqmc_gfun_copyup proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_sweep2->proc~ran0 blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning blas_dgemm blas_dgemm proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_sweep2~~CalledByGraph proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_sweep2.html"},{"title":"DQMC_Hub_Sweep_Cont – Quest","text":"public  subroutine DQMC_Hub_Sweep_Cont(Hub, nMeas0) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout), target :: Hub integer, intent(in) :: nMeas0 Calls proc~~dqmc_hub_sweep_cont~~CallsGraph proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate proc~dqmc_hub_sweep_cont->proc~dqmc_applyupdate proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_gfun_getjj DQMC_GFun::DQMC_Gfun_Getjj proc~dqmc_hub_sweep_cont->proc~dqmc_gfun_getjj proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_sweep_cont->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_sweep_cont->proc~dqmc_phy2_meas proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG proc~dqmc_hub_sweep_cont->proc~dqmc_updateg proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps proc~dqmc_hub_sweep_cont->proc~dqmc_updatewraps proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_sweep_cont->proc~ran0 blas_dgemm blas_dgemm proc~dqmc_applyupdate->blas_dgemm blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right blas_ddot blas_ddot proc~dqmc_gfun_getjj->blas_ddot blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair proc~dqmc_updateg->proc~dqmc_applyupdate blas_dgemv blas_dgemv proc~dqmc_updateg->blas_dgemv blas_dscal blas_dscal proc~dqmc_updateg->blas_dscal dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_multb_left->blas_dgemm proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_sweep_cont.html"},{"title":"DQMC_Hub_Sweep2_Cont – Quest","text":"public  subroutine DQMC_Hub_Sweep2_Cont(Hub, numTry) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: numTry Calls proc~~dqmc_hub_sweep2_cont~~CallsGraph proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_sweep2_cont->proc~ran0 blas_dcopy blas_dcopy proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning dlarnv dlarnv proc~ran0->dlarnv dscal dscal proc~dqmc_scalerow->dscal proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow blas_dgemm blas_dgemm proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_sweep2_cont.html"},{"title":"DQMC_Hub_Run – Quest","text":"public  subroutine DQMC_Hub_Run(Hub, Info) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer :: Info Calls proc~~dqmc_hub_run~~CallsGraph proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run interface~dqmc_phy2_avg DQMC_Phy2::DQMC_Phy2_avg proc~dqmc_hub_run->interface~dqmc_phy2_avg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_phy0_avg DQMC_Phy0::DQMC_Phy0_Avg proc~dqmc_hub_run->proc~dqmc_phy0_avg proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_hub_run->proc~dqmc_phy0_geterr proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_hub_run->proc~dqmc_phy2_geterr proc~dqmc_phy2_avg_symm DQMC_Phy2::DQMC_Phy2_Avg_Symm interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_symm proc~dqmc_phy2_avg_wave DQMC_Phy2::DQMC_Phy2_Avg_Wave interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_wave proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate proc~dqmc_hub_sweep->proc~dqmc_applyupdate proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_sweep->proc~dqmc_getg_2nd_order proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_sweep->proc~dqmc_gfun_copyup proc~dqmc_gfun_getjj DQMC_GFun::DQMC_Gfun_Getjj proc~dqmc_hub_sweep->proc~dqmc_gfun_getjj proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_sweep->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_sweep->proc~dqmc_phy2_meas proc~dqmc_syncwraps DQMC_GFun::DQMC_SyncWraps proc~dqmc_hub_sweep->proc~dqmc_syncwraps proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG proc~dqmc_hub_sweep->proc~dqmc_updateg proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps proc~dqmc_hub_sweep->proc~dqmc_updatewraps proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_sweep->proc~ran0 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2->proc~dqmc_gfun_copyup proc~dqmc_hub_sweep2->proc~ran0 blas_dscal blas_dscal proc~dqmc_phy0_avg->blas_dscal proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_phy0_avg->proc~dqmc_error interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife proc~dqmc_phy0_geterr->interface~dqmc_jackknife interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife proc~dqmc_phy0_geterr->interface~dqmc_signjackknife proc~dqmc_phy2_geterr->interface~dqmc_jackknife proc~dqmc_phy2_geterr->interface~dqmc_signjackknife proc~dqmc_jackknife_complex DQMC_Util::DQMC_JackKnife_Complex interface~dqmc_jackknife->proc~dqmc_jackknife_complex proc~dqmc_jackknife_real DQMC_Util::DQMC_JackKnife_Real interface~dqmc_jackknife->proc~dqmc_jackknife_real proc~dqmc_signjackknife_complex DQMC_Util::DQMC_SignJackKnife_Complex interface~dqmc_signjackknife->proc~dqmc_signjackknife_complex proc~dqmc_signjackknife_real DQMC_Util::DQMC_SignJackKnife_Real interface~dqmc_signjackknife->proc~dqmc_signjackknife_real blas_dgemm blas_dgemm proc~dqmc_applyupdate->blas_dgemm blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right blas_ddot blas_ddot proc~dqmc_gfun_getjj->blas_ddot blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_pair_symm DQMC_Phy2::DQMC_Pair_Symm proc~dqmc_phy2_avg_symm->proc~dqmc_pair_symm proc~dqmc_wave_avg DQMC_Phy2::DQMC_Wave_Avg proc~dqmc_phy2_avg_wave->proc~dqmc_wave_avg proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair proc~dqmc_updateg->blas_dscal proc~dqmc_updateg->proc~dqmc_applyupdate blas_dgemv blas_dgemv proc~dqmc_updateg->blas_dgemv dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_computeg->proc~dqmc_error proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_multb_left->blas_dscal proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->blas_dgemm dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv proc~dqmc_wave_avg->blas_ddot proc~dqmc_wave_avg->blas_dgemm dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dcopy blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_run~~CalledByGraph proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_run.html"},{"title":"DQMC_Hub_FullMeas – Quest","text":"public  subroutine DQMC_Hub_FullMeas(Hub, nnb, A_up, A_dn, sgn_up, sgn_dn) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: nnb real(kind=wp), intent(in) :: A_up (nnb,nnb) real(kind=wp), intent(in) :: A_dn (nnb,nnb) real(kind=wp), intent(in) :: sgn_up real(kind=wp), intent(in) :: sgn_dn Calls proc~~dqmc_hub_fullmeas~~CallsGraph proc~dqmc_hub_fullmeas DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_fullmeas->proc~dqmc_getg_2nd_order proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_fullmeas->proc~dqmc_gfun_clone proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_fullmeas->proc~dqmc_gfun_copyup proc~dqmc_gfun_duplicate DQMC_GFun::DQMC_GFun_Duplicate proc~dqmc_hub_fullmeas->proc~dqmc_gfun_duplicate proc~dqmc_gfun_free DQMC_GFun::DQMC_Gfun_Free proc~dqmc_hub_fullmeas->proc~dqmc_gfun_free proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_fullmeas->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_fullmeas->proc~dqmc_phy2_meas blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy blas_dgemm blas_dgemm proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_fullmeas~~CalledByGraph proc~dqmc_hub_fullmeas DQMC_Hubbard::DQMC_Hub_FullMeas program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_fullmeas Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_fullmeas.html"},{"title":"DQMC_Hub_Meas – Quest","text":"public  subroutine DQMC_Hub_Meas(Hub, slice) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(inout) :: slice Calls proc~~dqmc_hub_meas~~CallsGraph proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_meas->proc~dqmc_getg_2nd_order proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_meas->proc~dqmc_gfun_clone proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_meas->proc~dqmc_gfun_copyup proc~dqmc_gfun_duplicate DQMC_GFun::DQMC_GFun_Duplicate proc~dqmc_hub_meas->proc~dqmc_gfun_duplicate proc~dqmc_gfun_free DQMC_GFun::DQMC_Gfun_Free proc~dqmc_hub_meas->proc~dqmc_gfun_free proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_meas->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_meas->proc~dqmc_phy2_meas proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_meas->proc~ran0 blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy blas_dgemm blas_dgemm proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_meas~~CalledByGraph proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_meas.html"},{"title":"DQMC_Hub_Init_Vmat – Quest","text":"public  subroutine DQMC_Hub_Init_Vmat(Hub) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub Called by proc~~dqmc_hub_init_vmat~~CalledByGraph proc~dqmc_hub_init_vmat DQMC_Hubbard::DQMC_Hub_Init_Vmat proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_hub_init_vmat program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_init_vmat proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_init_vmat.html"},{"title":"closer_to_zero – Quest","text":"public  function closer_to_zero(ktp, kset, on_edge, ndim) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ktp (rdim) real(kind=8), intent(in) :: kset (3**ndim-1,rdim) logical :: on_edge integer, intent(in) :: ndim Return Value logical Called by proc~~closer_to_zero~~CalledByGraph proc~closer_to_zero DQMC_RECLATT::closer_to_zero proc~construct_recip_lattice DQMC_RECLATT::construct_recip_lattice proc~construct_recip_lattice->proc~closer_to_zero proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~construct_recip_lattice program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/closer_to_zero.html"},{"title":"free_reclatt – Quest","text":"public  subroutine free_reclatt(reclatt) Arguments Type Intent Optional Attributes Name type( recip_lattice_t ), intent(inout) :: reclatt","tags":"","loc":"proc/free_reclatt.html"},{"title":"init_recip_latt – Quest","text":"public  subroutine init_recip_latt(lattice, recip_lattice, applytwist, cfg) Arguments Type Intent Optional Attributes Name type( lattice_t ), intent(in), target :: lattice type( recip_lattice_t ), intent(out), target :: recip_lattice logical, intent(in) :: applytwist type( config ), intent(in), target :: cfg Calls proc~~init_recip_latt~~CallsGraph proc~init_recip_latt DQMC_RECLATT::init_recip_latt interface~cfg_get DQMC_Cfg::CFG_Get proc~init_recip_latt->interface~cfg_get proc~get_inverse DQMC_Util::get_inverse proc~init_recip_latt->proc~get_inverse proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI interface~cfg_get->proc~dqmc_config_geti proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI interface~cfg_get->proc~dqmc_config_getpi proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR interface~cfg_get->proc~dqmc_config_getpr proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR interface~cfg_get->proc~dqmc_config_getr proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS interface~cfg_get->proc~dqmc_config_gets proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_config_geti->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_geti->proc~dqmc_find_param proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_config_geti->proc~dqmc_warning proc~dqmc_config_getpi->proc~dqmc_error proc~dqmc_config_getpi->proc~dqmc_find_param proc~dqmc_config_getpi->proc~dqmc_warning proc~dqmc_config_getpr->proc~dqmc_error proc~dqmc_config_getpr->proc~dqmc_find_param proc~dqmc_config_getpr->proc~dqmc_warning proc~dqmc_config_getr->proc~dqmc_error proc~dqmc_config_getr->proc~dqmc_find_param proc~dqmc_config_getr->proc~dqmc_warning proc~dqmc_config_gets->proc~dqmc_error proc~dqmc_config_gets->proc~dqmc_find_param proc~dqmc_config_gets->proc~dqmc_warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_recip_latt~~CalledByGraph proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~init_recip_latt program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/init_recip_latt.html"},{"title":"construct_recip_lattice – Quest","text":"public  subroutine construct_recip_lattice(recip_lattice) Arguments Type Intent Optional Attributes Name type( recip_lattice_t ), intent(inout) :: recip_lattice Calls proc~~construct_recip_lattice~~CallsGraph proc~construct_recip_lattice DQMC_RECLATT::construct_recip_lattice proc~closer_to_zero DQMC_RECLATT::closer_to_zero proc~construct_recip_lattice->proc~closer_to_zero proc~get_inverse DQMC_Util::get_inverse proc~construct_recip_lattice->proc~get_inverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~construct_recip_lattice~~CalledByGraph proc~construct_recip_lattice DQMC_RECLATT::construct_recip_lattice proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~construct_recip_lattice program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_recip_lattice.html"},{"title":"DQMC_init_kmate – Quest","text":"public  subroutine DQMC_init_kmate(reclatt, nmom, ksum) Arguments Type Intent Optional Attributes Name type( recip_lattice_t ), intent(inout) :: reclatt integer, intent(in) :: nmom real(kind=wp), intent(in) :: ksum (nmom,rdim) Calls proc~~dqmc_init_kmate~~CallsGraph proc~dqmc_init_kmate DQMC_RECLATT::DQMC_init_kmate proc~get_inverse DQMC_Util::get_inverse proc~dqmc_init_kmate->proc~get_inverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_init_kmate.html"},{"title":"DQMC_Fill_FourierC – Quest","text":"public  subroutine DQMC_Fill_FourierC(Reciplattice, lattice) Arguments Type Intent Optional Attributes Name type( recip_lattice_t ), intent(inout), target :: Reciplattice type( lattice_t ), intent(in), target :: lattice Called by proc~~dqmc_fill_fourierc~~CalledByGraph proc~dqmc_fill_fourierc DQMC_RECLATT::DQMC_Fill_FourierC proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~dqmc_fill_fourierc program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_fill_fourierc.html"},{"title":"DQMC_B_Init – Quest","text":"public  subroutine DQMC_B_Init(n, B, WS, adj, ckb, t, mu, dtau) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n type( matB ), intent(inout) :: B type( WSpace ), intent(inout), target :: WS type( CCS ), intent(in) :: adj type( CCS ), intent(out) :: ckb real(kind=wp), intent(in) :: t (:) real(kind=wp), intent(in) :: mu (n) real(kind=wp), intent(in) :: dtau Calls proc~~dqmc_b_init~~CallsGraph proc~dqmc_b_init DQMC_MATB::DQMC_B_Init proc~dqmc_b_expinit DQMC_MATB::DQMC_B_ExpInit proc~dqmc_b_init->proc~dqmc_b_expinit blas_dgemm blas_dgemm proc~dqmc_b_expinit->blas_dgemm blas_dscal blas_dscal proc~dqmc_b_expinit->blas_dscal dexp dexp proc~dqmc_b_expinit->dexp lapack_dsyev lapack_dsyev proc~dqmc_b_expinit->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_b_expinit->proc~dqmc_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_b_init~~CalledByGraph proc~dqmc_b_init DQMC_MATB::DQMC_B_Init proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_b_init proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_b_init proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_b_init.html"},{"title":"DQMC_B_ExpInit – Quest","text":"public  subroutine DQMC_B_ExpInit(B, K, WS) Check error message\nScale the right eigenmatrix\nScale the right eigenmatrix\nScale the right eigenmatrix Arguments Type Intent Optional Attributes Name type( matB ), intent(inout) :: B real(kind=wp), intent(inout) :: K (:,:) type( WSpace ), intent(inout), target :: WS Calls proc~~dqmc_b_expinit~~CallsGraph proc~dqmc_b_expinit DQMC_MATB::DQMC_B_ExpInit blas_dgemm blas_dgemm proc~dqmc_b_expinit->blas_dgemm blas_dscal blas_dscal proc~dqmc_b_expinit->blas_dscal dexp dexp proc~dqmc_b_expinit->dexp lapack_dsyev lapack_dsyev proc~dqmc_b_expinit->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_b_expinit->proc~dqmc_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_b_expinit~~CalledByGraph proc~dqmc_b_expinit DQMC_MATB::DQMC_B_ExpInit proc~dqmc_b_init DQMC_MATB::DQMC_B_Init proc~dqmc_b_init->proc~dqmc_b_expinit proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_b_init proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_b_init proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_b_expinit.html"},{"title":"DQMC_B_Free – Quest","text":"public  subroutine DQMC_B_Free(B) Arguments Type Intent Optional Attributes Name type( matB ), intent(inout) :: B Called by proc~~dqmc_b_free~~CalledByGraph proc~dqmc_b_free DQMC_MATB::DQMC_B_Free proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free->proc~dqmc_b_free proc~dqmc_hub_free~2 DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free~2->proc~dqmc_b_free proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_free program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_free program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_free program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_b_free.html"},{"title":"DQMC_MultB_Left – Quest","text":"public  subroutine DQMC_MultB_Left(n, M, B, V_i, C) Check error message Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) Calls proc~~dqmc_multb_left~~CallsGraph proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left blas_dgemm blas_dgemm proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_multb_left->proc~dqmc_scalerow dscal dscal proc~dqmc_scalerow->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_multb_left~~CalledByGraph proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_change_gtau_time->proc~dqmc_multb_left proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_seqmultb proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_change_gtau_time proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_multb_left.html"},{"title":"DQMC_MultBi_Left – Quest","text":"public  subroutine DQMC_MultBi_Left(n, M, B, V_i, C) Check error message Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) Calls proc~~dqmc_multbi_left~~CallsGraph proc~dqmc_multbi_left DQMC_MATB::DQMC_MultBi_Left blas_dgemm blas_dgemm proc~dqmc_multbi_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multbi_left->blas_dscal dexp dexp proc~dqmc_multbi_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multbi_left->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multbi_left->proc~dqmc_error proc~dqmc_scalerowinv DQMC_Util::DQMC_ScaleRowInv proc~dqmc_multbi_left->proc~dqmc_scalerowinv dscal dscal proc~dqmc_scalerowinv->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_multbi_left~~CalledByGraph proc~dqmc_multbi_left DQMC_MATB::DQMC_MultBi_Left proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_change_gtau_time->proc~dqmc_multbi_left proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_seqmultbi->proc~dqmc_multbi_left proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_seqmultbi proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_change_gtau_time proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_multbi_left.html"},{"title":"DQMC_MultB_Right – Quest","text":"public  subroutine DQMC_MultB_Right(n, M, B, V_i, C) Check error message Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) Calls proc~~dqmc_multb_right~~CallsGraph proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right blas_dgemm blas_dgemm proc~dqmc_multb_right->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_right->blas_dscal dexp dexp proc~dqmc_multb_right->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_right->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_multb_right->proc~dqmc_scalecol dscal dscal proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_multb_right~~CalledByGraph proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_change_gtau_time->proc~dqmc_multb_right proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_gtau_loada DQMC_GTAU::DQMC_Gtau_LoadA proc~dqmc_gtau_loada->proc~dqmc_multb_right proc~dqmc_gtau_loada->proc~dqmc_getb proc~dqmc_gtau_getg0 DQMC_GTAU::DQMC_Gtau_GetG0 proc~dqmc_gtau_getg0->proc~dqmc_getb proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_change_gtau_time proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_gtau_loada program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy program~dqmc_ggeom->proc~dqmc_tdm1_selfenergy proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas program~dqmc_ggeom->proc~dqmc_hub_meas proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep program~dqmc_ggeom->proc~dqmc_hub_sweep proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 program~dqmc_ggeom->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_getgtau->proc~dqmc_seqmultb proc~dqmc_tdm1_selfenergy->proc~dqmc_gtau_getg0 proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_multb_right.html"},{"title":"DQMC_MultBi_Right – Quest","text":"public  subroutine DQMC_MultBi_Right(n, M, B, V_i, C) Check error message Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) Calls proc~~dqmc_multbi_right~~CallsGraph proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right blas_dgemm blas_dgemm proc~dqmc_multbi_right->blas_dgemm blas_dscal blas_dscal proc~dqmc_multbi_right->blas_dscal dexp dexp proc~dqmc_multbi_right->dexp lapack_dsyev lapack_dsyev proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_multbi_right~~CalledByGraph proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_change_gtau_time->proc~dqmc_multbi_right proc~dqmc_getbi DQMC_MATB::DQMC_GetBi proc~dqmc_getbi->proc~dqmc_multbi_right proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_multbi_right proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_change_gtau_time proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_seqmultbi->proc~dqmc_getbi proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_getgtau->proc~dqmc_seqmultbi proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_multbi_right.html"},{"title":"DQMC_MultrtB0_Left – Quest","text":"public  subroutine DQMC_MultrtB0_Left(n, M, B, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(inout) :: C (n,n) Calls proc~~dqmc_multrtb0_left~~CallsGraph proc~dqmc_multrtb0_left DQMC_MATB::DQMC_MultrtB0_Left blas_dgemm blas_dgemm proc~dqmc_multrtb0_left->blas_dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_multrtb0_left.html"},{"title":"DQMC_MultrtB0i_Right – Quest","text":"public  subroutine DQMC_MultrtB0i_Right(n, M, B, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(inout) :: C (n,n) Calls proc~~dqmc_multrtb0i_right~~CallsGraph proc~dqmc_multrtb0i_right DQMC_MATB::DQMC_MultrtB0i_Right blas_dgemm blas_dgemm proc~dqmc_multrtb0i_right->blas_dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_multrtb0i_right.html"},{"title":"DQMC_GetB – Quest","text":"public  subroutine DQMC_GetB(n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) Calls proc~~dqmc_getb~~CallsGraph proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_getb->proc~dqmc_scalerow blas_dgemm blas_dgemm proc~dqmc_multb_right->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_right->blas_dscal dexp dexp proc~dqmc_multb_right->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_right->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_multb_right->proc~dqmc_scalecol dscal dscal proc~dqmc_scalerow->dscal proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_getb~~CalledByGraph proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_gtau_getg0 DQMC_GTAU::DQMC_Gtau_GetG0 proc~dqmc_gtau_getg0->proc~dqmc_getb proc~dqmc_gtau_loada DQMC_GTAU::DQMC_Gtau_LoadA proc~dqmc_gtau_loada->proc~dqmc_getb proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_seqmultb proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy proc~dqmc_tdm1_selfenergy->proc~dqmc_gtau_getg0 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_gtau_loada program~dqmc_ggeom->proc~dqmc_tdm1_selfenergy proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas program~dqmc_ggeom->proc~dqmc_hub_meas proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep program~dqmc_ggeom->proc~dqmc_hub_sweep proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 program~dqmc_ggeom->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_getb.html"},{"title":"DQMC_GetBi – Quest","text":"public  subroutine DQMC_GetBi(n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) Calls proc~~dqmc_getbi~~CallsGraph proc~dqmc_getbi DQMC_MATB::DQMC_GetBi proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getbi->proc~dqmc_multbi_right proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_getbi->proc~dqmc_scalecolinv proc~dqmc_multbi_right->proc~dqmc_scalecolinv blas_dgemm blas_dgemm proc~dqmc_multbi_right->blas_dgemm blas_dscal blas_dscal proc~dqmc_multbi_right->blas_dscal dexp dexp proc~dqmc_multbi_right->dexp lapack_dsyev lapack_dsyev proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multbi_right->proc~dqmc_error dscal dscal proc~dqmc_scalecolinv->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_getbi~~CalledByGraph proc~dqmc_getbi DQMC_MATB::DQMC_GetBi proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_seqmultbi->proc~dqmc_getbi proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_seqmultbi proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_getgtau Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_getbi.html"},{"title":"count_symmetry – Quest","text":"public  function count_symmetry() Arguments None Return Value integer Calls proc~~count_symmetry~~CallsGraph proc~count_symmetry DQMC_SYMM::count_symmetry proc~move_to_record DQMC_Util::move_to_record proc~count_symmetry->proc~move_to_record Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~count_symmetry~~CalledByGraph proc~count_symmetry DQMC_SYMM::count_symmetry proc~read_symm DQMC_SYMM::read_symm proc~read_symm->proc~count_symmetry proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~read_symm program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/count_symmetry.html"},{"title":"free_symm – Quest","text":"public  subroutine free_symm(symm) Arguments Type Intent Optional Attributes Name type( symm_operations ), intent(inout) :: symm","tags":"","loc":"proc/free_symm.html"},{"title":"read_symm – Quest","text":"public  subroutine read_symm(SymmOp) Arguments Type Intent Optional Attributes Name type( symm_operations ), intent(out) :: SymmOp Calls proc~~read_symm~~CallsGraph proc~read_symm DQMC_SYMM::read_symm proc~count_symmetry DQMC_SYMM::count_symmetry proc~read_symm->proc~count_symmetry proc~move_to_record DQMC_Util::move_to_record proc~read_symm->proc~move_to_record proc~count_symmetry->proc~move_to_record Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_symm~~CalledByGraph proc~read_symm DQMC_SYMM::read_symm proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~read_symm program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/read_symm.html"},{"title":"apply_point_symm – Quest","text":"public  subroutine apply_point_symm(label, point, axis, theta, set, new_set, nset, reciprocal) Arguments Type Intent Optional Attributes Name character(len=1) :: label real(kind=8), intent(in) :: point (3) real(kind=8), intent(in) :: axis (3) real(kind=8), intent(in) :: theta real(kind=8), intent(in) :: set (3*nset) real(kind=8), intent(out) :: new_set (3,nset) integer, intent(in) :: nset logical, intent(in) :: reciprocal Called by proc~~apply_point_symm~~CalledByGraph proc~apply_point_symm DQMC_SYMM::apply_point_symm proc~map_symm_lattice DQMC_SYMM::map_symm_lattice proc~map_symm_lattice->proc~apply_point_symm proc~map_symm_recip_lattice DQMC_SYMM::map_symm_recip_lattice proc~map_symm_recip_lattice->proc~apply_point_symm proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~map_symm_lattice proc~dqmc_geom_fill->proc~map_symm_recip_lattice program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/apply_point_symm.html"},{"title":"map_symm_lattice – Quest","text":"public  subroutine map_symm_lattice(SymmOp, lattice, hamilt, SOP) Uses DQMC_HAMILT DQMC_LATT proc~~map_symm_lattice~~UsesGraph proc~map_symm_lattice DQMC_SYMM::map_symm_lattice module~dqmc_hamilt DQMC_HAMILT proc~map_symm_lattice->module~dqmc_hamilt module~dqmc_latt DQMC_LATT proc~map_symm_lattice->module~dqmc_latt module~dqmc_hamilt->module~dqmc_latt module~dqmc_cfg DQMC_Cfg module~dqmc_hamilt->module~dqmc_cfg module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_hamilt->module~dqmc_geom_param module~dqmc_reclatt DQMC_RECLATT module~dqmc_hamilt->module~dqmc_reclatt module~dqmc_latt->module~dqmc_geom_param module~dqmc_util DQMC_Util module~dqmc_latt->module~dqmc_util module~dqmc_cfg->module~dqmc_util module~dqmc_reclatt->module~dqmc_latt module~dqmc_reclatt->module~dqmc_cfg module~dqmc_reclatt->module~dqmc_geom_param Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( symm_operations ) :: SymmOp type( lattice_t ), intent(in) :: lattice type( Hamiltonian_t ), intent(in) :: hamilt integer, intent(in) :: SOP Calls proc~~map_symm_lattice~~CallsGraph proc~map_symm_lattice DQMC_SYMM::map_symm_lattice proc~apply_point_symm DQMC_SYMM::apply_point_symm proc~map_symm_lattice->proc~apply_point_symm proc~get_inverse DQMC_Util::get_inverse proc~map_symm_lattice->proc~get_inverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~map_symm_lattice~~CalledByGraph proc~map_symm_lattice DQMC_SYMM::map_symm_lattice proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~map_symm_lattice program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/map_symm_lattice.html"},{"title":"map_symm_recip_lattice – Quest","text":"public  subroutine map_symm_recip_lattice(SymmOp, recip_lattice, applytwist) Uses DQMC_RECLATT proc~~map_symm_recip_lattice~~UsesGraph proc~map_symm_recip_lattice DQMC_SYMM::map_symm_recip_lattice module~dqmc_reclatt DQMC_RECLATT proc~map_symm_recip_lattice->module~dqmc_reclatt module~dqmc_cfg DQMC_Cfg module~dqmc_reclatt->module~dqmc_cfg module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_reclatt->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_reclatt->module~dqmc_latt module~dqmc_util DQMC_Util module~dqmc_cfg->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param module~dqmc_latt->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( symm_operations ) :: SymmOp type( recip_lattice_t ), intent(in) :: recip_lattice logical, intent(in) :: applytwist Calls proc~~map_symm_recip_lattice~~CallsGraph proc~map_symm_recip_lattice DQMC_SYMM::map_symm_recip_lattice proc~apply_point_symm DQMC_SYMM::apply_point_symm proc~map_symm_recip_lattice->proc~apply_point_symm proc~get_inverse DQMC_Util::get_inverse proc~map_symm_recip_lattice->proc~get_inverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~map_symm_recip_lattice~~CalledByGraph proc~map_symm_recip_lattice DQMC_SYMM::map_symm_recip_lattice proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~map_symm_recip_lattice program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/map_symm_recip_lattice.html"},{"title":"map_symm_bonds – Quest","text":"public  subroutine map_symm_bonds(Bonds, SymmOp, Lattice) Uses DQMC_BONDS proc~~map_symm_bonds~~UsesGraph proc~map_symm_bonds DQMC_SYMM::map_symm_bonds module~dqmc_bonds DQMC_BONDS proc~map_symm_bonds->module~dqmc_bonds module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_latt->module~dqmc_geom_param module~dqmc_util DQMC_Util module~dqmc_latt->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( bonds_t ), intent(inout) :: Bonds type( symm_operations ), intent(inout) :: SymmOp type( lattice_t ), intent(in) :: Lattice Calls proc~~map_symm_bonds~~CallsGraph proc~map_symm_bonds DQMC_SYMM::map_symm_bonds proc~get_inverse DQMC_Util::get_inverse proc~map_symm_bonds->proc~get_inverse proc~hoptowho DQMC_LATT::hoptowho proc~map_symm_bonds->proc~hoptowho proc~hoptowho->proc~get_inverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~map_symm_bonds~~CalledByGraph proc~map_symm_bonds DQMC_SYMM::map_symm_bonds proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~map_symm_bonds program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/map_symm_bonds.html"},{"title":"map_symm_pairs – Quest","text":"public  subroutine map_symm_pairs(Pairs, SymmOp) Uses DQMC_BONDS proc~~map_symm_pairs~~UsesGraph proc~map_symm_pairs DQMC_SYMM::map_symm_pairs module~dqmc_bonds DQMC_BONDS proc~map_symm_pairs->module~dqmc_bonds module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_latt->module~dqmc_geom_param module~dqmc_util DQMC_Util module~dqmc_latt->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( pairing ), intent(inout) :: Pairs type( symm_operations ), intent(inout) :: SymmOp Called by proc~~map_symm_pairs~~CalledByGraph proc~map_symm_pairs DQMC_SYMM::map_symm_pairs proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~map_symm_pairs program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/map_symm_pairs.html"},{"title":"construct_lattice_classes – Quest","text":"public  subroutine construct_lattice_classes(SymmOp, lattice) Uses DQMC_LATT proc~~construct_lattice_classes~~UsesGraph proc~construct_lattice_classes DQMC_SYMM::construct_lattice_classes module~dqmc_latt DQMC_LATT proc~construct_lattice_classes->module~dqmc_latt module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_latt->module~dqmc_geom_param module~dqmc_util DQMC_Util module~dqmc_latt->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( symm_operations ) :: SymmOp type( lattice_t ) :: lattice Called by proc~~construct_lattice_classes~~CalledByGraph proc~construct_lattice_classes DQMC_SYMM::construct_lattice_classes proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~construct_lattice_classes program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_lattice_classes.html"},{"title":"construct_recip_lattice_classes – Quest","text":"public  subroutine construct_recip_lattice_classes(SymmOp, recip_lattice, applytwist) Uses DQMC_RECLATT proc~~construct_recip_lattice_classes~~UsesGraph proc~construct_recip_lattice_classes DQMC_SYMM::construct_recip_lattice_classes module~dqmc_reclatt DQMC_RECLATT proc~construct_recip_lattice_classes->module~dqmc_reclatt module~dqmc_cfg DQMC_Cfg module~dqmc_reclatt->module~dqmc_cfg module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_reclatt->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_reclatt->module~dqmc_latt module~dqmc_util DQMC_Util module~dqmc_cfg->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param module~dqmc_latt->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( symm_operations ) :: SymmOp type( recip_lattice_t ) :: recip_lattice logical, intent(in) :: applytwist Called by proc~~construct_recip_lattice_classes~~CalledByGraph proc~construct_recip_lattice_classes DQMC_SYMM::construct_recip_lattice_classes proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~construct_recip_lattice_classes program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_recip_lattice_classes.html"},{"title":"construct_bond_classes – Quest","text":"public  subroutine construct_bond_classes(Bonds, SymmOp) Uses DQMC_BONDS proc~~construct_bond_classes~~UsesGraph proc~construct_bond_classes DQMC_SYMM::construct_bond_classes module~dqmc_bonds DQMC_BONDS proc~construct_bond_classes->module~dqmc_bonds module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_latt->module~dqmc_geom_param module~dqmc_util DQMC_Util module~dqmc_latt->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( bonds_t ), intent(inout) :: Bonds type( symm_operations ), intent(in) :: SymmOp Called by proc~~construct_bond_classes~~CalledByGraph proc~construct_bond_classes DQMC_SYMM::construct_bond_classes proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~construct_bond_classes program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_bond_classes.html"},{"title":"construct_pair_classes – Quest","text":"public  subroutine construct_pair_classes(Bonds, Pairs) Uses DQMC_BONDS proc~~construct_pair_classes~~UsesGraph proc~construct_pair_classes DQMC_SYMM::construct_pair_classes module~dqmc_bonds DQMC_BONDS proc~construct_pair_classes->module~dqmc_bonds module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_latt->module~dqmc_geom_param module~dqmc_util DQMC_Util module~dqmc_latt->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( bonds_t ), intent(in) :: Bonds type( pairing ), intent(inout) :: Pairs Called by proc~~construct_pair_classes~~CalledByGraph proc~construct_pair_classes DQMC_SYMM::construct_pair_classes proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~construct_pair_classes program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_pair_classes.html"},{"title":"DQMC_Hub_Config – Quest","text":"public  subroutine DQMC_Hub_Config(Hub, cfg) Uses DQMC_MPI proc~~dqmc_hub_config~2~~UsesGraph proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config module~dqmc_mpi DQMC_MPI proc~dqmc_hub_config~2->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub type( config ), intent(inout) :: cfg Calls proc~~dqmc_hub_config~2~~CallsGraph proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config interface~cfg_get DQMC_Cfg::CFG_Get proc~dqmc_hub_config~2->interface~cfg_get interface~cfg_set DQMC_Cfg::CFG_Set proc~dqmc_hub_config~2->interface~cfg_set proc~dqmc_config_isset DQMC_Cfg::DQMC_Config_isSet proc~dqmc_hub_config~2->proc~dqmc_config_isset proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_hub_config~2->proc~dqmc_error proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_hub_config~2->proc~dqmc_warning proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI interface~cfg_get->proc~dqmc_config_geti proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI interface~cfg_get->proc~dqmc_config_getpi proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR interface~cfg_get->proc~dqmc_config_getpr proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR interface~cfg_get->proc~dqmc_config_getr proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS interface~cfg_get->proc~dqmc_config_gets proc~dqmc_config_seti DQMC_Cfg::DQMC_Config_SetI interface~cfg_set->proc~dqmc_config_seti proc~dqmc_config_setpi DQMC_Cfg::DQMC_Config_SetPI interface~cfg_set->proc~dqmc_config_setpi proc~dqmc_config_setpr DQMC_Cfg::DQMC_Config_SetPR interface~cfg_set->proc~dqmc_config_setpr proc~dqmc_config_setr DQMC_Cfg::DQMC_Config_SetR interface~cfg_set->proc~dqmc_config_setr proc~dqmc_config_sets DQMC_Cfg::DQMC_Config_SetS interface~cfg_set->proc~dqmc_config_sets proc~dqmc_config_isset->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_config_isset->proc~dqmc_find_param proc~dqmc_hub_init~2->proc~dqmc_error proc~dqmc_hub_init~2->proc~dqmc_warning float float proc~dqmc_hub_init~2->float proc~dqmc_b_init DQMC_MATB::DQMC_B_Init proc~dqmc_hub_init~2->proc~dqmc_b_init proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_init~2->proc~dqmc_gfun_clone proc~dqmc_gfun_init DQMC_GFun::DQMC_GFun_Init proc~dqmc_hub_init~2->proc~dqmc_gfun_init proc~dqmc_hub_init_vmat~2 DQMC_Hubbard::DQMC_Hub_Init_Vmat proc~dqmc_hub_init~2->proc~dqmc_hub_init_vmat~2 proc~dqmc_hub_input_hsf~2 DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_init~2->proc~dqmc_hub_input_hsf~2 proc~dqmc_phy0_init DQMC_Phy0::DQMC_Phy0_Init proc~dqmc_hub_init~2->proc~dqmc_phy0_init proc~dqmc_phy2_init DQMC_Phy2::DQMC_Phy2_Init proc~dqmc_hub_init~2->proc~dqmc_phy2_init proc~dqmc_seqb_init DQMC_SEQB::DQMC_SeqB_Init proc~dqmc_hub_init~2->proc~dqmc_seqb_init proc~dqmc_wspace_allocate DQMC_WSpace::DQMC_WSpace_Allocate proc~dqmc_hub_init~2->proc~dqmc_wspace_allocate proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_init~2->proc~ran0 proc~ran1 DQMC_Util::ran1 proc~dqmc_hub_init~2->proc~ran1 proc~dqmc_b_expinit DQMC_MATB::DQMC_B_ExpInit proc~dqmc_b_init->proc~dqmc_b_expinit proc~dqmc_config_geti->proc~dqmc_error proc~dqmc_config_geti->proc~dqmc_warning proc~dqmc_config_geti->proc~dqmc_find_param proc~dqmc_config_getpi->proc~dqmc_error proc~dqmc_config_getpi->proc~dqmc_warning proc~dqmc_config_getpi->proc~dqmc_find_param proc~dqmc_config_getpr->proc~dqmc_error proc~dqmc_config_getpr->proc~dqmc_warning proc~dqmc_config_getpr->proc~dqmc_find_param proc~dqmc_config_getr->proc~dqmc_error proc~dqmc_config_getr->proc~dqmc_warning proc~dqmc_config_getr->proc~dqmc_find_param proc~dqmc_config_gets->proc~dqmc_error proc~dqmc_config_gets->proc~dqmc_warning proc~dqmc_config_gets->proc~dqmc_find_param proc~dqmc_config_seti->proc~dqmc_error proc~dqmc_config_seti->proc~dqmc_find_param proc~dqmc_config_setpi->proc~dqmc_error proc~dqmc_config_setpi->proc~dqmc_find_param proc~dqmc_config_setpr->proc~dqmc_error proc~dqmc_config_setpr->proc~dqmc_find_param proc~dqmc_config_setr->proc~dqmc_error proc~dqmc_config_setr->proc~dqmc_find_param proc~dqmc_config_sets->proc~dqmc_error proc~dqmc_config_sets->proc~dqmc_find_param blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right proc~dqmc_hub_input_hsf~2->proc~dqmc_error lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_wspace_allocate->lapack_dgeqp3 lapack_dgetri lapack_dgetri proc~dqmc_wspace_allocate->lapack_dgetri lapack_dorgqr lapack_dorgqr proc~dqmc_wspace_allocate->lapack_dorgqr lapack_dormqr lapack_dormqr proc~dqmc_wspace_allocate->lapack_dormqr lapack_dsyev lapack_dsyev proc~dqmc_wspace_allocate->lapack_dsyev dlarnv dlarnv proc~ran0->dlarnv proc~ran1->dlarnv proc~dqmc_b_expinit->proc~dqmc_error proc~dqmc_b_expinit->lapack_dsyev blas_dgemm blas_dgemm proc~dqmc_b_expinit->blas_dgemm blas_dscal blas_dscal proc~dqmc_b_expinit->blas_dscal dexp dexp proc~dqmc_b_expinit->dexp proc~dqmc_computeg->proc~dqmc_error proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->blas_dgemm proc~dqmc_multb_left->blas_dscal proc~dqmc_multb_left->dexp proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->lapack_dgeqp3 proc~dqmc_udtd->lapack_dorgqr proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_config~2.html"},{"title":"DQMC_Hub_Init – Quest","text":"public  subroutine DQMC_Hub_Init(Hub, U, t_up, t_dn, mu_up, mu_dn, L, n_t, n_U, n_mu, dtau, HSF_IPT, nWarm, nPass, nMeas, nTry, nBin, ntausk, seed, nOrth, nWrap, fixw, errrate, difflim, gamma, accept, reject, delta1, delta2, ssxx, HSFtype, omega) Uses DQMC_MPI proc~~dqmc_hub_init~2~~UsesGraph proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init module~dqmc_mpi DQMC_MPI proc~dqmc_hub_init~2->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub real(kind=wp), intent(in) :: U (:) real(kind=wp), intent(in) :: t_up (:) real(kind=wp), intent(in) :: t_dn (:) real(kind=wp), intent(in) :: mu_up (:) real(kind=wp), intent(in) :: mu_dn (:) integer, intent(in) :: L integer, intent(in) :: n_t integer, intent(in) :: n_U integer, intent(in) :: n_mu real(kind=wp), intent(in) :: dtau integer, intent(in) :: HSF_IPT integer, intent(in) :: nWarm integer, intent(in) :: nPass integer, intent(in) :: nMeas integer, intent(in) :: nTry integer, intent(in) :: nBin integer, intent(in) :: ntausk integer, intent(in) :: seed integer, intent(in) :: nOrth integer, intent(in) :: nWrap integer, intent(in) :: fixw real(kind=wp), intent(in) :: errrate real(kind=wp), intent(in) :: difflim real(kind=wp), intent(in) :: gamma integer, intent(in) :: accept integer, intent(in) :: reject real(kind=wp), intent(in) :: delta1 real(kind=wp), intent(in) :: delta2 integer, intent(in) :: ssxx integer, intent(in) :: HSFtype real(kind=wp), intent(in) :: omega Calls proc~~dqmc_hub_init~2~~CallsGraph proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init float float proc~dqmc_hub_init~2->float proc~dqmc_b_init DQMC_MATB::DQMC_B_Init proc~dqmc_hub_init~2->proc~dqmc_b_init proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_hub_init~2->proc~dqmc_error proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_init~2->proc~dqmc_gfun_clone proc~dqmc_gfun_init DQMC_GFun::DQMC_GFun_Init proc~dqmc_hub_init~2->proc~dqmc_gfun_init proc~dqmc_hub_init_vmat~2 DQMC_Hubbard::DQMC_Hub_Init_Vmat proc~dqmc_hub_init~2->proc~dqmc_hub_init_vmat~2 proc~dqmc_hub_input_hsf~2 DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_init~2->proc~dqmc_hub_input_hsf~2 proc~dqmc_phy0_init DQMC_Phy0::DQMC_Phy0_Init proc~dqmc_hub_init~2->proc~dqmc_phy0_init proc~dqmc_phy2_init DQMC_Phy2::DQMC_Phy2_Init proc~dqmc_hub_init~2->proc~dqmc_phy2_init proc~dqmc_seqb_init DQMC_SEQB::DQMC_SeqB_Init proc~dqmc_hub_init~2->proc~dqmc_seqb_init proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_hub_init~2->proc~dqmc_warning proc~dqmc_wspace_allocate DQMC_WSpace::DQMC_WSpace_Allocate proc~dqmc_hub_init~2->proc~dqmc_wspace_allocate proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_init~2->proc~ran0 proc~ran1 DQMC_Util::ran1 proc~dqmc_hub_init~2->proc~ran1 proc~dqmc_b_expinit DQMC_MATB::DQMC_B_ExpInit proc~dqmc_b_init->proc~dqmc_b_expinit blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right proc~dqmc_hub_input_hsf~2->proc~dqmc_error lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_wspace_allocate->lapack_dgeqp3 lapack_dgetri lapack_dgetri proc~dqmc_wspace_allocate->lapack_dgetri lapack_dorgqr lapack_dorgqr proc~dqmc_wspace_allocate->lapack_dorgqr lapack_dormqr lapack_dormqr proc~dqmc_wspace_allocate->lapack_dormqr lapack_dsyev lapack_dsyev proc~dqmc_wspace_allocate->lapack_dsyev dlarnv dlarnv proc~ran0->dlarnv proc~ran1->dlarnv proc~dqmc_b_expinit->proc~dqmc_error proc~dqmc_b_expinit->lapack_dsyev blas_dgemm blas_dgemm proc~dqmc_b_expinit->blas_dgemm blas_dscal blas_dscal proc~dqmc_b_expinit->blas_dscal dexp dexp proc~dqmc_b_expinit->dexp proc~dqmc_computeg->proc~dqmc_error proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->blas_dgemm proc~dqmc_multb_left->blas_dscal proc~dqmc_multb_left->dexp proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->lapack_dgeqp3 proc~dqmc_udtd->lapack_dorgqr proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_init~2~~CalledByGraph proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_init~2.html"},{"title":"DQMC_Hub_Free – Quest","text":"public  subroutine DQMC_Hub_Free(Hub) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub Calls proc~~dqmc_hub_free~2~~CallsGraph proc~dqmc_hub_free~2 DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_b_free DQMC_MATB::DQMC_B_Free proc~dqmc_hub_free~2->proc~dqmc_b_free proc~dqmc_gfun_free DQMC_GFun::DQMC_Gfun_Free proc~dqmc_hub_free~2->proc~dqmc_gfun_free proc~dqmc_phy0_free DQMC_Phy0::DQMC_Phy0_Free proc~dqmc_hub_free~2->proc~dqmc_phy0_free proc~dqmc_phy2_free DQMC_Phy2::DQMC_Phy2_Free proc~dqmc_hub_free~2->proc~dqmc_phy2_free proc~dqmc_seqb_free DQMC_SEQB::DQMC_SeqB_Free proc~dqmc_hub_free~2->proc~dqmc_seqb_free proc~dqmc_struct_free DQMC_STRUCT::DQMC_Struct_Free proc~dqmc_hub_free~2->proc~dqmc_struct_free proc~dqmc_wspace_free DQMC_WSpace::DQMC_WSpace_Free proc~dqmc_hub_free~2->proc~dqmc_wspace_free proc~dqmc_ccs_free DQMC_STRUCT::DQMC_CCS_Free proc~dqmc_struct_free->proc~dqmc_ccs_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_free~2.html"},{"title":"DQMC_Hub_Output_HSF – Quest","text":"public  subroutine DQMC_Hub_Output_HSF(Hub, restore, slice, OPT) Uses DQMC_MPI proc~~dqmc_hub_output_hsf~2~~UsesGraph proc~dqmc_hub_output_hsf~2 DQMC_Hubbard::DQMC_Hub_Output_HSF module~dqmc_mpi DQMC_MPI proc~dqmc_hub_output_hsf~2->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in) :: Hub logical, intent(in) :: restore integer, intent(in) :: slice integer, intent(in) :: OPT Called by proc~~dqmc_hub_output_hsf~2~~CalledByGraph proc~dqmc_hub_output_hsf~2 DQMC_Hubbard::DQMC_Hub_Output_HSF proc~dqmc_hub_outputparam~2 DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_outputparam~2->proc~dqmc_hub_output_hsf~2 proc~dqmc_hub_print~2 DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_print~2->proc~dqmc_hub_outputparam~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_output_hsf~2.html"},{"title":"DQMC_Hub_Input_HSF – Quest","text":"public  subroutine DQMC_Hub_Input_HSF(Hub, restore, slice, IPT) Uses DQMC_MPI proc~~dqmc_hub_input_hsf~2~~UsesGraph proc~dqmc_hub_input_hsf~2 DQMC_Hubbard::DQMC_Hub_Input_HSF module~dqmc_mpi DQMC_MPI proc~dqmc_hub_input_hsf~2->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub logical, intent(in) :: restore integer, intent(out) :: slice integer, intent(in) :: IPT Calls proc~~dqmc_hub_input_hsf~2~~CallsGraph proc~dqmc_hub_input_hsf~2 DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_hub_input_hsf~2->proc~dqmc_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_input_hsf~2~~CalledByGraph proc~dqmc_hub_input_hsf~2 DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_hub_input_hsf~2 proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_input_hsf~2.html"},{"title":"DQMC_Hub_OutputParam – Quest","text":"public  subroutine DQMC_Hub_OutputParam(Hub, OPT) Uses DQMC_MPI proc~~dqmc_hub_outputparam~2~~UsesGraph proc~dqmc_hub_outputparam~2 DQMC_Hubbard::DQMC_Hub_OutputParam module~dqmc_mpi DQMC_MPI proc~dqmc_hub_outputparam~2->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in) :: Hub integer, intent(in) :: OPT Calls proc~~dqmc_hub_outputparam~2~~CallsGraph proc~dqmc_hub_outputparam~2 DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_output_hsf~2 DQMC_Hubbard::DQMC_Hub_Output_HSF proc~dqmc_hub_outputparam~2->proc~dqmc_hub_output_hsf~2 proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_hub_outputparam~2->proc~dqmc_warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_outputparam~2~~CalledByGraph proc~dqmc_hub_outputparam~2 DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_print~2 DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_print~2->proc~dqmc_hub_outputparam~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_outputparam~2.html"},{"title":"DQMC_Hub_Print – Quest","text":"public  subroutine DQMC_Hub_Print(Hub, OPT) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in) :: Hub integer, intent(in) :: OPT Calls proc~~dqmc_hub_print~2~~CallsGraph proc~dqmc_hub_print~2 DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_outputparam~2 DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_print~2->proc~dqmc_hub_outputparam~2 proc~dqmc_phy0_print DQMC_Phy0::DQMC_Phy0_Print proc~dqmc_hub_print~2->proc~dqmc_phy0_print proc~dqmc_phy2_print DQMC_Phy2::DQMC_Phy2_Print proc~dqmc_hub_print~2->proc~dqmc_phy2_print proc~dqmc_hub_output_hsf~2 DQMC_Hubbard::DQMC_Hub_Output_HSF proc~dqmc_hub_outputparam~2->proc~dqmc_hub_output_hsf~2 proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_hub_outputparam~2->proc~dqmc_warning proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray proc~dqmc_phy0_print->proc~dqmc_print_realarray proc~dqmc_phy2_print->proc~dqmc_print_realarray Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_print~2.html"},{"title":"DQMC_Hub_Sweep – Quest","text":"public  subroutine DQMC_Hub_Sweep(Hub, nMeas0) Uses DQMC_MPI proc~~dqmc_hub_sweep~2~~UsesGraph proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep module~dqmc_mpi DQMC_MPI proc~dqmc_hub_sweep~2->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout), target :: Hub integer, intent(in) :: nMeas0 Calls proc~~dqmc_hub_sweep~2~~CallsGraph proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate proc~dqmc_hub_sweep~2->proc~dqmc_applyupdate proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_sweep~2->proc~dqmc_getg_2nd_order proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_sweep~2->proc~dqmc_gfun_copyup proc~dqmc_gfun_getjj DQMC_GFun::DQMC_Gfun_Getjj proc~dqmc_hub_sweep~2->proc~dqmc_gfun_getjj proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_sweep~2->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_sweep~2->proc~dqmc_phy2_meas proc~dqmc_syncwraps DQMC_GFun::DQMC_SyncWraps proc~dqmc_hub_sweep~2->proc~dqmc_syncwraps proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG proc~dqmc_hub_sweep~2->proc~dqmc_updateg proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps proc~dqmc_hub_sweep~2->proc~dqmc_updatewraps proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_sweep~2->proc~ran0 blas_dgemm blas_dgemm proc~dqmc_applyupdate->blas_dgemm blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right blas_ddot blas_ddot proc~dqmc_gfun_getjj->blas_ddot blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair proc~dqmc_updateg->proc~dqmc_applyupdate blas_dgemv blas_dgemv proc~dqmc_updateg->blas_dgemv blas_dscal blas_dscal proc~dqmc_updateg->blas_dscal dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_multb_left->blas_dgemm proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_sweep~2~~CalledByGraph proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_sweep~2.html"},{"title":"DQMC_Hub_Sweep2 – Quest","text":"public  subroutine DQMC_Hub_Sweep2(Hub, numTry) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: numTry Calls proc~~dqmc_hub_sweep2~2~~CallsGraph proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_sweep2~2->proc~dqmc_gfun_copyup proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_sweep2~2->proc~ran0 blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning blas_dgemm blas_dgemm proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_hub_sweep2~2~~CalledByGraph proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_sweep2~2.html"},{"title":"DQMC_Hub_Sweep_Cont – Quest","text":"public  subroutine DQMC_Hub_Sweep_Cont(Hub, nMeas0) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout), target :: Hub integer, intent(in) :: nMeas0 Calls proc~~dqmc_hub_sweep_cont~2~~CallsGraph proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont float float proc~dqmc_hub_sweep_cont~2->float proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate proc~dqmc_hub_sweep_cont~2->proc~dqmc_applyupdate proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_gfun_getjj DQMC_GFun::DQMC_Gfun_Getjj proc~dqmc_hub_sweep_cont~2->proc~dqmc_gfun_getjj proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG proc~dqmc_hub_sweep_cont~2->proc~dqmc_updateg proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps proc~dqmc_hub_sweep_cont~2->proc~dqmc_updatewraps proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_sweep_cont~2->proc~ran0 blas_dgemm blas_dgemm proc~dqmc_applyupdate->blas_dgemm blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right blas_ddot blas_ddot proc~dqmc_gfun_getjj->blas_ddot proc~dqmc_updateg->proc~dqmc_applyupdate blas_dgemv blas_dgemv proc~dqmc_updateg->blas_dgemv blas_dscal blas_dscal proc~dqmc_updateg->blas_dscal dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_multb_left->blas_dgemm proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_sweep_cont~2.html"},{"title":"DQMC_Hub_Sweep2_Cont – Quest","text":"public  subroutine DQMC_Hub_Sweep2_Cont(Hub, numTry) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: numTry Calls proc~~dqmc_hub_sweep2_cont~2~~CallsGraph proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_sweep2_cont~2->proc~ran0 blas_dcopy blas_dcopy proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning dlarnv dlarnv proc~ran0->dlarnv dscal dscal proc~dqmc_scalerow->dscal proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow blas_dgemm blas_dgemm proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_sweep2_cont~2.html"},{"title":"DQMC_Hol_Sweep3_Cont – Quest","text":"public  subroutine DQMC_Hol_Sweep3_Cont(Hub, numTry) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: numTry Calls proc~~dqmc_hol_sweep3_cont~~CallsGraph proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~ran0 DQMC_Util::ran0 proc~dqmc_hol_sweep3_cont->proc~ran0 blas_dcopy blas_dcopy proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning dlarnv dlarnv proc~ran0->dlarnv dscal dscal proc~dqmc_scalerow->dscal proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow blas_dgemm blas_dgemm proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hol_sweep3_cont.html"},{"title":"DQMC_Hub_Run – Quest","text":"public  subroutine DQMC_Hub_Run(Hub, Info) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer :: Info Calls proc~~dqmc_hub_run~2~~CallsGraph proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run interface~dqmc_phy2_avg DQMC_Phy2::DQMC_Phy2_avg proc~dqmc_hub_run~2->interface~dqmc_phy2_avg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 proc~dqmc_phy0_avg DQMC_Phy0::DQMC_Phy0_Avg proc~dqmc_hub_run~2->proc~dqmc_phy0_avg proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_hub_run~2->proc~dqmc_phy0_geterr proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_hub_run~2->proc~dqmc_phy2_geterr proc~dqmc_phy2_avg_symm DQMC_Phy2::DQMC_Phy2_Avg_Symm interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_symm proc~dqmc_phy2_avg_wave DQMC_Phy2::DQMC_Phy2_Avg_Wave interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_wave proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_sweep2~2->proc~dqmc_gfun_copyup proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_sweep2~2->proc~ran0 proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate proc~dqmc_hub_sweep~2->proc~dqmc_applyupdate proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_sweep~2->proc~dqmc_getg_2nd_order proc~dqmc_hub_sweep~2->proc~dqmc_gfun_copyup proc~dqmc_gfun_getjj DQMC_GFun::DQMC_Gfun_Getjj proc~dqmc_hub_sweep~2->proc~dqmc_gfun_getjj proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_sweep~2->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_sweep~2->proc~dqmc_phy2_meas proc~dqmc_syncwraps DQMC_GFun::DQMC_SyncWraps proc~dqmc_hub_sweep~2->proc~dqmc_syncwraps proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG proc~dqmc_hub_sweep~2->proc~dqmc_updateg proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps proc~dqmc_hub_sweep~2->proc~dqmc_updatewraps proc~dqmc_hub_sweep~2->proc~ran0 blas_dscal blas_dscal proc~dqmc_phy0_avg->blas_dscal proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_phy0_avg->proc~dqmc_error interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife proc~dqmc_phy0_geterr->interface~dqmc_jackknife interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife proc~dqmc_phy0_geterr->interface~dqmc_signjackknife proc~dqmc_phy2_geterr->interface~dqmc_jackknife proc~dqmc_phy2_geterr->interface~dqmc_signjackknife proc~dqmc_jackknife_complex DQMC_Util::DQMC_JackKnife_Complex interface~dqmc_jackknife->proc~dqmc_jackknife_complex proc~dqmc_jackknife_real DQMC_Util::DQMC_JackKnife_Real interface~dqmc_jackknife->proc~dqmc_jackknife_real proc~dqmc_signjackknife_complex DQMC_Util::DQMC_SignJackKnife_Complex interface~dqmc_signjackknife->proc~dqmc_signjackknife_complex proc~dqmc_signjackknife_real DQMC_Util::DQMC_SignJackKnife_Real interface~dqmc_signjackknife->proc~dqmc_signjackknife_real blas_dgemm blas_dgemm proc~dqmc_applyupdate->blas_dgemm blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right blas_ddot blas_ddot proc~dqmc_gfun_getjj->blas_ddot blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_pair_symm DQMC_Phy2::DQMC_Pair_Symm proc~dqmc_phy2_avg_symm->proc~dqmc_pair_symm proc~dqmc_wave_avg DQMC_Phy2::DQMC_Wave_Avg proc~dqmc_phy2_avg_wave->proc~dqmc_wave_avg proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair proc~dqmc_updateg->blas_dscal proc~dqmc_updateg->proc~dqmc_applyupdate blas_dgemv blas_dgemv proc~dqmc_updateg->blas_dgemv dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_computeg->proc~dqmc_error proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_multb_left->blas_dscal proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->blas_dgemm dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv proc~dqmc_wave_avg->blas_ddot proc~dqmc_wave_avg->blas_dgemm dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dcopy blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_run~2.html"},{"title":"DQMC_Hub_FullMeas – Quest","text":"public  subroutine DQMC_Hub_FullMeas(Hub, nnb, A_up, A_dn, sgn_up, sgn_dn) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: nnb real(kind=wp), intent(in) :: A_up (nnb,nnb) real(kind=wp), intent(in) :: A_dn (nnb,nnb) real(kind=wp), intent(in) :: sgn_up real(kind=wp), intent(in) :: sgn_dn Calls proc~~dqmc_hub_fullmeas~2~~CallsGraph proc~dqmc_hub_fullmeas~2 DQMC_Hubbard::DQMC_Hub_FullMeas dqmc_phy0_meas_holstein dqmc_phy0_meas_holstein proc~dqmc_hub_fullmeas~2->dqmc_phy0_meas_holstein proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_fullmeas~2->proc~dqmc_getg_2nd_order proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_fullmeas~2->proc~dqmc_gfun_clone proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_fullmeas~2->proc~dqmc_gfun_copyup proc~dqmc_gfun_duplicate DQMC_GFun::DQMC_GFun_Duplicate proc~dqmc_hub_fullmeas~2->proc~dqmc_gfun_duplicate proc~dqmc_gfun_free DQMC_GFun::DQMC_Gfun_Free proc~dqmc_hub_fullmeas~2->proc~dqmc_gfun_free proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_fullmeas~2->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_fullmeas~2->proc~dqmc_phy2_meas blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy blas_dgemm blas_dgemm proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_fullmeas~2.html"},{"title":"DQMC_Hub_Meas – Quest","text":"public  subroutine DQMC_Hub_Meas(Hub, slice) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(inout) :: slice Calls proc~~dqmc_hub_meas~2~~CallsGraph proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas dqmc_phy0_meas_holstein dqmc_phy0_meas_holstein proc~dqmc_hub_meas~2->dqmc_phy0_meas_holstein proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_meas~2->proc~dqmc_getg_2nd_order proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_meas~2->proc~dqmc_gfun_clone proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_meas~2->proc~dqmc_gfun_copyup proc~dqmc_gfun_duplicate DQMC_GFun::DQMC_GFun_Duplicate proc~dqmc_hub_meas~2->proc~dqmc_gfun_duplicate proc~dqmc_gfun_free DQMC_GFun::DQMC_Gfun_Free proc~dqmc_hub_meas~2->proc~dqmc_gfun_free proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_meas~2->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_meas~2->proc~dqmc_phy2_meas proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_meas~2->proc~ran0 blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy blas_dgemm blas_dgemm proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_meas~2.html"},{"title":"DQMC_Hub_Init_Vmat – Quest","text":"public  subroutine DQMC_Hub_Init_Vmat(Hub) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub Called by proc~~dqmc_hub_init_vmat~2~~CalledByGraph proc~dqmc_hub_init_vmat~2 DQMC_Hubbard::DQMC_Hub_Init_Vmat proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_hub_init_vmat~2 proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_hub_init_vmat~2.html"},{"title":"DQMC_B_Init – Quest","text":"public  subroutine DQMC_B_Init(n, B, WS, adj, ckb, t, mu, dtau) Uses DQMC_STRUCT proc~~dqmc_b_init~2~~UsesGraph proc~dqmc_b_init~2 DQMC_CheckerBoard::DQMC_B_Init module~dqmc_struct DQMC_STRUCT proc~dqmc_b_init~2->module~dqmc_struct module~dqmc_cfg DQMC_Cfg module~dqmc_struct->module~dqmc_cfg module~dqmc_util DQMC_Util module~dqmc_struct->module~dqmc_util module~dqmc_cfg->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n type( matB ), intent(out) :: B type( WSpace ), intent(in), target :: WS type( CCS ), intent(in) :: adj type( CCS ), intent(in) :: ckb real(kind=wp), intent(in) :: t (*) real(kind=wp), intent(in) :: mu (n) real(kind=wp), intent(in) :: dtau Calls proc~~dqmc_b_init~2~~CallsGraph proc~dqmc_b_init~2 DQMC_CheckerBoard::DQMC_B_Init proc~dqmc_ccs_fill DQMC_STRUCT::DQMC_CCS_Fill proc~dqmc_b_init~2->proc~dqmc_ccs_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_b_init~2.html"},{"title":"DQMC_B_Free – Quest","text":"public  subroutine DQMC_B_Free(B) Arguments Type Intent Optional Attributes Name type( matB ), intent(inout) :: B","tags":"","loc":"proc/dqmc_b_free~2.html"},{"title":"DQMC_MultB_Left – Quest","text":"public  subroutine DQMC_MultB_Left(n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout), target :: M (n,n) type( matB ), intent(inout) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout), target :: C (n,n) Calls proc~~dqmc_multb_left~2~~CallsGraph proc~dqmc_multb_left~2 DQMC_CheckerBoard::DQMC_MultB_Left daxpy daxpy proc~dqmc_multb_left~2->daxpy dscal dscal proc~dqmc_multb_left~2->dscal proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_multb_left~2->proc~dqmc_scalecol proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_multb_left~2->proc~dqmc_trans proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_multb_left~2~~CalledByGraph proc~dqmc_multb_left~2 DQMC_CheckerBoard::DQMC_MultB_Left proc~dqmc_getb~2 DQMC_CheckerBoard::DQMC_GetB proc~dqmc_getb~2->proc~dqmc_multb_left~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_multb_left~2.html"},{"title":"DQMC_MultB_Right – Quest","text":"public  subroutine DQMC_MultB_Right(n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout), target :: M (n,n) type( matB ), intent(inout) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout), target :: C (n,n) Calls proc~~dqmc_multb_right~2~~CallsGraph proc~dqmc_multb_right~2 DQMC_CheckerBoard::DQMC_MultB_Right daxpy daxpy proc~dqmc_multb_right~2->daxpy dscal dscal proc~dqmc_multb_right~2->dscal proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_multb_right~2->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_multb_right~2.html"},{"title":"DQMC_MultBi_Left – Quest","text":"public  subroutine DQMC_MultBi_Left(n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout), target :: M (n,n) type( matB ), intent(inout) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout), target :: C (n,n) Calls proc~~dqmc_multbi_left~2~~CallsGraph proc~dqmc_multbi_left~2 DQMC_CheckerBoard::DQMC_MultBi_Left daxpy daxpy proc~dqmc_multbi_left~2->daxpy dscal dscal proc~dqmc_multbi_left~2->dscal proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_multbi_left~2->proc~dqmc_scalecol proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_multbi_left~2->proc~dqmc_trans proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_multbi_left~2~~CalledByGraph proc~dqmc_multbi_left~2 DQMC_CheckerBoard::DQMC_MultBi_Left proc~dqmc_getbi~2 DQMC_CheckerBoard::DQMC_GetBi proc~dqmc_getbi~2->proc~dqmc_multbi_left~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_multbi_left~2.html"},{"title":"DQMC_MultBi_Right – Quest","text":"public  subroutine DQMC_MultBi_Right(n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout), target :: M (n,n) type( matB ), intent(inout) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout), target :: C (n,n) Calls proc~~dqmc_multbi_right~2~~CallsGraph proc~dqmc_multbi_right~2 DQMC_CheckerBoard::DQMC_MultBi_Right daxpy daxpy proc~dqmc_multbi_right~2->daxpy dscal dscal proc~dqmc_multbi_right~2->dscal proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_multbi_right~2->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_multbi_right~2.html"},{"title":"DQMC_MultrtB0_Left – Quest","text":"public  subroutine DQMC_MultrtB0_Left(n, M, B, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(inout) :: C (n,n)","tags":"","loc":"proc/dqmc_multrtb0_left~2.html"},{"title":"DQMC_MultrtB0i_Right – Quest","text":"public  subroutine DQMC_MultrtB0i_Right(n, M, B, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(inout) :: C (n,n)","tags":"","loc":"proc/dqmc_multrtb0i_right~2.html"},{"title":"DQMC_GetB – Quest","text":"public  subroutine DQMC_GetB(n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(inout) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) Calls proc~~dqmc_getb~2~~CallsGraph proc~dqmc_getb~2 DQMC_CheckerBoard::DQMC_GetB proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_getb~2->proc~dqmc_eye proc~dqmc_multb_left~2 DQMC_CheckerBoard::DQMC_MultB_Left proc~dqmc_getb~2->proc~dqmc_multb_left~2 daxpy daxpy proc~dqmc_multb_left~2->daxpy dscal dscal proc~dqmc_multb_left~2->dscal proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_multb_left~2->proc~dqmc_scalecol proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_multb_left~2->proc~dqmc_trans proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_getb~2.html"},{"title":"DQMC_GetBi – Quest","text":"public  subroutine DQMC_GetBi(n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(inout) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) Calls proc~~dqmc_getbi~2~~CallsGraph proc~dqmc_getbi~2 DQMC_CheckerBoard::DQMC_GetBi proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_getbi~2->proc~dqmc_eye proc~dqmc_multbi_left~2 DQMC_CheckerBoard::DQMC_MultBi_Left proc~dqmc_getbi~2->proc~dqmc_multbi_left~2 daxpy daxpy proc~dqmc_multbi_left~2->daxpy dscal dscal proc~dqmc_multbi_left~2->dscal proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_multbi_left~2->proc~dqmc_scalecol proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_multbi_left~2->proc~dqmc_trans proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_getbi~2.html"},{"title":"DQMC_MPI_Is_Root – Quest","text":"public  function DQMC_MPI_Is_Root(sim, channel) result(isRoot) Arguments Type Intent Optional Attributes Name type( MPI_SIMOR ) :: sim integer, intent(in) :: channel Return Value logical","tags":"","loc":"proc/dqmc_mpi_is_root.html"},{"title":"DQMC_MPI_Init – Quest","text":"public  subroutine DQMC_MPI_Init(sim, level) Arguments Type Intent Optional Attributes Name type( MPI_SIMOR ) :: sim integer, intent(in) :: level Called by proc~~dqmc_mpi_init~~CalledByGraph proc~dqmc_mpi_init DQMC_MPI::DQMC_MPI_Init program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_mpi_init program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_mpi_init program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_mpi_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_mpi_init.html"},{"title":"DQMC_MPI_Final – Quest","text":"public  subroutine DQMC_MPI_Final(sim) Arguments Type Intent Optional Attributes Name type( MPI_SIMOR ) :: sim Called by proc~~dqmc_mpi_final~~CalledByGraph proc~dqmc_mpi_final DQMC_MPI::DQMC_MPI_Final program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_mpi_final Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_mpi_final.html"},{"title":"analyze_input – Quest","text":"public  subroutine analyze_input() Arguments None Called by proc~~analyze_input~~CalledByGraph proc~analyze_input DQMC_GEOM_PARAM::analyze_input proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~analyze_input program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/analyze_input.html"},{"title":"DQMC_SeqB_Init – Quest","text":"public  subroutine DQMC_SeqB_Init(n, L, nOrth, B, SB, WS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: L integer, intent(in) :: nOrth type( matB ), intent(in), target :: B type( SeqB ), intent(inout) :: SB type( WSpace ), intent(in), target :: WS Called by proc~~dqmc_seqb_init~~CalledByGraph proc~dqmc_seqb_init DQMC_SEQB::DQMC_SeqB_Init proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_seqb_init proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_seqb_init proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_seqb_init.html"},{"title":"DQMC_SeqB_Init2 – Quest","text":"public  subroutine DQMC_SeqB_Init2(n, L, nOrth, B, SB, U, D, T, WS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: L integer, intent(in) :: nOrth type( matB ), intent(in), target :: B type( SeqB ), intent(inout) :: SB real(kind=wp), intent(in), target :: U (:,:) real(kind=wp), intent(in), target :: D (:) real(kind=wp), intent(in), target :: T (:,:) type( WSpace ), intent(in), target :: WS","tags":"","loc":"proc/dqmc_seqb_init2.html"},{"title":"DQMC_SeqB_Free – Quest","text":"public  subroutine DQMC_SeqB_Free(SB) Arguments Type Intent Optional Attributes Name type( SeqB ), intent(inout) :: SB Called by proc~~dqmc_seqb_free~~CalledByGraph proc~dqmc_seqb_free DQMC_SEQB::DQMC_SeqB_Free proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free->proc~dqmc_seqb_free proc~dqmc_hub_free~2 DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free~2->proc~dqmc_seqb_free proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_free program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_free program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_free program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_seqb_free.html"},{"title":"DQMC_SeqB_Update – Quest","text":"public  subroutine DQMC_SeqB_Update(SB) Arguments Type Intent Optional Attributes Name type( SeqB ), intent(inout) :: SB","tags":"","loc":"proc/dqmc_seqb_update.html"},{"title":"DQMC_UDTD – Quest","text":"public  subroutine DQMC_UDTD(n, U, D, T, W1, W2, rw, tau, piv, lwork) Initial parameters for dgeqp3\nQR factorization with column pivoting\ndgegp3 returns R-factor on the upper triangle of G.\nThe lower triangle of G stores \"reflectors\",\nwhich is used to reconstruct the Q-factor. Move R-factor to R, and normalize it by diagonal elements. make T upper triangular.\nD = diag(T).\nNormalize R's row by its diagonal. R = inv(D) R\nCompute V = P V. (W is used as an temporary variable.)\nCompute V = R W = R P*V Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: U (n,n) real(kind=wp), intent(inout) :: D (n) real(kind=wp), intent(inout) :: T (n,n) real(kind=wp), intent(inout) :: W1 (n,n) real(kind=wp), intent(inout) :: W2 (n,n) real(kind=wp), intent(inout) :: rw (:) real(kind=wp), intent(inout) :: tau (n) integer, intent(inout) :: piv (:) integer, intent(in) :: lwork (:) Calls proc~~dqmc_udtd~~CallsGraph proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD blas_dcopy blas_dcopy proc~dqmc_udtd->blas_dcopy blas_dscal blas_dscal proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_udtd->proc~dqmc_error proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol dscal dscal proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_udtd~~CalledByGraph proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_seqmultbi->proc~dqmc_udtd proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_seqmultb proc~dqmc_getgtau->proc~dqmc_seqmultbi proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_udtd.html"},{"title":"DQMC_SeqMultB – Quest","text":"public  subroutine DQMC_SeqMultB(il, ir, SB, V) Initially, Q = B_{i} = V_i*B T = I, T will be the R-factor of the QDR factorization\nCompute the index of B_{i}\nThe UDT decomposition is performed at every nOrth step, and\nat the last step. In other steps, we just multiply B_i to\nthe Q-factor\nmultiply B_i to the Q-factor Arguments Type Intent Optional Attributes Name integer, intent(in) :: il integer, intent(in) :: ir type( SeqB ), intent(inout) :: SB real(kind=wp), intent(in) :: V (SB%n,SB%L) Calls proc~~dqmc_seqmultb~~CallsGraph proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_getb->proc~dqmc_scalerow blas_dgemm blas_dgemm proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow blas_dcopy blas_dcopy proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_udtd->proc~dqmc_error proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->proc~dqmc_scalecol dscal dscal proc~dqmc_scalecol->dscal proc~dqmc_scalerow->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_seqmultb~~CalledByGraph proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_seqmultb proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_seqmultb.html"},{"title":"DQMC_SeqMultBi – Quest","text":"public  subroutine DQMC_SeqMultBi(il, ir, SB, V) R = I, R will be the R-factor of the QDR factorization\nThe UDT decomposition is performed at every nOrth step, and\nat the last step. In other steps, we just multiply B_i to\nthe Q-factor\nmultiply B_i to the Q-factor Arguments Type Intent Optional Attributes Name integer, intent(in) :: il integer, intent(in) :: ir type( SeqB ), intent(inout) :: SB real(kind=wp), intent(in) :: V (SB%n,SB%L) Calls proc~~dqmc_seqmultbi~~CallsGraph proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultbi->proc~dqmc_eye proc~dqmc_getbi DQMC_MATB::DQMC_GetBi proc~dqmc_seqmultbi->proc~dqmc_getbi proc~dqmc_multbi_left DQMC_MATB::DQMC_MultBi_Left proc~dqmc_seqmultbi->proc~dqmc_multbi_left proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultbi->proc~dqmc_udtd proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getbi->proc~dqmc_multbi_right proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_getbi->proc~dqmc_scalecolinv blas_dgemm blas_dgemm proc~dqmc_multbi_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multbi_left->blas_dscal dexp dexp proc~dqmc_multbi_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multbi_left->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multbi_left->proc~dqmc_error proc~dqmc_scalerowinv DQMC_Util::DQMC_ScaleRowInv proc~dqmc_multbi_left->proc~dqmc_scalerowinv blas_dcopy blas_dcopy proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_udtd->proc~dqmc_error proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecol->dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerowinv->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_seqmultbi~~CalledByGraph proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_seqmultbi proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_getgtau Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_seqmultbi.html"},{"title":"DQMC_Gtau_Init – Quest","text":"public  subroutine DQMC_Gtau_Init(Hub, tau) Uses DQMC_Hubbard proc~~dqmc_gtau_init~~UsesGraph proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init module~dqmc_hubbard DQMC_Hubbard proc~dqmc_gtau_init->module~dqmc_hubbard module~dqmc_cfg DQMC_Cfg module~dqmc_hubbard->module~dqmc_cfg module~dqmc_gfun DQMC_GFun module~dqmc_hubbard->module~dqmc_gfun module~dqmc_matb DQMC_MATB module~dqmc_hubbard->module~dqmc_matb module~dqmc_phy0 DQMC_Phy0 module~dqmc_hubbard->module~dqmc_phy0 module~dqmc_phy2 DQMC_Phy2 module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_seqb DQMC_SEQB module~dqmc_hubbard->module~dqmc_seqb module~dqmc_struct DQMC_STRUCT module~dqmc_hubbard->module~dqmc_struct module~dqmc_util DQMC_Util module~dqmc_hubbard->module~dqmc_util module~dqmc_cfg->module~dqmc_util module~dqmc_gfun->module~dqmc_matb module~dqmc_gfun->module~dqmc_seqb module~dqmc_gfun->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_gfun->module~dqmc_wspace module~dqmc_matb->module~dqmc_struct module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_wspace module~dqmc_phy0->module~dqmc_struct module~dqmc_phy0->module~dqmc_util module~dqmc_phy0->module~dqmc_wspace module~dqmc_phy2->module~dqmc_struct module~dqmc_phy2->module~dqmc_util module~dqmc_bonds DQMC_BONDS module~dqmc_phy2->module~dqmc_bonds module~dqmc_symm DQMC_SYMM module~dqmc_phy2->module~dqmc_symm module~dqmc_phy2->module~dqmc_wspace module~dqmc_seqb->module~dqmc_matb module~dqmc_seqb->module~dqmc_util module~dqmc_seqb->module~dqmc_wspace module~dqmc_struct->module~dqmc_cfg module~dqmc_struct->module~dqmc_util module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_symm->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_wspace->module~dqmc_util module~dqmc_latt->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in), target :: Hub type( Gtau ), intent(inout) :: tau Calls proc~~dqmc_gtau_init~~CallsGraph proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init lapack_dgetri lapack_dgetri proc~dqmc_gtau_init->lapack_dgetri proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_gtau_init->proc~dqmc_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_gtau_init~~CalledByGraph proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_gtau_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_gtau_init.html"},{"title":"DQMC_Gtau_Free – Quest","text":"public  subroutine DQMC_Gtau_Free(tau) Arguments Type Intent Optional Attributes Name type( Gtau ), intent(inout) :: tau","tags":"","loc":"proc/dqmc_gtau_free.html"},{"title":"DQMC_Gtau_LoadA – Quest","text":"public  subroutine DQMC_Gtau_LoadA(tau, spin, slice, sgn) Arguments Type Intent Optional Attributes Name type( Gtau ), intent(inout), target :: tau integer, intent(in) :: spin integer, intent(in) :: slice real(kind=wp), intent(out) :: sgn Calls proc~~dqmc_gtau_loada~~CallsGraph proc~dqmc_gtau_loada DQMC_GTAU::DQMC_Gtau_LoadA lapack_dgetrf lapack_dgetrf proc~dqmc_gtau_loada->lapack_dgetrf lapack_dgetri lapack_dgetri proc~dqmc_gtau_loada->lapack_dgetri proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_gtau_loada->proc~dqmc_getb proc~dqmc_gtau_setalias DQMC_GTAU::DQMC_Gtau_SetAlias proc~dqmc_gtau_loada->proc~dqmc_gtau_setalias proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_gtau_loada->proc~dqmc_multb_right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_getb->proc~dqmc_scalerow blas_dgemm blas_dgemm proc~dqmc_multb_right->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_right->blas_dscal dexp dexp proc~dqmc_multb_right->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_right->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_multb_right->proc~dqmc_scalecol dscal dscal proc~dqmc_scalecol->dscal proc~dqmc_scalerow->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_gtau_loada~~CalledByGraph proc~dqmc_gtau_loada DQMC_GTAU::DQMC_Gtau_LoadA program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_gtau_loada Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_gtau_loada.html"},{"title":"DQMC_Gtau_CopyUp – Quest","text":"public  subroutine DQMC_Gtau_CopyUp(tau) Arguments Type Intent Optional Attributes Name type( Gtau ), intent(inout) :: tau Called by proc~~dqmc_gtau_copyup~~CalledByGraph proc~dqmc_gtau_copyup DQMC_GTAU::DQMC_Gtau_CopyUp proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_gtau_copyup proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_gtau_copyup program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_gtau_copyup.html"},{"title":"DQMC_Gtau_DumpA – Quest","text":"public  subroutine DQMC_Gtau_DumpA(tau, spin, it, i0) Arguments Type Intent Optional Attributes Name type( Gtau ), intent(inout) :: tau integer, intent(in) :: spin integer, intent(in) :: it integer, intent(in) :: i0 Calls proc~~dqmc_gtau_dumpa~~CallsGraph proc~dqmc_gtau_dumpa DQMC_GTAU::DQMC_Gtau_DumpA proc~dqmc_gtau_setalias DQMC_GTAU::DQMC_Gtau_SetAlias proc~dqmc_gtau_dumpa->proc~dqmc_gtau_setalias Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_gtau_dumpa~~CalledByGraph proc~dqmc_gtau_dumpa DQMC_GTAU::DQMC_Gtau_DumpA proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_gtau_dumpa proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_gtau_dumpa program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_gtau_dumpa.html"},{"title":"DQMC_MakeGtau – Quest","text":"public  subroutine DQMC_MakeGtau(tau, it, i0) Arguments Type Intent Optional Attributes Name type( Gtau ), intent(inout) :: tau integer, intent(in) :: it integer, intent(in) :: i0 Calls proc~~dqmc_makegtau~~CallsGraph proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_makegtau->proc~dqmc_change_gtau_time proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_gtau_setalias DQMC_GTAU::DQMC_Gtau_SetAlias proc~dqmc_change_gtau_time->proc~dqmc_gtau_setalias proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_change_gtau_time->proc~dqmc_multb_left proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_change_gtau_time->proc~dqmc_multb_right proc~dqmc_multbi_left DQMC_MATB::DQMC_MultBi_Left proc~dqmc_change_gtau_time->proc~dqmc_multbi_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_change_gtau_time->proc~dqmc_multbi_right blas_daxpy blas_daxpy proc~dqmc_getgtau->blas_daxpy blas_dcopy blas_dcopy proc~dqmc_getgtau->blas_dcopy blas_dgemm blas_dgemm proc~dqmc_getgtau->blas_dgemm lapack_dgesv lapack_dgesv proc~dqmc_getgtau->lapack_dgesv lapack_dgetrf lapack_dgetrf proc~dqmc_getgtau->lapack_dgetrf lapack_dgetri lapack_dgetri proc~dqmc_getgtau->lapack_dgetri lapack_dgetrs lapack_dgetrs proc~dqmc_getgtau->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_getgtau->proc~dqmc_error proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_getgtau->proc~dqmc_eye proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_getgtau->proc~dqmc_scalecol proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_getgtau->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_getgtau->proc~dqmc_seqmultb proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_getgtau->proc~dqmc_seqmultbi proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_getgtau->proc~dqmc_trans proc~dqmc_multb_left->blas_dgemm proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multbi_left->blas_dgemm proc~dqmc_multbi_left->proc~dqmc_error proc~dqmc_multbi_left->blas_dscal proc~dqmc_multbi_left->dexp proc~dqmc_multbi_left->lapack_dsyev proc~dqmc_scalerowinv DQMC_Util::DQMC_ScaleRowInv proc~dqmc_multbi_left->proc~dqmc_scalerowinv proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecol->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_seqmultbi->proc~dqmc_eye proc~dqmc_seqmultbi->proc~dqmc_multbi_left proc~dqmc_getbi DQMC_MATB::DQMC_GetBi proc~dqmc_seqmultbi->proc~dqmc_getbi proc~dqmc_seqmultbi->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_getbi->proc~dqmc_multbi_right proc~dqmc_getbi->proc~dqmc_scalecolinv proc~dqmc_scalecolinv->dscal proc~dqmc_scalerowinv->dscal proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_makegtau.html"},{"title":"DQMC_GetGtau – Quest","text":"public  subroutine DQMC_GetGtau(it, i0, spin, gt0, g0t, g00, gtt, tau) Compute  T_2*inv(T_1) *** We need to keep T2 and U1 for later use. Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: i0 integer, intent(in) :: spin real(kind=wp), intent(inout) :: gt0 (:,:) real(kind=wp), intent(inout) :: g0t (:,:) real(kind=wp), intent(inout) :: g00 (:,:) real(kind=wp), intent(inout) :: gtt (:,:) type( Gtau ), intent(inout), target :: tau Calls proc~~dqmc_getgtau~~CallsGraph proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau blas_daxpy blas_daxpy proc~dqmc_getgtau->blas_daxpy blas_dcopy blas_dcopy proc~dqmc_getgtau->blas_dcopy blas_dgemm blas_dgemm proc~dqmc_getgtau->blas_dgemm lapack_dgesv lapack_dgesv proc~dqmc_getgtau->lapack_dgesv lapack_dgetrf lapack_dgetrf proc~dqmc_getgtau->lapack_dgetrf lapack_dgetri lapack_dgetri proc~dqmc_getgtau->lapack_dgetri lapack_dgetrs lapack_dgetrs proc~dqmc_getgtau->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_getgtau->proc~dqmc_error proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_getgtau->proc~dqmc_eye proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_getgtau->proc~dqmc_scalecol proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_getgtau->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_getgtau->proc~dqmc_seqmultb proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_getgtau->proc~dqmc_seqmultbi proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_getgtau->proc~dqmc_trans dscal dscal proc~dqmc_scalecol->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_seqmultbi->proc~dqmc_eye proc~dqmc_getbi DQMC_MATB::DQMC_GetBi proc~dqmc_seqmultbi->proc~dqmc_getbi proc~dqmc_multbi_left DQMC_MATB::DQMC_MultBi_Left proc~dqmc_seqmultbi->proc~dqmc_multbi_left proc~dqmc_seqmultbi->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getbi->proc~dqmc_multbi_right proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_getbi->proc~dqmc_scalecolinv proc~dqmc_multb_left->blas_dgemm proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multbi_left->blas_dgemm proc~dqmc_multbi_left->proc~dqmc_error proc~dqmc_multbi_left->blas_dscal proc~dqmc_multbi_left->dexp proc~dqmc_multbi_left->lapack_dsyev proc~dqmc_scalerowinv DQMC_Util::DQMC_ScaleRowInv proc~dqmc_multbi_left->proc~dqmc_scalerowinv proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_scalecolinv proc~dqmc_scalecolinv->dscal proc~dqmc_scalerowinv->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_getgtau~~CalledByGraph proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_getgtau Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_getgtau.html"},{"title":"DQMC_change_gtau_time – Quest","text":"public  subroutine DQMC_change_gtau_time(tau, idir, spin) Arguments Type Intent Optional Attributes Name type( Gtau ), intent(inout) :: tau integer, intent(in) :: idir integer, intent(in) :: spin Calls proc~~dqmc_change_gtau_time~~CallsGraph proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_gtau_setalias DQMC_GTAU::DQMC_Gtau_SetAlias proc~dqmc_change_gtau_time->proc~dqmc_gtau_setalias proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_change_gtau_time->proc~dqmc_multb_left proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_change_gtau_time->proc~dqmc_multb_right proc~dqmc_multbi_left DQMC_MATB::DQMC_MultBi_Left proc~dqmc_change_gtau_time->proc~dqmc_multbi_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_change_gtau_time->proc~dqmc_multbi_right blas_dgemm blas_dgemm proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_multbi_left->blas_dgemm proc~dqmc_multbi_left->blas_dscal proc~dqmc_multbi_left->dexp proc~dqmc_multbi_left->lapack_dsyev proc~dqmc_multbi_left->proc~dqmc_error proc~dqmc_scalerowinv DQMC_Util::DQMC_ScaleRowInv proc~dqmc_multbi_left->proc~dqmc_scalerowinv proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecol->dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_scalerowinv->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_change_gtau_time~~CalledByGraph proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_change_gtau_time.html"},{"title":"DQMC_Gtau_SetAlias – Quest","text":"public  subroutine DQMC_Gtau_SetAlias(spin, tau, A, B, V, gt0, g0t, g00, gtt, it, i0, itau, sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: spin type( Gtau ), intent(in), target :: tau real(kind=wp), optional, pointer :: A (:,:) type( matB ), optional, pointer :: B real(kind=wp), optional, pointer :: V (:,:) real(kind=wp), optional, pointer :: gt0 (:,:) real(kind=wp), optional, pointer :: g0t (:,:) real(kind=wp), optional, pointer :: g00 (:,:) real(kind=wp), optional, pointer :: gtt (:,:) integer, optional, pointer :: it integer, optional, pointer :: i0 integer, optional, pointer :: itau (:) real(kind=wp), optional, pointer :: sgn Called by proc~~dqmc_gtau_setalias~~CalledByGraph proc~dqmc_gtau_setalias DQMC_GTAU::DQMC_Gtau_SetAlias proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_change_gtau_time->proc~dqmc_gtau_setalias proc~dqmc_gtau_dumpa DQMC_GTAU::DQMC_Gtau_DumpA proc~dqmc_gtau_dumpa->proc~dqmc_gtau_setalias proc~dqmc_gtau_loada DQMC_GTAU::DQMC_Gtau_LoadA proc~dqmc_gtau_loada->proc~dqmc_gtau_setalias proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas->proc~dqmc_gtau_dumpa proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas_para->proc~dqmc_gtau_dumpa program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_gtau_loada program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_gtau_setalias.html"},{"title":"DQMC_Gtau_GetG0 – Quest","text":"public  subroutine DQMC_Gtau_GetG0(n, tau, spin, slice, g0tau) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n type( Gtau ), intent(inout) :: tau integer, intent(in) :: spin integer, intent(in) :: slice real(kind=wp), intent(out) :: g0tau (n,n) Calls proc~~dqmc_gtau_getg0~~CallsGraph proc~dqmc_gtau_getg0 DQMC_GTAU::DQMC_Gtau_GetG0 dcopy dcopy proc~dqmc_gtau_getg0->dcopy dgemm dgemm proc~dqmc_gtau_getg0->dgemm dsyev dsyev proc~dqmc_gtau_getg0->dsyev proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_gtau_getg0->proc~dqmc_getb proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_gtau_getg0->proc~dqmc_scalecol proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_getb->proc~dqmc_scalerow dscal dscal proc~dqmc_scalecol->dscal proc~dqmc_multb_right->proc~dqmc_scalecol blas_dgemm blas_dgemm proc~dqmc_multb_right->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_right->blas_dscal dexp dexp proc~dqmc_multb_right->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_right->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_scalerow->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_gtau_getg0~~CalledByGraph proc~dqmc_gtau_getg0 DQMC_GTAU::DQMC_Gtau_GetG0 proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy proc~dqmc_tdm1_selfenergy->proc~dqmc_gtau_getg0 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_selfenergy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_gtau_getg0.html"},{"title":"free_bonds – Quest","text":"public  subroutine free_bonds(bonds) Arguments Type Intent Optional Attributes Name type( bonds_t ), intent(out) :: bonds","tags":"","loc":"proc/free_bonds.html"},{"title":"free_pairs – Quest","text":"public  subroutine free_pairs(pairs) Arguments Type Intent Optional Attributes Name type( pairing ), intent(out) :: pairs","tags":"","loc":"proc/free_pairs.html"},{"title":"read_bonds – Quest","text":"public  subroutine read_bonds(Bonds, SOP) Arguments Type Intent Optional Attributes Name type( bonds_t ) :: Bonds integer, intent(in) :: SOP Calls proc~~read_bonds~~CallsGraph proc~read_bonds DQMC_BONDS::read_bonds proc~move_to_record DQMC_Util::move_to_record proc~read_bonds->proc~move_to_record Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_bonds~~CalledByGraph proc~read_bonds DQMC_BONDS::read_bonds proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~read_bonds program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/read_bonds.html"},{"title":"construct_pairs – Quest","text":"public  subroutine construct_pairs(Bonds, Pairs, lattice, SOP) Arguments Type Intent Optional Attributes Name type( bonds_t ) :: Bonds type( pairing ) :: Pairs type( lattice_t ) :: lattice integer, intent(in) :: SOP Calls proc~~construct_pairs~~CallsGraph proc~construct_pairs DQMC_BONDS::construct_pairs proc~hoptowho DQMC_LATT::hoptowho proc~construct_pairs->proc~hoptowho proc~move_to_record DQMC_Util::move_to_record proc~construct_pairs->proc~move_to_record proc~get_inverse DQMC_Util::get_inverse proc~hoptowho->proc~get_inverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~construct_pairs~~CalledByGraph proc~construct_pairs DQMC_BONDS::construct_pairs proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~construct_pairs program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_pairs.html"},{"title":"DQMC_Comp_2DPerl – Quest","text":"public  subroutine DQMC_Comp_2DPerl() Arguments None Calls proc~~dqmc_comp_2dperl~~CallsGraph proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl interface~cfg_get DQMC_Cfg::CFG_Get proc~dqmc_comp_2dperl->interface~cfg_get interface~dqmc_phy2_avg DQMC_Phy2::DQMC_Phy2_avg proc~dqmc_comp_2dperl->interface~dqmc_phy2_avg proc~dqmc_config_free DQMC_Cfg::DQMC_Config_Free proc~dqmc_comp_2dperl->proc~dqmc_config_free proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_comp_2dperl->proc~dqmc_hub_free proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_hub_print DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_comp_2dperl->proc~dqmc_hub_print proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_init_2dperl DQMC_2DPERL::DQMC_Init_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_init_2dperl proc~dqmc_open_file DQMC_Util::DQMC_open_file proc~dqmc_comp_2dperl->proc~dqmc_open_file proc~dqmc_phy0_avg DQMC_Phy0::DQMC_Phy0_Avg proc~dqmc_comp_2dperl->proc~dqmc_phy0_avg proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_comp_2dperl->proc~dqmc_phy0_geterr proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_comp_2dperl->proc~dqmc_phy2_geterr proc~dqmc_read_config DQMC_Cfg::DQMC_Read_Config proc~dqmc_comp_2dperl->proc~dqmc_read_config proc~ran0 DQMC_Util::ran0 proc~dqmc_comp_2dperl->proc~ran0 proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI interface~cfg_get->proc~dqmc_config_geti proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI interface~cfg_get->proc~dqmc_config_getpi proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR interface~cfg_get->proc~dqmc_config_getpr proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR interface~cfg_get->proc~dqmc_config_getr proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS interface~cfg_get->proc~dqmc_config_gets proc~dqmc_phy2_avg_symm DQMC_Phy2::DQMC_Phy2_Avg_Symm interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_symm proc~dqmc_phy2_avg_wave DQMC_Phy2::DQMC_Phy2_Avg_Wave interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_wave proc~dqmc_hub_config->interface~cfg_get interface~cfg_set DQMC_Cfg::CFG_Set proc~dqmc_hub_config->interface~cfg_set proc~dqmc_config_isset DQMC_Cfg::DQMC_Config_isSet proc~dqmc_hub_config->proc~dqmc_config_isset proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_hub_config->proc~dqmc_warning proc~dqmc_b_free DQMC_MATB::DQMC_B_Free proc~dqmc_hub_free->proc~dqmc_b_free proc~dqmc_gfun_free DQMC_GFun::DQMC_Gfun_Free proc~dqmc_hub_free->proc~dqmc_gfun_free proc~dqmc_phy0_free DQMC_Phy0::DQMC_Phy0_Free proc~dqmc_hub_free->proc~dqmc_phy0_free proc~dqmc_phy2_free DQMC_Phy2::DQMC_Phy2_Free proc~dqmc_hub_free->proc~dqmc_phy2_free proc~dqmc_seqb_free DQMC_SEQB::DQMC_SeqB_Free proc~dqmc_hub_free->proc~dqmc_seqb_free proc~dqmc_struct_free DQMC_STRUCT::DQMC_Struct_Free proc~dqmc_hub_free->proc~dqmc_struct_free proc~dqmc_wspace_free DQMC_WSpace::DQMC_WSpace_Free proc~dqmc_hub_free->proc~dqmc_wspace_free proc~dqmc_hub_meas->proc~ran0 proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_meas->proc~dqmc_getg_2nd_order proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_meas->proc~dqmc_gfun_clone proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_meas->proc~dqmc_gfun_copyup proc~dqmc_gfun_duplicate DQMC_GFun::DQMC_GFun_Duplicate proc~dqmc_hub_meas->proc~dqmc_gfun_duplicate proc~dqmc_hub_meas->proc~dqmc_gfun_free proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_meas->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_meas->proc~dqmc_phy2_meas proc~dqmc_hub_outputparam DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_print->proc~dqmc_hub_outputparam proc~dqmc_phy0_print DQMC_Phy0::DQMC_Phy0_Print proc~dqmc_hub_print->proc~dqmc_phy0_print proc~dqmc_phy2_print DQMC_Phy2::DQMC_Phy2_Print proc~dqmc_hub_print->proc~dqmc_phy2_print proc~dqmc_hub_sweep->proc~ran0 proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate proc~dqmc_hub_sweep->proc~dqmc_applyupdate proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep->proc~dqmc_getg_2nd_order proc~dqmc_hub_sweep->proc~dqmc_gfun_copyup proc~dqmc_gfun_getjj DQMC_GFun::DQMC_Gfun_Getjj proc~dqmc_hub_sweep->proc~dqmc_gfun_getjj proc~dqmc_hub_sweep->proc~dqmc_phy0_meas proc~dqmc_hub_sweep->proc~dqmc_phy2_meas proc~dqmc_syncwraps DQMC_GFun::DQMC_SyncWraps proc~dqmc_hub_sweep->proc~dqmc_syncwraps proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG proc~dqmc_hub_sweep->proc~dqmc_updateg proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps proc~dqmc_hub_sweep->proc~dqmc_updatewraps proc~dqmc_hub_sweep2->proc~ran0 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2->proc~dqmc_gfun_copyup proc~dqmc_2dperl_dc_imp1 DQMC_2DPERL::DQMC_2DPerl_DC_Imp1 proc~dqmc_init_2dperl->proc~dqmc_2dperl_dc_imp1 proc~dqmc_2dperl_dc_imp2 DQMC_2DPERL::DQMC_2DPerl_DC_Imp2 proc~dqmc_init_2dperl->proc~dqmc_2dperl_dc_imp2 proc~dqmc_ccs_compress DQMC_STRUCT::DQMC_CCS_Compress proc~dqmc_init_2dperl->proc~dqmc_ccs_compress blas_dscal blas_dscal proc~dqmc_phy0_avg->blas_dscal proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_phy0_avg->proc~dqmc_error interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife proc~dqmc_phy0_geterr->interface~dqmc_jackknife interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife proc~dqmc_phy0_geterr->interface~dqmc_signjackknife proc~dqmc_phy2_geterr->interface~dqmc_jackknife proc~dqmc_phy2_geterr->interface~dqmc_signjackknife proc~dqmc_read_config->proc~dqmc_open_file proc~dqmc_default_def DQMC_Cfg::DQMC_Default_Def proc~dqmc_read_config->proc~dqmc_default_def proc~dqmc_read_config->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_read_config->proc~dqmc_find_param proc~dqmc_read_def DQMC_Cfg::DQMC_Read_Def proc~dqmc_read_config->proc~dqmc_read_def proc~dqmc_read_config->proc~dqmc_warning dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_config_seti DQMC_Cfg::DQMC_Config_SetI interface~cfg_set->proc~dqmc_config_seti proc~dqmc_config_setpi DQMC_Cfg::DQMC_Config_SetPI interface~cfg_set->proc~dqmc_config_setpi proc~dqmc_config_setpr DQMC_Cfg::DQMC_Config_SetPR interface~cfg_set->proc~dqmc_config_setpr proc~dqmc_config_setr DQMC_Cfg::DQMC_Config_SetR interface~cfg_set->proc~dqmc_config_setr proc~dqmc_config_sets DQMC_Cfg::DQMC_Config_SetS interface~cfg_set->proc~dqmc_config_sets proc~dqmc_jackknife_complex DQMC_Util::DQMC_JackKnife_Complex interface~dqmc_jackknife->proc~dqmc_jackknife_complex proc~dqmc_jackknife_real DQMC_Util::DQMC_JackKnife_Real interface~dqmc_jackknife->proc~dqmc_jackknife_real proc~dqmc_signjackknife_complex DQMC_Util::DQMC_SignJackKnife_Complex interface~dqmc_signjackknife->proc~dqmc_signjackknife_complex proc~dqmc_signjackknife_real DQMC_Util::DQMC_SignJackKnife_Real interface~dqmc_signjackknife->proc~dqmc_signjackknife_real blas_dgemm blas_dgemm proc~dqmc_applyupdate->blas_dgemm proc~dqmc_ccs_compress->proc~dqmc_error proc~dqmc_config_geti->proc~dqmc_error proc~dqmc_config_geti->proc~dqmc_find_param proc~dqmc_config_geti->proc~dqmc_warning proc~dqmc_config_getpi->proc~dqmc_error proc~dqmc_config_getpi->proc~dqmc_find_param proc~dqmc_config_getpi->proc~dqmc_warning proc~dqmc_config_getpr->proc~dqmc_error proc~dqmc_config_getpr->proc~dqmc_find_param proc~dqmc_config_getpr->proc~dqmc_warning proc~dqmc_config_getr->proc~dqmc_error proc~dqmc_config_getr->proc~dqmc_find_param proc~dqmc_config_getr->proc~dqmc_warning proc~dqmc_config_gets->proc~dqmc_error proc~dqmc_config_gets->proc~dqmc_find_param proc~dqmc_config_gets->proc~dqmc_warning proc~dqmc_config_isset->proc~dqmc_error proc~dqmc_config_isset->proc~dqmc_find_param blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right blas_ddot blas_ddot proc~dqmc_gfun_getjj->blas_ddot proc~dqmc_hub_init->proc~ran0 proc~dqmc_hub_init->proc~dqmc_error proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init->proc~dqmc_gfun_clone proc~dqmc_hub_init->proc~dqmc_warning proc~dqmc_b_init DQMC_MATB::DQMC_B_Init proc~dqmc_hub_init->proc~dqmc_b_init proc~dqmc_gfun_init DQMC_GFun::DQMC_GFun_Init proc~dqmc_hub_init->proc~dqmc_gfun_init proc~dqmc_hub_init_vmat DQMC_Hubbard::DQMC_Hub_Init_Vmat proc~dqmc_hub_init->proc~dqmc_hub_init_vmat proc~dqmc_hub_input_hsf DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_init->proc~dqmc_hub_input_hsf proc~dqmc_phy0_init DQMC_Phy0::DQMC_Phy0_Init proc~dqmc_hub_init->proc~dqmc_phy0_init proc~dqmc_phy2_init DQMC_Phy2::DQMC_Phy2_Init proc~dqmc_hub_init->proc~dqmc_phy2_init proc~dqmc_seqb_init DQMC_SEQB::DQMC_SeqB_Init proc~dqmc_hub_init->proc~dqmc_seqb_init proc~dqmc_wspace_allocate DQMC_WSpace::DQMC_WSpace_Allocate proc~dqmc_hub_init->proc~dqmc_wspace_allocate proc~ran1 DQMC_Util::ran1 proc~dqmc_hub_init->proc~ran1 proc~dqmc_hub_outputparam->proc~dqmc_warning proc~dqmc_hub_output_hsf DQMC_Hubbard::DQMC_Hub_Output_HSF proc~dqmc_hub_outputparam->proc~dqmc_hub_output_hsf blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray proc~dqmc_phy0_print->proc~dqmc_print_realarray proc~dqmc_pair_symm DQMC_Phy2::DQMC_Pair_Symm proc~dqmc_phy2_avg_symm->proc~dqmc_pair_symm proc~dqmc_wave_avg DQMC_Phy2::DQMC_Wave_Avg proc~dqmc_phy2_avg_wave->proc~dqmc_wave_avg proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair proc~dqmc_phy2_print->proc~dqmc_print_realarray proc~dqmc_readln DQMC_Cfg::DQMC_ReadLn proc~dqmc_read_def->proc~dqmc_readln proc~dqmc_ccs_free DQMC_STRUCT::DQMC_CCS_Free proc~dqmc_struct_free->proc~dqmc_ccs_free proc~dqmc_updateg->blas_dscal proc~dqmc_updateg->proc~dqmc_applyupdate blas_dgemv blas_dgemv proc~dqmc_updateg->blas_dgemv proc~dqmc_b_expinit DQMC_MATB::DQMC_B_ExpInit proc~dqmc_b_init->proc~dqmc_b_expinit proc~dqmc_computeg->proc~dqmc_error proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_config_seti->proc~dqmc_error proc~dqmc_config_seti->proc~dqmc_find_param proc~dqmc_config_setpi->proc~dqmc_error proc~dqmc_config_setpi->proc~dqmc_find_param proc~dqmc_config_setpr->proc~dqmc_error proc~dqmc_config_setpr->proc~dqmc_find_param proc~dqmc_config_setr->proc~dqmc_error proc~dqmc_config_setr->proc~dqmc_find_param proc~dqmc_config_sets->proc~dqmc_error proc~dqmc_config_sets->proc~dqmc_find_param proc~dqmc_hub_input_hsf->proc~dqmc_error proc~dqmc_multb_left->blas_dscal proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->blas_dgemm dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv proc~dqmc_wave_avg->blas_ddot proc~dqmc_wave_avg->blas_dgemm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_wspace_allocate->lapack_dgeqp3 lapack_dgetri lapack_dgetri proc~dqmc_wspace_allocate->lapack_dgetri lapack_dorgqr lapack_dorgqr proc~dqmc_wspace_allocate->lapack_dorgqr lapack_dormqr lapack_dormqr proc~dqmc_wspace_allocate->lapack_dormqr proc~dqmc_wspace_allocate->lapack_dsyev proc~ran1->dlarnv proc~dqmc_b_expinit->blas_dscal proc~dqmc_b_expinit->proc~dqmc_error proc~dqmc_b_expinit->blas_dgemm proc~dqmc_b_expinit->dexp proc~dqmc_b_expinit->lapack_dsyev dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->lapack_dgeqp3 proc~dqmc_udtd->lapack_dorgqr blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_comp_2dperl~~CalledByGraph proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_comp_2dperl.html"},{"title":"DQMC_Init_2DPerl – Quest","text":"public  subroutine DQMC_Init_2DPerl(nx, ny, S, IMP) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx integer, intent(in) :: ny type( Struct ), intent(inout) :: S integer, intent(in) :: IMP Calls proc~~dqmc_init_2dperl~~CallsGraph proc~dqmc_init_2dperl DQMC_2DPERL::DQMC_Init_2DPerl proc~dqmc_2dperl_dc_imp1 DQMC_2DPERL::DQMC_2DPerl_DC_Imp1 proc~dqmc_init_2dperl->proc~dqmc_2dperl_dc_imp1 proc~dqmc_2dperl_dc_imp2 DQMC_2DPERL::DQMC_2DPerl_DC_Imp2 proc~dqmc_init_2dperl->proc~dqmc_2dperl_dc_imp2 proc~dqmc_ccs_compress DQMC_STRUCT::DQMC_CCS_Compress proc~dqmc_init_2dperl->proc~dqmc_ccs_compress proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_ccs_compress->proc~dqmc_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_init_2dperl~~CalledByGraph proc~dqmc_init_2dperl DQMC_2DPERL::DQMC_Init_2DPerl proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_init_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_init_2dperl program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_init_2dperl.html"},{"title":"DQMC_2DPerl_DC_Imp1 – Quest","text":"public  subroutine DQMC_2DPerl_DC_Imp1(n, nx, ny, S, cord) using lookup table (maybe hashing table )\ncompute the index of i\ninitial the index of j\ncompute the index of j\ncompute the distance Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: nx integer, intent(in) :: ny type( Struct ), intent(inout) :: S real(kind=wp), pointer :: cord (:,:) Called by proc~~dqmc_2dperl_dc_imp1~~CalledByGraph proc~dqmc_2dperl_dc_imp1 DQMC_2DPERL::DQMC_2DPerl_DC_Imp1 proc~dqmc_init_2dperl DQMC_2DPERL::DQMC_Init_2DPerl proc~dqmc_init_2dperl->proc~dqmc_2dperl_dc_imp1 proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_init_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_init_2dperl program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_2dperl_dc_imp1.html"},{"title":"DQMC_2DPerl_DC_Imp2 – Quest","text":"public  subroutine DQMC_2DPerl_DC_Imp2(n, nx, ny, S, cord) using lookup table (maybe hashing table )\ncompute the index of i\ninitial the index of j\ncompute the index of j\ncompute the distance Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: nx integer, intent(in) :: ny type( Struct ), intent(inout) :: S real(kind=wp), pointer :: cord (:,:) Called by proc~~dqmc_2dperl_dc_imp2~~CalledByGraph proc~dqmc_2dperl_dc_imp2 DQMC_2DPERL::DQMC_2DPerl_DC_Imp2 proc~dqmc_init_2dperl DQMC_2DPERL::DQMC_Init_2DPerl proc~dqmc_init_2dperl->proc~dqmc_2dperl_dc_imp2 proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_init_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_init_2dperl program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_2dperl_dc_imp2.html"},{"title":"DQMC_Phy0_Init – Quest","text":"public  subroutine DQMC_Phy0_Init(P0, S, beta, nBin, WS) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(inout) :: P0 type( Struct ), intent(in) :: S real(kind=wp), intent(in) :: beta integer, intent(in) :: nBin type( WSpace ), intent(in), target :: WS Called by proc~~dqmc_phy0_init~~CalledByGraph proc~dqmc_phy0_init DQMC_Phy0::DQMC_Phy0_Init proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_phy0_init proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_phy0_init proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy0_init.html"},{"title":"DQMC_Phy0_Free – Quest","text":"public  subroutine DQMC_Phy0_Free(P0) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(inout) :: P0 Called by proc~~dqmc_phy0_free~~CalledByGraph proc~dqmc_phy0_free DQMC_Phy0::DQMC_Phy0_Free proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free->proc~dqmc_phy0_free proc~dqmc_hub_free~2 DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free~2->proc~dqmc_phy0_free proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_free program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_free program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_free program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy0_free.html"},{"title":"DQMC_Phy0_Avg – Quest","text":"public  subroutine DQMC_Phy0_Avg(P0) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(inout) :: P0 Calls proc~~dqmc_phy0_avg~~CallsGraph proc~dqmc_phy0_avg DQMC_Phy0::DQMC_Phy0_Avg blas_dscal blas_dscal proc~dqmc_phy0_avg->blas_dscal proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_phy0_avg->proc~dqmc_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy0_avg~~CalledByGraph proc~dqmc_phy0_avg DQMC_Phy0::DQMC_Phy0_Avg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_phy0_avg proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_phy0_avg proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_phy0_avg program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_avg program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy0_avg.html"},{"title":"DQMC_Phy0_Print – Quest","text":"public  subroutine DQMC_Phy0_Print(P0, S, OPT) Uses DQMC_MPI proc~~dqmc_phy0_print~~UsesGraph proc~dqmc_phy0_print DQMC_Phy0::DQMC_Phy0_Print module~dqmc_mpi DQMC_MPI proc~dqmc_phy0_print->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(in) :: P0 type( Struct ), intent(in) :: S integer, intent(in) :: OPT Calls proc~~dqmc_phy0_print~~CallsGraph proc~dqmc_phy0_print DQMC_Phy0::DQMC_Phy0_Print proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray proc~dqmc_phy0_print->proc~dqmc_print_realarray Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy0_print~~CalledByGraph proc~dqmc_phy0_print DQMC_Phy0::DQMC_Phy0_Print proc~dqmc_hub_print DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_print->proc~dqmc_phy0_print proc~dqmc_hub_print~2 DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_print~2->proc~dqmc_phy0_print program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_print proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_print program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy0_print.html"},{"title":"DQMC_Phy0_GetErr – Quest","text":"public  subroutine DQMC_Phy0_GetErr(P0) Uses DQMC_MPI proc~~dqmc_phy0_geterr~~UsesGraph proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr module~dqmc_mpi DQMC_MPI proc~dqmc_phy0_geterr->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(inout) :: P0 Calls proc~~dqmc_phy0_geterr~~CallsGraph proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife proc~dqmc_phy0_geterr->interface~dqmc_jackknife interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife proc~dqmc_phy0_geterr->interface~dqmc_signjackknife proc~dqmc_jackknife_complex DQMC_Util::DQMC_JackKnife_Complex interface~dqmc_jackknife->proc~dqmc_jackknife_complex proc~dqmc_jackknife_real DQMC_Util::DQMC_JackKnife_Real interface~dqmc_jackknife->proc~dqmc_jackknife_real proc~dqmc_signjackknife_complex DQMC_Util::DQMC_SignJackKnife_Complex interface~dqmc_signjackknife->proc~dqmc_signjackknife_complex proc~dqmc_signjackknife_real DQMC_Util::DQMC_SignJackKnife_Real interface~dqmc_signjackknife->proc~dqmc_signjackknife_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy0_geterr~~CalledByGraph proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_phy0_geterr proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_phy0_geterr proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_phy0_geterr program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_geterr program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy0_geterr.html"},{"title":"DQMC_Phy0_Meas – Quest","text":"public  subroutine DQMC_Phy0_Meas(n, P0, G_up, G_dn, U, mu_up, mu_dn, t_up, t_dn, sgnup, sgndn, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n type( Phy0 ), intent(inout) :: P0 real(kind=wp), intent(in) :: G_up (n,n) real(kind=wp), intent(in) :: G_dn (n,n) real(kind=wp), intent(in) :: U (:) real(kind=wp), intent(in) :: mu_up (n) real(kind=wp), intent(in) :: mu_dn (n) real(kind=wp), intent(in) :: t_up (:) real(kind=wp), intent(in) :: t_dn (:) real(kind=wp), intent(in) :: sgnup real(kind=wp), intent(in) :: sgndn type( Struct ), intent(in), target :: S Calls proc~~dqmc_phy0_meas~~CallsGraph proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy blas_dgemm blas_dgemm proc~dqmc_phy0_meas->blas_dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy0_meas~~CalledByGraph proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_fullmeas DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas->proc~dqmc_phy0_meas proc~dqmc_hub_fullmeas~2 DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas~2->proc~dqmc_phy0_meas proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_phy0_meas proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_phy0_meas proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_phy0_meas proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_phy0_meas proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_phy0_meas proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_fullmeas program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy0_meas.html"},{"title":"DQMC_Phy0_GetFT – Quest","text":"public  subroutine DQMC_Phy0_GetFT(P0, class, phase, ft_wgt_t, ft_wgt_g, nkt, nkg, na, nt) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(inout) :: P0 integer, intent(in) :: class (na*nt,na*nt) integer, intent(in) :: phase (na*nt,na*nt) complex(kind=16), intent(in), target :: ft_wgt_t (nt,nkt) complex(kind=16), intent(in), target :: ft_wgt_g (nt,nkg) integer, intent(in) :: nkt integer, intent(in) :: nkg integer, intent(in) :: na integer, intent(in) :: nt Calls proc~~dqmc_phy0_getft~~CallsGraph proc~dqmc_phy0_getft DQMC_Phy0::DQMC_Phy0_GetFT dconjg dconjg proc~dqmc_phy0_getft->dconjg zgemm zgemm proc~dqmc_phy0_getft->zgemm zheev zheev proc~dqmc_phy0_getft->zheev Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy0_getft~~CalledByGraph proc~dqmc_phy0_getft DQMC_Phy0::DQMC_Phy0_GetFT program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_getft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy0_getft.html"},{"title":"DQMC_Phy0_GetErrFT – Quest","text":"public  subroutine DQMC_Phy0_GetErrFT(P0) Uses DQMC_MPI proc~~dqmc_phy0_geterrft~~UsesGraph proc~dqmc_phy0_geterrft DQMC_Phy0::DQMC_Phy0_GetErrFT module~dqmc_mpi DQMC_MPI proc~dqmc_phy0_geterrft->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(inout) :: P0 Called by proc~~dqmc_phy0_geterrft~~CalledByGraph proc~dqmc_phy0_geterrft DQMC_Phy0::DQMC_Phy0_GetErrFT program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_geterrft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy0_geterrft.html"},{"title":"DQMC_Phy0_PrintFT – Quest","text":"public  subroutine DQMC_Phy0_PrintFT(P0, na, nkt, nkg, OPT) Uses DQMC_MPI proc~~dqmc_phy0_printft~~UsesGraph proc~dqmc_phy0_printft DQMC_Phy0::DQMC_Phy0_PrintFT module~dqmc_mpi DQMC_MPI proc~dqmc_phy0_printft->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(in) :: P0 integer, intent(in) :: na integer, intent(in) :: nkt integer, intent(in) :: nkg integer, intent(in) :: OPT Calls proc~~dqmc_phy0_printft~~CallsGraph proc~dqmc_phy0_printft DQMC_Phy0::DQMC_Phy0_PrintFT proc~dqmc_print_eigenmode DQMC_Util::DQMC_Print_EigenMode proc~dqmc_phy0_printft->proc~dqmc_print_eigenmode proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray proc~dqmc_phy0_printft->proc~dqmc_print_realarray Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy0_printft~~CalledByGraph proc~dqmc_phy0_printft DQMC_Phy0::DQMC_Phy0_PrintFT program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_printft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy0_printft.html"},{"title":"DQMC_Gfun_Getjj – Quest","text":"public  function DQMC_Gfun_Getjj(n, j, blksz, G, U, W) result(gjj) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: j integer, intent(in) :: blksz real(kind=wp), intent(in) :: G (n,n) real(kind=wp), intent(in) :: U (n,n) real(kind=wp), intent(in) :: W (n,n) Return Value real(kind=wp) Calls proc~~dqmc_gfun_getjj~~CallsGraph proc~dqmc_gfun_getjj DQMC_GFun::DQMC_Gfun_Getjj blas_ddot blas_ddot proc~dqmc_gfun_getjj->blas_ddot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_gfun_getjj~~CalledByGraph proc~dqmc_gfun_getjj DQMC_GFun::DQMC_Gfun_Getjj proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_gfun_getjj proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_gfun_getjj proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_gfun_getjj proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_gfun_getjj proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_gfun_getjj.html"},{"title":"DQMC_GFun_Init – Quest","text":"public  subroutine DQMC_GFun_Init(n, L, G, V, WS, nwrap, difflim, errrate, up, ssxx, fixw) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: L type( G_fun ), intent(inout) :: G real(kind=wp), intent(in), target :: V (n,L) type( WSpace ), intent(in), target :: WS integer, intent(in) :: nwrap real(kind=wp), intent(in) :: difflim real(kind=wp), intent(in) :: errrate logical, intent(in) :: up integer, intent(in) :: ssxx integer, intent(in) :: fixw Called by proc~~dqmc_gfun_init~~CalledByGraph proc~dqmc_gfun_init DQMC_GFun::DQMC_GFun_Init proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_gfun_init proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_gfun_init proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_gfun_init.html"},{"title":"DQMC_GFun_Init_original – Quest","text":"public  subroutine DQMC_GFun_Init_original(n, L, G, V, WS, nwrap, difflim, errrate, up, ssxx, fixw) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: L type( G_fun ), intent(inout) :: G real(kind=wp), intent(in), target :: V (n,L) type( WSpace ), intent(in), target :: WS integer, intent(in) :: nwrap real(kind=wp), intent(in) :: difflim real(kind=wp), intent(in) :: errrate logical, intent(in) :: up integer, intent(in) :: ssxx integer, intent(in) :: fixw","tags":"","loc":"proc/dqmc_gfun_init_original.html"},{"title":"DQMC_GFun_Clone – Quest","text":"public  subroutine DQMC_GFun_Clone(G1, G2) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G1 type( G_fun ), intent(in) :: G2 Called by proc~~dqmc_gfun_clone~~CalledByGraph proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_fullmeas DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas->proc~dqmc_gfun_clone proc~dqmc_hub_fullmeas~2 DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas~2->proc~dqmc_gfun_clone proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_gfun_clone proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_gfun_clone proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_gfun_clone proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_gfun_clone proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_fullmeas program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_gfun_clone.html"},{"title":"DQMC_GFun_Duplicate – Quest","text":"public  subroutine DQMC_GFun_Duplicate(G1, G2) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G1 type( G_fun ), intent(in) :: G2 Called by proc~~dqmc_gfun_duplicate~~CalledByGraph proc~dqmc_gfun_duplicate DQMC_GFun::DQMC_GFun_Duplicate proc~dqmc_hub_fullmeas DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas->proc~dqmc_gfun_duplicate proc~dqmc_hub_fullmeas~2 DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas~2->proc~dqmc_gfun_duplicate proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_gfun_duplicate proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_gfun_duplicate proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_fullmeas program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_gfun_duplicate.html"},{"title":"DQMC_GFun_CopyUp – Quest","text":"public  subroutine DQMC_GFun_CopyUp(G1, G2, P) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G1 type( G_fun ), intent(in) :: G2 real(kind=wp), intent(in) :: P (G2%n) Called by proc~~dqmc_gfun_copyup~~CalledByGraph proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_fullmeas DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas->proc~dqmc_gfun_copyup proc~dqmc_hub_fullmeas~2 DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas~2->proc~dqmc_gfun_copyup proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_gfun_copyup proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_gfun_copyup proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_gfun_copyup proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2->proc~dqmc_gfun_copyup proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_gfun_copyup proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_gfun_copyup proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_fullmeas program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_gfun_copyup.html"},{"title":"DQMC_Gfun_Free – Quest","text":"public  subroutine DQMC_Gfun_Free(G) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G Called by proc~~dqmc_gfun_free~~CalledByGraph proc~dqmc_gfun_free DQMC_GFun::DQMC_Gfun_Free proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free->proc~dqmc_gfun_free proc~dqmc_hub_free~2 DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free~2->proc~dqmc_gfun_free proc~dqmc_hub_fullmeas DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas->proc~dqmc_gfun_free proc~dqmc_hub_fullmeas~2 DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas~2->proc~dqmc_gfun_free proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_gfun_free proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_gfun_free proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_free proc~dqmc_comp_2dperl->proc~dqmc_hub_meas program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_free program~dqmc_ggeom->proc~dqmc_hub_fullmeas program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_free program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_gfun_free.html"},{"title":"DQMC_GetG – Quest","text":"public  subroutine DQMC_GetG(il, G, SB) Arguments Type Intent Optional Attributes Name integer, intent(in) :: il type( G_fun ), intent(inout) :: G type( SeqB ), intent(inout) :: SB Calls proc~~dqmc_getg~~CallsGraph proc~dqmc_getg DQMC_GFun::DQMC_GetG blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning blas_dgemm blas_dgemm proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_getg~~CalledByGraph proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_getg.html"},{"title":"DQMC_GetG_2nd_order – Quest","text":"public  subroutine DQMC_GetG_2nd_order(G, B) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G type( matB ), intent(in) :: B Called by proc~~dqmc_getg_2nd_order~~CalledByGraph proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_fullmeas DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas->proc~dqmc_getg_2nd_order proc~dqmc_hub_fullmeas~2 DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas~2->proc~dqmc_getg_2nd_order proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_getg_2nd_order proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg_2nd_order proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_getg_2nd_order proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg_2nd_order proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_fullmeas program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_getg_2nd_order.html"},{"title":"DQMC_ComputeG – Quest","text":"public  subroutine DQMC_ComputeG(il, n, sgn, G, V, SB, pvt2, compDet, det, sxx) Setup index for B_{i}\nCompute the LU decomposition of T first.\nSolve T'W = U. W = transpose(inv(U)inv(T)) Compute W D1+D2\n  = transpose(inv(U)inv(T)) D1+D2\n  = transpose(D1*inv(U)inv(T) + D2) Compute the LU decomposition of W1.\nG = inv(U), which is transpose of U.\nG = D1 G = D1 inv(U)\nSolve W'G = inv(U), G = inv(W') G\nSolve TG = inv(W') inv(U), G = inv(T)inv(W') D1 inv(U)\nCompute the LU decomposition of U first. Arguments Type Intent Optional Attributes Name integer, intent(in) :: il integer, intent(in) :: n real(kind=wp), intent(inout) :: sgn real(kind=wp), intent(inout) :: G (:,:) real(kind=wp), intent(in) :: V (:,:) type( SeqB ), intent(inout) :: SB integer, intent(inout) :: pvt2 (:) logical, intent(in) :: compDet real(kind=wp), intent(inout) :: det logical, intent(in) :: sxx Calls proc~~dqmc_computeg~~CallsGraph proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG blas_dcopy blas_dcopy proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_computeg->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg->proc~dqmc_warning dscal dscal proc~dqmc_scalerow->dscal proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->proc~dqmc_scalerow blas_dgemm blas_dgemm proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dscal blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_udtd->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_udtd->lapack_dorgqr proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_computeg~~CalledByGraph proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_computeg.html"},{"title":"DQMC_UpdateWraps – Quest","text":"public  subroutine DQMC_UpdateWraps(G) Uses DQMC_MPI proc~~dqmc_updatewraps~~UsesGraph proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps module~dqmc_mpi DQMC_MPI proc~dqmc_updatewraps->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G Called by proc~~dqmc_updatewraps~~CalledByGraph proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_updatewraps proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_updatewraps proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_updatewraps proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_updatewraps proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_updatewraps.html"},{"title":"DQMC_SyncWraps – Quest","text":"public  subroutine DQMC_SyncWraps(G1, G2) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G1 type( G_fun ), intent(inout) :: G2 Called by proc~~dqmc_syncwraps~~CalledByGraph proc~dqmc_syncwraps DQMC_GFun::DQMC_SyncWraps proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_syncwraps proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_syncwraps proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_syncwraps.html"},{"title":"DQMC_UpdateG – Quest","text":"public  subroutine DQMC_UpdateG(j, gamma, G) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j real(kind=wp), intent(in) :: gamma type( G_fun ), intent(inout), target :: G Calls proc~~dqmc_updateg~~CallsGraph proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG blas_dgemv blas_dgemv proc~dqmc_updateg->blas_dgemv blas_dscal blas_dscal proc~dqmc_updateg->blas_dscal proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate proc~dqmc_updateg->proc~dqmc_applyupdate blas_dgemm blas_dgemm proc~dqmc_applyupdate->blas_dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_updateg~~CalledByGraph proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_updateg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_updateg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_updateg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_updateg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_updateg.html"},{"title":"DQMC_ApplyUpdate – Quest","text":"public  subroutine DQMC_ApplyUpdate(G, forced) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G logical, intent(in) :: forced Calls proc~~dqmc_applyupdate~~CallsGraph proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate blas_dgemm blas_dgemm proc~dqmc_applyupdate->blas_dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_applyupdate~~CalledByGraph proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_applyupdate proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG proc~dqmc_hub_sweep->proc~dqmc_updateg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_applyupdate proc~dqmc_hub_sweep_cont->proc~dqmc_updateg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_applyupdate proc~dqmc_hub_sweep_cont~2->proc~dqmc_updateg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_applyupdate proc~dqmc_hub_sweep~2->proc~dqmc_updateg proc~dqmc_updateg->proc~dqmc_applyupdate proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_applyupdate.html"},{"title":"DQMC_Phy2_Init – Quest","text":"public  subroutine DQMC_Phy2_Init(P2, nBin, S, WS, meas) Allocate two additional bins for storing\naverage value and error Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 integer, intent(in) :: nBin type( Struct ), intent(in) :: S type( WSpace ), intent(in), target :: WS logical, intent(out) :: meas Called by proc~~dqmc_phy2_init~~CalledByGraph proc~dqmc_phy2_init DQMC_Phy2::DQMC_Phy2_Init proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_phy2_init proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_phy2_init proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_init.html"},{"title":"DQMC_Phy2_Free – Quest","text":"public  subroutine DQMC_Phy2_Free(P2) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 Called by proc~~dqmc_phy2_free~~CalledByGraph proc~dqmc_phy2_free DQMC_Phy2::DQMC_Phy2_Free proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free->proc~dqmc_phy2_free proc~dqmc_hub_free~2 DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free~2->proc~dqmc_phy2_free proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_free program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_free program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_free program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_free.html"},{"title":"DQMC_Phy2_Meas – Quest","text":"public  subroutine DQMC_Phy2_Meas(n, M1, M2, P2, Bond, G_up, G_dn, sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M1 (:,:) real(kind=wp), intent(inout) :: M2 (:,:) type( Phy2 ), intent(inout) :: P2 type( CCS ), intent(in) :: Bond real(kind=wp), intent(in) :: G_up (n,n) real(kind=wp), intent(in) :: G_dn (n,n) real(kind=wp), intent(in) :: sgn Calls proc~~dqmc_phy2_meas~~CallsGraph proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas blas_daxpy blas_daxpy proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy2_meas~~CalledByGraph proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_fullmeas DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas->proc~dqmc_phy2_meas proc~dqmc_hub_fullmeas~2 DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas~2->proc~dqmc_phy2_meas proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_phy2_meas proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_phy2_meas proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_phy2_meas proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_phy2_meas proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_phy2_meas proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_fullmeas program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_meas.html"},{"title":"DQMC_Phy2_Pair – Quest","text":"public  subroutine DQMC_Phy2_Pair(n, M, up, dn, Bond) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (:,:) real(kind=wp), intent(in) :: up (:,:) real(kind=wp), intent(in) :: dn (:,:) type( CCS ), intent(in) :: Bond Called by proc~~dqmc_phy2_pair~~CalledByGraph proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_geterrirrep DQMC_Phy2::DQMC_Phy2_GetErrIrrep proc~dqmc_phy2_geterrirrep->proc~dqmc_phy2_pair proc~dqmc_phy2_getirrep_connected DQMC_Phy2::DQMC_Phy2_GetIrrep_Connected proc~dqmc_phy2_getirrep_connected->proc~dqmc_phy2_pair proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_phy2_meas->proc~dqmc_phy2_pair proc~dqmc_tdm2_meas DQMC_TDM2::DQMC_TDM2_Meas proc~dqmc_tdm2_meas->proc~dqmc_phy2_pair interface~dqmc_phy2_getirrep DQMC_Phy2::DQMC_Phy2_GetIrrep interface~dqmc_phy2_getirrep->proc~dqmc_phy2_getirrep_connected proc~dqmc_hub_fullmeas DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas->proc~dqmc_phy2_meas proc~dqmc_hub_fullmeas~2 DQMC_Hubbard::DQMC_Hub_FullMeas proc~dqmc_hub_fullmeas~2->proc~dqmc_phy2_meas proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_phy2_meas proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_phy2_meas proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_phy2_meas proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_phy2_meas proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_phy2_meas program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy2_geterrirrep program~dqmc_ggeom->interface~dqmc_phy2_getirrep program~dqmc_ggeom->proc~dqmc_hub_fullmeas program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_pair.html"},{"title":"DQMC_Phy2_Avg_Wave – Quest","text":"public  subroutine DQMC_Phy2_Avg_Wave(P2, W) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 real(kind=wp), intent(in) :: W (P2%nb,P2%nwave) Calls proc~~dqmc_phy2_avg_wave~~CallsGraph proc~dqmc_phy2_avg_wave DQMC_Phy2::DQMC_Phy2_Avg_Wave proc~dqmc_wave_avg DQMC_Phy2::DQMC_Wave_Avg proc~dqmc_phy2_avg_wave->proc~dqmc_wave_avg blas_ddot blas_ddot proc~dqmc_wave_avg->blas_ddot blas_dgemm blas_dgemm proc~dqmc_wave_avg->blas_dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy2_avg_wave~~CalledByGraph proc~dqmc_phy2_avg_wave DQMC_Phy2::DQMC_Phy2_Avg_Wave interface~dqmc_phy2_avg DQMC_Phy2::DQMC_Phy2_avg interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_wave proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->interface~dqmc_phy2_avg proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->interface~dqmc_phy2_avg proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->interface~dqmc_phy2_avg program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~dqmc_phy2_avg program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_avg_wave.html"},{"title":"DQMC_Phy2_Avg_Symm – Quest","text":"public  subroutine DQMC_Phy2_Avg_Symm(P2, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 type( Struct ), intent(in) :: S Calls proc~~dqmc_phy2_avg_symm~~CallsGraph proc~dqmc_phy2_avg_symm DQMC_Phy2::DQMC_Phy2_Avg_Symm proc~dqmc_pair_symm DQMC_Phy2::DQMC_Pair_Symm proc~dqmc_phy2_avg_symm->proc~dqmc_pair_symm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy2_avg_symm~~CalledByGraph proc~dqmc_phy2_avg_symm DQMC_Phy2::DQMC_Phy2_Avg_Symm interface~dqmc_phy2_avg DQMC_Phy2::DQMC_Phy2_avg interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_symm proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->interface~dqmc_phy2_avg proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->interface~dqmc_phy2_avg proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->interface~dqmc_phy2_avg program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~dqmc_phy2_avg program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_avg_symm.html"},{"title":"DQMC_Wave_Avg – Quest","text":"public  subroutine DQMC_Wave_Avg(nB, nWave, W, T, I, O, factor, ldt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nB integer, intent(in) :: nWave real(kind=wp), intent(in) :: W (nb,nWave) real(kind=wp), intent(in) :: T (ldt,nWave) real(kind=wp), intent(in) :: I (nb,nb) real(kind=wp), intent(inout) :: O (:) real(kind=wp), intent(in) :: factor integer, intent(in) :: ldt Calls proc~~dqmc_wave_avg~~CallsGraph proc~dqmc_wave_avg DQMC_Phy2::DQMC_Wave_Avg blas_ddot blas_ddot proc~dqmc_wave_avg->blas_ddot blas_dgemm blas_dgemm proc~dqmc_wave_avg->blas_dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_wave_avg~~CalledByGraph proc~dqmc_wave_avg DQMC_Phy2::DQMC_Wave_Avg proc~dqmc_phy2_avg_wave DQMC_Phy2::DQMC_Phy2_Avg_Wave proc~dqmc_phy2_avg_wave->proc~dqmc_wave_avg proc~dqmc_phy2_geterrirrep DQMC_Phy2::DQMC_Phy2_GetErrIrrep proc~dqmc_phy2_geterrirrep->proc~dqmc_wave_avg proc~dqmc_tdm2_avg DQMC_TDM2::DQMC_TDM2_Avg proc~dqmc_tdm2_avg->proc~dqmc_wave_avg interface~dqmc_phy2_avg DQMC_Phy2::DQMC_Phy2_avg interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_wave program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy2_geterrirrep program~dqmc_ggeom->interface~dqmc_phy2_avg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->interface~dqmc_phy2_avg proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->interface~dqmc_phy2_avg proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->interface~dqmc_phy2_avg program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_wave_avg.html"},{"title":"DQMC_Pair_Symm – Quest","text":"public  subroutine DQMC_Pair_Symm(M2, M3, class_b, size_b, n, nclass, factor) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: M2 (n,n) real(kind=wp), intent(out) :: M3 (nclass) integer, intent(in) :: class_b (n,n) integer, intent(in) :: size_b (nclass) integer, intent(in) :: n integer, intent(in) :: nclass real(kind=wp), intent(in) :: factor Called by proc~~dqmc_pair_symm~~CalledByGraph proc~dqmc_pair_symm DQMC_Phy2::DQMC_Pair_Symm proc~dqmc_phy2_avg_symm DQMC_Phy2::DQMC_Phy2_Avg_Symm proc~dqmc_phy2_avg_symm->proc~dqmc_pair_symm interface~dqmc_phy2_avg DQMC_Phy2::DQMC_Phy2_avg interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_symm proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->interface~dqmc_phy2_avg proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->interface~dqmc_phy2_avg proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->interface~dqmc_phy2_avg program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~dqmc_phy2_avg program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_pair_symm.html"},{"title":"DQMC_Phy2_GetErr – Quest","text":"public  subroutine DQMC_Phy2_GetErr(P2) Uses DQMC_MPI proc~~dqmc_phy2_geterr~~UsesGraph proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr module~dqmc_mpi DQMC_MPI proc~dqmc_phy2_geterr->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 Calls proc~~dqmc_phy2_geterr~~CallsGraph proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife proc~dqmc_phy2_geterr->interface~dqmc_jackknife interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife proc~dqmc_phy2_geterr->interface~dqmc_signjackknife proc~dqmc_jackknife_complex DQMC_Util::DQMC_JackKnife_Complex interface~dqmc_jackknife->proc~dqmc_jackknife_complex proc~dqmc_jackknife_real DQMC_Util::DQMC_JackKnife_Real interface~dqmc_jackknife->proc~dqmc_jackknife_real proc~dqmc_signjackknife_complex DQMC_Util::DQMC_SignJackKnife_Complex interface~dqmc_signjackknife->proc~dqmc_signjackknife_complex proc~dqmc_signjackknife_real DQMC_Util::DQMC_SignJackKnife_Real interface~dqmc_signjackknife->proc~dqmc_signjackknife_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy2_geterr~~CalledByGraph proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_phy2_geterr proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_phy2_geterr proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_phy2_geterr program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy2_geterr program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_geterr.html"},{"title":"DQMC_Phy2_GetIrrep_Full – Quest","text":"public  subroutine DQMC_Phy2_GetIrrep_Full(P2, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 type( Struct ), intent(inout) :: S Calls proc~~dqmc_phy2_getirrep_full~~CallsGraph proc~dqmc_phy2_getirrep_full DQMC_Phy2::DQMC_Phy2_GetIrrep_Full lapack_dsyev lapack_dsyev proc~dqmc_phy2_getirrep_full->lapack_dsyev Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy2_getirrep_full~~CalledByGraph proc~dqmc_phy2_getirrep_full DQMC_Phy2::DQMC_Phy2_GetIrrep_Full interface~dqmc_phy2_getirrep DQMC_Phy2::DQMC_Phy2_GetIrrep interface~dqmc_phy2_getirrep->proc~dqmc_phy2_getirrep_full program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~dqmc_phy2_getirrep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_getirrep_full.html"},{"title":"DQMC_Phy2_GetIrrep_Connected – Quest","text":"public  subroutine DQMC_Phy2_GetIrrep_Connected(P2, G_fun, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 real(kind=wp), intent(in) :: G_fun (S%nclass) type( Struct ), intent(inout) :: S Calls proc~~dqmc_phy2_getirrep_connected~~CallsGraph proc~dqmc_phy2_getirrep_connected DQMC_Phy2::DQMC_Phy2_GetIrrep_Connected lapack_dsyev lapack_dsyev proc~dqmc_phy2_getirrep_connected->lapack_dsyev proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_getirrep_connected->proc~dqmc_phy2_pair Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy2_getirrep_connected~~CalledByGraph proc~dqmc_phy2_getirrep_connected DQMC_Phy2::DQMC_Phy2_GetIrrep_Connected interface~dqmc_phy2_getirrep DQMC_Phy2::DQMC_Phy2_GetIrrep interface~dqmc_phy2_getirrep->proc~dqmc_phy2_getirrep_connected program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~dqmc_phy2_getirrep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_getirrep_connected.html"},{"title":"DQMC_Phy2_GetErrIrrep – Quest","text":"public  subroutine DQMC_Phy2_GetErrIrrep(P2, G_fun, S) Uses DQMC_MPI proc~~dqmc_phy2_geterrirrep~~UsesGraph proc~dqmc_phy2_geterrirrep DQMC_Phy2::DQMC_Phy2_GetErrIrrep module~dqmc_mpi DQMC_MPI proc~dqmc_phy2_geterrirrep->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 real(kind=wp), intent(in) :: G_fun (S%nClass,P2%err) type( Struct ), intent(in) :: S Calls proc~~dqmc_phy2_geterrirrep~~CallsGraph proc~dqmc_phy2_geterrirrep DQMC_Phy2::DQMC_Phy2_GetErrIrrep proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_geterrirrep->proc~dqmc_phy2_pair proc~dqmc_wave_avg DQMC_Phy2::DQMC_Wave_Avg proc~dqmc_phy2_geterrirrep->proc~dqmc_wave_avg blas_ddot blas_ddot proc~dqmc_wave_avg->blas_ddot blas_dgemm blas_dgemm proc~dqmc_wave_avg->blas_dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy2_geterrirrep~~CalledByGraph proc~dqmc_phy2_geterrirrep DQMC_Phy2::DQMC_Phy2_GetErrIrrep program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy2_geterrirrep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_geterrirrep.html"},{"title":"DQMC_Phy2_Print – Quest","text":"public  subroutine DQMC_Phy2_Print(P2, wlabel, OPT) Uses DQMC_MPI proc~~dqmc_phy2_print~~UsesGraph proc~dqmc_phy2_print DQMC_Phy2::DQMC_Phy2_Print module~dqmc_mpi DQMC_MPI proc~dqmc_phy2_print->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(in) :: P2 character(len=*), intent(in) :: wlabel (:) integer, intent(in) :: OPT Calls proc~~dqmc_phy2_print~~CallsGraph proc~dqmc_phy2_print DQMC_Phy2::DQMC_Phy2_Print proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray proc~dqmc_phy2_print->proc~dqmc_print_realarray Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_phy2_print~~CalledByGraph proc~dqmc_phy2_print DQMC_Phy2::DQMC_Phy2_Print proc~dqmc_hub_print DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_print->proc~dqmc_phy2_print proc~dqmc_hub_print~2 DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_print~2->proc~dqmc_phy2_print program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy2_print proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_print program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_print.html"},{"title":"DQMC_phy2_WaveSymm – Quest","text":"public  subroutine DQMC_phy2_WaveSymm(S, P2, Symm) Arguments Type Intent Optional Attributes Name type( Struct ), intent(inout) :: S type( Phy2 ), intent(inout) :: P2 type( symm_operations ), intent(in) :: Symm Called by proc~~dqmc_phy2_wavesymm~~CalledByGraph proc~dqmc_phy2_wavesymm DQMC_Phy2::DQMC_phy2_WaveSymm program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy2_wavesymm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_wavesymm.html"},{"title":"dqmc_phy2_PrintSymm – Quest","text":"public  subroutine dqmc_phy2_PrintSymm(S, P2, OPT) Uses DQMC_MPI proc~~dqmc_phy2_printsymm~~UsesGraph proc~dqmc_phy2_printsymm DQMC_Phy2::dqmc_phy2_PrintSymm module~dqmc_mpi DQMC_MPI proc~dqmc_phy2_printsymm->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( Struct ), intent(inout) :: S type( Phy2 ), intent(inout) :: P2 integer, intent(in) :: OPT Called by proc~~dqmc_phy2_printsymm~~CalledByGraph proc~dqmc_phy2_printsymm DQMC_Phy2::dqmc_phy2_PrintSymm program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy2_printsymm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy2_printsymm.html"},{"title":"DQMC_Phy2_avg – Quest","text":"public interface DQMC_Phy2_avg Calls interface~~dqmc_phy2_avg~~CallsGraph interface~dqmc_phy2_avg DQMC_Phy2::DQMC_Phy2_avg proc~dqmc_phy2_avg_symm DQMC_Phy2::DQMC_Phy2_Avg_Symm interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_symm proc~dqmc_phy2_avg_wave DQMC_Phy2::DQMC_Phy2_Avg_Wave interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_wave proc~dqmc_pair_symm DQMC_Phy2::DQMC_Pair_Symm proc~dqmc_phy2_avg_symm->proc~dqmc_pair_symm proc~dqmc_wave_avg DQMC_Phy2::DQMC_Wave_Avg proc~dqmc_phy2_avg_wave->proc~dqmc_wave_avg blas_ddot blas_ddot proc~dqmc_wave_avg->blas_ddot blas_dgemm blas_dgemm proc~dqmc_wave_avg->blas_dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~dqmc_phy2_avg~~CalledByGraph interface~dqmc_phy2_avg DQMC_Phy2::DQMC_Phy2_avg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->interface~dqmc_phy2_avg proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->interface~dqmc_phy2_avg proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->interface~dqmc_phy2_avg program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~dqmc_phy2_avg program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine DQMC_Phy2_Avg_Wave (P2, W) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 real(kind=wp), intent(in) :: W (P2%nb,P2%nwave) public  subroutine DQMC_Phy2_Avg_Symm (P2, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 type( Struct ), intent(in) :: S","tags":"","loc":"interface/dqmc_phy2_avg.html"},{"title":"DQMC_Phy2_GetIrrep – Quest","text":"public interface DQMC_Phy2_GetIrrep Calls interface~~dqmc_phy2_getirrep~~CallsGraph interface~dqmc_phy2_getirrep DQMC_Phy2::DQMC_Phy2_GetIrrep proc~dqmc_phy2_getirrep_connected DQMC_Phy2::DQMC_Phy2_GetIrrep_Connected interface~dqmc_phy2_getirrep->proc~dqmc_phy2_getirrep_connected proc~dqmc_phy2_getirrep_full DQMC_Phy2::DQMC_Phy2_GetIrrep_Full interface~dqmc_phy2_getirrep->proc~dqmc_phy2_getirrep_full lapack_dsyev lapack_dsyev proc~dqmc_phy2_getirrep_connected->lapack_dsyev proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_getirrep_connected->proc~dqmc_phy2_pair proc~dqmc_phy2_getirrep_full->lapack_dsyev Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~dqmc_phy2_getirrep~~CalledByGraph interface~dqmc_phy2_getirrep DQMC_Phy2::DQMC_Phy2_GetIrrep program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->interface~dqmc_phy2_getirrep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine DQMC_Phy2_GetIrrep_Connected (P2, G_fun, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 real(kind=wp), intent(in) :: G_fun (S%nclass) type( Struct ), intent(inout) :: S public  subroutine DQMC_Phy2_GetIrrep_Full (P2, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 type( Struct ), intent(inout) :: S","tags":"","loc":"interface/dqmc_phy2_getirrep.html"},{"title":"DQMC_WSpace_Allocate – Quest","text":"public  subroutine DQMC_WSpace_Allocate(n, mx_nbr, WS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: mx_nbr type( WSpace ), intent(inout) :: WS Calls proc~~dqmc_wspace_allocate~~CallsGraph proc~dqmc_wspace_allocate DQMC_WSpace::DQMC_WSpace_Allocate lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_wspace_allocate->lapack_dgeqp3 lapack_dgetri lapack_dgetri proc~dqmc_wspace_allocate->lapack_dgetri lapack_dorgqr lapack_dorgqr proc~dqmc_wspace_allocate->lapack_dorgqr lapack_dormqr lapack_dormqr proc~dqmc_wspace_allocate->lapack_dormqr lapack_dsyev lapack_dsyev proc~dqmc_wspace_allocate->lapack_dsyev Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_wspace_allocate~~CalledByGraph proc~dqmc_wspace_allocate DQMC_WSpace::DQMC_WSpace_Allocate proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_wspace_allocate proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_wspace_allocate proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_wspace_allocate.html"},{"title":"DQMC_WSpace_Free – Quest","text":"public  subroutine DQMC_WSpace_Free(WS) Arguments Type Intent Optional Attributes Name type( WSpace ), intent(inout) :: WS Called by proc~~dqmc_wspace_free~~CalledByGraph proc~dqmc_wspace_free DQMC_WSpace::DQMC_WSpace_Free proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free->proc~dqmc_wspace_free proc~dqmc_hub_free~2 DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_hub_free~2->proc~dqmc_wspace_free proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_free program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_free program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_free program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_wspace_free.html"},{"title":"QUEST_GG_Init – Quest","text":"public  subroutine QUEST_GG_Init(S, prefix) Arguments Type Intent Optional Attributes Name type( Struct ), intent(inout) :: S character(len=*), intent(in) :: prefix Calls proc~~quest_gg_init~~CallsGraph proc~quest_gg_init DQMC_Geom::QUEST_GG_Init mumap mumap proc~quest_gg_init->mumap proc~quest_read_adj DQMC_Geom::QUEST_Read_Adj proc~quest_gg_init->proc~quest_read_adj proc~quest_read_class DQMC_Geom::QUEST_Read_Class proc~quest_gg_init->proc~quest_read_class proc~quest_read_phase DQMC_Geom::QUEST_Read_Phase proc~quest_gg_init->proc~quest_read_phase umap umap proc~quest_gg_init->umap bs bs proc~quest_read_adj->bs label label proc~quest_read_class->label Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/quest_gg_init.html"},{"title":"QUEST_Read_Adj – Quest","text":"public  subroutine QUEST_Read_Adj(IPT, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: IPT type( Struct ), intent(inout) :: S Calls proc~~quest_read_adj~~CallsGraph proc~quest_read_adj DQMC_Geom::QUEST_Read_Adj bs bs proc~quest_read_adj->bs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~quest_read_adj~~CalledByGraph proc~quest_read_adj DQMC_Geom::QUEST_Read_Adj proc~quest_gg_init DQMC_Geom::QUEST_GG_Init proc~quest_gg_init->proc~quest_read_adj Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/quest_read_adj.html"},{"title":"QUEST_Read_Class – Quest","text":"public  subroutine QUEST_Read_Class(IPT, IPT2, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: IPT integer, intent(in) :: IPT2 type( Struct ), intent(inout) :: S Calls proc~~quest_read_class~~CallsGraph proc~quest_read_class DQMC_Geom::QUEST_Read_Class label label proc~quest_read_class->label Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~quest_read_class~~CalledByGraph proc~quest_read_class DQMC_Geom::QUEST_Read_Class proc~quest_gg_init DQMC_Geom::QUEST_GG_Init proc~quest_gg_init->proc~quest_read_class Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/quest_read_class.html"},{"title":"QUEST_Read_Phase – Quest","text":"public  subroutine QUEST_Read_Phase(IPT, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: IPT type( Struct ), intent(inout) :: S Called by proc~~quest_read_phase~~CalledByGraph proc~quest_read_phase DQMC_Geom::QUEST_Read_Phase proc~quest_gg_init DQMC_Geom::QUEST_GG_Init proc~quest_gg_init->proc~quest_read_phase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/quest_read_phase.html"},{"title":"Display – Quest","text":"subroutine Display(name, theo, avg, err) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name real(kind=wp), intent(in) :: theo real(kind=wp), intent(in) :: avg real(kind=wp), intent(in) :: err Called by proc~~display~~CalledByGraph proc~display dqmc_verify::Display program~dqmc_verify dqmc_verify program~dqmc_verify->proc~display Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/display.html"},{"title":"DQMC_Phy0_GetResult – Quest","text":"subroutine DQMC_Phy0_GetResult(P0, meas, name, avg, err) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(in) :: P0 integer, intent(in) :: meas character(len=*), intent(inout) :: name real(kind=wp), intent(inout) :: avg real(kind=wp), intent(inout) :: err Called by proc~~dqmc_phy0_getresult~~CalledByGraph proc~dqmc_phy0_getresult dqmc_verify::DQMC_Phy0_GetResult program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_phy0_getresult Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_phy0_getresult.html"},{"title":"DQMC_TDM1_Init – Quest","text":"public  subroutine DQMC_TDM1_Init(L, dtau, T1, nBin, S, Gwrap) Uses DQMC_GEOM_WRAP proc~~dqmc_tdm1_init~~UsesGraph proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init module~dqmc_geom_wrap DQMC_GEOM_WRAP proc~dqmc_tdm1_init->module~dqmc_geom_wrap module~dqmc_bonds DQMC_BONDS module~dqmc_geom_wrap->module~dqmc_bonds module~dqmc_cfg DQMC_Cfg module~dqmc_geom_wrap->module~dqmc_cfg module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_geom_wrap->module~dqmc_geom_param module~dqmc_hamilt DQMC_HAMILT module~dqmc_geom_wrap->module~dqmc_hamilt module~dqmc_latt DQMC_LATT module~dqmc_geom_wrap->module~dqmc_latt module~dqmc_reclatt DQMC_RECLATT module~dqmc_geom_wrap->module~dqmc_reclatt module~dqmc_struct DQMC_STRUCT module~dqmc_geom_wrap->module~dqmc_struct module~dqmc_symm DQMC_SYMM module~dqmc_geom_wrap->module~dqmc_symm module~dqmc_bonds->module~dqmc_geom_param module~dqmc_bonds->module~dqmc_latt module~dqmc_util DQMC_Util module~dqmc_cfg->module~dqmc_util module~dqmc_hamilt->module~dqmc_cfg module~dqmc_hamilt->module~dqmc_geom_param module~dqmc_hamilt->module~dqmc_latt module~dqmc_hamilt->module~dqmc_reclatt module~dqmc_latt->module~dqmc_geom_param module~dqmc_latt->module~dqmc_util module~dqmc_reclatt->module~dqmc_cfg module~dqmc_reclatt->module~dqmc_geom_param module~dqmc_reclatt->module~dqmc_latt module~dqmc_struct->module~dqmc_cfg module~dqmc_struct->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_symm->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: L real(kind=wp), intent(in) :: dtau type( TDM1 ), intent(inout) :: T1 integer, intent(in) :: nBin type( Struct ), intent(in) :: S type( GeomWrap ), intent(in) :: Gwrap Calls proc~~dqmc_tdm1_init~~CallsGraph proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_initftw DQMC_TDM1::DQMC_TDM1_InitFTw proc~dqmc_tdm1_init->proc~dqmc_tdm1_initftw proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_init->proc~dqmc_tdm1_initprop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_tdm1_init~~CalledByGraph proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_init.html"},{"title":"DQMC_TDM1_InitFTw – Quest","text":"public  subroutine DQMC_TDM1_InitFTw(T1) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 Called by proc~~dqmc_tdm1_initftw~~CalledByGraph proc~dqmc_tdm1_initftw DQMC_TDM1::DQMC_TDM1_InitFTw proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_init->proc~dqmc_tdm1_initftw program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_initftw.html"},{"title":"DQMC_TDM1_InitProp – Quest","text":"public  subroutine DQMC_TDM1_InitProp(T1, S, Gwrap, iprop) Uses DQMC_GEOM_WRAP proc~~dqmc_tdm1_initprop~~UsesGraph proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp module~dqmc_geom_wrap DQMC_GEOM_WRAP proc~dqmc_tdm1_initprop->module~dqmc_geom_wrap module~dqmc_bonds DQMC_BONDS module~dqmc_geom_wrap->module~dqmc_bonds module~dqmc_cfg DQMC_Cfg module~dqmc_geom_wrap->module~dqmc_cfg module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_geom_wrap->module~dqmc_geom_param module~dqmc_hamilt DQMC_HAMILT module~dqmc_geom_wrap->module~dqmc_hamilt module~dqmc_latt DQMC_LATT module~dqmc_geom_wrap->module~dqmc_latt module~dqmc_reclatt DQMC_RECLATT module~dqmc_geom_wrap->module~dqmc_reclatt module~dqmc_struct DQMC_STRUCT module~dqmc_geom_wrap->module~dqmc_struct module~dqmc_symm DQMC_SYMM module~dqmc_geom_wrap->module~dqmc_symm module~dqmc_bonds->module~dqmc_geom_param module~dqmc_bonds->module~dqmc_latt module~dqmc_util DQMC_Util module~dqmc_cfg->module~dqmc_util module~dqmc_hamilt->module~dqmc_cfg module~dqmc_hamilt->module~dqmc_geom_param module~dqmc_hamilt->module~dqmc_latt module~dqmc_hamilt->module~dqmc_reclatt module~dqmc_latt->module~dqmc_geom_param module~dqmc_latt->module~dqmc_util module~dqmc_reclatt->module~dqmc_cfg module~dqmc_reclatt->module~dqmc_geom_param module~dqmc_reclatt->module~dqmc_latt module~dqmc_struct->module~dqmc_cfg module~dqmc_struct->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_symm->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 type( Struct ), intent(in) :: S type( GeomWrap ), intent(in) :: Gwrap integer, intent(in) :: iprop Called by proc~~dqmc_tdm1_initprop~~CalledByGraph proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_init->proc~dqmc_tdm1_initprop program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_initprop.html"},{"title":"DQMC_TDM1_Free – Quest","text":"public  subroutine DQMC_TDM1_Free(T1) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 Called by proc~~dqmc_tdm1_free~~CalledByGraph proc~dqmc_tdm1_free DQMC_TDM1::DQMC_TDM1_Free program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_free.html"},{"title":"DQMC_TDM1_Meas – Quest","text":"public  subroutine DQMC_TDM1_Meas(t1, tau) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: t1 type( Gtau ), intent(inout) :: tau Calls proc~~dqmc_tdm1_meas~~CallsGraph proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_gtau_copyup DQMC_GTAU::DQMC_Gtau_CopyUp proc~dqmc_tdm1_meas->proc~dqmc_gtau_copyup proc~dqmc_gtau_dumpa DQMC_GTAU::DQMC_Gtau_DumpA proc~dqmc_tdm1_meas->proc~dqmc_gtau_dumpa proc~dqmc_tdm1_compute DQMC_TDM1::DQMC_TDM1_Compute proc~dqmc_tdm1_meas->proc~dqmc_tdm1_compute proc~dqmc_gtau_setalias DQMC_GTAU::DQMC_Gtau_SetAlias proc~dqmc_change_gtau_time->proc~dqmc_gtau_setalias proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_change_gtau_time->proc~dqmc_multb_left proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_change_gtau_time->proc~dqmc_multb_right proc~dqmc_multbi_left DQMC_MATB::DQMC_MultBi_Left proc~dqmc_change_gtau_time->proc~dqmc_multbi_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_change_gtau_time->proc~dqmc_multbi_right proc~dqmc_gtau_dumpa->proc~dqmc_gtau_setalias blas_dgemm blas_dgemm proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_multbi_left->blas_dgemm proc~dqmc_multbi_left->blas_dscal proc~dqmc_multbi_left->dexp proc~dqmc_multbi_left->lapack_dsyev proc~dqmc_multbi_left->proc~dqmc_error proc~dqmc_scalerowinv DQMC_Util::DQMC_ScaleRowInv proc~dqmc_multbi_left->proc~dqmc_scalerowinv proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecol->dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_scalerowinv->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_tdm1_meas~~CalledByGraph proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_meas Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_meas.html"},{"title":"DQMC_TDM1_Meas_Para – Quest","text":"public  subroutine DQMC_TDM1_Meas_Para(t1, pT1, tau, ptau) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: t1 type( TDM1 ), intent(inout) :: pT1 (:) type( Gtau ), intent(inout) :: tau type( Gtau ), intent(inout) :: ptau (:) Calls proc~~dqmc_tdm1_meas_para~~CallsGraph proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time proc~dqmc_gtau_copyup DQMC_GTAU::DQMC_Gtau_CopyUp proc~dqmc_tdm1_meas_para->proc~dqmc_gtau_copyup proc~dqmc_gtau_dumpa DQMC_GTAU::DQMC_Gtau_DumpA proc~dqmc_tdm1_meas_para->proc~dqmc_gtau_dumpa proc~dqmc_tdm1_compute DQMC_TDM1::DQMC_TDM1_Compute proc~dqmc_tdm1_meas_para->proc~dqmc_tdm1_compute proc~dqmc_gtau_setalias DQMC_GTAU::DQMC_Gtau_SetAlias proc~dqmc_change_gtau_time->proc~dqmc_gtau_setalias proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_change_gtau_time->proc~dqmc_multb_left proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_change_gtau_time->proc~dqmc_multb_right proc~dqmc_multbi_left DQMC_MATB::DQMC_MultBi_Left proc~dqmc_change_gtau_time->proc~dqmc_multbi_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_change_gtau_time->proc~dqmc_multbi_right proc~dqmc_gtau_dumpa->proc~dqmc_gtau_setalias blas_dgemm blas_dgemm proc~dqmc_multb_left->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_left->blas_dscal dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_multbi_left->blas_dgemm proc~dqmc_multbi_left->blas_dscal proc~dqmc_multbi_left->dexp proc~dqmc_multbi_left->lapack_dsyev proc~dqmc_multbi_left->proc~dqmc_error proc~dqmc_scalerowinv DQMC_Util::DQMC_ScaleRowInv proc~dqmc_multbi_left->proc~dqmc_scalerowinv proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv dscal dscal proc~dqmc_scalecol->dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_scalerowinv->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_tdm1_meas_para~~CalledByGraph proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_meas_para Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_meas_para.html"},{"title":"DQMC_TDM1_Compute – Quest","text":"public  subroutine DQMC_TDM1_Compute(T1, upt0, up0t, dnt0, dn0t, up00, uptt, dn00, dntt, it, i0) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 real(kind=wp), intent(in) :: upt0 (:,:) real(kind=wp), intent(in) :: up0t (:,:) real(kind=wp), intent(in) :: dnt0 (:,:) real(kind=wp), intent(in) :: dn0t (:,:) real(kind=wp), intent(in) :: up00 (:,:) real(kind=wp), intent(in) :: uptt (:,:) real(kind=wp), intent(in) :: dn00 (:,:) real(kind=wp), intent(in) :: dntt (:,:) integer, intent(in) :: it integer, intent(in) :: i0 Called by proc~~dqmc_tdm1_compute~~CalledByGraph proc~dqmc_tdm1_compute DQMC_TDM1::DQMC_TDM1_Compute proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_tdm1_compute proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_tdm1_compute program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_compute.html"},{"title":"DQMC_TDM1_Avg – Quest","text":"public  subroutine DQMC_TDM1_Avg(T1) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 Calls proc~~dqmc_tdm1_avg~~CallsGraph proc~dqmc_tdm1_avg DQMC_TDM1::DQMC_TDM1_Avg dscal dscal proc~dqmc_tdm1_avg->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_tdm1_avg~~CalledByGraph proc~dqmc_tdm1_avg DQMC_TDM1::DQMC_TDM1_Avg program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_avg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_avg.html"},{"title":"DQMC_TDM1_GetErr – Quest","text":"public  subroutine DQMC_TDM1_GetErr(T1) Uses DQMC_MPI proc~~dqmc_tdm1_geterr~~UsesGraph proc~dqmc_tdm1_geterr DQMC_TDM1::DQMC_TDM1_GetErr module~dqmc_mpi DQMC_MPI proc~dqmc_tdm1_geterr->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 Calls proc~~dqmc_tdm1_geterr~~CallsGraph proc~dqmc_tdm1_geterr DQMC_TDM1::DQMC_TDM1_GetErr interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife proc~dqmc_tdm1_geterr->interface~dqmc_jackknife interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife proc~dqmc_tdm1_geterr->interface~dqmc_signjackknife proc~dqmc_jackknife_complex DQMC_Util::DQMC_JackKnife_Complex interface~dqmc_jackknife->proc~dqmc_jackknife_complex proc~dqmc_jackknife_real DQMC_Util::DQMC_JackKnife_Real interface~dqmc_jackknife->proc~dqmc_jackknife_real proc~dqmc_signjackknife_complex DQMC_Util::DQMC_SignJackKnife_Complex interface~dqmc_signjackknife->proc~dqmc_signjackknife_complex proc~dqmc_signjackknife_real DQMC_Util::DQMC_SignJackKnife_Real interface~dqmc_signjackknife->proc~dqmc_signjackknife_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_tdm1_geterr~~CalledByGraph proc~dqmc_tdm1_geterr DQMC_TDM1::DQMC_TDM1_GetErr program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_geterr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_geterr.html"},{"title":"DQMC_TDM1_Print – Quest","text":"public  subroutine DQMC_TDM1_Print(T1, OPT) Uses DQMC_MPI proc~~dqmc_tdm1_print~~UsesGraph proc~dqmc_tdm1_print DQMC_TDM1::DQMC_TDM1_Print module~dqmc_mpi DQMC_MPI proc~dqmc_tdm1_print->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(in) :: T1 integer, intent(in) :: OPT Calls proc~~dqmc_tdm1_print~~CallsGraph proc~dqmc_tdm1_print DQMC_TDM1::DQMC_TDM1_Print interface~dqmc_print_array DQMC_Util::DQMC_Print_Array proc~dqmc_tdm1_print->interface~dqmc_print_array proc~dqmc_print_complexarray DQMC_Util::DQMC_Print_ComplexArray interface~dqmc_print_array->proc~dqmc_print_complexarray proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray interface~dqmc_print_array->proc~dqmc_print_realarray Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_tdm1_print~~CalledByGraph proc~dqmc_tdm1_print DQMC_TDM1::DQMC_TDM1_Print program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_print.html"},{"title":"DQMC_TDM1_GetKFT – Quest","text":"public  subroutine DQMC_TDM1_GetKFT(T1) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 Calls proc~~dqmc_tdm1_getkft~~CallsGraph proc~dqmc_tdm1_getkft DQMC_TDM1::DQMC_TDM1_GetKFT proc~dqmc_getftk DQMC_Util::dqmc_getFTk proc~dqmc_tdm1_getkft->proc~dqmc_getftk dconjg dconjg proc~dqmc_getftk->dconjg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_tdm1_getkft~~CalledByGraph proc~dqmc_tdm1_getkft DQMC_TDM1::DQMC_TDM1_GetKFT program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_getkft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_getkft.html"},{"title":"DQMC_TDM1_GetErrKFT – Quest","text":"public  subroutine DQMC_TDM1_GetErrKFT(T1) Uses DQMC_MPI proc~~dqmc_tdm1_geterrkft~~UsesGraph proc~dqmc_tdm1_geterrkft DQMC_TDM1::DQMC_TDM1_GetErrKFT module~dqmc_mpi DQMC_MPI proc~dqmc_tdm1_geterrkft->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 Called by proc~~dqmc_tdm1_geterrkft~~CalledByGraph proc~dqmc_tdm1_geterrkft DQMC_TDM1::DQMC_TDM1_GetErrKFT program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_geterrkft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_geterrkft.html"},{"title":"DQMC_TDM1_PrintKFT – Quest","text":"public  subroutine DQMC_TDM1_PrintKFT(T1, OPT) Uses DQMC_MPI proc~~dqmc_tdm1_printkft~~UsesGraph proc~dqmc_tdm1_printkft DQMC_TDM1::DQMC_TDM1_PrintKFT module~dqmc_mpi DQMC_MPI proc~dqmc_tdm1_printkft->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(in) :: T1 integer, intent(in) :: OPT Calls proc~~dqmc_tdm1_printkft~~CallsGraph proc~dqmc_tdm1_printkft DQMC_TDM1::DQMC_TDM1_PrintKFT interface~dqmc_print_array DQMC_Util::DQMC_Print_Array proc~dqmc_tdm1_printkft->interface~dqmc_print_array proc~dqmc_print_complexarray DQMC_Util::DQMC_Print_ComplexArray interface~dqmc_print_array->proc~dqmc_print_complexarray proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray interface~dqmc_print_array->proc~dqmc_print_realarray Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_tdm1_printkft~~CalledByGraph proc~dqmc_tdm1_printkft DQMC_TDM1::DQMC_TDM1_PrintKFT program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_printkft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_printkft.html"},{"title":"DQMC_TDM1_SelfEnergy – Quest","text":"public  subroutine DQMC_TDM1_SelfEnergy(T1, tau, OPT) Uses DQMC_MPI proc~~dqmc_tdm1_selfenergy~~UsesGraph proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy module~dqmc_mpi DQMC_MPI proc~dqmc_tdm1_selfenergy->module~dqmc_mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(in) :: T1 type( Gtau ), intent(inout) :: tau integer, intent(in) :: OPT Calls proc~~dqmc_tdm1_selfenergy~~CallsGraph proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy interface~dqmc_print_array DQMC_Util::DQMC_Print_Array proc~dqmc_tdm1_selfenergy->interface~dqmc_print_array proc~dqmc_getftk DQMC_Util::dqmc_getFTk proc~dqmc_tdm1_selfenergy->proc~dqmc_getftk proc~dqmc_gtau_getg0 DQMC_GTAU::DQMC_Gtau_GetG0 proc~dqmc_tdm1_selfenergy->proc~dqmc_gtau_getg0 zgemv zgemv proc~dqmc_tdm1_selfenergy->zgemv zgetrf zgetrf proc~dqmc_tdm1_selfenergy->zgetrf zgetri zgetri proc~dqmc_tdm1_selfenergy->zgetri proc~dqmc_print_complexarray DQMC_Util::DQMC_Print_ComplexArray interface~dqmc_print_array->proc~dqmc_print_complexarray proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray interface~dqmc_print_array->proc~dqmc_print_realarray dconjg dconjg proc~dqmc_getftk->dconjg dcopy dcopy proc~dqmc_gtau_getg0->dcopy dgemm dgemm proc~dqmc_gtau_getg0->dgemm dsyev dsyev proc~dqmc_gtau_getg0->dsyev proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_gtau_getg0->proc~dqmc_getb proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_gtau_getg0->proc~dqmc_scalecol proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_getb->proc~dqmc_scalerow dscal dscal proc~dqmc_scalecol->dscal proc~dqmc_multb_right->proc~dqmc_scalecol blas_dgemm blas_dgemm proc~dqmc_multb_right->blas_dgemm blas_dscal blas_dscal proc~dqmc_multb_right->blas_dscal dexp dexp proc~dqmc_multb_right->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_right->lapack_dsyev proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_scalerow->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_tdm1_selfenergy~~CalledByGraph proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_selfenergy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_tdm1_selfenergy.html"},{"title":"count_atom – Quest","text":"public  function count_atom() result(natom) Arguments None Return Value integer Calls proc~~count_atom~~CallsGraph proc~count_atom DQMC_LATT::count_atom proc~move_to_record DQMC_Util::move_to_record proc~count_atom->proc~move_to_record Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~count_atom~~CalledByGraph proc~count_atom DQMC_LATT::count_atom proc~init_lattice DQMC_LATT::init_lattice proc~init_lattice->proc~count_atom proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~init_lattice program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/count_atom.html"},{"title":"hoptowho – Quest","text":"public  function hoptowho(iat, delta, jat, lattice) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iat real(kind=8), intent(in) :: delta (rdim) integer, intent(in) :: jat type( lattice_t ), intent(in) :: lattice Return Value integer Calls proc~~hoptowho~~CallsGraph proc~hoptowho DQMC_LATT::hoptowho proc~get_inverse DQMC_Util::get_inverse proc~hoptowho->proc~get_inverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hoptowho~~CalledByGraph proc~hoptowho DQMC_LATT::hoptowho proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->proc~hoptowho proc~construct_pairs DQMC_BONDS::construct_pairs proc~construct_pairs->proc~hoptowho proc~map_symm_bonds DQMC_SYMM::map_symm_bonds proc~map_symm_bonds->proc~hoptowho proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~construct_hamilt proc~dqmc_geom_fill->proc~construct_pairs proc~dqmc_geom_fill->proc~map_symm_bonds program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/hoptowho.html"},{"title":"free_lattice – Quest","text":"public  subroutine free_lattice(latt) Arguments Type Intent Optional Attributes Name type( lattice_t ), intent(inout) :: latt","tags":"","loc":"proc/free_lattice.html"},{"title":"init_lattice – Quest","text":"public  subroutine init_lattice(lattice, SOP) Arguments Type Intent Optional Attributes Name type( lattice_t ), target :: lattice integer, intent(in) :: SOP Calls proc~~init_lattice~~CallsGraph proc~init_lattice DQMC_LATT::init_lattice proc~convert_to_fractional DQMC_LATT::convert_to_fractional proc~init_lattice->proc~convert_to_fractional proc~count_atom DQMC_LATT::count_atom proc~init_lattice->proc~count_atom proc~get_det DQMC_Util::get_det proc~init_lattice->proc~get_det proc~get_inverse DQMC_Util::get_inverse proc~init_lattice->proc~get_inverse proc~move_to_record DQMC_Util::move_to_record proc~init_lattice->proc~move_to_record proc~count_atom->proc~move_to_record Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_lattice~~CalledByGraph proc~init_lattice DQMC_LATT::init_lattice proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~init_lattice program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/init_lattice.html"},{"title":"construct_lattice – Quest","text":"public  subroutine construct_lattice(lattice, SOP) Arguments Type Intent Optional Attributes Name type( lattice_t ), intent(inout), target :: lattice integer, intent(in) :: SOP Calls proc~~construct_lattice~~CallsGraph proc~construct_lattice DQMC_LATT::construct_lattice proc~get_inverse DQMC_Util::get_inverse proc~construct_lattice->proc~get_inverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~construct_lattice~~CalledByGraph proc~construct_lattice DQMC_LATT::construct_lattice proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~construct_lattice program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_lattice.html"},{"title":"convert_to_fractional – Quest","text":"public  subroutine convert_to_fractional(xat, ainv) Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: xat (rdim) real(kind=8), intent(in) :: ainv (rdim,rdim) Called by proc~~convert_to_fractional~~CalledByGraph proc~convert_to_fractional DQMC_LATT::convert_to_fractional proc~assign_phase DQMC_LATT::assign_phase proc~assign_phase->proc~convert_to_fractional proc~init_lattice DQMC_LATT::init_lattice proc~init_lattice->proc~convert_to_fractional proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~assign_phase proc~dqmc_geom_fill->proc~init_lattice program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/convert_to_fractional.html"},{"title":"assign_phase – Quest","text":"public  subroutine assign_phase(lattice) Arguments Type Intent Optional Attributes Name type( lattice_t ) :: lattice Calls proc~~assign_phase~~CallsGraph proc~assign_phase DQMC_LATT::assign_phase proc~convert_to_fractional DQMC_LATT::convert_to_fractional proc~assign_phase->proc~convert_to_fractional proc~get_det DQMC_Util::get_det proc~assign_phase->proc~get_det proc~get_inverse DQMC_Util::get_inverse proc~assign_phase->proc~get_inverse proc~move_to_record DQMC_Util::move_to_record proc~assign_phase->proc~move_to_record Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~assign_phase~~CalledByGraph proc~assign_phase DQMC_LATT::assign_phase proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~assign_phase program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/assign_phase.html"},{"title":"assign_gf_phase – Quest","text":"public  subroutine assign_gf_phase(lattice, twist) Arguments Type Intent Optional Attributes Name type( lattice_t ), intent(inout) :: lattice real(kind=8), intent(in) :: twist (3) Called by proc~~assign_gf_phase~~CalledByGraph proc~assign_gf_phase DQMC_LATT::assign_gf_phase proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~assign_gf_phase program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/assign_gf_phase.html"},{"title":"conjg_real – Quest","text":"public  function conjg_real(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), target :: x Return Value real(kind=8), pointer Called by proc~~conjg_real~~CalledByGraph proc~conjg_real DQMC_Util::conjg_real interface~conjg DQMC_Util::conjg interface~conjg->proc~conjg_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/conjg_real.html"},{"title":"conjg_real1 – Quest","text":"public  function conjg_real1(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), target :: x (:) Return Value real(kind=8), pointer, (:) Called by proc~~conjg_real1~~CalledByGraph proc~conjg_real1 DQMC_Util::conjg_real1 interface~conjg DQMC_Util::conjg interface~conjg->proc~conjg_real1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/conjg_real1.html"},{"title":"conjg_real2 – Quest","text":"public  function conjg_real2(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), target :: x (:,:) Return Value real(kind=8), pointer, (:,:) Called by proc~~conjg_real2~~CalledByGraph proc~conjg_real2 DQMC_Util::conjg_real2 interface~conjg DQMC_Util::conjg interface~conjg->proc~conjg_real2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/conjg_real2.html"},{"title":"DQMC_MatDiff – Quest","text":"public  function DQMC_MatDiff(n, A, B) result(diff) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(in) :: A (n,n) real(kind=WP), intent(in) :: B (n,n) Return Value real(kind=WP) Called by proc~~dqmc_matdiff~~CalledByGraph proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_matdiff.html"},{"title":"DQMC_MatNorm – Quest","text":"public  function DQMC_MatNorm(n, A) result(norm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(in) :: A (n,n) Return Value real(kind=WP)","tags":"","loc":"proc/dqmc_matnorm.html"},{"title":"intran – Quest","text":"public  function intran(L, seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: L integer, intent(inout) :: seed (4) Return Value integer Calls proc~~intran~~CallsGraph proc~intran DQMC_Util::intran proc~ran0 DQMC_Util::ran0 proc~intran->proc~ran0 dlarnv dlarnv proc~ran0->dlarnv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/intran.html"},{"title":"move_to_record – Quest","text":"public  function move_to_record(string, iunit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: iunit Return Value logical Called by proc~~move_to_record~~CalledByGraph proc~move_to_record DQMC_Util::move_to_record proc~assign_phase DQMC_LATT::assign_phase proc~assign_phase->proc~move_to_record proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->proc~move_to_record proc~construct_pairs DQMC_BONDS::construct_pairs proc~construct_pairs->proc~move_to_record proc~count_atom DQMC_LATT::count_atom proc~count_atom->proc~move_to_record proc~count_symmetry DQMC_SYMM::count_symmetry proc~count_symmetry->proc~move_to_record proc~init_lattice DQMC_LATT::init_lattice proc~init_lattice->proc~move_to_record proc~init_lattice->proc~count_atom proc~read_bonds DQMC_BONDS::read_bonds proc~read_bonds->proc~move_to_record proc~read_symm DQMC_SYMM::read_symm proc~read_symm->proc~move_to_record proc~read_symm->proc~count_symmetry proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~assign_phase proc~dqmc_geom_fill->proc~construct_hamilt proc~dqmc_geom_fill->proc~construct_pairs proc~dqmc_geom_fill->proc~init_lattice proc~dqmc_geom_fill->proc~read_bonds proc~dqmc_geom_fill->proc~read_symm program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/move_to_record.html"},{"title":"get_det – Quest","text":"public  function get_det(a) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Return Value real(kind=wp) Called by proc~~get_det~~CalledByGraph proc~get_det DQMC_Util::get_det proc~assign_phase DQMC_LATT::assign_phase proc~assign_phase->proc~get_det proc~init_lattice DQMC_LATT::init_lattice proc~init_lattice->proc~get_det proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~assign_phase proc~dqmc_geom_fill->proc~init_lattice program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_det.html"},{"title":"DQMC_Eye – Quest","text":"public  subroutine DQMC_Eye(n, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(inout) :: A (n,n) Called by proc~~dqmc_eye~~CalledByGraph proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_getbi~2 DQMC_CheckerBoard::DQMC_GetBi proc~dqmc_getbi~2->proc~dqmc_eye proc~dqmc_getb~2 DQMC_CheckerBoard::DQMC_GetB proc~dqmc_getb~2->proc~dqmc_eye proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_eye proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_getgtau->proc~dqmc_seqmultb proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_getgtau->proc~dqmc_seqmultbi proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_seqmultbi->proc~dqmc_eye proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_eye.html"},{"title":"DQMC_Trans – Quest","text":"public  subroutine DQMC_Trans(n, At, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: At (n,n) real(kind=wp), intent(in) :: A (n,n) decide the sgn of det(Q) Called by proc~~dqmc_trans~~CalledByGraph proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_trans proc~dqmc_multb_left~2 DQMC_CheckerBoard::DQMC_MultB_Left proc~dqmc_multb_left~2->proc~dqmc_trans proc~dqmc_multbi_left~2 DQMC_CheckerBoard::DQMC_MultBi_Left proc~dqmc_multbi_left~2->proc~dqmc_trans proc~dqmc_getbi~2 DQMC_CheckerBoard::DQMC_GetBi proc~dqmc_getbi~2->proc~dqmc_multbi_left~2 proc~dqmc_getb~2 DQMC_CheckerBoard::DQMC_GetB proc~dqmc_getb~2->proc~dqmc_multb_left~2 proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_trans.html"},{"title":"DQMC_ScaleCol – Quest","text":"public  subroutine DQMC_ScaleCol(n, A, D) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(inout) :: A (n,n) real(kind=WP), intent(in) :: D (n) Calls proc~~dqmc_scalecol~~CallsGraph proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol dscal dscal proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_scalecol~~CalledByGraph proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_scalecol proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_getgtau->proc~dqmc_seqmultb proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_getgtau->proc~dqmc_seqmultbi proc~dqmc_gtau_getg0 DQMC_GTAU::DQMC_Gtau_GetG0 proc~dqmc_gtau_getg0->proc~dqmc_scalecol proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_gtau_getg0->proc~dqmc_getb proc~dqmc_multb_left~2 DQMC_CheckerBoard::DQMC_MultB_Left proc~dqmc_multb_left~2->proc~dqmc_scalecol proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_multb_right~2 DQMC_CheckerBoard::DQMC_MultB_Right proc~dqmc_multb_right~2->proc~dqmc_scalecol proc~dqmc_multbi_left~2 DQMC_CheckerBoard::DQMC_MultBi_Left proc~dqmc_multbi_left~2->proc~dqmc_scalecol proc~dqmc_multbi_right~2 DQMC_CheckerBoard::DQMC_MultBi_Right proc~dqmc_multbi_right~2->proc~dqmc_scalecol proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_change_gtau_time->proc~dqmc_multb_right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_getbi~2 DQMC_CheckerBoard::DQMC_GetBi proc~dqmc_getbi~2->proc~dqmc_multbi_left~2 proc~dqmc_getb~2 DQMC_CheckerBoard::DQMC_GetB proc~dqmc_getb~2->proc~dqmc_multb_left~2 proc~dqmc_gtau_loada DQMC_GTAU::DQMC_Gtau_LoadA proc~dqmc_gtau_loada->proc~dqmc_multb_right proc~dqmc_gtau_loada->proc~dqmc_getb proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_makegtau->proc~dqmc_change_gtau_time proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_seqmultbi->proc~dqmc_udtd proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy proc~dqmc_tdm1_selfenergy->proc~dqmc_gtau_getg0 proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_gtau_loada program~dqmc_ggeom->proc~dqmc_tdm1_selfenergy program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas program~dqmc_ggeom->proc~dqmc_hub_meas proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep program~dqmc_ggeom->proc~dqmc_hub_sweep proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 program~dqmc_ggeom->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_scalecol.html"},{"title":"DQMC_ScaleRow – Quest","text":"public  subroutine DQMC_ScaleRow(n, A, D) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(inout) :: A (n,n) real(kind=WP), intent(in) :: D (n) Calls proc~~dqmc_scalerow~~CallsGraph proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow dscal dscal proc~dqmc_scalerow->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_scalerow~~CalledByGraph proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_scalerow proc~dqmc_getgtau->proc~dqmc_seqmultb proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_change_gtau_time->proc~dqmc_multb_left proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_gtau_getg0 DQMC_GTAU::DQMC_Gtau_GetG0 proc~dqmc_gtau_getg0->proc~dqmc_getb proc~dqmc_gtau_loada DQMC_GTAU::DQMC_Gtau_LoadA proc~dqmc_gtau_loada->proc~dqmc_getb proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_makegtau->proc~dqmc_change_gtau_time proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy proc~dqmc_tdm1_selfenergy->proc~dqmc_gtau_getg0 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_gtau_loada program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para program~dqmc_ggeom->proc~dqmc_tdm1_selfenergy proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_scalerow.html"},{"title":"DQMC_ScaleColInv – Quest","text":"public  subroutine DQMC_ScaleColInv(n, A, D) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(inout) :: A (n,n) real(kind=WP), intent(in) :: D (n) Calls proc~~dqmc_scalecolinv~~CallsGraph proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv dscal dscal proc~dqmc_scalecolinv->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_scalecolinv~~CalledByGraph proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_getbi DQMC_MATB::DQMC_GetBi proc~dqmc_getbi->proc~dqmc_scalecolinv proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getbi->proc~dqmc_multbi_right proc~dqmc_multbi_right->proc~dqmc_scalecolinv proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_change_gtau_time->proc~dqmc_multbi_right proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_getg->proc~dqmc_multbi_right proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_seqmultbi->proc~dqmc_getbi proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_seqmultbi proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_change_gtau_time proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_scalecolinv.html"},{"title":"DQMC_ScaleRowInv – Quest","text":"public  subroutine DQMC_ScaleRowInv(n, A, D) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(inout) :: A (n,n) real(kind=WP), intent(in) :: D (n) Calls proc~~dqmc_scalerowinv~~CallsGraph proc~dqmc_scalerowinv DQMC_Util::DQMC_ScaleRowInv dscal dscal proc~dqmc_scalerowinv->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_scalerowinv~~CalledByGraph proc~dqmc_scalerowinv DQMC_Util::DQMC_ScaleRowInv proc~dqmc_multbi_left DQMC_MATB::DQMC_MultBi_Left proc~dqmc_multbi_left->proc~dqmc_scalerowinv proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_change_gtau_time->proc~dqmc_multbi_left proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_seqmultbi->proc~dqmc_multbi_left proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_seqmultbi proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_change_gtau_time proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_meas program~dqmc_ggeom->proc~dqmc_tdm1_meas_para Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_scalerowinv.html"},{"title":"DQMC_SignJackKnife_Real – Quest","text":"public  subroutine DQMC_SignJackKnife_Real(n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: avg real(kind=wp), intent(out) :: err real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: sgn (:) real(kind=wp), intent(in) :: sum_sgn Called by proc~~dqmc_signjackknife_real~~CalledByGraph proc~dqmc_signjackknife_real DQMC_Util::DQMC_SignJackKnife_Real interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife interface~dqmc_signjackknife->proc~dqmc_signjackknife_real proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_phy0_geterr->interface~dqmc_signjackknife proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_phy2_geterr->interface~dqmc_signjackknife proc~dqmc_tdm1_geterr DQMC_TDM1::DQMC_TDM1_GetErr proc~dqmc_tdm1_geterr->interface~dqmc_signjackknife proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_phy0_geterr proc~dqmc_comp_2dperl->proc~dqmc_phy2_geterr proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_phy0_geterr proc~dqmc_hub_run->proc~dqmc_phy2_geterr proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_phy0_geterr proc~dqmc_hub_run~2->proc~dqmc_phy2_geterr program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_geterr program~dqmc_ggeom->proc~dqmc_phy2_geterr program~dqmc_ggeom->proc~dqmc_tdm1_geterr program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_signjackknife_real.html"},{"title":"DQMC_SignJackKnife_Complex – Quest","text":"public  subroutine DQMC_SignJackKnife_Complex(n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(out) :: avg complex(kind=wp), intent(out) :: err complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) complex(kind=wp), intent(in) :: sgn (:) complex(kind=wp), intent(in) :: sum_sgn Called by proc~~dqmc_signjackknife_complex~~CalledByGraph proc~dqmc_signjackknife_complex DQMC_Util::DQMC_SignJackKnife_Complex interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife interface~dqmc_signjackknife->proc~dqmc_signjackknife_complex proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_phy0_geterr->interface~dqmc_signjackknife proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_phy2_geterr->interface~dqmc_signjackknife proc~dqmc_tdm1_geterr DQMC_TDM1::DQMC_TDM1_GetErr proc~dqmc_tdm1_geterr->interface~dqmc_signjackknife proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_phy0_geterr proc~dqmc_comp_2dperl->proc~dqmc_phy2_geterr proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_phy0_geterr proc~dqmc_hub_run->proc~dqmc_phy2_geterr proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_phy0_geterr proc~dqmc_hub_run~2->proc~dqmc_phy2_geterr program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_geterr program~dqmc_ggeom->proc~dqmc_phy2_geterr program~dqmc_ggeom->proc~dqmc_tdm1_geterr program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_signjackknife_complex.html"},{"title":"DQMC_JackKnife_Real – Quest","text":"public  subroutine DQMC_JackKnife_Real(n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: avg real(kind=wp), intent(out) :: err real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(out) :: y (n) real(kind=wp), intent(out) :: sgn (n) real(kind=wp), intent(out) :: sum_sgn Called by proc~~dqmc_jackknife_real~~CalledByGraph proc~dqmc_jackknife_real DQMC_Util::DQMC_JackKnife_Real interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife interface~dqmc_jackknife->proc~dqmc_jackknife_real proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_phy0_geterr->interface~dqmc_jackknife proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_phy2_geterr->interface~dqmc_jackknife proc~dqmc_tdm1_geterr DQMC_TDM1::DQMC_TDM1_GetErr proc~dqmc_tdm1_geterr->interface~dqmc_jackknife proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_phy0_geterr proc~dqmc_comp_2dperl->proc~dqmc_phy2_geterr proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_phy0_geterr proc~dqmc_hub_run->proc~dqmc_phy2_geterr proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_phy0_geterr proc~dqmc_hub_run~2->proc~dqmc_phy2_geterr program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_geterr program~dqmc_ggeom->proc~dqmc_phy2_geterr program~dqmc_ggeom->proc~dqmc_tdm1_geterr program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_jackknife_real.html"},{"title":"DQMC_JackKnife_Complex – Quest","text":"public  subroutine DQMC_JackKnife_Complex(n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(out) :: avg complex(kind=wp), intent(out) :: err complex(kind=wp), intent(in) :: x (n) complex(kind=wp), intent(out) :: y (n) complex(kind=wp), intent(out) :: sgn (n) complex(kind=wp), intent(out) :: sum_sgn Called by proc~~dqmc_jackknife_complex~~CalledByGraph proc~dqmc_jackknife_complex DQMC_Util::DQMC_JackKnife_Complex interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife interface~dqmc_jackknife->proc~dqmc_jackknife_complex proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_phy0_geterr->interface~dqmc_jackknife proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_phy2_geterr->interface~dqmc_jackknife proc~dqmc_tdm1_geterr DQMC_TDM1::DQMC_TDM1_GetErr proc~dqmc_tdm1_geterr->interface~dqmc_jackknife proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_phy0_geterr proc~dqmc_comp_2dperl->proc~dqmc_phy2_geterr proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_phy0_geterr proc~dqmc_hub_run->proc~dqmc_phy2_geterr proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_phy0_geterr proc~dqmc_hub_run~2->proc~dqmc_phy2_geterr program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_geterr program~dqmc_ggeom->proc~dqmc_phy2_geterr program~dqmc_ggeom->proc~dqmc_tdm1_geterr program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_jackknife_complex.html"},{"title":"DQMC_GetErr – Quest","text":"public  subroutine DQMC_GetErr(n, err, avg, list) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: err real(kind=wp), intent(in) :: avg real(kind=wp), intent(inout) :: list (n)","tags":"","loc":"proc/dqmc_geterr.html"},{"title":"DQMC_GetErr1 – Quest","text":"public  subroutine DQMC_GetErr1(n, data, avg, err) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: data (n) real(kind=wp), intent(out) :: avg real(kind=wp), intent(out) :: err","tags":"","loc":"proc/dqmc_geterr1.html"},{"title":"DQMC_GetErr2 – Quest","text":"public  subroutine DQMC_GetErr2(n, sm, ssq, avg, err) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: sm real(kind=wp), intent(in) :: ssq real(kind=wp), intent(out) :: avg real(kind=wp), intent(out) :: err","tags":"","loc":"proc/dqmc_geterr2.html"},{"title":"DQMC_Error – Quest","text":"public  subroutine DQMC_Error(message, no) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message integer, intent(in) :: no Called by proc~~dqmc_error~~CalledByGraph proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_b_expinit DQMC_MATB::DQMC_B_ExpInit proc~dqmc_b_expinit->proc~dqmc_error proc~dqmc_ccs_compress DQMC_STRUCT::DQMC_CCS_Compress proc~dqmc_ccs_compress->proc~dqmc_error proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_computeg->proc~dqmc_error proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI proc~dqmc_config_geti->proc~dqmc_error proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI proc~dqmc_config_getpi->proc~dqmc_error proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR proc~dqmc_config_getpr->proc~dqmc_error proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR proc~dqmc_config_getr->proc~dqmc_error proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS proc~dqmc_config_gets->proc~dqmc_error proc~dqmc_config_isset DQMC_Cfg::DQMC_Config_isSet proc~dqmc_config_isset->proc~dqmc_error proc~dqmc_config_seti DQMC_Cfg::DQMC_Config_SetI proc~dqmc_config_seti->proc~dqmc_error proc~dqmc_config_setpi DQMC_Cfg::DQMC_Config_SetPI proc~dqmc_config_setpi->proc~dqmc_error proc~dqmc_config_setpr DQMC_Cfg::DQMC_Config_SetPR proc~dqmc_config_setpr->proc~dqmc_error proc~dqmc_config_setr DQMC_Cfg::DQMC_Config_SetR proc~dqmc_config_setr->proc~dqmc_error proc~dqmc_config_sets DQMC_Cfg::DQMC_Config_SetS proc~dqmc_config_sets->proc~dqmc_error proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~dqmc_error proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~dqmc_geom_fill->proc~construct_hamilt proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~dqmc_geom_fill->proc~init_recip_latt proc~dqmc_geom_read_def DQMC_STRUCT::DQMC_Geom_Read_Def proc~dqmc_geom_read_def->proc~dqmc_error proc~dqmc_geom_read_def->proc~dqmc_ccs_compress proc~dqmc_getgtau DQMC_GTAU::DQMC_GetGtau proc~dqmc_getgtau->proc~dqmc_error proc~dqmc_getgtau->proc~dqmc_seqmultb proc~dqmc_seqmultbi DQMC_SEQB::DQMC_SeqMultBi proc~dqmc_getgtau->proc~dqmc_seqmultbi proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->proc~dqmc_error proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_error proc~dqmc_hub_config~2->proc~dqmc_config_isset proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 interface~cfg_get DQMC_Cfg::CFG_Get proc~dqmc_hub_config~2->interface~cfg_get interface~cfg_set DQMC_Cfg::CFG_Set proc~dqmc_hub_config~2->interface~cfg_set proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~dqmc_error proc~dqmc_hub_input_hsf DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_init->proc~dqmc_hub_input_hsf proc~dqmc_b_init DQMC_MATB::DQMC_B_Init proc~dqmc_hub_init->proc~dqmc_b_init proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2->proc~dqmc_error proc~dqmc_hub_input_hsf~2 DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_init~2->proc~dqmc_hub_input_hsf~2 proc~dqmc_hub_init~2->proc~dqmc_b_init proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_input_hsf->proc~dqmc_error proc~dqmc_hub_input_hsf~2->proc~dqmc_error proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multbi_left DQMC_MATB::DQMC_MultBi_Left proc~dqmc_multbi_left->proc~dqmc_error proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_phy0_avg DQMC_Phy0::DQMC_Phy0_Avg proc~dqmc_phy0_avg->proc~dqmc_error proc~dqmc_read_config DQMC_Cfg::DQMC_Read_Config proc~dqmc_read_config->proc~dqmc_error proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_udtd->proc~dqmc_error interface~cfg_get->proc~dqmc_config_geti interface~cfg_get->proc~dqmc_config_getpi interface~cfg_get->proc~dqmc_config_getpr interface~cfg_get->proc~dqmc_config_getr interface~cfg_get->proc~dqmc_config_gets interface~cfg_set->proc~dqmc_config_seti interface~cfg_set->proc~dqmc_config_setpi interface~cfg_set->proc~dqmc_config_setpr interface~cfg_set->proc~dqmc_config_setr interface~cfg_set->proc~dqmc_config_sets proc~dqmc_b_init->proc~dqmc_b_expinit proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_change_gtau_time->proc~dqmc_multb_left proc~dqmc_change_gtau_time->proc~dqmc_multb_right proc~dqmc_change_gtau_time->proc~dqmc_multbi_left proc~dqmc_change_gtau_time->proc~dqmc_multbi_right proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_phy0_avg proc~dqmc_comp_2dperl->proc~dqmc_read_config proc~dqmc_comp_2dperl->interface~cfg_get proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_init_2dperl DQMC_2DPERL::DQMC_Init_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_init_2dperl proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init proc~dqmc_geom_init->proc~dqmc_ccs_compress proc~dqmc_geom_init->interface~cfg_set proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_getbi DQMC_MATB::DQMC_GetBi proc~dqmc_getbi->proc~dqmc_multbi_right proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_getg->proc~dqmc_multbi_right proc~dqmc_gtau_loada DQMC_GTAU::DQMC_Gtau_LoadA proc~dqmc_gtau_loada->proc~dqmc_multb_right proc~dqmc_gtau_loada->proc~dqmc_getb proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~dqmc_hub_config->proc~dqmc_config_isset proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config->interface~cfg_get proc~dqmc_hub_config->interface~cfg_set proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_phy0_avg proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_phy0_avg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg proc~dqmc_init_2dperl->proc~dqmc_ccs_compress proc~dqmc_makegtau DQMC_GTAU::DQMC_MakeGtau proc~dqmc_makegtau->proc~dqmc_getgtau proc~dqmc_makegtau->proc~dqmc_change_gtau_time proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_seqmultbi->proc~dqmc_multbi_left proc~dqmc_seqmultbi->proc~dqmc_udtd proc~dqmc_seqmultbi->proc~dqmc_getbi program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill program~dqmc_ggeom->proc~dqmc_geom_read_def program~dqmc_ggeom->proc~dqmc_gtau_init program~dqmc_ggeom->proc~dqmc_hub_input_hsf program~dqmc_ggeom->proc~dqmc_phy0_avg program~dqmc_ggeom->proc~dqmc_read_config program~dqmc_ggeom->interface~cfg_get program~dqmc_ggeom->proc~dqmc_geom_init program~dqmc_ggeom->proc~dqmc_gtau_loada program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas program~dqmc_ggeom->proc~dqmc_tdm1_meas proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para program~dqmc_ggeom->proc~dqmc_tdm1_meas_para proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy program~dqmc_ggeom->proc~dqmc_tdm1_selfenergy program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run program~dqmc_verify->proc~dqmc_init_2dperl proc~construct_hamilt->interface~cfg_get proc~dqmc_gtau_getg0 DQMC_GTAU::DQMC_Gtau_GetG0 proc~dqmc_gtau_getg0->proc~dqmc_getb proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time proc~init_recip_latt->interface~cfg_get program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl proc~dqmc_tdm1_selfenergy->proc~dqmc_gtau_getg0 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_error.html"},{"title":"DQMC_Warning – Quest","text":"public  subroutine DQMC_Warning(message, no) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message integer, intent(in) :: no Called by proc~~dqmc_warning~~CalledByGraph proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI proc~dqmc_config_geti->proc~dqmc_warning proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI proc~dqmc_config_getpi->proc~dqmc_warning proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR proc~dqmc_config_getpr->proc~dqmc_warning proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR proc~dqmc_config_getr->proc~dqmc_warning proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS proc~dqmc_config_gets->proc~dqmc_warning proc~dqmc_geom_read_def DQMC_STRUCT::DQMC_Geom_Read_Def proc~dqmc_geom_read_def->proc~dqmc_warning proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->proc~dqmc_warning proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_config->proc~dqmc_hub_init interface~cfg_get DQMC_Cfg::CFG_Get proc~dqmc_hub_config->interface~cfg_get proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_warning proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_config~2->interface~cfg_get proc~dqmc_hub_init->proc~dqmc_warning proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init~2->proc~dqmc_warning proc~dqmc_hub_init~2->proc~dqmc_getg proc~dqmc_hub_outputparam DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_outputparam->proc~dqmc_warning proc~dqmc_hub_outputparam~2 DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_outputparam~2->proc~dqmc_warning proc~dqmc_read_config DQMC_Cfg::DQMC_Read_Config proc~dqmc_read_config->proc~dqmc_warning interface~cfg_get->proc~dqmc_config_geti interface~cfg_get->proc~dqmc_config_getpi interface~cfg_get->proc~dqmc_config_getpr interface~cfg_get->proc~dqmc_config_getr interface~cfg_get->proc~dqmc_config_gets proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_comp_2dperl->proc~dqmc_read_config proc~dqmc_comp_2dperl->interface~cfg_get proc~dqmc_hub_print DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_comp_2dperl->proc~dqmc_hub_print proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~dqmc_computeg proc~dqmc_hub_print->proc~dqmc_hub_outputparam proc~dqmc_hub_print~2 DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_print~2->proc~dqmc_hub_outputparam~2 proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~dqmc_computeg proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~dqmc_computeg program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_read_def program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_ggeom->proc~dqmc_hub_outputparam program~dqmc_ggeom->proc~dqmc_read_config program~dqmc_ggeom->interface~cfg_get program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill program~dqmc_ggeom->proc~dqmc_geom_fill program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run program~dqmc_verify->proc~dqmc_hub_run proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->interface~cfg_get proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~dqmc_getg proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~dqmc_getg proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~dqmc_getg proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~dqmc_getg proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~dqmc_getg proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~init_recip_latt->interface~cfg_get program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl proc~dqmc_geom_fill->proc~construct_hamilt proc~dqmc_geom_fill->proc~init_recip_latt proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_warning.html"},{"title":"ran0 – Quest","text":"public  subroutine ran0(n, var, seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: var (n) integer, intent(inout) :: seed (4) Calls proc~~ran0~~CallsGraph proc~ran0 DQMC_Util::ran0 dlarnv dlarnv proc~ran0->dlarnv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ran0~~CalledByGraph proc~ran0 DQMC_Util::ran0 proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~ran0 proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hol_sweep3_cont DQMC_Hubbard::DQMC_Hol_Sweep3_Cont proc~dqmc_hol_sweep3_cont->proc~ran0 proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~ran0 proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~ran0 proc~dqmc_hub_meas->proc~ran0 proc~dqmc_hub_meas~2 DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_hub_meas~2->proc~ran0 proc~dqmc_hub_sweep->proc~ran0 proc~dqmc_hub_sweep2->proc~ran0 proc~dqmc_hub_sweep2_cont DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont->proc~ran0 proc~dqmc_hub_sweep2_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep2_Cont proc~dqmc_hub_sweep2_cont~2->proc~ran0 proc~dqmc_hub_sweep2~2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_sweep2~2->proc~ran0 proc~dqmc_hub_sweep_cont DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont->proc~ran0 proc~dqmc_hub_sweep_cont~2 DQMC_Hubbard::DQMC_Hub_Sweep_Cont proc~dqmc_hub_sweep_cont~2->proc~ran0 proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->proc~ran0 proc~intran DQMC_Util::intran proc~intran->proc~ran0 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~ran0 program~dqmc_ggeom->proc~dqmc_hub_meas program~dqmc_ggeom->proc~dqmc_hub_sweep program~dqmc_ggeom->proc~dqmc_hub_sweep2 program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_hub_sweep2~2 proc~dqmc_hub_run~2->proc~dqmc_hub_sweep~2 program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ran0.html"},{"title":"ran1 – Quest","text":"public  subroutine ran1(n, var, seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: var (n) integer, intent(inout) :: seed (4) Calls proc~~ran1~~CallsGraph proc~ran1 DQMC_Util::ran1 dlarnv dlarnv proc~ran1->dlarnv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ran1~~CalledByGraph proc~ran1 DQMC_Util::ran1 proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->proc~ran1 proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->proc~ran1 proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->proc~dqmc_hub_init~2 program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_config program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_hub_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ran1.html"},{"title":"ranN – Quest","text":"public  subroutine ranN(n, var, seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: var (n) integer, intent(inout) :: seed (4) Calls proc~~rann~~CallsGraph proc~rann DQMC_Util::ranN dlarnv dlarnv proc~rann->dlarnv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/rann.html"},{"title":"dumpA – Quest","text":"public  subroutine dumpA(m, n, A, OPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: A (1:m,1:n) integer, intent(in) :: OPT","tags":"","loc":"proc/dumpa.html"},{"title":"DQMC_Print_RealArray – Quest","text":"public  subroutine DQMC_Print_RealArray(n, m, title, label, avg, err, OPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in) :: title character(len=*), intent(in) :: label (:) real(kind=wp), intent(in) :: avg (:,:) real(kind=wp), intent(in) :: err (:,:) integer, intent(in) :: OPT Called by proc~~dqmc_print_realarray~~CalledByGraph proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray interface~dqmc_print_array DQMC_Util::DQMC_Print_Array interface~dqmc_print_array->proc~dqmc_print_realarray proc~dqmc_phy0_print DQMC_Phy0::DQMC_Phy0_Print proc~dqmc_phy0_print->proc~dqmc_print_realarray proc~dqmc_phy0_printft DQMC_Phy0::DQMC_Phy0_PrintFT proc~dqmc_phy0_printft->proc~dqmc_print_realarray proc~dqmc_phy2_print DQMC_Phy2::DQMC_Phy2_Print proc~dqmc_phy2_print->proc~dqmc_print_realarray proc~dqmc_hub_print DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_print->proc~dqmc_phy0_print proc~dqmc_hub_print->proc~dqmc_phy2_print proc~dqmc_hub_print~2 DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_hub_print~2->proc~dqmc_phy0_print proc~dqmc_hub_print~2->proc~dqmc_phy2_print proc~dqmc_tdm1_print DQMC_TDM1::DQMC_TDM1_Print proc~dqmc_tdm1_print->interface~dqmc_print_array proc~dqmc_tdm1_printkft DQMC_TDM1::DQMC_TDM1_PrintKFT proc~dqmc_tdm1_printkft->interface~dqmc_print_array proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy proc~dqmc_tdm1_selfenergy->interface~dqmc_print_array program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_print program~dqmc_ggeom->proc~dqmc_phy0_printft program~dqmc_ggeom->proc~dqmc_phy2_print program~dqmc_ggeom->proc~dqmc_tdm1_print program~dqmc_ggeom->proc~dqmc_tdm1_printkft program~dqmc_ggeom->proc~dqmc_tdm1_selfenergy proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_hub_print program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_print_realarray.html"},{"title":"DQMC_Print_ComplexArray – Quest","text":"public  subroutine DQMC_Print_ComplexArray(n, m, title, label, avg, err, OPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in) :: title character(len=*), intent(in) :: label (:) complex(kind=wp), intent(in) :: avg (:,:) complex(kind=wp), intent(in) :: err (:,:) integer, intent(in) :: OPT Called by proc~~dqmc_print_complexarray~~CalledByGraph proc~dqmc_print_complexarray DQMC_Util::DQMC_Print_ComplexArray interface~dqmc_print_array DQMC_Util::DQMC_Print_Array interface~dqmc_print_array->proc~dqmc_print_complexarray proc~dqmc_tdm1_print DQMC_TDM1::DQMC_TDM1_Print proc~dqmc_tdm1_print->interface~dqmc_print_array proc~dqmc_tdm1_printkft DQMC_TDM1::DQMC_TDM1_PrintKFT proc~dqmc_tdm1_printkft->interface~dqmc_print_array proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy proc~dqmc_tdm1_selfenergy->interface~dqmc_print_array program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_print program~dqmc_ggeom->proc~dqmc_tdm1_printkft program~dqmc_ggeom->proc~dqmc_tdm1_selfenergy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_print_complexarray.html"},{"title":"DQMC_Print_EigenMode – Quest","text":"public  subroutine DQMC_Print_EigenMode(n, m, title, value, OPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in) :: title complex(kind=16), intent(in) :: value (:,:,:) integer, intent(in) :: OPT Called by proc~~dqmc_print_eigenmode~~CalledByGraph proc~dqmc_print_eigenmode DQMC_Util::DQMC_Print_EigenMode proc~dqmc_phy0_printft DQMC_Phy0::DQMC_Phy0_PrintFT proc~dqmc_phy0_printft->proc~dqmc_print_eigenmode program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_printft Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_print_eigenmode.html"},{"title":"dqmc_getFTk – Quest","text":"public  subroutine dqmc_getFTk(value, n, nclass, class, na, nk, ft_wgt, phase, valuek) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: value (nclass) integer, intent(in) :: n integer, intent(in) :: nclass integer, intent(in) :: class (n,n) integer, intent(in) :: na integer, intent(in) :: nk complex(kind=wp), intent(in) :: ft_wgt (n/na,nk) integer, intent(in) :: phase (n,n) complex(kind=wp), intent(out) :: valuek (nk*na*(na+1)/2) Calls proc~~dqmc_getftk~~CallsGraph proc~dqmc_getftk DQMC_Util::dqmc_getFTk dconjg dconjg proc~dqmc_getftk->dconjg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_getftk~~CalledByGraph proc~dqmc_getftk DQMC_Util::dqmc_getFTk proc~dqmc_tdm1_getkft DQMC_TDM1::DQMC_TDM1_GetKFT proc~dqmc_tdm1_getkft->proc~dqmc_getftk proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy proc~dqmc_tdm1_selfenergy->proc~dqmc_getftk program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_getkft program~dqmc_ggeom->proc~dqmc_tdm1_selfenergy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_getftk.html"},{"title":"DQMC_IO_open – Quest","text":"public  subroutine DQMC_IO_open(fname, INP_UNIT, OUT_UNIT) Arguments Type Intent Optional Attributes Name character(len=60), intent(out) :: fname integer, intent(out) :: INP_UNIT integer, intent(out) :: OUT_UNIT Calls proc~~dqmc_io_open~~CallsGraph proc~dqmc_io_open DQMC_Util::DQMC_IO_open proc~dqmc_open_file DQMC_Util::DQMC_open_file proc~dqmc_io_open->proc~dqmc_open_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_io_open.html"},{"title":"DQMC_open_file – Quest","text":"public  subroutine DQMC_open_file(fname, fstatus, FILE_UNIT) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname character(len=*), intent(in) :: fstatus integer, intent(out) :: FILE_UNIT Called by proc~~dqmc_open_file~~CalledByGraph proc~dqmc_open_file DQMC_Util::DQMC_open_file proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_open_file proc~dqmc_read_config DQMC_Cfg::DQMC_Read_Config proc~dqmc_comp_2dperl->proc~dqmc_read_config proc~dqmc_io_open DQMC_Util::DQMC_IO_open proc~dqmc_io_open->proc~dqmc_open_file proc~dqmc_read_config->proc~dqmc_open_file program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_open_file program~dqmc_ggeom->proc~dqmc_read_config program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_open_file.html"},{"title":"DQMC_count_records – Quest","text":"public  subroutine DQMC_count_records(n, FILE_UNIT) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n integer, intent(in) :: FILE_UNIT Called by proc~~dqmc_count_records~~CalledByGraph proc~dqmc_count_records DQMC_Util::DQMC_count_records program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_count_records Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_count_records.html"},{"title":"get_inverse – Quest","text":"public  subroutine get_inverse(a, inv) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) real(kind=wp), intent(out) :: inv (3,3) Called by proc~~get_inverse~~CalledByGraph proc~get_inverse DQMC_Util::get_inverse proc~assign_phase DQMC_LATT::assign_phase proc~assign_phase->proc~get_inverse proc~construct_lattice DQMC_LATT::construct_lattice proc~construct_lattice->proc~get_inverse proc~construct_recip_lattice DQMC_RECLATT::construct_recip_lattice proc~construct_recip_lattice->proc~get_inverse proc~dqmc_init_kmate DQMC_RECLATT::DQMC_init_kmate proc~dqmc_init_kmate->proc~get_inverse proc~hoptowho DQMC_LATT::hoptowho proc~hoptowho->proc~get_inverse proc~init_lattice DQMC_LATT::init_lattice proc~init_lattice->proc~get_inverse proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~init_recip_latt->proc~get_inverse proc~map_symm_bonds DQMC_SYMM::map_symm_bonds proc~map_symm_bonds->proc~get_inverse proc~map_symm_bonds->proc~hoptowho proc~map_symm_lattice DQMC_SYMM::map_symm_lattice proc~map_symm_lattice->proc~get_inverse proc~map_symm_recip_lattice DQMC_SYMM::map_symm_recip_lattice proc~map_symm_recip_lattice->proc~get_inverse proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~construct_hamilt->proc~hoptowho proc~construct_pairs DQMC_BONDS::construct_pairs proc~construct_pairs->proc~hoptowho proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill proc~dqmc_geom_fill->proc~assign_phase proc~dqmc_geom_fill->proc~construct_lattice proc~dqmc_geom_fill->proc~construct_recip_lattice proc~dqmc_geom_fill->proc~init_lattice proc~dqmc_geom_fill->proc~init_recip_latt proc~dqmc_geom_fill->proc~map_symm_bonds proc~dqmc_geom_fill->proc~map_symm_lattice proc~dqmc_geom_fill->proc~map_symm_recip_lattice proc~dqmc_geom_fill->proc~construct_hamilt proc~dqmc_geom_fill->proc~construct_pairs program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_geom_fill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_inverse.html"},{"title":"conjg – Quest","text":"public interface conjg Calls interface~~conjg~~CallsGraph interface~conjg DQMC_Util::conjg proc~conjg_real DQMC_Util::conjg_real interface~conjg->proc~conjg_real proc~conjg_real1 DQMC_Util::conjg_real1 interface~conjg->proc~conjg_real1 proc~conjg_real2 DQMC_Util::conjg_real2 interface~conjg->proc~conjg_real2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function conjg_real (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), target :: x Return Value real(kind=8), pointer public  function conjg_real1 (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), target :: x (:) Return Value real(kind=8), pointer, (:) public  function conjg_real2 (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), target :: x (:,:) Return Value real(kind=8), pointer, (:,:)","tags":"","loc":"interface/conjg.html"},{"title":"DQMC_JackKnife – Quest","text":"public interface DQMC_JackKnife Calls interface~~dqmc_jackknife~~CallsGraph interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife proc~dqmc_jackknife_complex DQMC_Util::DQMC_JackKnife_Complex interface~dqmc_jackknife->proc~dqmc_jackknife_complex proc~dqmc_jackknife_real DQMC_Util::DQMC_JackKnife_Real interface~dqmc_jackknife->proc~dqmc_jackknife_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~dqmc_jackknife~~CalledByGraph interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_phy0_geterr->interface~dqmc_jackknife proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_phy2_geterr->interface~dqmc_jackknife proc~dqmc_tdm1_geterr DQMC_TDM1::DQMC_TDM1_GetErr proc~dqmc_tdm1_geterr->interface~dqmc_jackknife proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_phy0_geterr proc~dqmc_comp_2dperl->proc~dqmc_phy2_geterr proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_phy0_geterr proc~dqmc_hub_run->proc~dqmc_phy2_geterr proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_phy0_geterr proc~dqmc_hub_run~2->proc~dqmc_phy2_geterr program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_geterr program~dqmc_ggeom->proc~dqmc_phy2_geterr program~dqmc_ggeom->proc~dqmc_tdm1_geterr program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine DQMC_JackKnife_Real (n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: avg real(kind=wp), intent(out) :: err real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(out) :: y (n) real(kind=wp), intent(out) :: sgn (n) real(kind=wp), intent(out) :: sum_sgn public  subroutine DQMC_JackKnife_Complex (n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(out) :: avg complex(kind=wp), intent(out) :: err complex(kind=wp), intent(in) :: x (n) complex(kind=wp), intent(out) :: y (n) complex(kind=wp), intent(out) :: sgn (n) complex(kind=wp), intent(out) :: sum_sgn","tags":"","loc":"interface/dqmc_jackknife.html"},{"title":"DQMC_SignJackKnife – Quest","text":"public interface DQMC_SignJackKnife Calls interface~~dqmc_signjackknife~~CallsGraph interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife proc~dqmc_signjackknife_complex DQMC_Util::DQMC_SignJackKnife_Complex interface~dqmc_signjackknife->proc~dqmc_signjackknife_complex proc~dqmc_signjackknife_real DQMC_Util::DQMC_SignJackKnife_Real interface~dqmc_signjackknife->proc~dqmc_signjackknife_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~dqmc_signjackknife~~CalledByGraph interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_phy0_geterr->interface~dqmc_signjackknife proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_phy2_geterr->interface~dqmc_signjackknife proc~dqmc_tdm1_geterr DQMC_TDM1::DQMC_TDM1_GetErr proc~dqmc_tdm1_geterr->interface~dqmc_signjackknife proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_phy0_geterr proc~dqmc_comp_2dperl->proc~dqmc_phy2_geterr proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run->proc~dqmc_phy0_geterr proc~dqmc_hub_run->proc~dqmc_phy2_geterr proc~dqmc_hub_run~2 DQMC_Hubbard::DQMC_Hub_Run proc~dqmc_hub_run~2->proc~dqmc_phy0_geterr proc~dqmc_hub_run~2->proc~dqmc_phy2_geterr program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_phy0_geterr program~dqmc_ggeom->proc~dqmc_phy2_geterr program~dqmc_ggeom->proc~dqmc_tdm1_geterr program~dqmc_test dqmc_test program~dqmc_test->proc~dqmc_comp_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->proc~dqmc_hub_run Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine DQMC_SignJackKnife_Real (n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: avg real(kind=wp), intent(out) :: err real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: sgn (:) real(kind=wp), intent(in) :: sum_sgn public  subroutine DQMC_SignJackKnife_Complex (n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(out) :: avg complex(kind=wp), intent(out) :: err complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) complex(kind=wp), intent(in) :: sgn (:) complex(kind=wp), intent(in) :: sum_sgn","tags":"","loc":"interface/dqmc_signjackknife.html"},{"title":"DQMC_Print_Array – Quest","text":"public interface DQMC_Print_Array Calls interface~~dqmc_print_array~~CallsGraph interface~dqmc_print_array DQMC_Util::DQMC_Print_Array proc~dqmc_print_complexarray DQMC_Util::DQMC_Print_ComplexArray interface~dqmc_print_array->proc~dqmc_print_complexarray proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray interface~dqmc_print_array->proc~dqmc_print_realarray Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~dqmc_print_array~~CalledByGraph interface~dqmc_print_array DQMC_Util::DQMC_Print_Array proc~dqmc_tdm1_print DQMC_TDM1::DQMC_TDM1_Print proc~dqmc_tdm1_print->interface~dqmc_print_array proc~dqmc_tdm1_printkft DQMC_TDM1::DQMC_TDM1_PrintKFT proc~dqmc_tdm1_printkft->interface~dqmc_print_array proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy proc~dqmc_tdm1_selfenergy->interface~dqmc_print_array program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_tdm1_print program~dqmc_ggeom->proc~dqmc_tdm1_printkft program~dqmc_ggeom->proc~dqmc_tdm1_selfenergy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine DQMC_Print_RealArray (n, m, title, label, avg, err, OPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in) :: title character(len=*), intent(in) :: label (:) real(kind=wp), intent(in) :: avg (:,:) real(kind=wp), intent(in) :: err (:,:) integer, intent(in) :: OPT public  subroutine DQMC_Print_ComplexArray (n, m, title, label, avg, err, OPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in) :: title character(len=*), intent(in) :: label (:) complex(kind=wp), intent(in) :: avg (:,:) complex(kind=wp), intent(in) :: err (:,:) integer, intent(in) :: OPT","tags":"","loc":"interface/dqmc_print_array.html"},{"title":"DQMC_OMP_Init – Quest","text":"public  subroutine DQMC_OMP_Init(nproc) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: nproc Calls proc~~dqmc_omp_init~~CallsGraph proc~dqmc_omp_init DQMC_OMP::DQMC_OMP_Init omp_set_num_threads omp_set_num_threads proc~dqmc_omp_init->omp_set_num_threads Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dqmc_omp_init~~CalledByGraph proc~dqmc_omp_init DQMC_OMP::DQMC_OMP_Init program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->proc~dqmc_omp_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dqmc_omp_init.html"},{"title":"DQMC_GEOM_WRAP – Quest","text":"Uses DQMC_STRUCT DQMC_HAMILT DQMC_GEOM_PARAM DQMC_LATT DQMC_SYMM DQMC_BONDS DQMC_RECLATT DQMC_Cfg module~~dqmc_geom_wrap~~UsesGraph module~dqmc_geom_wrap DQMC_GEOM_WRAP module~dqmc_bonds DQMC_BONDS module~dqmc_geom_wrap->module~dqmc_bonds module~dqmc_cfg DQMC_Cfg module~dqmc_geom_wrap->module~dqmc_cfg module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_geom_wrap->module~dqmc_geom_param module~dqmc_hamilt DQMC_HAMILT module~dqmc_geom_wrap->module~dqmc_hamilt module~dqmc_latt DQMC_LATT module~dqmc_geom_wrap->module~dqmc_latt module~dqmc_reclatt DQMC_RECLATT module~dqmc_geom_wrap->module~dqmc_reclatt module~dqmc_struct DQMC_STRUCT module~dqmc_geom_wrap->module~dqmc_struct module~dqmc_symm DQMC_SYMM module~dqmc_geom_wrap->module~dqmc_symm module~dqmc_bonds->module~dqmc_geom_param module~dqmc_bonds->module~dqmc_latt module~dqmc_util DQMC_Util module~dqmc_cfg->module~dqmc_util module~dqmc_hamilt->module~dqmc_cfg module~dqmc_hamilt->module~dqmc_geom_param module~dqmc_hamilt->module~dqmc_latt module~dqmc_hamilt->module~dqmc_reclatt module~dqmc_latt->module~dqmc_geom_param module~dqmc_latt->module~dqmc_util module~dqmc_reclatt->module~dqmc_cfg module~dqmc_reclatt->module~dqmc_geom_param module~dqmc_reclatt->module~dqmc_latt module~dqmc_struct->module~dqmc_cfg module~dqmc_struct->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_symm->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_geom_wrap~~UsedByGraph module~dqmc_geom_wrap DQMC_GEOM_WRAP proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_init->module~dqmc_geom_wrap proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_initprop->module~dqmc_geom_wrap program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_geom_wrap Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: GeomWrap Components Type Visibility Attributes Name Initial type( lattice_t ), public :: Lattice type( recip_lattice_t ), public :: RecipLattice type( recip_lattice_t ), public :: GammaLattice type( Hamiltonian_t ), public :: Hamilt type( bonds_t ), public :: Bonds type( symm_operations ), public :: SymmOp type( pairing ), public :: Pairs Subroutines public  subroutine DQMC_Geom_Fill (gwrap, gfile, cfg, SOP) Arguments Type Intent Optional Attributes Name type( GeomWrap ), intent(inout) :: gwrap character(len=60), intent(in) :: gfile type( config ), intent(inout) :: cfg integer, intent(in) :: SOP public  subroutine DQMC_Geom_Init (gwrap, S, cfg) Arguments Type Intent Optional Attributes Name type( GeomWrap ), intent(in) :: gwrap type( Struct ), intent(inout) :: S type( config ), intent(inout) :: cfg public  subroutine DQMC_Print_HeaderFT (Gwrap, OPT, applytwist) Arguments Type Intent Optional Attributes Name type( GeomWrap ), intent(in) :: Gwrap integer, intent(in) :: OPT logical, intent(in) :: applytwist","tags":"","loc":"module/dqmc_geom_wrap.html"},{"title":"DQMC_HAMILT – Quest","text":"Uses DQMC_GEOM_PARAM DQMC_LATT DQMC_RECLATT DQMC_Cfg module~~dqmc_hamilt~~UsesGraph module~dqmc_hamilt DQMC_HAMILT module~dqmc_cfg DQMC_Cfg module~dqmc_hamilt->module~dqmc_cfg module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_hamilt->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_hamilt->module~dqmc_latt module~dqmc_reclatt DQMC_RECLATT module~dqmc_hamilt->module~dqmc_reclatt module~dqmc_util DQMC_Util module~dqmc_cfg->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param module~dqmc_latt->module~dqmc_util module~dqmc_reclatt->module~dqmc_cfg module~dqmc_reclatt->module~dqmc_geom_param module~dqmc_reclatt->module~dqmc_latt Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_hamilt~~UsedByGraph module~dqmc_hamilt DQMC_HAMILT module~dqmc_geom_wrap DQMC_GEOM_WRAP module~dqmc_geom_wrap->module~dqmc_hamilt proc~map_symm_lattice DQMC_SYMM::map_symm_lattice proc~map_symm_lattice->module~dqmc_hamilt proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_init->module~dqmc_geom_wrap proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_initprop->module~dqmc_geom_wrap program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_geom_wrap Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: Hamiltonian_t Components Type Visibility Attributes Name Initial integer, public :: nJsites integer, public :: nUsites integer, public :: ntsites integer, public :: maxneig integer, public, pointer :: tnneig (:) integer, public, pointer :: Unneig (:) integer, public, pointer :: Jnneig (:) integer, public, pointer :: tsite (:) integer, public, pointer :: Usite (:) integer, public, pointer :: Jsite (:) integer, public, pointer :: tneig (:,:) integer, public, pointer :: Uneig (:,:) integer, public, pointer :: Jneig (:,:) integer, public, pointer :: tckb (:,:) real(kind=8), public :: mu_up real(kind=8), public :: mu_dn real(kind=8), public, pointer :: Uv (:,:) real(kind=8), public, pointer :: Jv (:,:) real(kind=8), public, pointer :: Uvalue (:) real(kind=8), public, pointer :: muupvalue (:) real(kind=8), public, pointer :: mudnvalue (:) complex(kind=16), public, pointer :: hopup (:,:) complex(kind=16), public, pointer :: hopdn (:,:) complex(kind=16), public, pointer :: tupvalue (:) complex(kind=16), public, pointer :: tdnvalue (:) complex(kind=16), public, pointer :: phase (:) integer, public :: nhopclass integer, public :: nlocclass integer, public, pointer :: mylocclass (:) integer, public, pointer :: myhopclass (:,:) integer, public :: nplink integer, public, pointer :: plink (:,:) real(kind=wp), public, pointer :: tlink (:,:) logical, public :: constructed logical, public :: neig_found logical, public :: analyzed Subroutines public  subroutine free_hamilt (hamilt) Arguments Type Intent Optional Attributes Name type( Hamiltonian_t ), intent(inout) :: hamilt public  subroutine construct_hamilt (hamilt, lattice, recip_lattice, cfg) Arguments Type Intent Optional Attributes Name type( Hamiltonian_t ), intent(out) :: hamilt type( lattice_t ), intent(in), target :: lattice type( recip_lattice_t ), intent(in) :: recip_lattice type( config ), intent(inout) :: cfg public  subroutine find_neighbors (hamilt) Arguments Type Intent Optional Attributes Name type( Hamiltonian_t ), intent(inout) :: hamilt public  subroutine count_hop_class (lattice, hamilt) Arguments Type Intent Optional Attributes Name type( lattice_t ) :: lattice type( Hamiltonian_t ) :: hamilt public  subroutine count_local_classes (lattice, hamilt) Arguments Type Intent Optional Attributes Name type( lattice_t ), intent(in) :: lattice type( Hamiltonian_t ), intent(inout) :: hamilt public  subroutine dqmc_hamilt_groupckb (hamilt) Arguments Type Intent Optional Attributes Name type( Hamiltonian_t ), intent(inout) :: hamilt public  subroutine group_hopping (hamilt, n, nt, tmap, tupvalue, tdnvalue) Arguments Type Intent Optional Attributes Name type( Hamiltonian_t ), intent(in) :: hamilt integer, intent(in) :: n integer, intent(out) :: nt integer, intent(out) :: tmap (n,n) real(kind=8), intent(inout), pointer :: tupvalue (:) real(kind=8), intent(inout), pointer :: tdnvalue (:)","tags":"","loc":"module/dqmc_hamilt.html"},{"title":"DQMC_STRUCT – Quest","text":"Uses DQMC_Util DQMC_Cfg module~~dqmc_struct~~UsesGraph module~dqmc_struct DQMC_STRUCT module~dqmc_cfg DQMC_Cfg module~dqmc_struct->module~dqmc_cfg module~dqmc_util DQMC_Util module~dqmc_struct->module~dqmc_util module~dqmc_cfg->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_struct~~UsedByGraph module~dqmc_struct DQMC_STRUCT module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_struct module~dqmc_hubbard DQMC_Hubbard module~dqmc_2dperl->module~dqmc_hubbard module~dqmc_geom DQMC_Geom module~dqmc_geom->module~dqmc_struct module~dqmc_geom_wrap DQMC_GEOM_WRAP module~dqmc_geom_wrap->module~dqmc_struct module~dqmc_hubbard->module~dqmc_struct module~dqmc_matb DQMC_MATB module~dqmc_hubbard->module~dqmc_matb module~dqmc_phy0 DQMC_Phy0 module~dqmc_hubbard->module~dqmc_phy0 module~dqmc_phy2 DQMC_Phy2 module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_gfun DQMC_GFun module~dqmc_hubbard->module~dqmc_gfun module~dqmc_seqb DQMC_SEQB module~dqmc_hubbard->module~dqmc_seqb module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_struct module~dqmc_hubbard~2->module~dqmc_matb module~dqmc_hubbard~2->module~dqmc_phy0 module~dqmc_hubbard~2->module~dqmc_phy2 module~dqmc_hubbard~2->module~dqmc_gfun module~dqmc_hubbard~2->module~dqmc_seqb module~dqmc_matb->module~dqmc_struct module~dqmc_phy0->module~dqmc_struct module~dqmc_phy2->module~dqmc_struct module~dqmc_tdm1 DQMC_TDM1 module~dqmc_tdm1->module~dqmc_struct module~dqmc_gtau DQMC_GTAU module~dqmc_tdm1->module~dqmc_gtau module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_struct module~dqmc_tdm2->module~dqmc_phy2 module~dqmc_tdm2->module~dqmc_tdm1 proc~dqmc_b_init~2 DQMC_CheckerBoard::DQMC_B_Init proc~dqmc_b_init~2->module~dqmc_struct program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_struct program~dqmc_verify->module~dqmc_2dperl program~dqmc_verify->module~dqmc_hubbard program~dqmc_verify->module~dqmc_phy0 module~dqmc_gfun->module~dqmc_matb module~dqmc_gfun->module~dqmc_seqb module~dqmc_gtau->module~dqmc_matb module~dqmc_gtau->module~dqmc_gfun module~dqmc_gtau->module~dqmc_seqb module~dqmc_seqb->module~dqmc_matb proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_init->module~dqmc_geom_wrap proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_initprop->module~dqmc_geom_wrap program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_geom_wrap program~dqmc_ggeom->module~dqmc_hubbard program~dqmc_ggeom->module~dqmc_tdm1 program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: N_CHECKLIST = 8 integer, public, parameter :: STRUCT_INIT = 1 integer, public, parameter :: STRUCT_DIM = 2 integer, public, parameter :: STRUCT_ADJ = 3 integer, public, parameter :: STRUCT_CLASS = 4 integer, public, parameter :: STRUCT_WAVE = 5 integer, public, parameter :: STRUCT_BOND = 6 integer, public, parameter :: STRUCT_PHASE = 7 integer, public, parameter :: STRUCT_FT = 8 integer, public, parameter :: label_len = 47 integer, public, parameter :: gname_len = 80 integer, public, parameter :: N_GEO_PARAM = 15 integer, public, parameter :: GEMO_B = 1 integer, public, parameter :: GEMO_D = 2 integer, public, parameter :: GEMO_FT = 3 integer, public, parameter :: GEMO_P = 4 integer, public, parameter :: GEMO_T = 5 integer, public, parameter :: GEMO_W = 6 integer, public, parameter :: GEMO_CLabel = 7 integer, public, parameter :: GEMO_dim = 8 integer, public, parameter :: GEMO_nClass = 9 integer, public, parameter :: GEMO_nSite = 10 integer, public, parameter :: GEMO_nWave = 11 integer, public, parameter :: GEMO_n_b = 12 integer, public, parameter :: GEMO_n_t = 13 integer, public, parameter :: GEMO_Name = 14 integer, public, parameter :: GEMO_wLabel = 15 character(len=*), public, parameter :: GEO_PARAM (N_GEO_Param) = (/\"B      \", \"D      \", \"FT     \", \"P      \", \"T      \", \"W      \", \"cLabel \", \"dim    \", \"nClass \", \"nSite  \", \"nWave  \", \"n_b    \", \"n_t    \", \"name   \", \"wLabel \"/) Derived Types type, public :: CCS Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: nnz integer, public, pointer :: A (:) integer, public, pointer :: row (:) integer, public, pointer :: cstart (:) type, public :: Struct Components Type Visibility Attributes Name Initial integer, public :: nSite integer, public :: nCell character(len=gname_len), public :: name integer, public, pointer :: dim (:) integer, public :: n_t type( CCS ), public :: T integer, public :: nClass integer, public, pointer :: D (:,:) integer, public, pointer :: F (:) integer, public :: nGroup integer, public, pointer :: map (:) integer, public, pointer :: gf_phase (:,:) integer, public, pointer :: chi_phase (:,:) integer, public :: n_b type( CCS ), public :: B integer, public :: nClass_b integer, public, pointer :: class_b (:,:) integer, public, pointer :: size_b (:) type( CCS ), public :: ckb integer, public :: nckb real(kind=wp), public, pointer :: W (:,:) integer, public :: nWave integer, public :: nirrep integer, public, pointer :: wrepr (:) integer, public :: nwclass integer, public, pointer :: wclass (:) character(len=label_len), public, pointer :: clabel (:) character(len=label_len), public, pointer :: wlabel (:) real(kind=wp), public, pointer :: P (:) real(kind=wp), public, pointer :: FT (:,:) logical, public :: checklist (N_CHECKLIST) Subroutines public  subroutine DQMC_CCS_Free (sparA) Arguments Type Intent Optional Attributes Name type( CCS ), intent(inout) :: sparA public  subroutine DQMC_CCS_Print (sparA, OPT) Arguments Type Intent Optional Attributes Name type( CCS ), intent(in) :: sparA integer, intent(in) :: OPT public  subroutine DQMC_CCS_Compress (n, nnz, A, sparA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: nnz integer, intent(in) :: A (:,:) type( CCS ), intent(inout) :: sparA public  subroutine DQMC_CCS_Fill (n, A, sparA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(inout) :: A (:,:) type( CCS ), intent(in) :: sparA public  subroutine DQMC_Struct_Free (S) Arguments Type Intent Optional Attributes Name type( Struct ), intent(inout) :: S public  subroutine DQMC_Geom_Read_Def (S, gfile, tableFormat) Arguments Type Intent Optional Attributes Name type( Struct ), intent(inout) :: S character(len=*), intent(in) :: gfile logical, intent(out) :: tableFormat public  subroutine DQMC_Geom_Discover_F (n, D, F) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: D (:,:) integer, intent(inout) :: F (:) public  subroutine DQMC_Geom_Discover_Map (n, D, F, Map, idx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: D (:,:) integer, intent(inout) :: F (:) integer, intent(inout) :: Map (:) integer, intent(out) :: idx public  subroutine DQMC_Geom_Print (S, OPT) Arguments Type Intent Optional Attributes Name type( Struct ), intent(in) :: S integer, intent(in) :: OPT","tags":"","loc":"module/dqmc_struct.html"},{"title":"DQMC_Cfg – Quest","text":"Uses DQMC_Util module~~dqmc_cfg~~UsesGraph module~dqmc_cfg DQMC_Cfg module~dqmc_util DQMC_Util module~dqmc_cfg->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_cfg~~UsedByGraph module~dqmc_cfg DQMC_Cfg module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_cfg module~dqmc_hubbard DQMC_Hubbard module~dqmc_2dperl->module~dqmc_hubbard module~dqmc_struct DQMC_STRUCT module~dqmc_2dperl->module~dqmc_struct module~dqmc_geom_wrap DQMC_GEOM_WRAP module~dqmc_geom_wrap->module~dqmc_cfg module~dqmc_hamilt DQMC_HAMILT module~dqmc_geom_wrap->module~dqmc_hamilt module~dqmc_reclatt DQMC_RECLATT module~dqmc_geom_wrap->module~dqmc_reclatt module~dqmc_geom_wrap->module~dqmc_struct module~dqmc_hamilt->module~dqmc_cfg module~dqmc_hamilt->module~dqmc_reclatt module~dqmc_hubbard->module~dqmc_cfg module~dqmc_hubbard->module~dqmc_struct module~dqmc_matb DQMC_MATB module~dqmc_hubbard->module~dqmc_matb module~dqmc_phy0 DQMC_Phy0 module~dqmc_hubbard->module~dqmc_phy0 module~dqmc_phy2 DQMC_Phy2 module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_gfun DQMC_GFun module~dqmc_hubbard->module~dqmc_gfun module~dqmc_seqb DQMC_SEQB module~dqmc_hubbard->module~dqmc_seqb module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_cfg module~dqmc_hubbard~2->module~dqmc_struct module~dqmc_hubbard~2->module~dqmc_matb module~dqmc_hubbard~2->module~dqmc_phy0 module~dqmc_hubbard~2->module~dqmc_phy2 module~dqmc_hubbard~2->module~dqmc_gfun module~dqmc_hubbard~2->module~dqmc_seqb module~dqmc_reclatt->module~dqmc_cfg module~dqmc_struct->module~dqmc_cfg program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_cfg program~dqmc_ggeom->module~dqmc_geom_wrap program~dqmc_ggeom->module~dqmc_hubbard module~dqmc_tdm1 DQMC_TDM1 program~dqmc_ggeom->module~dqmc_tdm1 module~dqmc_geom DQMC_Geom module~dqmc_geom->module~dqmc_struct module~dqmc_kbonds DQMC_KBONDS module~dqmc_kbonds->module~dqmc_reclatt module~dqmc_matb->module~dqmc_struct module~dqmc_phy0->module~dqmc_struct module~dqmc_phy2->module~dqmc_struct module~dqmc_tdm1->module~dqmc_struct module~dqmc_gtau DQMC_GTAU module~dqmc_tdm1->module~dqmc_gtau module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_struct module~dqmc_tdm2->module~dqmc_phy2 module~dqmc_tdm2->module~dqmc_tdm1 proc~construct_recip_lattice_classes DQMC_SYMM::construct_recip_lattice_classes proc~construct_recip_lattice_classes->module~dqmc_reclatt proc~dqmc_b_init~2 DQMC_CheckerBoard::DQMC_B_Init proc~dqmc_b_init~2->module~dqmc_struct proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_init->module~dqmc_geom_wrap proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_initprop->module~dqmc_geom_wrap proc~map_symm_lattice DQMC_SYMM::map_symm_lattice proc~map_symm_lattice->module~dqmc_hamilt proc~map_symm_recip_lattice DQMC_SYMM::map_symm_recip_lattice proc~map_symm_recip_lattice->module~dqmc_reclatt program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_2dperl program~dqmc_verify->module~dqmc_hubbard program~dqmc_verify->module~dqmc_struct program~dqmc_verify->module~dqmc_phy0 module~dqmc_gfun->module~dqmc_matb module~dqmc_gfun->module~dqmc_seqb module~dqmc_gtau->module~dqmc_matb module~dqmc_gtau->module~dqmc_gfun module~dqmc_gtau->module~dqmc_seqb module~dqmc_seqb->module~dqmc_matb Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), public, parameter :: COMMENT = \"#\" character(len=1), public, parameter :: SEPARAT = \"=\" character(len=1), public, parameter :: COMMA = \",\" integer, public, parameter :: slen = 60 integer, public, parameter :: llen = 256 integer, public, parameter :: alen = 10 integer, public, parameter :: STAT_EOF = -1 integer, public, parameter :: STAT_COMMENT = 0 integer, public, parameter :: STAT_NORMAL = 1 character(len=8), public, parameter :: TYPE_STR (3) = (/\"Real*8  \", \"Integer \", \"Char(60)\"/) integer, public, parameter :: TYPE_REAL = 1 integer, public, parameter :: TYPE_INTEGER = 2 integer, public, parameter :: TYPE_STRING = 3 integer, public, parameter :: N_Param = 40 character(len=*), public, parameter :: PARAM_NAME (N_Param) = (/\"HSF    \", \"HSFin  \", \"HSFout \", \"HSFtype\", \"L      \", \"U      \", \"accept \", \"bcond  \", \"debug  \", \"delta1 \", \"delta2 \", \"difflim\", \"dmu    \", \"dtau   \", \"errrate\", \"fixwrap\", \"gamma  \", \"gfile  \", \"mu_dn  \", \"mu_up  \", \"n      \", \"nbin   \", \"nhist  \", \"nitvl  \", \"north  \", \"npass  \", \"ntry   \", \"nwarm  \", \"nwrap  \", \"nx     \", \"ny     \", \"nz     \", \"ofile  \", \"reject \", \"seed   \", \"ssxx   \", \"t_dn   \", \"t_up   \", \"tausk  \", \"tdm    \"/) character(len=*), public, parameter :: PARAM_DVAL (N_Param) = (/\"-1      \", \"HSF.in  \", \"HSF.out \", \"0       \", \"12      \", \"0.0     \", \"0       \", \"0,0,0   \", \"0       \", \"1.0     \", \"1.0     \", \"0.001   \", \"0.0     \", \"0.125   \", \"0.001   \", \"0       \", \"0.0     \", \"geom.def\", \"0.0     \", \"0.0     \", \"16      \", \"10      \", \"0       \", \"4       \", \"12      \", \"5000    \", \"0       \", \"1000    \", \"12      \", \"4       \", \"4       \", \"2       \", \"quest   \", \"0       \", \"0       \", \"0       \", \"1.0     \", \"1.0     \", \"10      \", \"0       \"/) integer, public, parameter :: PARAM_TYPE (N_Param) = (/TYPE_INTEGER, TYPE_STRING, TYPE_STRING, TYPE_INTEGER, TYPE_INTEGER, TYPE_REAL, TYPE_INTEGER, TYPE_REAL, TYPE_INTEGER, TYPE_REAL, TYPE_REAL, TYPE_REAL, TYPE_REAL, TYPE_REAL, TYPE_REAL, TYPE_INTEGER, TYPE_REAL, TYPE_STRING, TYPE_REAL, TYPE_REAL, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_STRING, TYPE_INTEGER, TYPE_INTEGER, TYPE_INTEGER, TYPE_REAL, TYPE_REAL, TYPE_INTEGER, TYPE_INTEGER/) logical, public, parameter :: PARAM_ARRAY (N_Param) = (/.false., .false., .false., .false., .false., .true., .false., .true., .false., .false., .false., .false., .false., .false., .false., .false., .false., .false., .true., .true., .false., .false., .false., .false., .false., .false., .false., .false., .false., .false., .false., .false., .false., .false., .false., .false., .true., .true., .false., .false./) Interfaces public        interface CFG_Set public  subroutine DQMC_Config_SetI (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name integer, intent(in) :: value public  subroutine DQMC_Config_SetR (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name real(kind=wp), intent(in) :: value public  subroutine DQMC_Config_SetS (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name character(len=*), intent(in) :: value public  subroutine DQMC_Config_SetPR (cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name integer, intent(in) :: n real(kind=wp), intent(in) :: value (n) public  subroutine DQMC_Config_SetPI (cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name integer, intent(in) :: n integer, intent(in) :: value (n) public        interface CFG_Get public  subroutine DQMC_Config_GetI (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name integer, intent(out) :: value public  subroutine DQMC_Config_GetR (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name real(kind=wp), intent(out) :: value public  subroutine DQMC_Config_GetS (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name character(len=slen) :: value public  subroutine DQMC_Config_GetPR (cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name integer, intent(out) :: n real(kind=wp), intent(inout), pointer :: value (:) public  subroutine DQMC_Config_GetPI (cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name integer, intent(out) :: n integer, intent(inout), pointer :: value (:) Derived Types type, public :: Param Components Type Visibility Attributes Name Initial integer, public :: id character(len=slen), public :: pname integer, public :: ptype logical, public :: isArray logical, public :: isSet character(len=slen), public :: defaultval type( Param ), public, pointer :: next integer, public :: ival real(kind=wp), public :: rval integer, public, pointer :: iptr (:) real(kind=wp), public, pointer :: rptr (:) type, public :: config Components Type Visibility Attributes Name Initial type( Param ), public, pointer :: record (:) integer, public :: nParam logical, public :: hasDef = .false. Functions public  function DQMC_Find_Param (cfg, pname) result(id) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: pname Return Value integer public  function DQMC_Config_isSet (cfg, name) result(isSet) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name Return Value logical Subroutines public  subroutine DQMC_ReadLn (str, IPT, status) Arguments Type Intent Optional Attributes Name character(len=llen), intent(inout) :: str integer, intent(in) :: IPT integer, intent(inout) :: status public  subroutine DQMC_Default_Def (cfg) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg public  subroutine DQMC_Config_Free (cfg) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg public  subroutine DQMC_Read_Def (cfg, IPT) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg integer, intent(in) :: IPT public  subroutine DQMC_Print_Def (cfg, OPT) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg integer, intent(in) :: OPT public  subroutine DQMC_Read_Config (cfg) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg public  subroutine DQMC_Config_SetI (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name integer, intent(in) :: value public  subroutine DQMC_Config_SetR (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name real(kind=wp), intent(in) :: value public  subroutine DQMC_Config_SetPR (cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name integer, intent(in) :: n real(kind=wp), intent(in) :: value (n) public  subroutine DQMC_Config_SetPI (cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name integer, intent(in) :: n integer, intent(in) :: value (n) public  subroutine DQMC_Config_SetS (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(inout) :: cfg character(len=*), intent(in) :: name character(len=*), intent(in) :: value public  subroutine DQMC_Config_GetI (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name integer, intent(out) :: value public  subroutine DQMC_Config_GetR (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name real(kind=wp), intent(out) :: value public  subroutine DQMC_Config_GetPR (cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name integer, intent(out) :: n real(kind=wp), intent(inout), pointer :: value (:) public  subroutine DQMC_Config_GetPI (cfg, name, n, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name integer, intent(out) :: n integer, intent(inout), pointer :: value (:) public  subroutine DQMC_Config_GetS (cfg, name, value) Arguments Type Intent Optional Attributes Name type( config ), intent(in) :: cfg character(len=*), intent(in) :: name character(len=slen) :: value","tags":"","loc":"module/dqmc_cfg.html"},{"title":"DQMC_KBONDS – Quest","text":"Uses DQMC_RECLATT module~~dqmc_kbonds~~UsesGraph module~dqmc_kbonds DQMC_KBONDS module~dqmc_reclatt DQMC_RECLATT module~dqmc_kbonds->module~dqmc_reclatt module~dqmc_cfg DQMC_Cfg module~dqmc_reclatt->module~dqmc_cfg module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_reclatt->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_reclatt->module~dqmc_latt module~dqmc_util DQMC_Util module~dqmc_cfg->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param module~dqmc_latt->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: kbonds_t Components Type Visibility Attributes Name Initial integer, public :: nak integer, public :: nbonds integer, public :: nmomenta integer, public, pointer :: map_symm_ak (:,:) integer, public, pointer :: map_symm_bak (:,:,:) integer, public, pointer :: class_size (:,:) integer, public, pointer :: myclass (:,:,:) integer, public, pointer :: nclass (:) integer, public, pointer :: bond_origin (:,:) integer, public, pointer :: bond_target (:,:) integer, public, pointer :: bmap (:,:,:) real(kind=wp), public, pointer :: ksum (:,:) Subroutines public  subroutine init_kbonds (symm, lattice, reclatt, kbonds) Arguments Type Intent Optional Attributes Name type( symm_operations ), intent(in) :: symm type( lattice_t ), intent(in) :: lattice type( recip_lattice_t ), intent(in) :: reclatt type( kbonds_t ), intent(inout) :: kbonds public  subroutine construct_kbonds (reclatt, kbonds) Arguments Type Intent Optional Attributes Name type( recip_lattice_t ), intent(in) :: reclatt type( kbonds_t ), intent(inout) :: kbonds public  subroutine map_symm_kbond (kbonds) Arguments Type Intent Optional Attributes Name type( kbonds_t ), intent(inout) :: kbonds public  subroutine construct_kbond_classes (kbonds) Arguments Type Intent Optional Attributes Name type( kbonds_t ), intent(inout) :: kbonds","tags":"","loc":"module/dqmc_kbonds.html"},{"title":"DQMC_TDM2 – Quest","text":"Uses DQMC_Phy2 DQMC_Util DQMC_STRUCT DQMC_TDM1 module~~dqmc_tdm2~~UsesGraph module~dqmc_tdm2 DQMC_TDM2 module~dqmc_phy2 DQMC_Phy2 module~dqmc_tdm2->module~dqmc_phy2 module~dqmc_struct DQMC_STRUCT module~dqmc_tdm2->module~dqmc_struct module~dqmc_tdm1 DQMC_TDM1 module~dqmc_tdm2->module~dqmc_tdm1 module~dqmc_util DQMC_Util module~dqmc_tdm2->module~dqmc_util module~dqmc_phy2->module~dqmc_struct module~dqmc_phy2->module~dqmc_util module~dqmc_bonds DQMC_BONDS module~dqmc_phy2->module~dqmc_bonds module~dqmc_symm DQMC_SYMM module~dqmc_phy2->module~dqmc_symm module~dqmc_wspace DQMC_WSpace module~dqmc_phy2->module~dqmc_wspace module~dqmc_struct->module~dqmc_util module~dqmc_cfg DQMC_Cfg module~dqmc_struct->module~dqmc_cfg module~dqmc_tdm1->module~dqmc_struct module~dqmc_tdm1->module~dqmc_util module~dqmc_gtau DQMC_GTAU module~dqmc_tdm1->module~dqmc_gtau module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_cfg->module~dqmc_util module~dqmc_gtau->module~dqmc_util module~dqmc_gtau->module~dqmc_wspace module~dqmc_gfun DQMC_GFun module~dqmc_gtau->module~dqmc_gfun module~dqmc_matb DQMC_MATB module~dqmc_gtau->module~dqmc_matb module~dqmc_seqb DQMC_SEQB module~dqmc_gtau->module~dqmc_seqb module~dqmc_symm->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_wspace->module~dqmc_util module~dqmc_gfun->module~dqmc_util module~dqmc_gfun->module~dqmc_wspace module~dqmc_gfun->module~dqmc_matb module~dqmc_gfun->module~dqmc_seqb module~dqmc_latt->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param module~dqmc_matb->module~dqmc_struct module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_wspace module~dqmc_seqb->module~dqmc_util module~dqmc_seqb->module~dqmc_wspace module~dqmc_seqb->module~dqmc_matb Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: TDM2 Components Type Visibility Attributes Name Initial real(kind=wp), public, pointer :: Pair (:,:,:) real(kind=wp), public, pointer :: Apair (:,:,:) real(kind=wp), public, pointer :: Bpair (:,:,:) real(kind=wp), public, pointer :: Npair (:,:,:) integer, public :: n integer, public :: nClass integer, public :: nB integer, public :: nWave integer, public :: L integer, public :: itvl real(kind=wp), public :: dtau type( CCS ), public, pointer :: Bond integer, public, pointer :: D (:,:,:) integer, public, pointer :: SD (:,:) real(kind=wp), public, pointer :: Wave (:,:) real(kind=wp), public, pointer :: T (:,:) integer, public :: ldt character(len=label_len), public, pointer :: label (:) Subroutines public  subroutine DQMC_TDM2_Init (n, L, nBin, T2, S, T) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: L integer, intent(in) :: nBin type( TDM2 ), intent(inout) :: T2 type( Struct ), intent(in), target :: S real(kind=wp), intent(in), target :: T (:,:) public  subroutine DQMC_TDM2_Free (T2) Arguments Type Intent Optional Attributes Name type( TDM2 ), intent(inout) :: T2 public  subroutine DQMC_TDM2_Meas (T2, upt0, up0t, dnt0, dn0t, ti) Arguments Type Intent Optional Attributes Name type( TDM2 ), intent(inout) :: T2 real(kind=wp), intent(in) :: upt0 (:,:) real(kind=wp), intent(in) :: up0t (:,:) real(kind=wp), intent(in) :: dnt0 (:,:) real(kind=wp), intent(in) :: dn0t (:,:) integer, intent(in) :: ti public  subroutine DQMC_TDM2_Acc (T2, sgn) Arguments Type Intent Optional Attributes Name type( TDM2 ), intent(inout) :: T2 real(kind=wp), intent(in) :: sgn public  subroutine DQMC_TDM2_Avg (T2, gnl, idx, factor) Arguments Type Intent Optional Attributes Name type( TDM2 ), intent(inout) :: T2 real(kind=wp), intent(in) :: gnl (:,:) integer, intent(in) :: idx real(kind=wp), intent(in) :: factor","tags":"","loc":"module/dqmc_tdm2.html"},{"title":"DQMC_Hubbard – Quest","text":"Uses DQMC_Phy2 DQMC_STRUCT DQMC_SEQB DQMC_Util DQMC_Phy0 DQMC_MATB DQMC_Cfg DQMC_GFun module~~dqmc_hubbard~~UsesGraph module~dqmc_hubbard DQMC_Hubbard module~dqmc_cfg DQMC_Cfg module~dqmc_hubbard->module~dqmc_cfg module~dqmc_gfun DQMC_GFun module~dqmc_hubbard->module~dqmc_gfun module~dqmc_matb DQMC_MATB module~dqmc_hubbard->module~dqmc_matb module~dqmc_phy0 DQMC_Phy0 module~dqmc_hubbard->module~dqmc_phy0 module~dqmc_phy2 DQMC_Phy2 module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_seqb DQMC_SEQB module~dqmc_hubbard->module~dqmc_seqb module~dqmc_struct DQMC_STRUCT module~dqmc_hubbard->module~dqmc_struct module~dqmc_util DQMC_Util module~dqmc_hubbard->module~dqmc_util module~dqmc_cfg->module~dqmc_util module~dqmc_gfun->module~dqmc_matb module~dqmc_gfun->module~dqmc_seqb module~dqmc_gfun->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_gfun->module~dqmc_wspace module~dqmc_matb->module~dqmc_struct module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_wspace module~dqmc_phy0->module~dqmc_struct module~dqmc_phy0->module~dqmc_util module~dqmc_phy0->module~dqmc_wspace module~dqmc_phy2->module~dqmc_struct module~dqmc_phy2->module~dqmc_util module~dqmc_bonds DQMC_BONDS module~dqmc_phy2->module~dqmc_bonds module~dqmc_symm DQMC_SYMM module~dqmc_phy2->module~dqmc_symm module~dqmc_phy2->module~dqmc_wspace module~dqmc_seqb->module~dqmc_matb module~dqmc_seqb->module~dqmc_util module~dqmc_seqb->module~dqmc_wspace module~dqmc_struct->module~dqmc_cfg module~dqmc_struct->module~dqmc_util module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_symm->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_wspace->module~dqmc_util module~dqmc_latt->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_hubbard~~UsedByGraph module~dqmc_hubbard DQMC_Hubbard module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_hubbard proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_hubbard program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_hubbard program~dqmc_verify->module~dqmc_2dperl program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: NO_MEAS0 = -1 integer, public, parameter :: HSF_OUTPUT_UNIT = 28 integer, public, parameter :: HSF_INPUT_UNIT = 27 integer, public, parameter :: HSF_RANDOM_GEN = -1 integer, public, parameter :: HSF_FROM_FILE = 1 integer, public, parameter :: HSF_RESTORE = 2 integer, public, parameter :: HSF_FROM_MEMORY = 0 integer, public, parameter :: HSF_DISC = 0 integer, public, parameter :: HSF_CONT = 1 Derived Types type, public :: Hubbard Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: L integer, public :: n_U real(kind=wp), public, pointer :: U (:) integer, public :: n_t real(kind=wp), public, pointer :: t_up (:) real(kind=wp), public, pointer :: t_dn (:) integer, public :: n_mu real(kind=wp), public, pointer :: mu_up (:) real(kind=wp), public, pointer :: mu_dn (:) real(kind=wp), public :: dtau integer, public, pointer :: HSF (:,:) real(kind=wp), public, pointer :: CHSF (:,:) integer, public :: HSFtype logical, public :: outputHSF logical, public :: continuous real(kind=wp), public :: delta1 real(kind=wp), public :: delta2 real(kind=wp), public, pointer :: lambda (:) integer, public :: n_start integer, public :: n_end type( Struct ), public :: S type( matB ), public :: B_up type( SeqB ), public :: SB_up type( matB ), public :: B_dn type( SeqB ), public :: SB_dn type( G_fun ), public :: G_up type( G_fun ), public :: G_dn real(kind=wp), public, pointer :: V_up (:,:) real(kind=wp), public, pointer :: V_dn (:,:) integer, public :: idum integer, public :: seed (4) real(kind=wp), public, pointer :: explook (:,:) logical, public :: comp_dn logical, public :: neg_u integer, public :: nWarm integer, public :: nPass integer, public :: nTry real(kind=wp), public :: gamma integer, public :: nAccept integer, public :: nReject integer, public :: nAcceptGlobal integer, public :: nRejectGlobal type( Phy0 ), public :: P0 type( Phy2 ), public :: P2 integer, public :: nMeas integer, public :: tausk logical, public :: meas2 type( WSpace ), public :: WS integer, public :: OUT_UNIT Subroutines public  subroutine DQMC_Hub_Config (Hub, cfg) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub type( config ), intent(inout) :: cfg public  subroutine DQMC_Hub_Init (Hub, U, t_up, t_dn, mu_up, mu_dn, L, n_t, n_U, n_mu, dtau, HSF_IPT, nWarm, nPass, nMeas, nTry, nBin, ntausk, seed, nOrth, nWrap, fixw, errrate, difflim, gamma, accept, reject, delta1, delta2, ssxx, HSFtype) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub real(kind=wp), intent(in) :: U (:) real(kind=wp), intent(in) :: t_up (:) real(kind=wp), intent(in) :: t_dn (:) real(kind=wp), intent(in) :: mu_up (:) real(kind=wp), intent(in) :: mu_dn (:) integer, intent(in) :: L integer, intent(in) :: n_t integer, intent(in) :: n_U integer, intent(in) :: n_mu real(kind=wp), intent(in) :: dtau integer, intent(in) :: HSF_IPT integer, intent(in) :: nWarm integer, intent(in) :: nPass integer, intent(in) :: nMeas integer, intent(in) :: nTry integer, intent(in) :: nBin integer, intent(in) :: ntausk integer, intent(in) :: seed integer, intent(in) :: nOrth integer, intent(in) :: nWrap integer, intent(in) :: fixw real(kind=wp), intent(in) :: errrate real(kind=wp), intent(in) :: difflim real(kind=wp), intent(in) :: gamma integer, intent(in) :: accept integer, intent(in) :: reject real(kind=wp), intent(in) :: delta1 real(kind=wp), intent(in) :: delta2 integer, intent(in) :: ssxx integer, intent(in) :: HSFtype public  subroutine DQMC_Hub_Free (Hub) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub public  subroutine DQMC_Hub_Output_HSF (Hub, restore, slice, OPT) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in) :: Hub logical, intent(in) :: restore integer, intent(in) :: slice integer, intent(in) :: OPT public  subroutine DQMC_Hub_Input_HSF (Hub, restore, slice, IPT) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub logical, intent(in) :: restore integer, intent(out) :: slice integer, intent(in) :: IPT public  subroutine DQMC_Hub_OutputParam (Hub, OPT) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in) :: Hub integer, intent(in) :: OPT public  subroutine DQMC_Hub_Print (Hub, OPT) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in) :: Hub integer, intent(in) :: OPT public  subroutine DQMC_Hub_Sweep (Hub, nMeas0) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout), target :: Hub integer, intent(in) :: nMeas0 public  subroutine DQMC_Hub_Sweep2 (Hub, numTry) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: numTry public  subroutine DQMC_Hub_Sweep_Cont (Hub, nMeas0) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout), target :: Hub integer, intent(in) :: nMeas0 public  subroutine DQMC_Hub_Sweep2_Cont (Hub, numTry) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: numTry public  subroutine DQMC_Hub_Run (Hub, Info) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer :: Info public  subroutine DQMC_Hub_FullMeas (Hub, nnb, A_up, A_dn, sgn_up, sgn_dn) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: nnb real(kind=wp), intent(in) :: A_up (nnb,nnb) real(kind=wp), intent(in) :: A_dn (nnb,nnb) real(kind=wp), intent(in) :: sgn_up real(kind=wp), intent(in) :: sgn_dn public  subroutine DQMC_Hub_Meas (Hub, slice) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(inout) :: slice public  subroutine DQMC_Hub_Init_Vmat (Hub) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub","tags":"","loc":"module/dqmc_hubbard.html"},{"title":"DQMC_RECLATT – Quest","text":"Uses DQMC_GEOM_PARAM DQMC_LATT DQMC_Cfg module~~dqmc_reclatt~~UsesGraph module~dqmc_reclatt DQMC_RECLATT module~dqmc_cfg DQMC_Cfg module~dqmc_reclatt->module~dqmc_cfg module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_reclatt->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_reclatt->module~dqmc_latt module~dqmc_util DQMC_Util module~dqmc_cfg->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param module~dqmc_latt->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_reclatt~~UsedByGraph module~dqmc_reclatt DQMC_RECLATT module~dqmc_geom_wrap DQMC_GEOM_WRAP module~dqmc_geom_wrap->module~dqmc_reclatt module~dqmc_hamilt DQMC_HAMILT module~dqmc_geom_wrap->module~dqmc_hamilt module~dqmc_hamilt->module~dqmc_reclatt module~dqmc_kbonds DQMC_KBONDS module~dqmc_kbonds->module~dqmc_reclatt proc~construct_recip_lattice_classes DQMC_SYMM::construct_recip_lattice_classes proc~construct_recip_lattice_classes->module~dqmc_reclatt proc~map_symm_recip_lattice DQMC_SYMM::map_symm_recip_lattice proc~map_symm_recip_lattice->module~dqmc_reclatt proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_init->module~dqmc_geom_wrap proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_initprop->module~dqmc_geom_wrap proc~map_symm_lattice DQMC_SYMM::map_symm_lattice proc~map_symm_lattice->module~dqmc_hamilt program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_geom_wrap Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: recip_lattice_t Components Type Visibility Attributes Name Initial integer, public :: ndim integer, public :: nkpts real(kind=8), public, pointer :: klist (:,:) real(kind=8), public :: kpoint (rdim) real(kind=8), public :: ktwist (rdim) real(kind=8), public :: kcs (rdim,rdim) real(kind=8), public :: ks (rdim,rdim) real(kind=8), public :: kc (rdim,rdim) ** rows of these matrices are the vectors integer, public :: nmomenta real(kind=8), public, pointer :: ksum (:,:) integer, public, pointer :: kmate (:,:) integer, public :: nclass_k integer, public, pointer :: myclass_k (:) integer, public, pointer :: class_size_k (:) integer, public, pointer :: class_repr_k (:) complex(kind=16), public, pointer :: FourierC (:,:) logical, public :: initialized logical, public :: constructed logical, public :: analyzed Functions public  function closer_to_zero (ktp, kset, on_edge, ndim) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: ktp (rdim) real(kind=8), intent(in) :: kset (3**ndim-1,rdim) logical :: on_edge integer, intent(in) :: ndim Return Value logical Subroutines public  subroutine free_reclatt (reclatt) Arguments Type Intent Optional Attributes Name type( recip_lattice_t ), intent(inout) :: reclatt public  subroutine init_recip_latt (lattice, recip_lattice, applytwist, cfg) Arguments Type Intent Optional Attributes Name type( lattice_t ), intent(in), target :: lattice type( recip_lattice_t ), intent(out), target :: recip_lattice logical, intent(in) :: applytwist type( config ), intent(in), target :: cfg public  subroutine construct_recip_lattice (recip_lattice) Arguments Type Intent Optional Attributes Name type( recip_lattice_t ), intent(inout) :: recip_lattice public  subroutine DQMC_init_kmate (reclatt, nmom, ksum) Arguments Type Intent Optional Attributes Name type( recip_lattice_t ), intent(inout) :: reclatt integer, intent(in) :: nmom real(kind=wp), intent(in) :: ksum (nmom,rdim) public  subroutine DQMC_Fill_FourierC (Reciplattice, lattice) Arguments Type Intent Optional Attributes Name type( recip_lattice_t ), intent(inout), target :: Reciplattice type( lattice_t ), intent(in), target :: lattice","tags":"","loc":"module/dqmc_reclatt.html"},{"title":"DQMC_MATB – Quest","text":"Uses DQMC_Util DQMC_STRUCT DQMC_WSpace module~~dqmc_matb~~UsesGraph module~dqmc_matb DQMC_MATB module~dqmc_struct DQMC_STRUCT module~dqmc_matb->module~dqmc_struct module~dqmc_util DQMC_Util module~dqmc_matb->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_matb->module~dqmc_wspace module~dqmc_struct->module~dqmc_util module~dqmc_cfg DQMC_Cfg module~dqmc_struct->module~dqmc_cfg module~dqmc_wspace->module~dqmc_util module~dqmc_cfg->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_matb~~UsedByGraph module~dqmc_matb DQMC_MATB module~dqmc_gfun DQMC_GFun module~dqmc_gfun->module~dqmc_matb module~dqmc_seqb DQMC_SEQB module~dqmc_gfun->module~dqmc_seqb module~dqmc_gtau DQMC_GTAU module~dqmc_gtau->module~dqmc_matb module~dqmc_gtau->module~dqmc_gfun module~dqmc_gtau->module~dqmc_seqb module~dqmc_hubbard DQMC_Hubbard module~dqmc_hubbard->module~dqmc_matb module~dqmc_hubbard->module~dqmc_gfun module~dqmc_hubbard->module~dqmc_seqb module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_matb module~dqmc_hubbard~2->module~dqmc_gfun module~dqmc_hubbard~2->module~dqmc_seqb module~dqmc_seqb->module~dqmc_matb module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_hubbard module~dqmc_tdm1 DQMC_TDM1 module~dqmc_tdm1->module~dqmc_gtau proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_hubbard program~dqmc_ggeom->module~dqmc_tdm1 program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_hubbard program~dqmc_verify->module~dqmc_2dperl module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_tdm1 program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: matB Components Type Visibility Attributes Name Initial integer, public :: n real(kind=wp), public, pointer :: K (:,:) real(kind=wp), public, pointer :: B (:,:) real(kind=wp), public, pointer :: Bi (:,:) real(kind=wp), public, pointer :: rtB (:,:) real(kind=wp), public, pointer :: rtBi (:,:) character(len=12), public :: name logical, public :: exactb Subroutines public  subroutine DQMC_B_Init (n, B, WS, adj, ckb, t, mu, dtau) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n type( matB ), intent(inout) :: B type( WSpace ), intent(inout), target :: WS type( CCS ), intent(in) :: adj type( CCS ), intent(out) :: ckb real(kind=wp), intent(in) :: t (:) real(kind=wp), intent(in) :: mu (n) real(kind=wp), intent(in) :: dtau public  subroutine DQMC_B_ExpInit (B, K, WS) Check error message\nScale the right eigenmatrix\nScale the right eigenmatrix\nScale the right eigenmatrix Arguments Type Intent Optional Attributes Name type( matB ), intent(inout) :: B real(kind=wp), intent(inout) :: K (:,:) type( WSpace ), intent(inout), target :: WS public  subroutine DQMC_B_Free (B) Arguments Type Intent Optional Attributes Name type( matB ), intent(inout) :: B public  subroutine DQMC_MultB_Left (n, M, B, V_i, C) Check error message Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) public  subroutine DQMC_MultBi_Left (n, M, B, V_i, C) Check error message Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) public  subroutine DQMC_MultB_Right (n, M, B, V_i, C) Check error message Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) public  subroutine DQMC_MultBi_Right (n, M, B, V_i, C) Check error message Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) public  subroutine DQMC_MultrtB0_Left (n, M, B, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(inout) :: C (n,n) public  subroutine DQMC_MultrtB0i_Right (n, M, B, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(inout) :: C (n,n) public  subroutine DQMC_GetB (n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) public  subroutine DQMC_GetBi (n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n)","tags":"","loc":"module/dqmc_matb.html"},{"title":"DQMC_SYMM – Quest","text":"Uses DQMC_Util DQMC_GEOM_PARAM module~~dqmc_symm~~UsesGraph module~dqmc_symm DQMC_SYMM module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_symm->module~dqmc_geom_param module~dqmc_util DQMC_Util module~dqmc_symm->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_symm~~UsedByGraph module~dqmc_symm DQMC_SYMM module~dqmc_geom_wrap DQMC_GEOM_WRAP module~dqmc_geom_wrap->module~dqmc_symm module~dqmc_phy2 DQMC_Phy2 module~dqmc_phy2->module~dqmc_symm proc~init_kbonds DQMC_KBONDS::init_kbonds proc~init_kbonds->module~dqmc_symm module~dqmc_hubbard DQMC_Hubbard module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_phy2 module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_phy2 proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_init->module~dqmc_geom_wrap proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_initprop->module~dqmc_geom_wrap program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_geom_wrap program~dqmc_ggeom->module~dqmc_hubbard module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_hubbard proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_hubbard program~dqmc_verify->module~dqmc_2dperl program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: symm_operations Components Type Visibility Attributes Name Initial integer, public :: ntotsymm integer, public :: nsymm integer, public :: ntransl integer, public, pointer :: map_symm (:,:) integer, public, pointer :: map_symm_k (:,:) integer, public, pointer :: map_symm_g (:,:) integer, public, pointer :: map_symm_b (:,:) integer, public, pointer :: map_symm_p (:,:) integer, public, pointer :: translback (:) integer, public, pointer :: translate (:,:) integer, public, pointer :: valid_symm (:) real(kind=8), public, pointer :: symmangle (:) real(kind=8), public, pointer :: symmpoint (:,:) real(kind=8), public, pointer :: symmaxis (:,:) character(len=1), public, pointer :: symmlabel (:) logical, public :: initialized logical, public :: lattice_mapped logical, public :: recip_lattice_mapped logical, public :: bonds_mapped logical, public :: addTimeRev Functions public  function count_symmetry () Arguments None Return Value integer Subroutines public  subroutine free_symm (symm) Arguments Type Intent Optional Attributes Name type( symm_operations ), intent(inout) :: symm public  subroutine read_symm (SymmOp) Arguments Type Intent Optional Attributes Name type( symm_operations ), intent(out) :: SymmOp public  subroutine apply_point_symm (label, point, axis, theta, set, new_set, nset, reciprocal) Arguments Type Intent Optional Attributes Name character(len=1) :: label real(kind=8), intent(in) :: point (3) real(kind=8), intent(in) :: axis (3) real(kind=8), intent(in) :: theta real(kind=8), intent(in) :: set (3*nset) real(kind=8), intent(out) :: new_set (3,nset) integer, intent(in) :: nset logical, intent(in) :: reciprocal public  subroutine map_symm_lattice (SymmOp, lattice, hamilt, SOP) Arguments Type Intent Optional Attributes Name type( symm_operations ) :: SymmOp type( lattice_t ), intent(in) :: lattice type( Hamiltonian_t ), intent(in) :: hamilt integer, intent(in) :: SOP public  subroutine map_symm_recip_lattice (SymmOp, recip_lattice, applytwist) Arguments Type Intent Optional Attributes Name type( symm_operations ) :: SymmOp type( recip_lattice_t ), intent(in) :: recip_lattice logical, intent(in) :: applytwist public  subroutine map_symm_bonds (Bonds, SymmOp, Lattice) Arguments Type Intent Optional Attributes Name type( bonds_t ), intent(inout) :: Bonds type( symm_operations ), intent(inout) :: SymmOp type( lattice_t ), intent(in) :: Lattice public  subroutine map_symm_pairs (Pairs, SymmOp) Arguments Type Intent Optional Attributes Name type( pairing ), intent(inout) :: Pairs type( symm_operations ), intent(inout) :: SymmOp public  subroutine construct_lattice_classes (SymmOp, lattice) Arguments Type Intent Optional Attributes Name type( symm_operations ) :: SymmOp type( lattice_t ) :: lattice public  subroutine construct_recip_lattice_classes (SymmOp, recip_lattice, applytwist) Arguments Type Intent Optional Attributes Name type( symm_operations ) :: SymmOp type( recip_lattice_t ) :: recip_lattice logical, intent(in) :: applytwist public  subroutine construct_bond_classes (Bonds, SymmOp) Arguments Type Intent Optional Attributes Name type( bonds_t ), intent(inout) :: Bonds type( symm_operations ), intent(in) :: SymmOp public  subroutine construct_pair_classes (Bonds, Pairs) Arguments Type Intent Optional Attributes Name type( bonds_t ), intent(in) :: Bonds type( pairing ), intent(inout) :: Pairs","tags":"","loc":"module/dqmc_symm.html"},{"title":"DQMC_Hubbard – Quest","text":"Uses DQMC_Phy2 DQMC_STRUCT DQMC_SEQB DQMC_Util DQMC_Phy0 DQMC_MATB DQMC_Cfg DQMC_GFun module~~dqmc_hubbard~2~~UsesGraph module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_cfg DQMC_Cfg module~dqmc_hubbard~2->module~dqmc_cfg module~dqmc_gfun DQMC_GFun module~dqmc_hubbard~2->module~dqmc_gfun module~dqmc_matb DQMC_MATB module~dqmc_hubbard~2->module~dqmc_matb module~dqmc_phy0 DQMC_Phy0 module~dqmc_hubbard~2->module~dqmc_phy0 module~dqmc_phy2 DQMC_Phy2 module~dqmc_hubbard~2->module~dqmc_phy2 module~dqmc_seqb DQMC_SEQB module~dqmc_hubbard~2->module~dqmc_seqb module~dqmc_struct DQMC_STRUCT module~dqmc_hubbard~2->module~dqmc_struct module~dqmc_util DQMC_Util module~dqmc_hubbard~2->module~dqmc_util module~dqmc_cfg->module~dqmc_util module~dqmc_gfun->module~dqmc_matb module~dqmc_gfun->module~dqmc_seqb module~dqmc_gfun->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_gfun->module~dqmc_wspace module~dqmc_matb->module~dqmc_struct module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_wspace module~dqmc_phy0->module~dqmc_struct module~dqmc_phy0->module~dqmc_util module~dqmc_phy0->module~dqmc_wspace module~dqmc_phy2->module~dqmc_struct module~dqmc_phy2->module~dqmc_util module~dqmc_bonds DQMC_BONDS module~dqmc_phy2->module~dqmc_bonds module~dqmc_symm DQMC_SYMM module~dqmc_phy2->module~dqmc_symm module~dqmc_phy2->module~dqmc_wspace module~dqmc_seqb->module~dqmc_matb module~dqmc_seqb->module~dqmc_util module~dqmc_seqb->module~dqmc_wspace module~dqmc_struct->module~dqmc_cfg module~dqmc_struct->module~dqmc_util module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_symm->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_wspace->module~dqmc_util module~dqmc_latt->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: NO_MEAS0 = -1 integer, public, parameter :: HSF_OUTPUT_UNIT = 28 integer, public, parameter :: HSF_INPUT_UNIT = 27 integer, public, parameter :: HSF_RANDOM_GEN = -1 integer, public, parameter :: HSF_FROM_FILE = 1 integer, public, parameter :: HSF_RESTORE = 2 integer, public, parameter :: HSF_FROM_MEMORY = 0 integer, public, parameter :: HSF_DISC = 0 integer, public, parameter :: HSF_CONT = 1 integer, public :: SimType real(kind=wp), public :: CHSF0 real(kind=wp), public :: norm_phonon (2) Derived Types type, public :: Hubbard Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: L integer, public :: n_U real(kind=wp), public, pointer :: U (:) integer, public :: n_t real(kind=wp), public, pointer :: t_up (:) real(kind=wp), public, pointer :: t_dn (:) integer, public :: n_mu real(kind=wp), public, pointer :: mu_up (:) real(kind=wp), public, pointer :: mu_dn (:) real(kind=wp), public :: dtau integer, public, pointer :: HSF (:,:) real(kind=wp), public, pointer :: CHSF (:,:) integer, public :: HSFtype logical, public :: outputHSF logical, public :: continuous real(kind=wp), public :: delta1 real(kind=wp), public :: delta2 real(kind=wp), public, pointer :: lambda (:) integer, public :: n_start integer, public :: n_end real(kind=wp), public :: omega type( Struct ), public :: S type( matB ), public :: B_up type( SeqB ), public :: SB_up type( matB ), public :: B_dn type( SeqB ), public :: SB_dn type( G_fun ), public :: G_up type( G_fun ), public :: G_dn real(kind=wp), public, pointer :: V_up (:,:) real(kind=wp), public, pointer :: V_dn (:,:) integer, public :: idum integer, public :: seed (4) real(kind=wp), public, pointer :: explook (:,:) logical, public :: comp_dn logical, public :: neg_u integer, public :: nWarm integer, public :: nPass integer, public :: nTry real(kind=wp), public :: gamma integer, public :: nAccept integer, public :: nReject integer, public :: nAcceptGlobal integer, public :: nRejectGlobal integer, public :: nAcceptGlobal2 integer, public :: nRejectGlobal2 type( Phy0 ), public :: P0 type( Phy2 ), public :: P2 integer, public :: nMeas integer, public :: tausk logical, public :: meas2 type( WSpace ), public :: WS integer, public :: OUT_UNIT Subroutines public  subroutine DQMC_Hub_Config (Hub, cfg) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub type( config ), intent(inout) :: cfg public  subroutine DQMC_Hub_Init (Hub, U, t_up, t_dn, mu_up, mu_dn, L, n_t, n_U, n_mu, dtau, HSF_IPT, nWarm, nPass, nMeas, nTry, nBin, ntausk, seed, nOrth, nWrap, fixw, errrate, difflim, gamma, accept, reject, delta1, delta2, ssxx, HSFtype, omega) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub real(kind=wp), intent(in) :: U (:) real(kind=wp), intent(in) :: t_up (:) real(kind=wp), intent(in) :: t_dn (:) real(kind=wp), intent(in) :: mu_up (:) real(kind=wp), intent(in) :: mu_dn (:) integer, intent(in) :: L integer, intent(in) :: n_t integer, intent(in) :: n_U integer, intent(in) :: n_mu real(kind=wp), intent(in) :: dtau integer, intent(in) :: HSF_IPT integer, intent(in) :: nWarm integer, intent(in) :: nPass integer, intent(in) :: nMeas integer, intent(in) :: nTry integer, intent(in) :: nBin integer, intent(in) :: ntausk integer, intent(in) :: seed integer, intent(in) :: nOrth integer, intent(in) :: nWrap integer, intent(in) :: fixw real(kind=wp), intent(in) :: errrate real(kind=wp), intent(in) :: difflim real(kind=wp), intent(in) :: gamma integer, intent(in) :: accept integer, intent(in) :: reject real(kind=wp), intent(in) :: delta1 real(kind=wp), intent(in) :: delta2 integer, intent(in) :: ssxx integer, intent(in) :: HSFtype real(kind=wp), intent(in) :: omega public  subroutine DQMC_Hub_Free (Hub) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub public  subroutine DQMC_Hub_Output_HSF (Hub, restore, slice, OPT) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in) :: Hub logical, intent(in) :: restore integer, intent(in) :: slice integer, intent(in) :: OPT public  subroutine DQMC_Hub_Input_HSF (Hub, restore, slice, IPT) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub logical, intent(in) :: restore integer, intent(out) :: slice integer, intent(in) :: IPT public  subroutine DQMC_Hub_OutputParam (Hub, OPT) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in) :: Hub integer, intent(in) :: OPT public  subroutine DQMC_Hub_Print (Hub, OPT) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in) :: Hub integer, intent(in) :: OPT public  subroutine DQMC_Hub_Sweep (Hub, nMeas0) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout), target :: Hub integer, intent(in) :: nMeas0 public  subroutine DQMC_Hub_Sweep2 (Hub, numTry) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: numTry public  subroutine DQMC_Hub_Sweep_Cont (Hub, nMeas0) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout), target :: Hub integer, intent(in) :: nMeas0 public  subroutine DQMC_Hub_Sweep2_Cont (Hub, numTry) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: numTry public  subroutine DQMC_Hol_Sweep3_Cont (Hub, numTry) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: numTry public  subroutine DQMC_Hub_Run (Hub, Info) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer :: Info public  subroutine DQMC_Hub_FullMeas (Hub, nnb, A_up, A_dn, sgn_up, sgn_dn) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(in) :: nnb real(kind=wp), intent(in) :: A_up (nnb,nnb) real(kind=wp), intent(in) :: A_dn (nnb,nnb) real(kind=wp), intent(in) :: sgn_up real(kind=wp), intent(in) :: sgn_dn public  subroutine DQMC_Hub_Meas (Hub, slice) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub integer, intent(inout) :: slice public  subroutine DQMC_Hub_Init_Vmat (Hub) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(inout) :: Hub","tags":"","loc":"module/dqmc_hubbard~2.html"},{"title":"DQMC_CheckerBoard – Quest","text":"Uses DQMC_Util DQMC_WSpace module~~dqmc_checkerboard~~UsesGraph module~dqmc_checkerboard DQMC_CheckerBoard module~dqmc_util DQMC_Util module~dqmc_checkerboard->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_checkerboard->module~dqmc_wspace module~dqmc_wspace->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: matB Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: m integer, public, pointer :: A (:,:) real(kind=wp), public, pointer :: sinht (:) real(kind=wp), public, pointer :: cosht (:) real(kind=wp), public, pointer :: exptaumu (:) real(kind=wp), public, pointer :: work (:) character(len=12), public :: name logical, public :: exactb Subroutines public  subroutine DQMC_B_Init (n, B, WS, adj, ckb, t, mu, dtau) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n type( matB ), intent(out) :: B type( WSpace ), intent(in), target :: WS type( CCS ), intent(in) :: adj type( CCS ), intent(in) :: ckb real(kind=wp), intent(in) :: t (*) real(kind=wp), intent(in) :: mu (n) real(kind=wp), intent(in) :: dtau public  subroutine DQMC_B_Free (B) Arguments Type Intent Optional Attributes Name type( matB ), intent(inout) :: B public  subroutine DQMC_MultB_Left (n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout), target :: M (n,n) type( matB ), intent(inout) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout), target :: C (n,n) public  subroutine DQMC_MultB_Right (n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout), target :: M (n,n) type( matB ), intent(inout) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout), target :: C (n,n) public  subroutine DQMC_MultBi_Left (n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout), target :: M (n,n) type( matB ), intent(inout) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout), target :: C (n,n) public  subroutine DQMC_MultBi_Right (n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout), target :: M (n,n) type( matB ), intent(inout) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout), target :: C (n,n) public  subroutine DQMC_MultrtB0_Left (n, M, B, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(inout) :: C (n,n) public  subroutine DQMC_MultrtB0i_Right (n, M, B, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(in) :: B real(kind=wp), intent(inout) :: C (n,n) public  subroutine DQMC_GetB (n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(inout) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n) public  subroutine DQMC_GetBi (n, M, B, V_i, C) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (n,n) type( matB ), intent(inout) :: B real(kind=wp), intent(in) :: V_i (n) real(kind=wp), intent(inout) :: C (n,n)","tags":"","loc":"module/dqmc_checkerboard.html"},{"title":"DQMC_MPI – Quest","text":"Used by module~~dqmc_mpi~~UsedByGraph module~dqmc_mpi DQMC_MPI module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_mpi proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config->module~dqmc_mpi proc~dqmc_hub_config~2 DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_hub_config~2->module~dqmc_mpi proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init->module~dqmc_mpi proc~dqmc_hub_init~2 DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_init~2->module~dqmc_mpi proc~dqmc_hub_input_hsf DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_input_hsf->module~dqmc_mpi proc~dqmc_hub_input_hsf~2 DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_input_hsf~2->module~dqmc_mpi proc~dqmc_hub_output_hsf DQMC_Hubbard::DQMC_Hub_Output_HSF proc~dqmc_hub_output_hsf->module~dqmc_mpi proc~dqmc_hub_output_hsf~2 DQMC_Hubbard::DQMC_Hub_Output_HSF proc~dqmc_hub_output_hsf~2->module~dqmc_mpi proc~dqmc_hub_outputparam DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_outputparam->module~dqmc_mpi proc~dqmc_hub_outputparam~2 DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_outputparam~2->module~dqmc_mpi proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep->module~dqmc_mpi proc~dqmc_hub_sweep~2 DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_sweep~2->module~dqmc_mpi proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_phy0_geterr->module~dqmc_mpi proc~dqmc_phy0_geterrft DQMC_Phy0::DQMC_Phy0_GetErrFT proc~dqmc_phy0_geterrft->module~dqmc_mpi proc~dqmc_phy0_print DQMC_Phy0::DQMC_Phy0_Print proc~dqmc_phy0_print->module~dqmc_mpi proc~dqmc_phy0_printft DQMC_Phy0::DQMC_Phy0_PrintFT proc~dqmc_phy0_printft->module~dqmc_mpi proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_phy2_geterr->module~dqmc_mpi proc~dqmc_phy2_geterrirrep DQMC_Phy2::DQMC_Phy2_GetErrIrrep proc~dqmc_phy2_geterrirrep->module~dqmc_mpi proc~dqmc_phy2_print DQMC_Phy2::DQMC_Phy2_Print proc~dqmc_phy2_print->module~dqmc_mpi proc~dqmc_phy2_printsymm DQMC_Phy2::dqmc_phy2_PrintSymm proc~dqmc_phy2_printsymm->module~dqmc_mpi proc~dqmc_print_headerft DQMC_GEOM_WRAP::DQMC_Print_HeaderFT proc~dqmc_print_headerft->module~dqmc_mpi proc~dqmc_tdm1_geterr DQMC_TDM1::DQMC_TDM1_GetErr proc~dqmc_tdm1_geterr->module~dqmc_mpi proc~dqmc_tdm1_geterrkft DQMC_TDM1::DQMC_TDM1_GetErrKFT proc~dqmc_tdm1_geterrkft->module~dqmc_mpi proc~dqmc_tdm1_print DQMC_TDM1::DQMC_TDM1_Print proc~dqmc_tdm1_print->module~dqmc_mpi proc~dqmc_tdm1_printkft DQMC_TDM1::DQMC_TDM1_PrintKFT proc~dqmc_tdm1_printkft->module~dqmc_mpi proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy proc~dqmc_tdm1_selfenergy->module~dqmc_mpi proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps proc~dqmc_updatewraps->module~dqmc_mpi program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_mpi program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_mpi program~dqmc_test->module~dqmc_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_mpi program~dqmc_verify->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: MPI_COMM_WORLD integer, public, parameter :: CHANNEL_AGGR = 1 integer, public, parameter :: CHANNEL_MEAS = 2 integer, public, parameter :: CHANNEL_GFUN = 3 integer, public, parameter :: PLEVEL_1 = 1 integer, public, parameter :: PLEVEL_2 = 2 integer, public, parameter :: PLEVEL_3 = 3 integer, public, parameter :: PLEVEL_4 = 4 type( MPI_SIMOR ), public :: qmc_sim Derived Types type, public :: MPI_SIMOR Components Type Visibility Attributes Name Initial integer, public :: level integer, public :: rank integer, public :: size integer, public :: aggr_rank integer, public :: meas_rank integer, public :: gfun_rank integer, public :: aggr_size integer, public :: meas_size integer, public :: gfun_size integer, public :: aggr_root integer, public :: meas_root integer, public :: gfun_root integer, public :: aggr_comm integer, public :: meas_comm integer, public :: gfun_comm Functions public  function DQMC_MPI_Is_Root (sim, channel) result(isRoot) Arguments Type Intent Optional Attributes Name type( MPI_SIMOR ) :: sim integer, intent(in) :: channel Return Value logical Subroutines public  subroutine DQMC_MPI_Init (sim, level) Arguments Type Intent Optional Attributes Name type( MPI_SIMOR ) :: sim integer, intent(in) :: level public  subroutine DQMC_MPI_Final (sim) Arguments Type Intent Optional Attributes Name type( MPI_SIMOR ) :: sim","tags":"","loc":"module/dqmc_mpi.html"},{"title":"DQMC_GEOM_PARAM – Quest","text":"Used by module~~dqmc_geom_param~~UsedByGraph module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds DQMC_BONDS module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_geom_wrap DQMC_GEOM_WRAP module~dqmc_geom_wrap->module~dqmc_geom_param module~dqmc_geom_wrap->module~dqmc_bonds module~dqmc_hamilt DQMC_HAMILT module~dqmc_geom_wrap->module~dqmc_hamilt module~dqmc_geom_wrap->module~dqmc_latt module~dqmc_reclatt DQMC_RECLATT module~dqmc_geom_wrap->module~dqmc_reclatt module~dqmc_symm DQMC_SYMM module~dqmc_geom_wrap->module~dqmc_symm module~dqmc_hamilt->module~dqmc_geom_param module~dqmc_hamilt->module~dqmc_latt module~dqmc_hamilt->module~dqmc_reclatt module~dqmc_latt->module~dqmc_geom_param module~dqmc_reclatt->module~dqmc_geom_param module~dqmc_reclatt->module~dqmc_latt module~dqmc_symm->module~dqmc_geom_param module~dqmc_kbonds DQMC_KBONDS module~dqmc_kbonds->module~dqmc_reclatt module~dqmc_phy2 DQMC_Phy2 module~dqmc_phy2->module~dqmc_bonds module~dqmc_phy2->module~dqmc_symm proc~construct_bond_classes DQMC_SYMM::construct_bond_classes proc~construct_bond_classes->module~dqmc_bonds proc~construct_lattice_classes DQMC_SYMM::construct_lattice_classes proc~construct_lattice_classes->module~dqmc_latt proc~construct_pair_classes DQMC_SYMM::construct_pair_classes proc~construct_pair_classes->module~dqmc_bonds proc~construct_recip_lattice_classes DQMC_SYMM::construct_recip_lattice_classes proc~construct_recip_lattice_classes->module~dqmc_reclatt proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_init->module~dqmc_geom_wrap proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_initprop->module~dqmc_geom_wrap proc~init_kbonds DQMC_KBONDS::init_kbonds proc~init_kbonds->module~dqmc_latt proc~init_kbonds->module~dqmc_symm proc~map_symm_bonds DQMC_SYMM::map_symm_bonds proc~map_symm_bonds->module~dqmc_bonds proc~map_symm_lattice DQMC_SYMM::map_symm_lattice proc~map_symm_lattice->module~dqmc_hamilt proc~map_symm_lattice->module~dqmc_latt proc~map_symm_pairs DQMC_SYMM::map_symm_pairs proc~map_symm_pairs->module~dqmc_bonds proc~map_symm_recip_lattice DQMC_SYMM::map_symm_recip_lattice proc~map_symm_recip_lattice->module~dqmc_reclatt program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_geom_wrap module~dqmc_hubbard DQMC_Hubbard program~dqmc_ggeom->module~dqmc_hubbard module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_phy2 module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_phy2 module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_hubbard proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_hubbard program~dqmc_verify->module~dqmc_2dperl program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rdim = 3 real(kind=8), public, parameter :: toll = 1.d-6 real(kind=8), public, parameter :: pi = acos(-1.d0) complex(kind=16), public, parameter :: im = (0.d0, 1.d0) integer, public, parameter :: N_Fields = 10 integer, public, parameter :: NDIM_F = 1 integer, public, parameter :: PRIM_F = 2 integer, public, parameter :: SUPER_F = 3 integer, public, parameter :: ORB_F = 4 integer, public, parameter :: HAMILT_F = 5 integer, public, parameter :: SYMM_F = 6 integer, public, parameter :: PHASE_F = 7 integer, public, parameter :: BONDS_F = 8 integer, public, parameter :: PAIRS_F = 9 integer, public, parameter :: DILUT_F = 10 character(len=10), public, parameter :: INPUT_FIELDS (N_Fields) = (/'  #NDIM   ', '  #PRIM   ', '  #SUPER  ', '   #ORB   ', ' #HAMILT  ', '  #SYMM   ', '  #PHASE  ', '  #BONDS  ', '   #PAIR  ', '  #DILUT  '/) integer, public :: inpunit logical, public :: Found_Field (N_fields) Subroutines public  subroutine analyze_input () Arguments None","tags":"","loc":"module/dqmc_geom_param.html"},{"title":"DQMC_SEQB – Quest","text":"Uses DQMC_MATB DQMC_WSpace DQMC_Util module~~dqmc_seqb~~UsesGraph module~dqmc_seqb DQMC_SEQB module~dqmc_matb DQMC_MATB module~dqmc_seqb->module~dqmc_matb module~dqmc_util DQMC_Util module~dqmc_seqb->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_seqb->module~dqmc_wspace module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_wspace module~dqmc_struct DQMC_STRUCT module~dqmc_matb->module~dqmc_struct module~dqmc_wspace->module~dqmc_util module~dqmc_struct->module~dqmc_util module~dqmc_cfg DQMC_Cfg module~dqmc_struct->module~dqmc_cfg module~dqmc_cfg->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_seqb~~UsedByGraph module~dqmc_seqb DQMC_SEQB module~dqmc_gfun DQMC_GFun module~dqmc_gfun->module~dqmc_seqb module~dqmc_gtau DQMC_GTAU module~dqmc_gtau->module~dqmc_seqb module~dqmc_gtau->module~dqmc_gfun module~dqmc_hubbard DQMC_Hubbard module~dqmc_hubbard->module~dqmc_seqb module~dqmc_hubbard->module~dqmc_gfun module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_seqb module~dqmc_hubbard~2->module~dqmc_gfun module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_hubbard module~dqmc_tdm1 DQMC_TDM1 module~dqmc_tdm1->module~dqmc_gtau proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_hubbard program~dqmc_ggeom->module~dqmc_tdm1 program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_hubbard program~dqmc_verify->module~dqmc_2dperl module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_tdm1 program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: SeqB Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: L integer, public :: nOrth type( matB ), public, pointer :: B real(kind=wp), public, pointer :: U (:,:) real(kind=wp), public, pointer :: D (:) real(kind=wp), public, pointer :: T (:,:) real(kind=wp), public, pointer :: W1 (:,:) real(kind=wp), public, pointer :: W2 (:,:) real(kind=wp), public, pointer :: W3 (:,:) real(kind=wp), public, pointer :: rw (:) real(kind=wp), public, pointer :: tau (:) integer, public, pointer :: piv (:) integer, public, pointer :: lw (:) Subroutines public  subroutine DQMC_SeqB_Init (n, L, nOrth, B, SB, WS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: L integer, intent(in) :: nOrth type( matB ), intent(in), target :: B type( SeqB ), intent(inout) :: SB type( WSpace ), intent(in), target :: WS public  subroutine DQMC_SeqB_Init2 (n, L, nOrth, B, SB, U, D, T, WS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: L integer, intent(in) :: nOrth type( matB ), intent(in), target :: B type( SeqB ), intent(inout) :: SB real(kind=wp), intent(in), target :: U (:,:) real(kind=wp), intent(in), target :: D (:) real(kind=wp), intent(in), target :: T (:,:) type( WSpace ), intent(in), target :: WS public  subroutine DQMC_SeqB_Free (SB) Arguments Type Intent Optional Attributes Name type( SeqB ), intent(inout) :: SB public  subroutine DQMC_SeqB_Update (SB) Arguments Type Intent Optional Attributes Name type( SeqB ), intent(inout) :: SB public  subroutine DQMC_UDTD (n, U, D, T, W1, W2, rw, tau, piv, lwork) Initial parameters for dgeqp3\nQR factorization with column pivoting\ndgegp3 returns R-factor on the upper triangle of G.\nThe lower triangle of G stores \"reflectors\",\nwhich is used to reconstruct the Q-factor. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: U (n,n) real(kind=wp), intent(inout) :: D (n) real(kind=wp), intent(inout) :: T (n,n) real(kind=wp), intent(inout) :: W1 (n,n) real(kind=wp), intent(inout) :: W2 (n,n) real(kind=wp), intent(inout) :: rw (:) real(kind=wp), intent(inout) :: tau (n) integer, intent(inout) :: piv (:) integer, intent(in) :: lwork (:) public  subroutine DQMC_SeqMultB (il, ir, SB, V) Initially, Q = B_{i} = V_i*B Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: il integer, intent(in) :: ir type( SeqB ), intent(inout) :: SB real(kind=wp), intent(in) :: V (SB%n,SB%L) public  subroutine DQMC_SeqMultBi (il, ir, SB, V) R = I, R will be the R-factor of the QDR factorization\nThe UDT decomposition is performed at every nOrth step, and\nat the last step. In other steps, we just multiply B_i to\nthe Q-factor\nmultiply B_i to the Q-factor Arguments Type Intent Optional Attributes Name integer, intent(in) :: il integer, intent(in) :: ir type( SeqB ), intent(inout) :: SB real(kind=wp), intent(in) :: V (SB%n,SB%L)","tags":"","loc":"module/dqmc_seqb.html"},{"title":"DQMC_GTAU – Quest","text":"Uses DQMC_SEQB DQMC_Util DQMC_MATB DQMC_GFun DQMC_WSpace module~~dqmc_gtau~~UsesGraph module~dqmc_gtau DQMC_GTAU module~dqmc_gfun DQMC_GFun module~dqmc_gtau->module~dqmc_gfun module~dqmc_matb DQMC_MATB module~dqmc_gtau->module~dqmc_matb module~dqmc_seqb DQMC_SEQB module~dqmc_gtau->module~dqmc_seqb module~dqmc_util DQMC_Util module~dqmc_gtau->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_gtau->module~dqmc_wspace module~dqmc_gfun->module~dqmc_matb module~dqmc_gfun->module~dqmc_seqb module~dqmc_gfun->module~dqmc_util module~dqmc_gfun->module~dqmc_wspace module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_wspace module~dqmc_struct DQMC_STRUCT module~dqmc_matb->module~dqmc_struct module~dqmc_seqb->module~dqmc_matb module~dqmc_seqb->module~dqmc_util module~dqmc_seqb->module~dqmc_wspace module~dqmc_wspace->module~dqmc_util module~dqmc_struct->module~dqmc_util module~dqmc_cfg DQMC_Cfg module~dqmc_struct->module~dqmc_cfg module~dqmc_cfg->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_gtau~~UsedByGraph module~dqmc_gtau DQMC_GTAU module~dqmc_tdm1 DQMC_TDM1 module~dqmc_tdm1->module~dqmc_gtau module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_tdm1 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_tdm1 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: TAU_T0 = 0 integer, public, parameter :: TAU_BOTH = 1 integer, public, parameter :: TAU_0T = 2 integer, public, parameter :: TAU_UP = 1 integer, public, parameter :: TAU_DN = -1 integer, public, parameter :: TPLUS = 1 integer, public, parameter :: TMINUS = 2 integer, public, parameter :: ZPLUS = 3 integer, public, parameter :: ZMINUS = 4 Derived Types type, public :: Gtau Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: L integer, public :: nb integer, public :: nnb integer, public :: it_up integer, public :: i0_up integer, public :: it_dn integer, public :: i0_dn integer, public :: north integer, public :: which integer, public :: sfc real(kind=wp), public, pointer :: upt0 (:,:) real(kind=wp), public, pointer :: up0t (:,:) real(kind=wp), public, pointer :: dnt0 (:,:) real(kind=wp), public, pointer :: dn0t (:,:) real(kind=wp), public, pointer :: up00 (:,:) real(kind=wp), public, pointer :: uptt (:,:) real(kind=wp), public, pointer :: dn00 (:,:) real(kind=wp), public, pointer :: dntt (:,:) real(kind=wp), public, pointer :: A_up (:,:) real(kind=wp), public, pointer :: A_dn (:,:) integer, public, pointer :: itau_up (:) integer, public, pointer :: itau_dn (:) type( matB ), public, pointer :: B_up type( matB ), public, pointer :: B_dn real(kind=wp), public, pointer :: V_up (:,:) real(kind=wp), public, pointer :: V_dn (:,:) real(kind=wp), public, pointer :: P (:) logical, public :: comp_dn logical, public :: neg_u real(kind=wp), public, pointer :: sgnup real(kind=wp), public, pointer :: sgndn integer, public :: lw integer, public, pointer :: IW (:) real(kind=wp), public, pointer :: W1 (:) real(kind=wp), public, pointer :: W2 (:,:) real(kind=wp), public, pointer :: W3 (:,:) logical, public :: g0_stored = .false. real(kind=wp), public, pointer :: e0up (:) real(kind=wp), public, pointer :: e0dn (:) real(kind=wp), public, pointer :: U0up (:,:) real(kind=wp), public, pointer :: U0dn (:,:) Subroutines public  subroutine DQMC_Gtau_Init (Hub, tau) Arguments Type Intent Optional Attributes Name type( Hubbard ), intent(in), target :: Hub type( Gtau ), intent(inout) :: tau public  subroutine DQMC_Gtau_Free (tau) Arguments Type Intent Optional Attributes Name type( Gtau ), intent(inout) :: tau public  subroutine DQMC_Gtau_LoadA (tau, spin, slice, sgn) Arguments Type Intent Optional Attributes Name type( Gtau ), intent(inout), target :: tau integer, intent(in) :: spin integer, intent(in) :: slice real(kind=wp), intent(out) :: sgn public  subroutine DQMC_Gtau_CopyUp (tau) Arguments Type Intent Optional Attributes Name type( Gtau ), intent(inout) :: tau public  subroutine DQMC_Gtau_DumpA (tau, spin, it, i0) Arguments Type Intent Optional Attributes Name type( Gtau ), intent(inout) :: tau integer, intent(in) :: spin integer, intent(in) :: it integer, intent(in) :: i0 public  subroutine DQMC_MakeGtau (tau, it, i0) Arguments Type Intent Optional Attributes Name type( Gtau ), intent(inout) :: tau integer, intent(in) :: it integer, intent(in) :: i0 public  subroutine DQMC_GetGtau (it, i0, spin, gt0, g0t, g00, gtt, tau) Compute  T_2*inv(T_1) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: it integer, intent(in) :: i0 integer, intent(in) :: spin real(kind=wp), intent(inout) :: gt0 (:,:) real(kind=wp), intent(inout) :: g0t (:,:) real(kind=wp), intent(inout) :: g00 (:,:) real(kind=wp), intent(inout) :: gtt (:,:) type( Gtau ), intent(inout), target :: tau public  subroutine DQMC_change_gtau_time (tau, idir, spin) Arguments Type Intent Optional Attributes Name type( Gtau ), intent(inout) :: tau integer, intent(in) :: idir integer, intent(in) :: spin public  subroutine DQMC_Gtau_SetAlias (spin, tau, A, B, V, gt0, g0t, g00, gtt, it, i0, itau, sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: spin type( Gtau ), intent(in), target :: tau real(kind=wp), optional, pointer :: A (:,:) type( matB ), optional, pointer :: B real(kind=wp), optional, pointer :: V (:,:) real(kind=wp), optional, pointer :: gt0 (:,:) real(kind=wp), optional, pointer :: g0t (:,:) real(kind=wp), optional, pointer :: g00 (:,:) real(kind=wp), optional, pointer :: gtt (:,:) integer, optional, pointer :: it integer, optional, pointer :: i0 integer, optional, pointer :: itau (:) real(kind=wp), optional, pointer :: sgn public  subroutine DQMC_Gtau_GetG0 (n, tau, spin, slice, g0tau) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n type( Gtau ), intent(inout) :: tau integer, intent(in) :: spin integer, intent(in) :: slice real(kind=wp), intent(out) :: g0tau (n,n)","tags":"","loc":"module/dqmc_gtau.html"},{"title":"DQMC_BONDS – Quest","text":"Uses DQMC_GEOM_PARAM DQMC_LATT module~~dqmc_bonds~~UsesGraph module~dqmc_bonds DQMC_BONDS module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_latt->module~dqmc_geom_param module~dqmc_util DQMC_Util module~dqmc_latt->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_bonds~~UsedByGraph module~dqmc_bonds DQMC_BONDS module~dqmc_geom_wrap DQMC_GEOM_WRAP module~dqmc_geom_wrap->module~dqmc_bonds module~dqmc_phy2 DQMC_Phy2 module~dqmc_phy2->module~dqmc_bonds proc~construct_bond_classes DQMC_SYMM::construct_bond_classes proc~construct_bond_classes->module~dqmc_bonds proc~construct_pair_classes DQMC_SYMM::construct_pair_classes proc~construct_pair_classes->module~dqmc_bonds proc~map_symm_bonds DQMC_SYMM::map_symm_bonds proc~map_symm_bonds->module~dqmc_bonds proc~map_symm_pairs DQMC_SYMM::map_symm_pairs proc~map_symm_pairs->module~dqmc_bonds module~dqmc_hubbard DQMC_Hubbard module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_phy2 module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_phy2 proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_init->module~dqmc_geom_wrap proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_initprop->module~dqmc_geom_wrap program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_geom_wrap program~dqmc_ggeom->module~dqmc_hubbard module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_hubbard proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_hubbard program~dqmc_verify->module~dqmc_2dperl program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: bonds_t Components Type Visibility Attributes Name Initial integer, public :: ntotbond integer, public, pointer :: bond_label (:) integer, public, pointer :: bond_origin (:) integer, public, pointer :: bond_target (:) real(kind=wp), public, pointer :: xxbond (:,:) integer, public :: nclass_b integer, public, pointer :: myclass_b (:,:) integer, public, pointer :: class_size_b (:) logical, public :: initialized logical, public :: analyzed type, public :: pairing Components Type Visibility Attributes Name Initial integer, public :: nwave integer, public :: nbond integer, public, pointer :: nbondv (:) integer, public, pointer :: bond_origin (:,:) integer, public, pointer :: bond_end (:,:) integer, public, pointer :: bond_map (:) integer, public, pointer :: pair_map (:) integer, public, pointer :: bond_number (:,:) real(kind=wp), public, pointer :: bond_wgt (:,:) character(len=20), public, pointer :: wave_label (:) integer, public, pointer :: myclass_p (:,:) integer, public :: nclass_p integer, public, pointer :: class_size_p (:) logical, public :: initialized Subroutines public  subroutine free_bonds (bonds) Arguments Type Intent Optional Attributes Name type( bonds_t ), intent(out) :: bonds public  subroutine free_pairs (pairs) Arguments Type Intent Optional Attributes Name type( pairing ), intent(out) :: pairs public  subroutine read_bonds (Bonds, SOP) Arguments Type Intent Optional Attributes Name type( bonds_t ) :: Bonds integer, intent(in) :: SOP public  subroutine construct_pairs (Bonds, Pairs, lattice, SOP) Arguments Type Intent Optional Attributes Name type( bonds_t ) :: Bonds type( pairing ) :: Pairs type( lattice_t ) :: lattice integer, intent(in) :: SOP","tags":"","loc":"module/dqmc_bonds.html"},{"title":"DQMC_2DPERL – Quest","text":"Uses DQMC_STRUCT DQMC_MPI DQMC_Util DQMC_Hubbard DQMC_Cfg module~~dqmc_2dperl~~UsesGraph module~dqmc_2dperl DQMC_2DPERL module~dqmc_cfg DQMC_Cfg module~dqmc_2dperl->module~dqmc_cfg module~dqmc_hubbard DQMC_Hubbard module~dqmc_2dperl->module~dqmc_hubbard module~dqmc_mpi DQMC_MPI module~dqmc_2dperl->module~dqmc_mpi module~dqmc_struct DQMC_STRUCT module~dqmc_2dperl->module~dqmc_struct module~dqmc_util DQMC_Util module~dqmc_2dperl->module~dqmc_util module~dqmc_cfg->module~dqmc_util module~dqmc_hubbard->module~dqmc_cfg module~dqmc_hubbard->module~dqmc_struct module~dqmc_hubbard->module~dqmc_util module~dqmc_gfun DQMC_GFun module~dqmc_hubbard->module~dqmc_gfun module~dqmc_matb DQMC_MATB module~dqmc_hubbard->module~dqmc_matb module~dqmc_phy0 DQMC_Phy0 module~dqmc_hubbard->module~dqmc_phy0 module~dqmc_phy2 DQMC_Phy2 module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_seqb DQMC_SEQB module~dqmc_hubbard->module~dqmc_seqb module~dqmc_struct->module~dqmc_cfg module~dqmc_struct->module~dqmc_util module~dqmc_gfun->module~dqmc_util module~dqmc_gfun->module~dqmc_matb module~dqmc_gfun->module~dqmc_seqb module~dqmc_wspace DQMC_WSpace module~dqmc_gfun->module~dqmc_wspace module~dqmc_matb->module~dqmc_struct module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_wspace module~dqmc_phy0->module~dqmc_struct module~dqmc_phy0->module~dqmc_util module~dqmc_phy0->module~dqmc_wspace module~dqmc_phy2->module~dqmc_struct module~dqmc_phy2->module~dqmc_util module~dqmc_bonds DQMC_BONDS module~dqmc_phy2->module~dqmc_bonds module~dqmc_symm DQMC_SYMM module~dqmc_phy2->module~dqmc_symm module~dqmc_phy2->module~dqmc_wspace module~dqmc_seqb->module~dqmc_util module~dqmc_seqb->module~dqmc_matb module~dqmc_seqb->module~dqmc_wspace module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_symm->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_wspace->module~dqmc_util module~dqmc_latt->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_2dperl~~UsedByGraph module~dqmc_2dperl DQMC_2DPERL program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: IMP_TRIANGLE = 1 integer, public, parameter :: IMP_RECTANGLE = 2 Subroutines public  subroutine DQMC_Comp_2DPerl () Arguments None public  subroutine DQMC_Init_2DPerl (nx, ny, S, IMP) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nx integer, intent(in) :: ny type( Struct ), intent(inout) :: S integer, intent(in) :: IMP public  subroutine DQMC_2DPerl_DC_Imp1 (n, nx, ny, S, cord) using lookup table (maybe hashing table )\ncompute the index of i\ninitial the index of j\ncompute the index of j\ncompute the distance Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: nx integer, intent(in) :: ny type( Struct ), intent(inout) :: S real(kind=wp), pointer :: cord (:,:) public  subroutine DQMC_2DPerl_DC_Imp2 (n, nx, ny, S, cord) using lookup table (maybe hashing table )\ncompute the index of i\ninitial the index of j\ncompute the index of j\ncompute the distance Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: nx integer, intent(in) :: ny type( Struct ), intent(inout) :: S real(kind=wp), pointer :: cord (:,:)","tags":"","loc":"module/dqmc_2dperl.html"},{"title":"DQMC_Phy0 – Quest","text":"Uses DQMC_Util DQMC_STRUCT DQMC_WSpace module~~dqmc_phy0~~UsesGraph module~dqmc_phy0 DQMC_Phy0 module~dqmc_struct DQMC_STRUCT module~dqmc_phy0->module~dqmc_struct module~dqmc_util DQMC_Util module~dqmc_phy0->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_phy0->module~dqmc_wspace module~dqmc_struct->module~dqmc_util module~dqmc_cfg DQMC_Cfg module~dqmc_struct->module~dqmc_cfg module~dqmc_wspace->module~dqmc_util module~dqmc_cfg->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_phy0~~UsedByGraph module~dqmc_phy0 DQMC_Phy0 module~dqmc_hubbard DQMC_Hubbard module~dqmc_hubbard->module~dqmc_phy0 module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_phy0 program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_phy0 program~dqmc_verify->module~dqmc_hubbard module~dqmc_2dperl DQMC_2DPERL program~dqmc_verify->module~dqmc_2dperl module~dqmc_2dperl->module~dqmc_hubbard proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_hubbard program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: narrays = 9 integer, public, parameter :: IMEAS = 0 integer, public, parameter :: IGFUN = 1 integer, public, parameter :: IGFUP = 2 integer, public, parameter :: IGFDN = 3 integer, public, parameter :: ISPXX = 4 integer, public, parameter :: ISPZZ = 5 integer, public, parameter :: IAVSP = 6 integer, public, parameter :: IDEN0 = 7 integer, public, parameter :: IDEN1 = 8 integer, public, parameter :: IPAIR = 9 integer, public, parameter :: P0_NUP = 1 integer, public, parameter :: P0_NDN = 2 integer, public, parameter :: P0_NUD = 3 integer, public, parameter :: P0_KE = 4 integer, public, parameter :: P0_ENERGY = 5 integer, public, parameter :: P0_DENSITY = 6 integer, public, parameter :: P0_CHIT = 7 integer, public, parameter :: P0_CV = 8 integer, public, parameter :: P0_SFERRO = 9 integer, public, parameter :: P0_SFER2 = 10 integer, public, parameter :: P0_SAF = 15 integer, public, parameter :: P0_SAFSQ = 16 integer, public, parameter :: P0_SAF2 = 17 integer, public, parameter :: P0_SAF2SQ = 18 integer, public, parameter :: P0_potential_energy = 11 integer, public, parameter :: P0_hopping_energy = 12 integer, public, parameter :: P0_double_occupancy = 13 integer, public, parameter :: P0_magnetization_squared = 14 integer, public, parameter :: P0_N_NO_SAF = 14 integer, public, parameter :: P0_N = 18 integer, public, parameter :: P0_SGN = 1 integer, public, parameter :: P0_SGNUP = 2 integer, public, parameter :: P0_SGNDN = 3 character(len=*), public, parameter :: P0_STR (P0_N) = (/\"          Up spin occupancy : \", \"        Down spin occupancy : \", \"             <U*N_up*N_dn>  : \", \"             Kinetic energy : \", \"               Total energy : \", \"                    Density : \", \"                Chi_thermal : \", \"              Specific heat : \", \"  XX Ferro structure factor : \", \"  ZZ Ferro structure factor : \", \"           Potential energy : \", \"             Hopping energy : \", \"           Double occupancy : \", \"      Magnetization squared : \", \"     XX AF structure factor : \", \"  Root Mean Square of XX AF : \", \"     ZZ AF structure factor : \", \"  Root Mean Square of ZZ AF : \"/) character(len=*), public, parameter :: P0_SIGN_STR (3) = (/\"                   Avg sign : \", \"                Avg up sign : \", \"                Avg dn sign : \"/) Derived Types type, public :: Phy0 Components Type Visibility Attributes Name Initial integer, public :: nClass integer, public :: nBin integer, public :: nMeas integer, public :: avg integer, public :: err integer, public :: cnt integer, public :: idx integer, public :: n real(kind=wp), public :: beta real(kind=wp), public, pointer :: meas (:,:) real(kind=wp), public, pointer :: sign (:,:) integer, public :: IARR (0:narrays+1) integer, public :: IARRFT (1:narrays+1) integer, public :: IARREV (1:narrays+1) real(kind=wp), public, pointer :: AllProp (:,:) real(kind=wp), public, pointer :: AllPropFT (:,:) real(kind=wp), public, pointer :: AllPropEigVal (:,:) complex(kind=16), public, pointer :: AllPropEigVec (:,:,:,:) real(kind=wp), public, pointer :: G_fun (:,:) real(kind=wp), public, pointer :: Gf_up (:,:) real(kind=wp), public, pointer :: Gf_dn (:,:) real(kind=wp), public, pointer :: SpinXX (:,:) real(kind=wp), public, pointer :: SpinZZ (:,:) real(kind=wp), public, pointer :: AveSpin (:,:) real(kind=wp), public, pointer :: Den0 (:,:) real(kind=wp), public, pointer :: Den1 (:,:) real(kind=wp), public, pointer :: Pair (:,:) real(kind=wp), public, pointer :: up (:) real(kind=wp), public, pointer :: dn (:) logical, public :: compSAF logical, public :: init logical, public :: initFT Subroutines public  subroutine DQMC_Phy0_Init (P0, S, beta, nBin, WS) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(inout) :: P0 type( Struct ), intent(in) :: S real(kind=wp), intent(in) :: beta integer, intent(in) :: nBin type( WSpace ), intent(in), target :: WS public  subroutine DQMC_Phy0_Free (P0) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(inout) :: P0 public  subroutine DQMC_Phy0_Avg (P0) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(inout) :: P0 public  subroutine DQMC_Phy0_Print (P0, S, OPT) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(in) :: P0 type( Struct ), intent(in) :: S integer, intent(in) :: OPT public  subroutine DQMC_Phy0_GetErr (P0) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(inout) :: P0 public  subroutine DQMC_Phy0_Meas (n, P0, G_up, G_dn, U, mu_up, mu_dn, t_up, t_dn, sgnup, sgndn, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n type( Phy0 ), intent(inout) :: P0 real(kind=wp), intent(in) :: G_up (n,n) real(kind=wp), intent(in) :: G_dn (n,n) real(kind=wp), intent(in) :: U (:) real(kind=wp), intent(in) :: mu_up (n) real(kind=wp), intent(in) :: mu_dn (n) real(kind=wp), intent(in) :: t_up (:) real(kind=wp), intent(in) :: t_dn (:) real(kind=wp), intent(in) :: sgnup real(kind=wp), intent(in) :: sgndn type( Struct ), intent(in), target :: S public  subroutine DQMC_Phy0_GetFT (P0, class, phase, ft_wgt_t, ft_wgt_g, nkt, nkg, na, nt) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(inout) :: P0 integer, intent(in) :: class (na*nt,na*nt) integer, intent(in) :: phase (na*nt,na*nt) complex(kind=16), intent(in), target :: ft_wgt_t (nt,nkt) complex(kind=16), intent(in), target :: ft_wgt_g (nt,nkg) integer, intent(in) :: nkt integer, intent(in) :: nkg integer, intent(in) :: na integer, intent(in) :: nt public  subroutine DQMC_Phy0_GetErrFT (P0) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(inout) :: P0 public  subroutine DQMC_Phy0_PrintFT (P0, na, nkt, nkg, OPT) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(in) :: P0 integer, intent(in) :: na integer, intent(in) :: nkt integer, intent(in) :: nkg integer, intent(in) :: OPT","tags":"","loc":"module/dqmc_phy0.html"},{"title":"DQMC_GFun – Quest","text":"Uses DQMC_Util DQMC_WSpace DQMC_SEQB DQMC_MATB module~~dqmc_gfun~~UsesGraph module~dqmc_gfun DQMC_GFun module~dqmc_matb DQMC_MATB module~dqmc_gfun->module~dqmc_matb module~dqmc_seqb DQMC_SEQB module~dqmc_gfun->module~dqmc_seqb module~dqmc_util DQMC_Util module~dqmc_gfun->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_gfun->module~dqmc_wspace module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_wspace module~dqmc_struct DQMC_STRUCT module~dqmc_matb->module~dqmc_struct module~dqmc_seqb->module~dqmc_matb module~dqmc_seqb->module~dqmc_util module~dqmc_seqb->module~dqmc_wspace module~dqmc_wspace->module~dqmc_util module~dqmc_struct->module~dqmc_util module~dqmc_cfg DQMC_Cfg module~dqmc_struct->module~dqmc_cfg module~dqmc_cfg->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_gfun~~UsedByGraph module~dqmc_gfun DQMC_GFun module~dqmc_gtau DQMC_GTAU module~dqmc_gtau->module~dqmc_gfun module~dqmc_hubbard DQMC_Hubbard module~dqmc_hubbard->module~dqmc_gfun module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_gfun module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_hubbard module~dqmc_tdm1 DQMC_TDM1 module~dqmc_tdm1->module~dqmc_gtau proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_hubbard program~dqmc_ggeom->module~dqmc_tdm1 program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_hubbard program~dqmc_verify->module~dqmc_2dperl module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_tdm1 program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, public, parameter :: GMAT_UP = .true. logical, public, parameter :: GMAT_DN = .false. Derived Types type, public :: G_fun Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: L real(kind=wp), public :: sgn real(kind=wp), public, pointer :: G (:,:) logical, public :: owns_G real(kind=wp), public, pointer :: V (:,:) integer, public :: ilb real(kind=wp), public :: det integer, public, pointer :: pvt (:) real(kind=wp), public, pointer :: tmp (:,:) integer, public :: nWrap integer, public :: wps integer, public :: lastwr integer, public :: maxwrap integer, public :: fixwrap real(kind=wp), public :: difflim real(kind=wp), public :: errrate integer, public :: redo integer, public :: noredo integer, public :: nBlk integer, public :: blkSz real(kind=wp), public, pointer :: U (:,:) real(kind=wp), public, pointer :: W (:,:) integer, public :: nModify real(kind=wp), public, pointer :: GS (:,:) real(kind=wp), public, pointer :: WS (:,:) logical, public :: sxx Functions public  function DQMC_Gfun_Getjj (n, j, blksz, G, U, W) result(gjj) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: j integer, intent(in) :: blksz real(kind=wp), intent(in) :: G (n,n) real(kind=wp), intent(in) :: U (n,n) real(kind=wp), intent(in) :: W (n,n) Return Value real(kind=wp) Subroutines public  subroutine DQMC_GFun_Init (n, L, G, V, WS, nwrap, difflim, errrate, up, ssxx, fixw) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: L type( G_fun ), intent(inout) :: G real(kind=wp), intent(in), target :: V (n,L) type( WSpace ), intent(in), target :: WS integer, intent(in) :: nwrap real(kind=wp), intent(in) :: difflim real(kind=wp), intent(in) :: errrate logical, intent(in) :: up integer, intent(in) :: ssxx integer, intent(in) :: fixw public  subroutine DQMC_GFun_Init_original (n, L, G, V, WS, nwrap, difflim, errrate, up, ssxx, fixw) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: L type( G_fun ), intent(inout) :: G real(kind=wp), intent(in), target :: V (n,L) type( WSpace ), intent(in), target :: WS integer, intent(in) :: nwrap real(kind=wp), intent(in) :: difflim real(kind=wp), intent(in) :: errrate logical, intent(in) :: up integer, intent(in) :: ssxx integer, intent(in) :: fixw public  subroutine DQMC_GFun_Clone (G1, G2) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G1 type( G_fun ), intent(in) :: G2 public  subroutine DQMC_GFun_Duplicate (G1, G2) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G1 type( G_fun ), intent(in) :: G2 public  subroutine DQMC_GFun_CopyUp (G1, G2, P) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G1 type( G_fun ), intent(in) :: G2 real(kind=wp), intent(in) :: P (G2%n) public  subroutine DQMC_Gfun_Free (G) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G public  subroutine DQMC_GetG (il, G, SB) Arguments Type Intent Optional Attributes Name integer, intent(in) :: il type( G_fun ), intent(inout) :: G type( SeqB ), intent(inout) :: SB public  subroutine DQMC_GetG_2nd_order (G, B) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G type( matB ), intent(in) :: B public  subroutine DQMC_ComputeG (il, n, sgn, G, V, SB, pvt2, compDet, det, sxx) Setup index for B_{i}\nCompute the LU decomposition of T first.\nSolve T'W = U. W = transpose(inv(U)inv(T)) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: il integer, intent(in) :: n real(kind=wp), intent(inout) :: sgn real(kind=wp), intent(inout) :: G (:,:) real(kind=wp), intent(in) :: V (:,:) type( SeqB ), intent(inout) :: SB integer, intent(inout) :: pvt2 (:) logical, intent(in) :: compDet real(kind=wp), intent(inout) :: det logical, intent(in) :: sxx public  subroutine DQMC_UpdateWraps (G) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G public  subroutine DQMC_SyncWraps (G1, G2) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G1 type( G_fun ), intent(inout) :: G2 public  subroutine DQMC_UpdateG (j, gamma, G) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j real(kind=wp), intent(in) :: gamma type( G_fun ), intent(inout), target :: G public  subroutine DQMC_ApplyUpdate (G, forced) Arguments Type Intent Optional Attributes Name type( G_fun ), intent(inout) :: G logical, intent(in) :: forced","tags":"","loc":"module/dqmc_gfun.html"},{"title":"DQMC_Phy2 – Quest","text":"Uses DQMC_STRUCT DQMC_SYMM DQMC_BONDS DQMC_Util DQMC_WSpace module~~dqmc_phy2~~UsesGraph module~dqmc_phy2 DQMC_Phy2 module~dqmc_bonds DQMC_BONDS module~dqmc_phy2->module~dqmc_bonds module~dqmc_struct DQMC_STRUCT module~dqmc_phy2->module~dqmc_struct module~dqmc_symm DQMC_SYMM module~dqmc_phy2->module~dqmc_symm module~dqmc_util DQMC_Util module~dqmc_phy2->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_phy2->module~dqmc_wspace module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_struct->module~dqmc_util module~dqmc_cfg DQMC_Cfg module~dqmc_struct->module~dqmc_cfg module~dqmc_symm->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_wspace->module~dqmc_util module~dqmc_cfg->module~dqmc_util module~dqmc_latt->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_phy2~~UsedByGraph module~dqmc_phy2 DQMC_Phy2 module~dqmc_hubbard DQMC_Hubbard module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_phy2 module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_phy2 module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_hubbard proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_hubbard program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_hubbard program~dqmc_verify->module~dqmc_2dperl program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface DQMC_Phy2_avg public  subroutine DQMC_Phy2_Avg_Wave (P2, W) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 real(kind=wp), intent(in) :: W (P2%nb,P2%nwave) public  subroutine DQMC_Phy2_Avg_Symm (P2, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 type( Struct ), intent(in) :: S public        interface DQMC_Phy2_GetIrrep public  subroutine DQMC_Phy2_GetIrrep_Connected (P2, G_fun, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 real(kind=wp), intent(in) :: G_fun (S%nclass) type( Struct ), intent(inout) :: S public  subroutine DQMC_Phy2_GetIrrep_Full (P2, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 type( Struct ), intent(inout) :: S Derived Types type, public :: Phy2 Components Type Visibility Attributes Name Initial integer, public :: nb integer, public :: nWave integer, public :: nBin integer, public :: idx integer, public :: cnt integer, public :: ncell integer, public :: avg integer, public :: err real(kind=wp), public, pointer :: sgn (:) real(kind=wp), public, pointer :: M1 (:,:) real(kind=wp), public, pointer :: M2 (:,:) real(kind=wp), public, pointer :: M3 (:,:) real(kind=wp), public, pointer :: M4 (:,:) real(kind=wp), public, pointer :: M5 (:,:) real(kind=wp), public, pointer :: T (:,:) integer, public :: ldt integer, public :: nData logical, public :: compute logical, public :: connected logical, public :: diagonalize = .false. Subroutines public  subroutine DQMC_Phy2_Init (P2, nBin, S, WS, meas) Allocate two additional bins for storing\naverage value and error Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 integer, intent(in) :: nBin type( Struct ), intent(in) :: S type( WSpace ), intent(in), target :: WS logical, intent(out) :: meas public  subroutine DQMC_Phy2_Free (P2) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 public  subroutine DQMC_Phy2_Meas (n, M1, M2, P2, Bond, G_up, G_dn, sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M1 (:,:) real(kind=wp), intent(inout) :: M2 (:,:) type( Phy2 ), intent(inout) :: P2 type( CCS ), intent(in) :: Bond real(kind=wp), intent(in) :: G_up (n,n) real(kind=wp), intent(in) :: G_dn (n,n) real(kind=wp), intent(in) :: sgn public  subroutine DQMC_Phy2_Pair (n, M, up, dn, Bond) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: M (:,:) real(kind=wp), intent(in) :: up (:,:) real(kind=wp), intent(in) :: dn (:,:) type( CCS ), intent(in) :: Bond public  subroutine DQMC_Phy2_Avg_Wave (P2, W) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 real(kind=wp), intent(in) :: W (P2%nb,P2%nwave) public  subroutine DQMC_Phy2_Avg_Symm (P2, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 type( Struct ), intent(in) :: S public  subroutine DQMC_Wave_Avg (nB, nWave, W, T, I, O, factor, ldt) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nB integer, intent(in) :: nWave real(kind=wp), intent(in) :: W (nb,nWave) real(kind=wp), intent(in) :: T (ldt,nWave) real(kind=wp), intent(in) :: I (nb,nb) real(kind=wp), intent(inout) :: O (:) real(kind=wp), intent(in) :: factor integer, intent(in) :: ldt public  subroutine DQMC_Pair_Symm (M2, M3, class_b, size_b, n, nclass, factor) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: M2 (n,n) real(kind=wp), intent(out) :: M3 (nclass) integer, intent(in) :: class_b (n,n) integer, intent(in) :: size_b (nclass) integer, intent(in) :: n integer, intent(in) :: nclass real(kind=wp), intent(in) :: factor public  subroutine DQMC_Phy2_GetErr (P2) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 public  subroutine DQMC_Phy2_GetIrrep_Full (P2, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 type( Struct ), intent(inout) :: S public  subroutine DQMC_Phy2_GetIrrep_Connected (P2, G_fun, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 real(kind=wp), intent(in) :: G_fun (S%nclass) type( Struct ), intent(inout) :: S public  subroutine DQMC_Phy2_GetErrIrrep (P2, G_fun, S) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(inout) :: P2 real(kind=wp), intent(in) :: G_fun (S%nClass,P2%err) type( Struct ), intent(in) :: S public  subroutine DQMC_Phy2_Print (P2, wlabel, OPT) Arguments Type Intent Optional Attributes Name type( Phy2 ), intent(in) :: P2 character(len=*), intent(in) :: wlabel (:) integer, intent(in) :: OPT public  subroutine DQMC_phy2_WaveSymm (S, P2, Symm) Arguments Type Intent Optional Attributes Name type( Struct ), intent(inout) :: S type( Phy2 ), intent(inout) :: P2 type( symm_operations ), intent(in) :: Symm public  subroutine dqmc_phy2_PrintSymm (S, P2, OPT) Arguments Type Intent Optional Attributes Name type( Struct ), intent(inout) :: S type( Phy2 ), intent(inout) :: P2 integer, intent(in) :: OPT","tags":"","loc":"module/dqmc_phy2.html"},{"title":"DQMC_WSpace – Quest","text":"Uses DQMC_Util module~~dqmc_wspace~~UsesGraph module~dqmc_wspace DQMC_WSpace module~dqmc_util DQMC_Util module~dqmc_wspace->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_wspace~~UsedByGraph module~dqmc_wspace DQMC_WSpace module~dqmc_checkerboard DQMC_CheckerBoard module~dqmc_checkerboard->module~dqmc_wspace module~dqmc_gfun DQMC_GFun module~dqmc_gfun->module~dqmc_wspace module~dqmc_matb DQMC_MATB module~dqmc_gfun->module~dqmc_matb module~dqmc_seqb DQMC_SEQB module~dqmc_gfun->module~dqmc_seqb module~dqmc_gtau DQMC_GTAU module~dqmc_gtau->module~dqmc_wspace module~dqmc_gtau->module~dqmc_gfun module~dqmc_gtau->module~dqmc_matb module~dqmc_gtau->module~dqmc_seqb module~dqmc_matb->module~dqmc_wspace module~dqmc_phy0 DQMC_Phy0 module~dqmc_phy0->module~dqmc_wspace module~dqmc_phy2 DQMC_Phy2 module~dqmc_phy2->module~dqmc_wspace module~dqmc_seqb->module~dqmc_wspace module~dqmc_seqb->module~dqmc_matb module~dqmc_hubbard DQMC_Hubbard module~dqmc_hubbard->module~dqmc_gfun module~dqmc_hubbard->module~dqmc_matb module~dqmc_hubbard->module~dqmc_phy0 module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_hubbard->module~dqmc_seqb module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_gfun module~dqmc_hubbard~2->module~dqmc_matb module~dqmc_hubbard~2->module~dqmc_phy0 module~dqmc_hubbard~2->module~dqmc_phy2 module~dqmc_hubbard~2->module~dqmc_seqb module~dqmc_tdm1 DQMC_TDM1 module~dqmc_tdm1->module~dqmc_gtau module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_phy2 module~dqmc_tdm2->module~dqmc_tdm1 program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_phy0 program~dqmc_verify->module~dqmc_hubbard module~dqmc_2dperl DQMC_2DPERL program~dqmc_verify->module~dqmc_2dperl module~dqmc_2dperl->module~dqmc_hubbard proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_hubbard program~dqmc_ggeom->module~dqmc_tdm1 program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: LA_SYEV = 1 integer, public, parameter :: LA_GEQRF = 2 integer, public, parameter :: LA_ORGQR = 3 integer, public, parameter :: LA_ORMQR = 4 integer, public, parameter :: LA_GETRI = 5 Derived Types type, public :: WSpace Components Type Visibility Attributes Name Initial integer, public :: lw (5) real(kind=wp), public, pointer :: R1 (:,:) real(kind=wp), public, pointer :: R2 (:,:) real(kind=wp), public, pointer :: R3 (:,:) real(kind=wp), public, pointer :: R4 (:,:) real(kind=wp), public, pointer :: R5 (:) real(kind=wp), public, pointer :: R6 (:) real(kind=wp), public, pointer :: R7 (:) real(kind=wp), public, pointer :: R8 (:,:) integer, public, pointer :: I1 (:) integer, public, pointer :: I2 (:) Subroutines public  subroutine DQMC_WSpace_Allocate (n, mx_nbr, WS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: mx_nbr type( WSpace ), intent(inout) :: WS public  subroutine DQMC_WSpace_Free (WS) Arguments Type Intent Optional Attributes Name type( WSpace ), intent(inout) :: WS","tags":"","loc":"module/dqmc_wspace.html"},{"title":"DQMC_Geom – Quest","text":"Uses DQMC_STRUCT module~~dqmc_geom~~UsesGraph module~dqmc_geom DQMC_Geom module~dqmc_struct DQMC_STRUCT module~dqmc_geom->module~dqmc_struct module~dqmc_cfg DQMC_Cfg module~dqmc_struct->module~dqmc_cfg module~dqmc_util DQMC_Util module~dqmc_struct->module~dqmc_util module~dqmc_cfg->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine QUEST_GG_Init (S, prefix) Arguments Type Intent Optional Attributes Name type( Struct ), intent(inout) :: S character(len=*), intent(in) :: prefix public  subroutine QUEST_Read_Adj (IPT, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: IPT type( Struct ), intent(inout) :: S public  subroutine QUEST_Read_Class (IPT, IPT2, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: IPT integer, intent(in) :: IPT2 type( Struct ), intent(inout) :: S public  subroutine QUEST_Read_Phase (IPT, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: IPT type( Struct ), intent(inout) :: S","tags":"","loc":"module/dqmc_geom.html"},{"title":"DQMC_TDM1 – Quest","text":"Uses DQMC_Util DQMC_STRUCT DQMC_GTAU module~~dqmc_tdm1~~UsesGraph module~dqmc_tdm1 DQMC_TDM1 module~dqmc_gtau DQMC_GTAU module~dqmc_tdm1->module~dqmc_gtau module~dqmc_struct DQMC_STRUCT module~dqmc_tdm1->module~dqmc_struct module~dqmc_util DQMC_Util module~dqmc_tdm1->module~dqmc_util module~dqmc_gtau->module~dqmc_util module~dqmc_gfun DQMC_GFun module~dqmc_gtau->module~dqmc_gfun module~dqmc_matb DQMC_MATB module~dqmc_gtau->module~dqmc_matb module~dqmc_seqb DQMC_SEQB module~dqmc_gtau->module~dqmc_seqb module~dqmc_wspace DQMC_WSpace module~dqmc_gtau->module~dqmc_wspace module~dqmc_struct->module~dqmc_util module~dqmc_cfg DQMC_Cfg module~dqmc_struct->module~dqmc_cfg module~dqmc_cfg->module~dqmc_util module~dqmc_gfun->module~dqmc_util module~dqmc_gfun->module~dqmc_matb module~dqmc_gfun->module~dqmc_seqb module~dqmc_gfun->module~dqmc_wspace module~dqmc_matb->module~dqmc_struct module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_wspace module~dqmc_seqb->module~dqmc_util module~dqmc_seqb->module~dqmc_matb module~dqmc_seqb->module~dqmc_wspace module~dqmc_wspace->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_tdm1~~UsedByGraph module~dqmc_tdm1 DQMC_TDM1 module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_tdm1 program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_tdm1 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: NTDMARRAY = 8 integer, public, parameter :: IGFUN = 1 integer, public, parameter :: IGFUP = 2 integer, public, parameter :: IGFDN = 3 integer, public, parameter :: ISPXX = 4 integer, public, parameter :: ISPZZ = 5 integer, public, parameter :: IDENS = 6 integer, public, parameter :: IPAIR = 7 integer, public, parameter :: ICOND = 8 character(len=12), public, parameter :: pname (NTDMARRAY) = (/\"Gfun        \", \"Gfun up     \", \"Gfun dn     \", \"SxSx        \", \"SzSz        \", \"Den-Den     \", \"S-wave      \", \"Conductivity\"/) Derived Types type, public :: tdmarray Components Type Visibility Attributes Name Initial integer, public :: n integer, public :: nclass integer, public :: nk integer, public :: np integer, public, pointer :: D (:,:) integer, public, pointer :: F (:) integer, public, pointer :: phase (:,:) complex(kind=wp), public, pointer :: ftk (:,:) complex(kind=wp), public, pointer :: ftw (:,:) real(kind=wp), public, pointer :: values (:,:,:) complex(kind=wp), public, pointer :: valuesk (:,:,:) real(kind=wp), public, pointer :: tlink (:,:) character(len=label_len), public, pointer :: clabel (:) type, public :: TDM1 Components Type Visibility Attributes Name Initial integer, public :: L integer, public :: nbin integer, public :: avg integer, public :: err integer, public :: idx integer, public :: tmp integer, public :: cnt logical, public :: compute = .false. real(kind=wp), public :: dtau real(kind=wp), public, pointer :: sgn (:) type( tdmarray ), public, pointer :: properties (:) complex(kind=wp), public, pointer :: ftwfer (:,:) complex(kind=wp), public, pointer :: ftwbos (:,:) Subroutines public  subroutine DQMC_TDM1_Init (L, dtau, T1, nBin, S, Gwrap) Arguments Type Intent Optional Attributes Name integer, intent(in) :: L real(kind=wp), intent(in) :: dtau type( TDM1 ), intent(inout) :: T1 integer, intent(in) :: nBin type( Struct ), intent(in) :: S type( GeomWrap ), intent(in) :: Gwrap public  subroutine DQMC_TDM1_InitFTw (T1) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 public  subroutine DQMC_TDM1_InitProp (T1, S, Gwrap, iprop) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 type( Struct ), intent(in) :: S type( GeomWrap ), intent(in) :: Gwrap integer, intent(in) :: iprop public  subroutine DQMC_TDM1_Free (T1) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 public  subroutine DQMC_TDM1_Meas (t1, tau) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: t1 type( Gtau ), intent(inout) :: tau public  subroutine DQMC_TDM1_Meas_Para (t1, pT1, tau, ptau) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: t1 type( TDM1 ), intent(inout) :: pT1 (:) type( Gtau ), intent(inout) :: tau type( Gtau ), intent(inout) :: ptau (:) public  subroutine DQMC_TDM1_Compute (T1, upt0, up0t, dnt0, dn0t, up00, uptt, dn00, dntt, it, i0) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 real(kind=wp), intent(in) :: upt0 (:,:) real(kind=wp), intent(in) :: up0t (:,:) real(kind=wp), intent(in) :: dnt0 (:,:) real(kind=wp), intent(in) :: dn0t (:,:) real(kind=wp), intent(in) :: up00 (:,:) real(kind=wp), intent(in) :: uptt (:,:) real(kind=wp), intent(in) :: dn00 (:,:) real(kind=wp), intent(in) :: dntt (:,:) integer, intent(in) :: it integer, intent(in) :: i0 public  subroutine DQMC_TDM1_Avg (T1) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 public  subroutine DQMC_TDM1_GetErr (T1) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 public  subroutine DQMC_TDM1_Print (T1, OPT) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(in) :: T1 integer, intent(in) :: OPT public  subroutine DQMC_TDM1_GetKFT (T1) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 public  subroutine DQMC_TDM1_GetErrKFT (T1) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(inout) :: T1 public  subroutine DQMC_TDM1_PrintKFT (T1, OPT) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(in) :: T1 integer, intent(in) :: OPT public  subroutine DQMC_TDM1_SelfEnergy (T1, tau, OPT) Arguments Type Intent Optional Attributes Name type( TDM1 ), intent(in) :: T1 type( Gtau ), intent(inout) :: tau integer, intent(in) :: OPT","tags":"","loc":"module/dqmc_tdm1.html"},{"title":"DQMC_LATT – Quest","text":"Loop over cell Uses DQMC_Util DQMC_GEOM_PARAM module~~dqmc_latt~~UsesGraph module~dqmc_latt DQMC_LATT module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_latt->module~dqmc_geom_param module~dqmc_util DQMC_Util module~dqmc_latt->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~dqmc_latt~~UsedByGraph module~dqmc_latt DQMC_LATT module~dqmc_bonds DQMC_BONDS module~dqmc_bonds->module~dqmc_latt module~dqmc_geom_wrap DQMC_GEOM_WRAP module~dqmc_geom_wrap->module~dqmc_latt module~dqmc_geom_wrap->module~dqmc_bonds module~dqmc_hamilt DQMC_HAMILT module~dqmc_geom_wrap->module~dqmc_hamilt module~dqmc_reclatt DQMC_RECLATT module~dqmc_geom_wrap->module~dqmc_reclatt module~dqmc_hamilt->module~dqmc_latt module~dqmc_hamilt->module~dqmc_reclatt module~dqmc_reclatt->module~dqmc_latt proc~construct_lattice_classes DQMC_SYMM::construct_lattice_classes proc~construct_lattice_classes->module~dqmc_latt proc~init_kbonds DQMC_KBONDS::init_kbonds proc~init_kbonds->module~dqmc_latt proc~map_symm_lattice DQMC_SYMM::map_symm_lattice proc~map_symm_lattice->module~dqmc_latt proc~map_symm_lattice->module~dqmc_hamilt module~dqmc_kbonds DQMC_KBONDS module~dqmc_kbonds->module~dqmc_reclatt module~dqmc_phy2 DQMC_Phy2 module~dqmc_phy2->module~dqmc_bonds proc~construct_bond_classes DQMC_SYMM::construct_bond_classes proc~construct_bond_classes->module~dqmc_bonds proc~construct_pair_classes DQMC_SYMM::construct_pair_classes proc~construct_pair_classes->module~dqmc_bonds proc~construct_recip_lattice_classes DQMC_SYMM::construct_recip_lattice_classes proc~construct_recip_lattice_classes->module~dqmc_reclatt proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_init->module~dqmc_geom_wrap proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_initprop->module~dqmc_geom_wrap proc~map_symm_bonds DQMC_SYMM::map_symm_bonds proc~map_symm_bonds->module~dqmc_bonds proc~map_symm_pairs DQMC_SYMM::map_symm_pairs proc~map_symm_pairs->module~dqmc_bonds proc~map_symm_recip_lattice DQMC_SYMM::map_symm_recip_lattice proc~map_symm_recip_lattice->module~dqmc_reclatt program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_geom_wrap module~dqmc_hubbard DQMC_Hubbard program~dqmc_ggeom->module~dqmc_hubbard module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_phy2 module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_phy2 module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_hubbard proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_hubbard program~dqmc_verify->module~dqmc_2dperl program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: lattice_t Components Type Visibility Attributes Name Initial integer, public :: nsites integer, public :: natom integer, public :: ncell integer, public :: ndim integer, public :: sc (rdim,rdim) real(kind=8), public :: ac (rdim,rdim) real(kind=8), public :: scc (rdim,rdim) real(kind=8), public, pointer :: pos (:,:) real(kind=8), public, pointer :: cartpos (:,:) real(kind=8), public, pointer :: xat (:,:) real(kind=8), public, pointer :: phase (:) real(kind=8), public, pointer :: translation (:,:) Read more… integer, public :: nclass integer, public, pointer :: myclass (:,:) integer, public, pointer :: class_size (:) real(kind=8), public, pointer :: class_label (:,:) integer, public, pointer :: gf_phase (:,:) character(len=3), public, pointer :: olabel (:) logical, public :: initialized logical, public :: constructed logical, public :: analyzed Functions public  function count_atom () result(natom) Arguments None Return Value integer public  function hoptowho (iat, delta, jat, lattice) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iat real(kind=8), intent(in) :: delta (rdim) integer, intent(in) :: jat type( lattice_t ), intent(in) :: lattice Return Value integer Subroutines public  subroutine free_lattice (latt) Arguments Type Intent Optional Attributes Name type( lattice_t ), intent(inout) :: latt public  subroutine init_lattice (lattice, SOP) Arguments Type Intent Optional Attributes Name type( lattice_t ), target :: lattice integer, intent(in) :: SOP public  subroutine construct_lattice (lattice, SOP) Arguments Type Intent Optional Attributes Name type( lattice_t ), intent(inout), target :: lattice integer, intent(in) :: SOP public  subroutine convert_to_fractional (xat, ainv) Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: xat (rdim) real(kind=8), intent(in) :: ainv (rdim,rdim) public  subroutine assign_phase (lattice) Arguments Type Intent Optional Attributes Name type( lattice_t ) :: lattice public  subroutine assign_gf_phase (lattice, twist) Arguments Type Intent Optional Attributes Name type( lattice_t ), intent(inout) :: lattice real(kind=8), intent(in) :: twist (3)","tags":"","loc":"module/dqmc_latt.html"},{"title":"DQMC_Util – Quest","text":"Used by module~~dqmc_util~~UsedByGraph module~dqmc_util DQMC_Util module~dqmc_2dperl DQMC_2DPERL module~dqmc_2dperl->module~dqmc_util module~dqmc_cfg DQMC_Cfg module~dqmc_2dperl->module~dqmc_cfg module~dqmc_hubbard DQMC_Hubbard module~dqmc_2dperl->module~dqmc_hubbard module~dqmc_struct DQMC_STRUCT module~dqmc_2dperl->module~dqmc_struct module~dqmc_cfg->module~dqmc_util module~dqmc_checkerboard DQMC_CheckerBoard module~dqmc_checkerboard->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_checkerboard->module~dqmc_wspace module~dqmc_gfun DQMC_GFun module~dqmc_gfun->module~dqmc_util module~dqmc_matb DQMC_MATB module~dqmc_gfun->module~dqmc_matb module~dqmc_seqb DQMC_SEQB module~dqmc_gfun->module~dqmc_seqb module~dqmc_gfun->module~dqmc_wspace module~dqmc_gtau DQMC_GTAU module~dqmc_gtau->module~dqmc_util module~dqmc_gtau->module~dqmc_gfun module~dqmc_gtau->module~dqmc_matb module~dqmc_gtau->module~dqmc_seqb module~dqmc_gtau->module~dqmc_wspace module~dqmc_hubbard->module~dqmc_util module~dqmc_hubbard->module~dqmc_cfg module~dqmc_hubbard->module~dqmc_gfun module~dqmc_hubbard->module~dqmc_matb module~dqmc_phy0 DQMC_Phy0 module~dqmc_hubbard->module~dqmc_phy0 module~dqmc_phy2 DQMC_Phy2 module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_hubbard->module~dqmc_seqb module~dqmc_hubbard->module~dqmc_struct module~dqmc_hubbard~2 DQMC_Hubbard module~dqmc_hubbard~2->module~dqmc_util module~dqmc_hubbard~2->module~dqmc_cfg module~dqmc_hubbard~2->module~dqmc_gfun module~dqmc_hubbard~2->module~dqmc_matb module~dqmc_hubbard~2->module~dqmc_phy0 module~dqmc_hubbard~2->module~dqmc_phy2 module~dqmc_hubbard~2->module~dqmc_seqb module~dqmc_hubbard~2->module~dqmc_struct module~dqmc_latt DQMC_LATT module~dqmc_latt->module~dqmc_util module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_struct module~dqmc_matb->module~dqmc_wspace module~dqmc_phy0->module~dqmc_util module~dqmc_phy0->module~dqmc_struct module~dqmc_phy0->module~dqmc_wspace module~dqmc_phy2->module~dqmc_util module~dqmc_phy2->module~dqmc_struct module~dqmc_symm DQMC_SYMM module~dqmc_phy2->module~dqmc_symm module~dqmc_phy2->module~dqmc_wspace module~dqmc_bonds DQMC_BONDS module~dqmc_phy2->module~dqmc_bonds module~dqmc_seqb->module~dqmc_util module~dqmc_seqb->module~dqmc_matb module~dqmc_seqb->module~dqmc_wspace module~dqmc_struct->module~dqmc_util module~dqmc_struct->module~dqmc_cfg module~dqmc_symm->module~dqmc_util module~dqmc_tdm1 DQMC_TDM1 module~dqmc_tdm1->module~dqmc_util module~dqmc_tdm1->module~dqmc_gtau module~dqmc_tdm1->module~dqmc_struct module~dqmc_tdm2 DQMC_TDM2 module~dqmc_tdm2->module~dqmc_util module~dqmc_tdm2->module~dqmc_phy2 module~dqmc_tdm2->module~dqmc_struct module~dqmc_tdm2->module~dqmc_tdm1 module~dqmc_wspace->module~dqmc_util module~dqmc_bonds->module~dqmc_latt module~dqmc_geom DQMC_Geom module~dqmc_geom->module~dqmc_struct module~dqmc_geom_wrap DQMC_GEOM_WRAP module~dqmc_geom_wrap->module~dqmc_cfg module~dqmc_geom_wrap->module~dqmc_latt module~dqmc_geom_wrap->module~dqmc_struct module~dqmc_geom_wrap->module~dqmc_symm module~dqmc_geom_wrap->module~dqmc_bonds module~dqmc_hamilt DQMC_HAMILT module~dqmc_geom_wrap->module~dqmc_hamilt module~dqmc_reclatt DQMC_RECLATT module~dqmc_geom_wrap->module~dqmc_reclatt module~dqmc_hamilt->module~dqmc_cfg module~dqmc_hamilt->module~dqmc_latt module~dqmc_hamilt->module~dqmc_reclatt module~dqmc_reclatt->module~dqmc_cfg module~dqmc_reclatt->module~dqmc_latt proc~construct_lattice_classes DQMC_SYMM::construct_lattice_classes proc~construct_lattice_classes->module~dqmc_latt proc~dqmc_b_init~2 DQMC_CheckerBoard::DQMC_B_Init proc~dqmc_b_init~2->module~dqmc_struct proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init proc~dqmc_gtau_init->module~dqmc_hubbard proc~init_kbonds DQMC_KBONDS::init_kbonds proc~init_kbonds->module~dqmc_latt proc~init_kbonds->module~dqmc_symm proc~map_symm_lattice DQMC_SYMM::map_symm_lattice proc~map_symm_lattice->module~dqmc_latt proc~map_symm_lattice->module~dqmc_hamilt program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_cfg program~dqmc_ggeom->module~dqmc_hubbard program~dqmc_ggeom->module~dqmc_tdm1 program~dqmc_ggeom->module~dqmc_geom_wrap program~dqmc_test dqmc_test program~dqmc_test->module~dqmc_2dperl program~dqmc_verify dqmc_verify program~dqmc_verify->module~dqmc_2dperl program~dqmc_verify->module~dqmc_hubbard program~dqmc_verify->module~dqmc_phy0 program~dqmc_verify->module~dqmc_struct module~dqmc_kbonds DQMC_KBONDS module~dqmc_kbonds->module~dqmc_reclatt proc~construct_bond_classes DQMC_SYMM::construct_bond_classes proc~construct_bond_classes->module~dqmc_bonds proc~construct_pair_classes DQMC_SYMM::construct_pair_classes proc~construct_pair_classes->module~dqmc_bonds proc~construct_recip_lattice_classes DQMC_SYMM::construct_recip_lattice_classes proc~construct_recip_lattice_classes->module~dqmc_reclatt proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init proc~dqmc_tdm1_init->module~dqmc_geom_wrap proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_initprop->module~dqmc_geom_wrap proc~map_symm_bonds DQMC_SYMM::map_symm_bonds proc~map_symm_bonds->module~dqmc_bonds proc~map_symm_pairs DQMC_SYMM::map_symm_pairs proc~map_symm_pairs->module~dqmc_bonds proc~map_symm_recip_lattice DQMC_SYMM::map_symm_recip_lattice proc~map_symm_recip_lattice->module~dqmc_reclatt Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: WP = kind(1.0d0) real(kind=WP), public, parameter :: ZERO = 0.0D0 real(kind=WP), public, parameter :: ONE = 1.0D0 real(kind=WP), public, parameter :: TWO = 2.0D0 real(kind=WP), public, parameter :: HALF = 0.5D0 integer, public, parameter :: STDERR = 0 integer, public, parameter :: STDOUT = 6 integer, public, parameter :: STDIN = 5 character(len=*), public, parameter :: FMT_STRINT = \"(a30, i12)\" character(len=*), public, parameter :: FMT_STRDBL = \"(a30, f19.6)\" character(len=*), public, parameter :: FMT_STR2BL = \"(a30, '(', f11.6, ',', f11.6, ')')\" character(len=*), public, parameter :: FMT_VALERR = \"(a30, f12.6,' +- ',f12.6)\" character(len=*), public, parameter :: FMT_INTPAR = \"(i3,i3)\" character(len=*), public, parameter :: FMT_DBLINE = \"(76('='))\" character(len=*), public, parameter :: FMT_SGLINE = \"(76('-'))\" character(len=*), public, parameter :: FMT_POINT = \"('point ; dx=', i3, ' ; dy=', i3, ' :')\" integer, public, parameter :: DLARNV_UNI_0_1 = 1 integer, public, parameter :: DLARNV_UNI_N1_1 = 2 integer, public, parameter :: DLARNV_NORMAL = 3 Interfaces public        interface conjg public  function conjg_real (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), target :: x Return Value real(kind=8), pointer public  function conjg_real1 (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), target :: x (:) Return Value real(kind=8), pointer, (:) public  function conjg_real2 (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), target :: x (:,:) Return Value real(kind=8), pointer, (:,:) public        interface DQMC_JackKnife public  subroutine DQMC_JackKnife_Real (n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: avg real(kind=wp), intent(out) :: err real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(out) :: y (n) real(kind=wp), intent(out) :: sgn (n) real(kind=wp), intent(out) :: sum_sgn public  subroutine DQMC_JackKnife_Complex (n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(out) :: avg complex(kind=wp), intent(out) :: err complex(kind=wp), intent(in) :: x (n) complex(kind=wp), intent(out) :: y (n) complex(kind=wp), intent(out) :: sgn (n) complex(kind=wp), intent(out) :: sum_sgn public        interface DQMC_SignJackKnife public  subroutine DQMC_SignJackKnife_Real (n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: avg real(kind=wp), intent(out) :: err real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: sgn (:) real(kind=wp), intent(in) :: sum_sgn public  subroutine DQMC_SignJackKnife_Complex (n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(out) :: avg complex(kind=wp), intent(out) :: err complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) complex(kind=wp), intent(in) :: sgn (:) complex(kind=wp), intent(in) :: sum_sgn public        interface DQMC_Print_Array public  subroutine DQMC_Print_RealArray (n, m, title, label, avg, err, OPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in) :: title character(len=*), intent(in) :: label (:) real(kind=wp), intent(in) :: avg (:,:) real(kind=wp), intent(in) :: err (:,:) integer, intent(in) :: OPT public  subroutine DQMC_Print_ComplexArray (n, m, title, label, avg, err, OPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in) :: title character(len=*), intent(in) :: label (:) complex(kind=wp), intent(in) :: avg (:,:) complex(kind=wp), intent(in) :: err (:,:) integer, intent(in) :: OPT Functions public  function conjg_real (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), target :: x Return Value real(kind=8), pointer public  function conjg_real1 (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), target :: x (:) Return Value real(kind=8), pointer, (:) public  function conjg_real2 (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), target :: x (:,:) Return Value real(kind=8), pointer, (:,:) public  function DQMC_MatDiff (n, A, B) result(diff) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(in) :: A (n,n) real(kind=WP), intent(in) :: B (n,n) Return Value real(kind=WP) public  function DQMC_MatNorm (n, A) result(norm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(in) :: A (n,n) Return Value real(kind=WP) public  function intran (L, seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: L integer, intent(inout) :: seed (4) Return Value integer public  function move_to_record (string, iunit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: iunit Return Value logical public  function get_det (a) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) Return Value real(kind=wp) Subroutines public  subroutine DQMC_Eye (n, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(inout) :: A (n,n) public  subroutine DQMC_Trans (n, At, A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(inout) :: At (n,n) real(kind=wp), intent(in) :: A (n,n) decide the sgn of det(Q) public  subroutine DQMC_ScaleCol (n, A, D) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(inout) :: A (n,n) real(kind=WP), intent(in) :: D (n) public  subroutine DQMC_ScaleRow (n, A, D) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(inout) :: A (n,n) real(kind=WP), intent(in) :: D (n) public  subroutine DQMC_ScaleColInv (n, A, D) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(inout) :: A (n,n) real(kind=WP), intent(in) :: D (n) public  subroutine DQMC_ScaleRowInv (n, A, D) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=WP), intent(inout) :: A (n,n) real(kind=WP), intent(in) :: D (n) public  subroutine DQMC_SignJackKnife_Real (n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: avg real(kind=wp), intent(out) :: err real(kind=wp), intent(in) :: x (:) real(kind=wp), intent(inout) :: y (:) real(kind=wp), intent(in) :: sgn (:) real(kind=wp), intent(in) :: sum_sgn public  subroutine DQMC_SignJackKnife_Complex (n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(out) :: avg complex(kind=wp), intent(out) :: err complex(kind=wp), intent(in) :: x (:) complex(kind=wp), intent(inout) :: y (:) complex(kind=wp), intent(in) :: sgn (:) complex(kind=wp), intent(in) :: sum_sgn public  subroutine DQMC_JackKnife_Real (n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: avg real(kind=wp), intent(out) :: err real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(out) :: y (n) real(kind=wp), intent(out) :: sgn (n) real(kind=wp), intent(out) :: sum_sgn public  subroutine DQMC_JackKnife_Complex (n, avg, err, x, y, sgn, sum_sgn) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=wp), intent(out) :: avg complex(kind=wp), intent(out) :: err complex(kind=wp), intent(in) :: x (n) complex(kind=wp), intent(out) :: y (n) complex(kind=wp), intent(out) :: sgn (n) complex(kind=wp), intent(out) :: sum_sgn public  subroutine DQMC_GetErr (n, err, avg, list) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: err real(kind=wp), intent(in) :: avg real(kind=wp), intent(inout) :: list (n) public  subroutine DQMC_GetErr1 (n, data, avg, err) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: data (n) real(kind=wp), intent(out) :: avg real(kind=wp), intent(out) :: err public  subroutine DQMC_GetErr2 (n, sm, ssq, avg, err) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: sm real(kind=wp), intent(in) :: ssq real(kind=wp), intent(out) :: avg real(kind=wp), intent(out) :: err public  subroutine DQMC_Error (message, no) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message integer, intent(in) :: no public  subroutine DQMC_Warning (message, no) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message integer, intent(in) :: no public  subroutine ran0 (n, var, seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: var (n) integer, intent(inout) :: seed (4) public  subroutine ran1 (n, var, seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: var (n) integer, intent(inout) :: seed (4) public  subroutine ranN (n, var, seed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(out) :: var (n) integer, intent(inout) :: seed (4) public  subroutine dumpA (m, n, A, OPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: A (1:m,1:n) integer, intent(in) :: OPT public  subroutine DQMC_Print_RealArray (n, m, title, label, avg, err, OPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in) :: title character(len=*), intent(in) :: label (:) real(kind=wp), intent(in) :: avg (:,:) real(kind=wp), intent(in) :: err (:,:) integer, intent(in) :: OPT public  subroutine DQMC_Print_ComplexArray (n, m, title, label, avg, err, OPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in) :: title character(len=*), intent(in) :: label (:) complex(kind=wp), intent(in) :: avg (:,:) complex(kind=wp), intent(in) :: err (:,:) integer, intent(in) :: OPT public  subroutine DQMC_Print_EigenMode (n, m, title, value, OPT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: m character(len=*), intent(in) :: title complex(kind=16), intent(in) :: value (:,:,:) integer, intent(in) :: OPT public  subroutine dqmc_getFTk (value, n, nclass, class, na, nk, ft_wgt, phase, valuek) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: value (nclass) integer, intent(in) :: n integer, intent(in) :: nclass integer, intent(in) :: class (n,n) integer, intent(in) :: na integer, intent(in) :: nk complex(kind=wp), intent(in) :: ft_wgt (n/na,nk) integer, intent(in) :: phase (n,n) complex(kind=wp), intent(out) :: valuek (nk*na*(na+1)/2) public  subroutine DQMC_IO_open (fname, INP_UNIT, OUT_UNIT) Arguments Type Intent Optional Attributes Name character(len=60), intent(out) :: fname integer, intent(out) :: INP_UNIT integer, intent(out) :: OUT_UNIT public  subroutine DQMC_open_file (fname, fstatus, FILE_UNIT) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname character(len=*), intent(in) :: fstatus integer, intent(out) :: FILE_UNIT public  subroutine DQMC_count_records (n, FILE_UNIT) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n integer, intent(in) :: FILE_UNIT public  subroutine get_inverse (a, inv) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (3,3) real(kind=wp), intent(out) :: inv (3,3)","tags":"","loc":"module/dqmc_util.html"},{"title":"DQMC_OMP – Quest","text":"Used by module~~dqmc_omp~~UsedByGraph module~dqmc_omp DQMC_OMP program~dqmc_ggeom dqmc_ggeom program~dqmc_ggeom->module~dqmc_omp Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine DQMC_OMP_Init (nproc) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: nproc","tags":"","loc":"module/dqmc_omp.html"},{"title":"dqmc_test – Quest","text":"Uses DQMC_MPI DQMC_2DPERL program~~dqmc_test~~UsesGraph program~dqmc_test dqmc_test module~dqmc_2dperl DQMC_2DPERL program~dqmc_test->module~dqmc_2dperl module~dqmc_mpi DQMC_MPI program~dqmc_test->module~dqmc_mpi module~dqmc_2dperl->module~dqmc_mpi module~dqmc_cfg DQMC_Cfg module~dqmc_2dperl->module~dqmc_cfg module~dqmc_hubbard DQMC_Hubbard module~dqmc_2dperl->module~dqmc_hubbard module~dqmc_struct DQMC_STRUCT module~dqmc_2dperl->module~dqmc_struct module~dqmc_util DQMC_Util module~dqmc_2dperl->module~dqmc_util module~dqmc_cfg->module~dqmc_util module~dqmc_hubbard->module~dqmc_cfg module~dqmc_hubbard->module~dqmc_struct module~dqmc_hubbard->module~dqmc_util module~dqmc_gfun DQMC_GFun module~dqmc_hubbard->module~dqmc_gfun module~dqmc_matb DQMC_MATB module~dqmc_hubbard->module~dqmc_matb module~dqmc_phy0 DQMC_Phy0 module~dqmc_hubbard->module~dqmc_phy0 module~dqmc_phy2 DQMC_Phy2 module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_seqb DQMC_SEQB module~dqmc_hubbard->module~dqmc_seqb module~dqmc_struct->module~dqmc_cfg module~dqmc_struct->module~dqmc_util module~dqmc_gfun->module~dqmc_util module~dqmc_gfun->module~dqmc_matb module~dqmc_gfun->module~dqmc_seqb module~dqmc_wspace DQMC_WSpace module~dqmc_gfun->module~dqmc_wspace module~dqmc_matb->module~dqmc_struct module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_wspace module~dqmc_phy0->module~dqmc_struct module~dqmc_phy0->module~dqmc_util module~dqmc_phy0->module~dqmc_wspace module~dqmc_phy2->module~dqmc_struct module~dqmc_phy2->module~dqmc_util module~dqmc_bonds DQMC_BONDS module~dqmc_phy2->module~dqmc_bonds module~dqmc_symm DQMC_SYMM module~dqmc_phy2->module~dqmc_symm module~dqmc_phy2->module~dqmc_wspace module~dqmc_seqb->module~dqmc_util module~dqmc_seqb->module~dqmc_matb module~dqmc_seqb->module~dqmc_wspace module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_symm->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_wspace->module~dqmc_util module~dqmc_latt->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~dqmc_test~~CallsGraph program~dqmc_test dqmc_test proc~dqmc_comp_2dperl DQMC_2DPERL::DQMC_Comp_2DPerl program~dqmc_test->proc~dqmc_comp_2dperl proc~dqmc_mpi_init DQMC_MPI::DQMC_MPI_Init program~dqmc_test->proc~dqmc_mpi_init interface~cfg_get DQMC_Cfg::CFG_Get proc~dqmc_comp_2dperl->interface~cfg_get interface~dqmc_phy2_avg DQMC_Phy2::DQMC_Phy2_avg proc~dqmc_comp_2dperl->interface~dqmc_phy2_avg proc~dqmc_config_free DQMC_Cfg::DQMC_Config_Free proc~dqmc_comp_2dperl->proc~dqmc_config_free proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config proc~dqmc_comp_2dperl->proc~dqmc_hub_config proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free proc~dqmc_comp_2dperl->proc~dqmc_hub_free proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas proc~dqmc_comp_2dperl->proc~dqmc_hub_meas proc~dqmc_hub_print DQMC_Hubbard::DQMC_Hub_Print proc~dqmc_comp_2dperl->proc~dqmc_hub_print proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_comp_2dperl->proc~dqmc_hub_sweep2 proc~dqmc_init_2dperl DQMC_2DPERL::DQMC_Init_2DPerl proc~dqmc_comp_2dperl->proc~dqmc_init_2dperl proc~dqmc_open_file DQMC_Util::DQMC_open_file proc~dqmc_comp_2dperl->proc~dqmc_open_file proc~dqmc_phy0_avg DQMC_Phy0::DQMC_Phy0_Avg proc~dqmc_comp_2dperl->proc~dqmc_phy0_avg proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_comp_2dperl->proc~dqmc_phy0_geterr proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_comp_2dperl->proc~dqmc_phy2_geterr proc~dqmc_read_config DQMC_Cfg::DQMC_Read_Config proc~dqmc_comp_2dperl->proc~dqmc_read_config proc~ran0 DQMC_Util::ran0 proc~dqmc_comp_2dperl->proc~ran0 proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI interface~cfg_get->proc~dqmc_config_geti proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI interface~cfg_get->proc~dqmc_config_getpi proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR interface~cfg_get->proc~dqmc_config_getpr proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR interface~cfg_get->proc~dqmc_config_getr proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS interface~cfg_get->proc~dqmc_config_gets proc~dqmc_phy2_avg_symm DQMC_Phy2::DQMC_Phy2_Avg_Symm interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_symm proc~dqmc_phy2_avg_wave DQMC_Phy2::DQMC_Phy2_Avg_Wave interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_wave proc~dqmc_hub_config->interface~cfg_get interface~cfg_set DQMC_Cfg::CFG_Set proc~dqmc_hub_config->interface~cfg_set proc~dqmc_config_isset DQMC_Cfg::DQMC_Config_isSet proc~dqmc_hub_config->proc~dqmc_config_isset proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_hub_config->proc~dqmc_warning proc~dqmc_b_free DQMC_MATB::DQMC_B_Free proc~dqmc_hub_free->proc~dqmc_b_free proc~dqmc_gfun_free DQMC_GFun::DQMC_Gfun_Free proc~dqmc_hub_free->proc~dqmc_gfun_free proc~dqmc_phy0_free DQMC_Phy0::DQMC_Phy0_Free proc~dqmc_hub_free->proc~dqmc_phy0_free proc~dqmc_phy2_free DQMC_Phy2::DQMC_Phy2_Free proc~dqmc_hub_free->proc~dqmc_phy2_free proc~dqmc_seqb_free DQMC_SEQB::DQMC_SeqB_Free proc~dqmc_hub_free->proc~dqmc_seqb_free proc~dqmc_struct_free DQMC_STRUCT::DQMC_Struct_Free proc~dqmc_hub_free->proc~dqmc_struct_free proc~dqmc_wspace_free DQMC_WSpace::DQMC_WSpace_Free proc~dqmc_hub_free->proc~dqmc_wspace_free proc~dqmc_hub_meas->proc~ran0 proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_meas->proc~dqmc_getg_2nd_order proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_meas->proc~dqmc_gfun_clone proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_meas->proc~dqmc_gfun_copyup proc~dqmc_gfun_duplicate DQMC_GFun::DQMC_GFun_Duplicate proc~dqmc_hub_meas->proc~dqmc_gfun_duplicate proc~dqmc_hub_meas->proc~dqmc_gfun_free proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_meas->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_meas->proc~dqmc_phy2_meas proc~dqmc_hub_outputparam DQMC_Hubbard::DQMC_Hub_OutputParam proc~dqmc_hub_print->proc~dqmc_hub_outputparam proc~dqmc_phy0_print DQMC_Phy0::DQMC_Phy0_Print proc~dqmc_hub_print->proc~dqmc_phy0_print proc~dqmc_phy2_print DQMC_Phy2::DQMC_Phy2_Print proc~dqmc_hub_print->proc~dqmc_phy2_print proc~dqmc_hub_sweep->proc~ran0 proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate proc~dqmc_hub_sweep->proc~dqmc_applyupdate proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep->proc~dqmc_getg_2nd_order proc~dqmc_hub_sweep->proc~dqmc_gfun_copyup proc~dqmc_gfun_getjj DQMC_GFun::DQMC_Gfun_Getjj proc~dqmc_hub_sweep->proc~dqmc_gfun_getjj proc~dqmc_hub_sweep->proc~dqmc_phy0_meas proc~dqmc_hub_sweep->proc~dqmc_phy2_meas proc~dqmc_syncwraps DQMC_GFun::DQMC_SyncWraps proc~dqmc_hub_sweep->proc~dqmc_syncwraps proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG proc~dqmc_hub_sweep->proc~dqmc_updateg proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps proc~dqmc_hub_sweep->proc~dqmc_updatewraps proc~dqmc_hub_sweep2->proc~ran0 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2->proc~dqmc_gfun_copyup proc~dqmc_2dperl_dc_imp1 DQMC_2DPERL::DQMC_2DPerl_DC_Imp1 proc~dqmc_init_2dperl->proc~dqmc_2dperl_dc_imp1 proc~dqmc_2dperl_dc_imp2 DQMC_2DPERL::DQMC_2DPerl_DC_Imp2 proc~dqmc_init_2dperl->proc~dqmc_2dperl_dc_imp2 proc~dqmc_ccs_compress DQMC_STRUCT::DQMC_CCS_Compress proc~dqmc_init_2dperl->proc~dqmc_ccs_compress blas_dscal blas_dscal proc~dqmc_phy0_avg->blas_dscal proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_phy0_avg->proc~dqmc_error interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife proc~dqmc_phy0_geterr->interface~dqmc_jackknife interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife proc~dqmc_phy0_geterr->interface~dqmc_signjackknife proc~dqmc_phy2_geterr->interface~dqmc_jackknife proc~dqmc_phy2_geterr->interface~dqmc_signjackknife proc~dqmc_read_config->proc~dqmc_open_file proc~dqmc_default_def DQMC_Cfg::DQMC_Default_Def proc~dqmc_read_config->proc~dqmc_default_def proc~dqmc_read_config->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_read_config->proc~dqmc_find_param proc~dqmc_read_def DQMC_Cfg::DQMC_Read_Def proc~dqmc_read_config->proc~dqmc_read_def proc~dqmc_read_config->proc~dqmc_warning dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_config_seti DQMC_Cfg::DQMC_Config_SetI interface~cfg_set->proc~dqmc_config_seti proc~dqmc_config_setpi DQMC_Cfg::DQMC_Config_SetPI interface~cfg_set->proc~dqmc_config_setpi proc~dqmc_config_setpr DQMC_Cfg::DQMC_Config_SetPR interface~cfg_set->proc~dqmc_config_setpr proc~dqmc_config_setr DQMC_Cfg::DQMC_Config_SetR interface~cfg_set->proc~dqmc_config_setr proc~dqmc_config_sets DQMC_Cfg::DQMC_Config_SetS interface~cfg_set->proc~dqmc_config_sets proc~dqmc_jackknife_complex DQMC_Util::DQMC_JackKnife_Complex interface~dqmc_jackknife->proc~dqmc_jackknife_complex proc~dqmc_jackknife_real DQMC_Util::DQMC_JackKnife_Real interface~dqmc_jackknife->proc~dqmc_jackknife_real proc~dqmc_signjackknife_complex DQMC_Util::DQMC_SignJackKnife_Complex interface~dqmc_signjackknife->proc~dqmc_signjackknife_complex proc~dqmc_signjackknife_real DQMC_Util::DQMC_SignJackKnife_Real interface~dqmc_signjackknife->proc~dqmc_signjackknife_real blas_dgemm blas_dgemm proc~dqmc_applyupdate->blas_dgemm proc~dqmc_ccs_compress->proc~dqmc_error proc~dqmc_config_geti->proc~dqmc_error proc~dqmc_config_geti->proc~dqmc_find_param proc~dqmc_config_geti->proc~dqmc_warning proc~dqmc_config_getpi->proc~dqmc_error proc~dqmc_config_getpi->proc~dqmc_find_param proc~dqmc_config_getpi->proc~dqmc_warning proc~dqmc_config_getpr->proc~dqmc_error proc~dqmc_config_getpr->proc~dqmc_find_param proc~dqmc_config_getpr->proc~dqmc_warning proc~dqmc_config_getr->proc~dqmc_error proc~dqmc_config_getr->proc~dqmc_find_param proc~dqmc_config_getr->proc~dqmc_warning proc~dqmc_config_gets->proc~dqmc_error proc~dqmc_config_gets->proc~dqmc_find_param proc~dqmc_config_gets->proc~dqmc_warning proc~dqmc_config_isset->proc~dqmc_error proc~dqmc_config_isset->proc~dqmc_find_param blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right blas_ddot blas_ddot proc~dqmc_gfun_getjj->blas_ddot proc~dqmc_hub_init->proc~ran0 proc~dqmc_hub_init->proc~dqmc_error proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init->proc~dqmc_gfun_clone proc~dqmc_hub_init->proc~dqmc_warning proc~dqmc_b_init DQMC_MATB::DQMC_B_Init proc~dqmc_hub_init->proc~dqmc_b_init proc~dqmc_gfun_init DQMC_GFun::DQMC_GFun_Init proc~dqmc_hub_init->proc~dqmc_gfun_init proc~dqmc_hub_init_vmat DQMC_Hubbard::DQMC_Hub_Init_Vmat proc~dqmc_hub_init->proc~dqmc_hub_init_vmat proc~dqmc_hub_input_hsf DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_init->proc~dqmc_hub_input_hsf proc~dqmc_phy0_init DQMC_Phy0::DQMC_Phy0_Init proc~dqmc_hub_init->proc~dqmc_phy0_init proc~dqmc_phy2_init DQMC_Phy2::DQMC_Phy2_Init proc~dqmc_hub_init->proc~dqmc_phy2_init proc~dqmc_seqb_init DQMC_SEQB::DQMC_SeqB_Init proc~dqmc_hub_init->proc~dqmc_seqb_init proc~dqmc_wspace_allocate DQMC_WSpace::DQMC_WSpace_Allocate proc~dqmc_hub_init->proc~dqmc_wspace_allocate proc~ran1 DQMC_Util::ran1 proc~dqmc_hub_init->proc~ran1 proc~dqmc_hub_outputparam->proc~dqmc_warning proc~dqmc_hub_output_hsf DQMC_Hubbard::DQMC_Hub_Output_HSF proc~dqmc_hub_outputparam->proc~dqmc_hub_output_hsf blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray proc~dqmc_phy0_print->proc~dqmc_print_realarray proc~dqmc_pair_symm DQMC_Phy2::DQMC_Pair_Symm proc~dqmc_phy2_avg_symm->proc~dqmc_pair_symm proc~dqmc_wave_avg DQMC_Phy2::DQMC_Wave_Avg proc~dqmc_phy2_avg_wave->proc~dqmc_wave_avg proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair proc~dqmc_phy2_print->proc~dqmc_print_realarray proc~dqmc_readln DQMC_Cfg::DQMC_ReadLn proc~dqmc_read_def->proc~dqmc_readln proc~dqmc_ccs_free DQMC_STRUCT::DQMC_CCS_Free proc~dqmc_struct_free->proc~dqmc_ccs_free proc~dqmc_updateg->blas_dscal proc~dqmc_updateg->proc~dqmc_applyupdate blas_dgemv blas_dgemv proc~dqmc_updateg->blas_dgemv proc~dqmc_b_expinit DQMC_MATB::DQMC_B_ExpInit proc~dqmc_b_init->proc~dqmc_b_expinit proc~dqmc_computeg->proc~dqmc_error proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_config_seti->proc~dqmc_error proc~dqmc_config_seti->proc~dqmc_find_param proc~dqmc_config_setpi->proc~dqmc_error proc~dqmc_config_setpi->proc~dqmc_find_param proc~dqmc_config_setpr->proc~dqmc_error proc~dqmc_config_setpr->proc~dqmc_find_param proc~dqmc_config_setr->proc~dqmc_error proc~dqmc_config_setr->proc~dqmc_find_param proc~dqmc_config_sets->proc~dqmc_error proc~dqmc_config_sets->proc~dqmc_find_param proc~dqmc_hub_input_hsf->proc~dqmc_error proc~dqmc_multb_left->blas_dscal proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->blas_dgemm dexp dexp proc~dqmc_multb_left->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv proc~dqmc_wave_avg->blas_ddot proc~dqmc_wave_avg->blas_dgemm lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_wspace_allocate->lapack_dgeqp3 lapack_dgetri lapack_dgetri proc~dqmc_wspace_allocate->lapack_dgetri lapack_dorgqr lapack_dorgqr proc~dqmc_wspace_allocate->lapack_dorgqr lapack_dormqr lapack_dormqr proc~dqmc_wspace_allocate->lapack_dormqr proc~dqmc_wspace_allocate->lapack_dsyev proc~ran1->dlarnv proc~dqmc_b_expinit->blas_dscal proc~dqmc_b_expinit->proc~dqmc_error proc~dqmc_b_expinit->blas_dgemm proc~dqmc_b_expinit->dexp proc~dqmc_b_expinit->lapack_dsyev dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->lapack_dgeqp3 proc~dqmc_udtd->lapack_dorgqr blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->dexp proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer :: t1 integer :: t2 integer :: rate","tags":"","loc":"program/dqmc_test.html"},{"title":"dqmc_verify – Quest","text":"Uses DQMC_MPI DQMC_STRUCT DQMC_Phy0 DQMC_Hubbard DQMC_2DPERL program~~dqmc_verify~~UsesGraph program~dqmc_verify dqmc_verify module~dqmc_2dperl DQMC_2DPERL program~dqmc_verify->module~dqmc_2dperl module~dqmc_hubbard DQMC_Hubbard program~dqmc_verify->module~dqmc_hubbard module~dqmc_mpi DQMC_MPI program~dqmc_verify->module~dqmc_mpi module~dqmc_phy0 DQMC_Phy0 program~dqmc_verify->module~dqmc_phy0 module~dqmc_struct DQMC_STRUCT program~dqmc_verify->module~dqmc_struct module~dqmc_2dperl->module~dqmc_hubbard module~dqmc_2dperl->module~dqmc_mpi module~dqmc_2dperl->module~dqmc_struct module~dqmc_cfg DQMC_Cfg module~dqmc_2dperl->module~dqmc_cfg module~dqmc_util DQMC_Util module~dqmc_2dperl->module~dqmc_util module~dqmc_hubbard->module~dqmc_phy0 module~dqmc_hubbard->module~dqmc_struct module~dqmc_hubbard->module~dqmc_cfg module~dqmc_gfun DQMC_GFun module~dqmc_hubbard->module~dqmc_gfun module~dqmc_matb DQMC_MATB module~dqmc_hubbard->module~dqmc_matb module~dqmc_phy2 DQMC_Phy2 module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_seqb DQMC_SEQB module~dqmc_hubbard->module~dqmc_seqb module~dqmc_hubbard->module~dqmc_util module~dqmc_phy0->module~dqmc_struct module~dqmc_phy0->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_phy0->module~dqmc_wspace module~dqmc_struct->module~dqmc_cfg module~dqmc_struct->module~dqmc_util module~dqmc_cfg->module~dqmc_util module~dqmc_gfun->module~dqmc_matb module~dqmc_gfun->module~dqmc_seqb module~dqmc_gfun->module~dqmc_util module~dqmc_gfun->module~dqmc_wspace module~dqmc_matb->module~dqmc_struct module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_wspace module~dqmc_phy2->module~dqmc_struct module~dqmc_phy2->module~dqmc_util module~dqmc_phy2->module~dqmc_wspace module~dqmc_bonds DQMC_BONDS module~dqmc_phy2->module~dqmc_bonds module~dqmc_symm DQMC_SYMM module~dqmc_phy2->module~dqmc_symm module~dqmc_seqb->module~dqmc_matb module~dqmc_seqb->module~dqmc_util module~dqmc_seqb->module~dqmc_wspace module~dqmc_wspace->module~dqmc_util module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_bonds->module~dqmc_geom_param module~dqmc_latt DQMC_LATT module~dqmc_bonds->module~dqmc_latt module~dqmc_symm->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_latt->module~dqmc_util module~dqmc_latt->module~dqmc_geom_param Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~dqmc_verify~~CallsGraph program~dqmc_verify dqmc_verify proc~display dqmc_verify::Display program~dqmc_verify->proc~display proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free program~dqmc_verify->proc~dqmc_hub_free proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init program~dqmc_verify->proc~dqmc_hub_init proc~dqmc_hub_run DQMC_Hubbard::DQMC_Hub_Run program~dqmc_verify->proc~dqmc_hub_run proc~dqmc_init_2dperl DQMC_2DPERL::DQMC_Init_2DPerl program~dqmc_verify->proc~dqmc_init_2dperl proc~dqmc_mpi_init DQMC_MPI::DQMC_MPI_Init program~dqmc_verify->proc~dqmc_mpi_init proc~dqmc_phy0_getresult dqmc_verify::DQMC_Phy0_GetResult program~dqmc_verify->proc~dqmc_phy0_getresult proc~dqmc_b_free DQMC_MATB::DQMC_B_Free proc~dqmc_hub_free->proc~dqmc_b_free proc~dqmc_gfun_free DQMC_GFun::DQMC_Gfun_Free proc~dqmc_hub_free->proc~dqmc_gfun_free proc~dqmc_phy0_free DQMC_Phy0::DQMC_Phy0_Free proc~dqmc_hub_free->proc~dqmc_phy0_free proc~dqmc_phy2_free DQMC_Phy2::DQMC_Phy2_Free proc~dqmc_hub_free->proc~dqmc_phy2_free proc~dqmc_seqb_free DQMC_SEQB::DQMC_SeqB_Free proc~dqmc_hub_free->proc~dqmc_seqb_free proc~dqmc_struct_free DQMC_STRUCT::DQMC_Struct_Free proc~dqmc_hub_free->proc~dqmc_struct_free proc~dqmc_wspace_free DQMC_WSpace::DQMC_WSpace_Free proc~dqmc_hub_free->proc~dqmc_wspace_free proc~dqmc_b_init DQMC_MATB::DQMC_B_Init proc~dqmc_hub_init->proc~dqmc_b_init proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_hub_init->proc~dqmc_error proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_init->proc~dqmc_gfun_clone proc~dqmc_gfun_init DQMC_GFun::DQMC_GFun_Init proc~dqmc_hub_init->proc~dqmc_gfun_init proc~dqmc_hub_init_vmat DQMC_Hubbard::DQMC_Hub_Init_Vmat proc~dqmc_hub_init->proc~dqmc_hub_init_vmat proc~dqmc_hub_input_hsf DQMC_Hubbard::DQMC_Hub_Input_HSF proc~dqmc_hub_init->proc~dqmc_hub_input_hsf proc~dqmc_phy0_init DQMC_Phy0::DQMC_Phy0_Init proc~dqmc_hub_init->proc~dqmc_phy0_init proc~dqmc_phy2_init DQMC_Phy2::DQMC_Phy2_Init proc~dqmc_hub_init->proc~dqmc_phy2_init proc~dqmc_seqb_init DQMC_SEQB::DQMC_SeqB_Init proc~dqmc_hub_init->proc~dqmc_seqb_init proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_hub_init->proc~dqmc_warning proc~dqmc_wspace_allocate DQMC_WSpace::DQMC_WSpace_Allocate proc~dqmc_hub_init->proc~dqmc_wspace_allocate proc~ran0 DQMC_Util::ran0 proc~dqmc_hub_init->proc~ran0 proc~ran1 DQMC_Util::ran1 proc~dqmc_hub_init->proc~ran1 interface~dqmc_phy2_avg DQMC_Phy2::DQMC_Phy2_avg proc~dqmc_hub_run->interface~dqmc_phy2_avg proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep proc~dqmc_hub_run->proc~dqmc_hub_sweep proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 proc~dqmc_hub_run->proc~dqmc_hub_sweep2 proc~dqmc_phy0_avg DQMC_Phy0::DQMC_Phy0_Avg proc~dqmc_hub_run->proc~dqmc_phy0_avg proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr proc~dqmc_hub_run->proc~dqmc_phy0_geterr proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr proc~dqmc_hub_run->proc~dqmc_phy2_geterr proc~dqmc_2dperl_dc_imp1 DQMC_2DPERL::DQMC_2DPerl_DC_Imp1 proc~dqmc_init_2dperl->proc~dqmc_2dperl_dc_imp1 proc~dqmc_2dperl_dc_imp2 DQMC_2DPERL::DQMC_2DPerl_DC_Imp2 proc~dqmc_init_2dperl->proc~dqmc_2dperl_dc_imp2 proc~dqmc_ccs_compress DQMC_STRUCT::DQMC_CCS_Compress proc~dqmc_init_2dperl->proc~dqmc_ccs_compress proc~dqmc_phy2_avg_symm DQMC_Phy2::DQMC_Phy2_Avg_Symm interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_symm proc~dqmc_phy2_avg_wave DQMC_Phy2::DQMC_Phy2_Avg_Wave interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_wave proc~dqmc_b_expinit DQMC_MATB::DQMC_B_ExpInit proc~dqmc_b_init->proc~dqmc_b_expinit proc~dqmc_ccs_compress->proc~dqmc_error blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_getg->proc~dqmc_multbi_right proc~dqmc_hub_input_hsf->proc~dqmc_error proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep->proc~ran0 proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate proc~dqmc_hub_sweep->proc~dqmc_applyupdate proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_sweep->proc~dqmc_getg_2nd_order proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_sweep->proc~dqmc_gfun_copyup proc~dqmc_gfun_getjj DQMC_GFun::DQMC_Gfun_Getjj proc~dqmc_hub_sweep->proc~dqmc_gfun_getjj proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_sweep->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_sweep->proc~dqmc_phy2_meas proc~dqmc_syncwraps DQMC_GFun::DQMC_SyncWraps proc~dqmc_hub_sweep->proc~dqmc_syncwraps proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG proc~dqmc_hub_sweep->proc~dqmc_updateg proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps proc~dqmc_hub_sweep->proc~dqmc_updatewraps proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2->proc~ran0 proc~dqmc_hub_sweep2->proc~dqmc_gfun_copyup proc~dqmc_phy0_avg->proc~dqmc_error blas_dscal blas_dscal proc~dqmc_phy0_avg->blas_dscal interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife proc~dqmc_phy0_geterr->interface~dqmc_jackknife interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife proc~dqmc_phy0_geterr->interface~dqmc_signjackknife proc~dqmc_phy2_geterr->interface~dqmc_jackknife proc~dqmc_phy2_geterr->interface~dqmc_signjackknife proc~dqmc_ccs_free DQMC_STRUCT::DQMC_CCS_Free proc~dqmc_struct_free->proc~dqmc_ccs_free lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_wspace_allocate->lapack_dgeqp3 lapack_dgetri lapack_dgetri proc~dqmc_wspace_allocate->lapack_dgetri lapack_dorgqr lapack_dorgqr proc~dqmc_wspace_allocate->lapack_dorgqr lapack_dormqr lapack_dormqr proc~dqmc_wspace_allocate->lapack_dormqr lapack_dsyev lapack_dsyev proc~dqmc_wspace_allocate->lapack_dsyev dlarnv dlarnv proc~ran0->dlarnv proc~ran1->dlarnv proc~dqmc_jackknife_complex DQMC_Util::DQMC_JackKnife_Complex interface~dqmc_jackknife->proc~dqmc_jackknife_complex proc~dqmc_jackknife_real DQMC_Util::DQMC_JackKnife_Real interface~dqmc_jackknife->proc~dqmc_jackknife_real proc~dqmc_signjackknife_complex DQMC_Util::DQMC_SignJackKnife_Complex interface~dqmc_signjackknife->proc~dqmc_signjackknife_complex proc~dqmc_signjackknife_real DQMC_Util::DQMC_SignJackKnife_Real interface~dqmc_signjackknife->proc~dqmc_signjackknife_real blas_dgemm blas_dgemm proc~dqmc_applyupdate->blas_dgemm proc~dqmc_b_expinit->proc~dqmc_error proc~dqmc_b_expinit->blas_dscal proc~dqmc_b_expinit->lapack_dsyev proc~dqmc_b_expinit->blas_dgemm dexp dexp proc~dqmc_b_expinit->dexp proc~dqmc_computeg->proc~dqmc_error proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_computeg->blas_dcopy lapack_dgetrf lapack_dgetrf proc~dqmc_computeg->lapack_dgetrf lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_computeg->proc~dqmc_scalerow proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans blas_ddot blas_ddot proc~dqmc_gfun_getjj->blas_ddot proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->blas_dscal proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->blas_dgemm proc~dqmc_multb_left->dexp proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->dexp proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_pair_symm DQMC_Phy2::DQMC_Pair_Symm proc~dqmc_phy2_avg_symm->proc~dqmc_pair_symm proc~dqmc_wave_avg DQMC_Phy2::DQMC_Wave_Avg proc~dqmc_phy2_avg_wave->proc~dqmc_wave_avg proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_meas->proc~dqmc_phy2_pair proc~dqmc_updateg->blas_dscal proc~dqmc_updateg->proc~dqmc_applyupdate blas_dgemv blas_dgemv proc~dqmc_updateg->blas_dgemv dscal dscal proc~dqmc_scalecolinv->dscal proc~dqmc_scalerow->dscal proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_wave_avg->blas_ddot proc~dqmc_wave_avg->blas_dgemm proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->lapack_dgeqp3 proc~dqmc_udtd->lapack_dorgqr blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->blas_dgemm proc~dqmc_multb_right->dexp proc~dqmc_multb_right->proc~dqmc_scalecol proc~dqmc_scalecol->dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer, parameter :: nx = 4 integer, parameter :: ny = 4 integer, parameter :: N = nx*ny real(kind=wp), parameter :: t (4) = [0.3_wp, 0.6_wp, ONE, ZERO] real(kind=wp), parameter :: dtau = 0.125_wp real(kind=wp), parameter :: U (6) = [ONE, TWO, TWO*TWO, ZERO, -ONE, -TWO] real(kind=wp), parameter :: mu (3) = [HALF, ZERO, -HALF] integer, parameter :: L = 12 integer, parameter :: HSF_IPT = -1 integer, parameter :: n_t = 1 integer, parameter :: nWarm = 1000 integer, parameter :: nPass = 5000 integer, parameter :: nTry = 0 integer, parameter :: nmeas = 12 integer, parameter :: nBin = 10 integer, parameter :: tausk = 10 integer, parameter :: idum = 0 integer, parameter :: nOrth = 12 integer, parameter :: nWrap = 12 integer, parameter :: ssxx = 0 integer, parameter :: fixw = 0 real(kind=wp), parameter :: errrate = 0.001_wp real(kind=wp), parameter :: difflim = 0.001_wp character(len=*), parameter :: FMT_CMP = \"(a20,f10.6,'  |',f10.6,' +-',f10.6,'  |  ',f6.2,' :',f6.2)\" character(len=*), parameter :: FMT_CONFIG = \"('Parameters : ',4(a,' =',f6.2,', '))\" character(len=*), parameter :: FMT_TITLE = \"(20X,'Theoretical | Computed (avg +- error) |  |T-C| : error')\" real(kind=wp) :: t_up (4) real(kind=wp) :: t_dn (4) real(kind=wp) :: mu_up (3) real(kind=wp) :: mu_dn (3) type( Hubbard ) :: Hub integer :: i integer :: j integer :: k real(kind=wp) :: rho real(kind=wp) :: energy_total real(kind=wp) :: avg real(kind=wp) :: err real(kind=wp) :: one_site_occupancy real(kind=wp) :: tmp1 real(kind=wp) :: tmp2 real(kind=wp) :: tmp3 real(kind=wp) :: beta real(kind=wp) :: lambda (N) real(kind=wp) :: X (N) real :: t1 real :: t2 character(len=30) :: name integer :: cnt (0:3) Subroutines subroutine Display (name, theo, avg, err) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name real(kind=wp), intent(in) :: theo real(kind=wp), intent(in) :: avg real(kind=wp), intent(in) :: err subroutine DQMC_Phy0_GetResult (P0, meas, name, avg, err) Arguments Type Intent Optional Attributes Name type( Phy0 ), intent(in) :: P0 integer, intent(in) :: meas character(len=*), intent(inout) :: name real(kind=wp), intent(inout) :: avg real(kind=wp), intent(inout) :: err","tags":"","loc":"program/dqmc_verify.html"},{"title":"dqmc_ggeom – Quest","text":"Uses DQMC_MPI DQMC_TDM1 DQMC_GEOM_WRAP DQMC_Hubbard DQMC_Cfg DQMC_OMP program~~dqmc_ggeom~~UsesGraph program~dqmc_ggeom dqmc_ggeom module~dqmc_cfg DQMC_Cfg program~dqmc_ggeom->module~dqmc_cfg module~dqmc_geom_wrap DQMC_GEOM_WRAP program~dqmc_ggeom->module~dqmc_geom_wrap module~dqmc_hubbard DQMC_Hubbard program~dqmc_ggeom->module~dqmc_hubbard module~dqmc_mpi DQMC_MPI program~dqmc_ggeom->module~dqmc_mpi module~dqmc_omp DQMC_OMP program~dqmc_ggeom->module~dqmc_omp module~dqmc_tdm1 DQMC_TDM1 program~dqmc_ggeom->module~dqmc_tdm1 module~dqmc_util DQMC_Util module~dqmc_cfg->module~dqmc_util module~dqmc_geom_wrap->module~dqmc_cfg module~dqmc_bonds DQMC_BONDS module~dqmc_geom_wrap->module~dqmc_bonds module~dqmc_geom_param DQMC_GEOM_PARAM module~dqmc_geom_wrap->module~dqmc_geom_param module~dqmc_hamilt DQMC_HAMILT module~dqmc_geom_wrap->module~dqmc_hamilt module~dqmc_latt DQMC_LATT module~dqmc_geom_wrap->module~dqmc_latt module~dqmc_reclatt DQMC_RECLATT module~dqmc_geom_wrap->module~dqmc_reclatt module~dqmc_struct DQMC_STRUCT module~dqmc_geom_wrap->module~dqmc_struct module~dqmc_symm DQMC_SYMM module~dqmc_geom_wrap->module~dqmc_symm module~dqmc_hubbard->module~dqmc_cfg module~dqmc_gfun DQMC_GFun module~dqmc_hubbard->module~dqmc_gfun module~dqmc_matb DQMC_MATB module~dqmc_hubbard->module~dqmc_matb module~dqmc_phy0 DQMC_Phy0 module~dqmc_hubbard->module~dqmc_phy0 module~dqmc_phy2 DQMC_Phy2 module~dqmc_hubbard->module~dqmc_phy2 module~dqmc_seqb DQMC_SEQB module~dqmc_hubbard->module~dqmc_seqb module~dqmc_hubbard->module~dqmc_struct module~dqmc_hubbard->module~dqmc_util module~dqmc_gtau DQMC_GTAU module~dqmc_tdm1->module~dqmc_gtau module~dqmc_tdm1->module~dqmc_struct module~dqmc_tdm1->module~dqmc_util module~dqmc_bonds->module~dqmc_geom_param module~dqmc_bonds->module~dqmc_latt module~dqmc_gfun->module~dqmc_matb module~dqmc_gfun->module~dqmc_seqb module~dqmc_gfun->module~dqmc_util module~dqmc_wspace DQMC_WSpace module~dqmc_gfun->module~dqmc_wspace module~dqmc_gtau->module~dqmc_gfun module~dqmc_gtau->module~dqmc_matb module~dqmc_gtau->module~dqmc_seqb module~dqmc_gtau->module~dqmc_util module~dqmc_gtau->module~dqmc_wspace module~dqmc_hamilt->module~dqmc_cfg module~dqmc_hamilt->module~dqmc_geom_param module~dqmc_hamilt->module~dqmc_latt module~dqmc_hamilt->module~dqmc_reclatt module~dqmc_latt->module~dqmc_geom_param module~dqmc_latt->module~dqmc_util module~dqmc_matb->module~dqmc_struct module~dqmc_matb->module~dqmc_util module~dqmc_matb->module~dqmc_wspace module~dqmc_phy0->module~dqmc_struct module~dqmc_phy0->module~dqmc_util module~dqmc_phy0->module~dqmc_wspace module~dqmc_phy2->module~dqmc_bonds module~dqmc_phy2->module~dqmc_struct module~dqmc_phy2->module~dqmc_symm module~dqmc_phy2->module~dqmc_util module~dqmc_phy2->module~dqmc_wspace module~dqmc_reclatt->module~dqmc_cfg module~dqmc_reclatt->module~dqmc_geom_param module~dqmc_reclatt->module~dqmc_latt module~dqmc_seqb->module~dqmc_matb module~dqmc_seqb->module~dqmc_util module~dqmc_seqb->module~dqmc_wspace module~dqmc_struct->module~dqmc_cfg module~dqmc_struct->module~dqmc_util module~dqmc_symm->module~dqmc_geom_param module~dqmc_symm->module~dqmc_util module~dqmc_wspace->module~dqmc_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~dqmc_ggeom~~CallsGraph program~dqmc_ggeom dqmc_ggeom interface~cfg_get DQMC_Cfg::CFG_Get program~dqmc_ggeom->interface~cfg_get interface~dqmc_phy2_avg DQMC_Phy2::DQMC_Phy2_avg program~dqmc_ggeom->interface~dqmc_phy2_avg interface~dqmc_phy2_getirrep DQMC_Phy2::DQMC_Phy2_GetIrrep program~dqmc_ggeom->interface~dqmc_phy2_getirrep proc~dqmc_config_free DQMC_Cfg::DQMC_Config_Free program~dqmc_ggeom->proc~dqmc_config_free proc~dqmc_count_records DQMC_Util::DQMC_count_records program~dqmc_ggeom->proc~dqmc_count_records proc~dqmc_geom_fill DQMC_GEOM_WRAP::DQMC_Geom_Fill program~dqmc_ggeom->proc~dqmc_geom_fill proc~dqmc_geom_init DQMC_GEOM_WRAP::DQMC_Geom_Init program~dqmc_ggeom->proc~dqmc_geom_init proc~dqmc_geom_print DQMC_STRUCT::DQMC_Geom_Print program~dqmc_ggeom->proc~dqmc_geom_print proc~dqmc_geom_read_def DQMC_STRUCT::DQMC_Geom_Read_Def program~dqmc_ggeom->proc~dqmc_geom_read_def proc~dqmc_gtau_init DQMC_GTAU::DQMC_Gtau_Init program~dqmc_ggeom->proc~dqmc_gtau_init proc~dqmc_gtau_loada DQMC_GTAU::DQMC_Gtau_LoadA program~dqmc_ggeom->proc~dqmc_gtau_loada proc~dqmc_hub_config DQMC_Hubbard::DQMC_Hub_Config program~dqmc_ggeom->proc~dqmc_hub_config proc~dqmc_hub_free DQMC_Hubbard::DQMC_Hub_Free program~dqmc_ggeom->proc~dqmc_hub_free proc~dqmc_hub_fullmeas DQMC_Hubbard::DQMC_Hub_FullMeas program~dqmc_ggeom->proc~dqmc_hub_fullmeas proc~dqmc_hub_init_vmat DQMC_Hubbard::DQMC_Hub_Init_Vmat program~dqmc_ggeom->proc~dqmc_hub_init_vmat proc~dqmc_hub_input_hsf DQMC_Hubbard::DQMC_Hub_Input_HSF program~dqmc_ggeom->proc~dqmc_hub_input_hsf proc~dqmc_hub_meas DQMC_Hubbard::DQMC_Hub_Meas program~dqmc_ggeom->proc~dqmc_hub_meas proc~dqmc_hub_outputparam DQMC_Hubbard::DQMC_Hub_OutputParam program~dqmc_ggeom->proc~dqmc_hub_outputparam proc~dqmc_hub_sweep DQMC_Hubbard::DQMC_Hub_Sweep program~dqmc_ggeom->proc~dqmc_hub_sweep proc~dqmc_hub_sweep2 DQMC_Hubbard::DQMC_Hub_Sweep2 program~dqmc_ggeom->proc~dqmc_hub_sweep2 proc~dqmc_mpi_final DQMC_MPI::DQMC_MPI_Final program~dqmc_ggeom->proc~dqmc_mpi_final proc~dqmc_mpi_init DQMC_MPI::DQMC_MPI_Init program~dqmc_ggeom->proc~dqmc_mpi_init proc~dqmc_omp_init DQMC_OMP::DQMC_OMP_Init program~dqmc_ggeom->proc~dqmc_omp_init proc~dqmc_open_file DQMC_Util::DQMC_open_file program~dqmc_ggeom->proc~dqmc_open_file proc~dqmc_phy0_avg DQMC_Phy0::DQMC_Phy0_Avg program~dqmc_ggeom->proc~dqmc_phy0_avg proc~dqmc_phy0_geterr DQMC_Phy0::DQMC_Phy0_GetErr program~dqmc_ggeom->proc~dqmc_phy0_geterr proc~dqmc_phy0_geterrft DQMC_Phy0::DQMC_Phy0_GetErrFT program~dqmc_ggeom->proc~dqmc_phy0_geterrft proc~dqmc_phy0_getft DQMC_Phy0::DQMC_Phy0_GetFT program~dqmc_ggeom->proc~dqmc_phy0_getft proc~dqmc_phy0_print DQMC_Phy0::DQMC_Phy0_Print program~dqmc_ggeom->proc~dqmc_phy0_print proc~dqmc_phy0_printft DQMC_Phy0::DQMC_Phy0_PrintFT program~dqmc_ggeom->proc~dqmc_phy0_printft proc~dqmc_phy2_geterr DQMC_Phy2::DQMC_Phy2_GetErr program~dqmc_ggeom->proc~dqmc_phy2_geterr proc~dqmc_phy2_geterrirrep DQMC_Phy2::DQMC_Phy2_GetErrIrrep program~dqmc_ggeom->proc~dqmc_phy2_geterrirrep proc~dqmc_phy2_print DQMC_Phy2::DQMC_Phy2_Print program~dqmc_ggeom->proc~dqmc_phy2_print proc~dqmc_phy2_printsymm DQMC_Phy2::dqmc_phy2_PrintSymm program~dqmc_ggeom->proc~dqmc_phy2_printsymm proc~dqmc_phy2_wavesymm DQMC_Phy2::DQMC_phy2_WaveSymm program~dqmc_ggeom->proc~dqmc_phy2_wavesymm proc~dqmc_print_headerft DQMC_GEOM_WRAP::DQMC_Print_HeaderFT program~dqmc_ggeom->proc~dqmc_print_headerft proc~dqmc_read_config DQMC_Cfg::DQMC_Read_Config program~dqmc_ggeom->proc~dqmc_read_config proc~dqmc_tdm1_avg DQMC_TDM1::DQMC_TDM1_Avg program~dqmc_ggeom->proc~dqmc_tdm1_avg proc~dqmc_tdm1_free DQMC_TDM1::DQMC_TDM1_Free program~dqmc_ggeom->proc~dqmc_tdm1_free proc~dqmc_tdm1_geterr DQMC_TDM1::DQMC_TDM1_GetErr program~dqmc_ggeom->proc~dqmc_tdm1_geterr proc~dqmc_tdm1_geterrkft DQMC_TDM1::DQMC_TDM1_GetErrKFT program~dqmc_ggeom->proc~dqmc_tdm1_geterrkft proc~dqmc_tdm1_getkft DQMC_TDM1::DQMC_TDM1_GetKFT program~dqmc_ggeom->proc~dqmc_tdm1_getkft proc~dqmc_tdm1_init DQMC_TDM1::DQMC_TDM1_Init program~dqmc_ggeom->proc~dqmc_tdm1_init proc~dqmc_tdm1_meas DQMC_TDM1::DQMC_TDM1_Meas program~dqmc_ggeom->proc~dqmc_tdm1_meas proc~dqmc_tdm1_meas_para DQMC_TDM1::DQMC_TDM1_Meas_Para program~dqmc_ggeom->proc~dqmc_tdm1_meas_para proc~dqmc_tdm1_print DQMC_TDM1::DQMC_TDM1_Print program~dqmc_ggeom->proc~dqmc_tdm1_print proc~dqmc_tdm1_printkft DQMC_TDM1::DQMC_TDM1_PrintKFT program~dqmc_ggeom->proc~dqmc_tdm1_printkft proc~dqmc_tdm1_selfenergy DQMC_TDM1::DQMC_TDM1_SelfEnergy program~dqmc_ggeom->proc~dqmc_tdm1_selfenergy proc~ran0 DQMC_Util::ran0 program~dqmc_ggeom->proc~ran0 proc~dqmc_config_geti DQMC_Cfg::DQMC_Config_GetI interface~cfg_get->proc~dqmc_config_geti proc~dqmc_config_getpi DQMC_Cfg::DQMC_Config_GetPI interface~cfg_get->proc~dqmc_config_getpi proc~dqmc_config_getpr DQMC_Cfg::DQMC_Config_GetPR interface~cfg_get->proc~dqmc_config_getpr proc~dqmc_config_getr DQMC_Cfg::DQMC_Config_GetR interface~cfg_get->proc~dqmc_config_getr proc~dqmc_config_gets DQMC_Cfg::DQMC_Config_GetS interface~cfg_get->proc~dqmc_config_gets proc~dqmc_phy2_avg_symm DQMC_Phy2::DQMC_Phy2_Avg_Symm interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_symm proc~dqmc_phy2_avg_wave DQMC_Phy2::DQMC_Phy2_Avg_Wave interface~dqmc_phy2_avg->proc~dqmc_phy2_avg_wave proc~dqmc_phy2_getirrep_connected DQMC_Phy2::DQMC_Phy2_GetIrrep_Connected interface~dqmc_phy2_getirrep->proc~dqmc_phy2_getirrep_connected proc~dqmc_phy2_getirrep_full DQMC_Phy2::DQMC_Phy2_GetIrrep_Full interface~dqmc_phy2_getirrep->proc~dqmc_phy2_getirrep_full proc~analyze_input DQMC_GEOM_PARAM::analyze_input proc~dqmc_geom_fill->proc~analyze_input proc~assign_gf_phase DQMC_LATT::assign_gf_phase proc~dqmc_geom_fill->proc~assign_gf_phase proc~assign_phase DQMC_LATT::assign_phase proc~dqmc_geom_fill->proc~assign_phase proc~construct_bond_classes DQMC_SYMM::construct_bond_classes proc~dqmc_geom_fill->proc~construct_bond_classes proc~construct_hamilt DQMC_HAMILT::construct_hamilt proc~dqmc_geom_fill->proc~construct_hamilt proc~construct_lattice DQMC_LATT::construct_lattice proc~dqmc_geom_fill->proc~construct_lattice proc~construct_lattice_classes DQMC_SYMM::construct_lattice_classes proc~dqmc_geom_fill->proc~construct_lattice_classes proc~construct_pair_classes DQMC_SYMM::construct_pair_classes proc~dqmc_geom_fill->proc~construct_pair_classes proc~construct_pairs DQMC_BONDS::construct_pairs proc~dqmc_geom_fill->proc~construct_pairs proc~construct_recip_lattice DQMC_RECLATT::construct_recip_lattice proc~dqmc_geom_fill->proc~construct_recip_lattice proc~construct_recip_lattice_classes DQMC_SYMM::construct_recip_lattice_classes proc~dqmc_geom_fill->proc~construct_recip_lattice_classes proc~count_hop_class DQMC_HAMILT::count_hop_class proc~dqmc_geom_fill->proc~count_hop_class proc~count_local_classes DQMC_HAMILT::count_local_classes proc~dqmc_geom_fill->proc~count_local_classes proc~dqmc_error DQMC_Util::DQMC_Error proc~dqmc_geom_fill->proc~dqmc_error proc~dqmc_fill_fourierc DQMC_RECLATT::DQMC_Fill_FourierC proc~dqmc_geom_fill->proc~dqmc_fill_fourierc proc~init_lattice DQMC_LATT::init_lattice proc~dqmc_geom_fill->proc~init_lattice proc~init_recip_latt DQMC_RECLATT::init_recip_latt proc~dqmc_geom_fill->proc~init_recip_latt proc~map_symm_bonds DQMC_SYMM::map_symm_bonds proc~dqmc_geom_fill->proc~map_symm_bonds proc~map_symm_lattice DQMC_SYMM::map_symm_lattice proc~dqmc_geom_fill->proc~map_symm_lattice proc~map_symm_pairs DQMC_SYMM::map_symm_pairs proc~dqmc_geom_fill->proc~map_symm_pairs proc~map_symm_recip_lattice DQMC_SYMM::map_symm_recip_lattice proc~dqmc_geom_fill->proc~map_symm_recip_lattice proc~read_bonds DQMC_BONDS::read_bonds proc~dqmc_geom_fill->proc~read_bonds proc~read_symm DQMC_SYMM::read_symm proc~dqmc_geom_fill->proc~read_symm interface~cfg_set DQMC_Cfg::CFG_Set proc~dqmc_geom_init->interface~cfg_set proc~dqmc_ccs_compress DQMC_STRUCT::DQMC_CCS_Compress proc~dqmc_geom_init->proc~dqmc_ccs_compress proc~group_hopping DQMC_HAMILT::group_hopping proc~dqmc_geom_init->proc~group_hopping proc~dqmc_ccs_print DQMC_STRUCT::DQMC_CCS_Print proc~dqmc_geom_print->proc~dqmc_ccs_print proc~dqmc_geom_read_def->proc~dqmc_ccs_compress proc~dqmc_geom_read_def->proc~dqmc_error proc~dqmc_geom_discover_f DQMC_STRUCT::DQMC_Geom_Discover_F proc~dqmc_geom_read_def->proc~dqmc_geom_discover_f proc~dqmc_geom_discover_map DQMC_STRUCT::DQMC_Geom_Discover_Map proc~dqmc_geom_read_def->proc~dqmc_geom_discover_map proc~dqmc_readln DQMC_Cfg::DQMC_ReadLn proc~dqmc_geom_read_def->proc~dqmc_readln proc~dqmc_warning DQMC_Util::DQMC_Warning proc~dqmc_geom_read_def->proc~dqmc_warning lapack_dgetri lapack_dgetri proc~dqmc_gtau_init->lapack_dgetri proc~dqmc_gtau_init->proc~dqmc_error lapack_dgetrf lapack_dgetrf proc~dqmc_gtau_loada->lapack_dgetrf proc~dqmc_gtau_loada->lapack_dgetri proc~dqmc_getb DQMC_MATB::DQMC_GetB proc~dqmc_gtau_loada->proc~dqmc_getb proc~dqmc_gtau_setalias DQMC_GTAU::DQMC_Gtau_SetAlias proc~dqmc_gtau_loada->proc~dqmc_gtau_setalias proc~dqmc_multb_right DQMC_MATB::DQMC_MultB_Right proc~dqmc_gtau_loada->proc~dqmc_multb_right proc~dqmc_hub_config->interface~cfg_get proc~dqmc_hub_config->interface~cfg_set proc~dqmc_config_isset DQMC_Cfg::DQMC_Config_isSet proc~dqmc_hub_config->proc~dqmc_config_isset proc~dqmc_hub_init DQMC_Hubbard::DQMC_Hub_Init proc~dqmc_hub_config->proc~dqmc_hub_init proc~dqmc_hub_config->proc~dqmc_warning proc~dqmc_b_free DQMC_MATB::DQMC_B_Free proc~dqmc_hub_free->proc~dqmc_b_free proc~dqmc_gfun_free DQMC_GFun::DQMC_Gfun_Free proc~dqmc_hub_free->proc~dqmc_gfun_free proc~dqmc_phy0_free DQMC_Phy0::DQMC_Phy0_Free proc~dqmc_hub_free->proc~dqmc_phy0_free proc~dqmc_phy2_free DQMC_Phy2::DQMC_Phy2_Free proc~dqmc_hub_free->proc~dqmc_phy2_free proc~dqmc_seqb_free DQMC_SEQB::DQMC_SeqB_Free proc~dqmc_hub_free->proc~dqmc_seqb_free proc~dqmc_struct_free DQMC_STRUCT::DQMC_Struct_Free proc~dqmc_hub_free->proc~dqmc_struct_free proc~dqmc_wspace_free DQMC_WSpace::DQMC_WSpace_Free proc~dqmc_hub_free->proc~dqmc_wspace_free proc~dqmc_getg_2nd_order DQMC_GFun::DQMC_GetG_2nd_order proc~dqmc_hub_fullmeas->proc~dqmc_getg_2nd_order proc~dqmc_gfun_clone DQMC_GFun::DQMC_GFun_Clone proc~dqmc_hub_fullmeas->proc~dqmc_gfun_clone proc~dqmc_gfun_copyup DQMC_GFun::DQMC_GFun_CopyUp proc~dqmc_hub_fullmeas->proc~dqmc_gfun_copyup proc~dqmc_gfun_duplicate DQMC_GFun::DQMC_GFun_Duplicate proc~dqmc_hub_fullmeas->proc~dqmc_gfun_duplicate proc~dqmc_hub_fullmeas->proc~dqmc_gfun_free proc~dqmc_phy0_meas DQMC_Phy0::DQMC_Phy0_Meas proc~dqmc_hub_fullmeas->proc~dqmc_phy0_meas proc~dqmc_phy2_meas DQMC_Phy2::DQMC_Phy2_Meas proc~dqmc_hub_fullmeas->proc~dqmc_phy2_meas proc~dqmc_hub_input_hsf->proc~dqmc_error proc~dqmc_hub_meas->proc~ran0 proc~dqmc_getg DQMC_GFun::DQMC_GetG proc~dqmc_hub_meas->proc~dqmc_getg proc~dqmc_hub_meas->proc~dqmc_getg_2nd_order proc~dqmc_hub_meas->proc~dqmc_gfun_clone proc~dqmc_hub_meas->proc~dqmc_gfun_copyup proc~dqmc_hub_meas->proc~dqmc_gfun_duplicate proc~dqmc_hub_meas->proc~dqmc_gfun_free proc~dqmc_hub_meas->proc~dqmc_phy0_meas proc~dqmc_hub_meas->proc~dqmc_phy2_meas proc~dqmc_hub_output_hsf DQMC_Hubbard::DQMC_Hub_Output_HSF proc~dqmc_hub_outputparam->proc~dqmc_hub_output_hsf proc~dqmc_hub_outputparam->proc~dqmc_warning proc~dqmc_hub_sweep->proc~ran0 proc~dqmc_applyupdate DQMC_GFun::DQMC_ApplyUpdate proc~dqmc_hub_sweep->proc~dqmc_applyupdate proc~dqmc_hub_sweep->proc~dqmc_getg proc~dqmc_hub_sweep->proc~dqmc_getg_2nd_order proc~dqmc_hub_sweep->proc~dqmc_gfun_copyup proc~dqmc_gfun_getjj DQMC_GFun::DQMC_Gfun_Getjj proc~dqmc_hub_sweep->proc~dqmc_gfun_getjj proc~dqmc_hub_sweep->proc~dqmc_phy0_meas proc~dqmc_hub_sweep->proc~dqmc_phy2_meas proc~dqmc_syncwraps DQMC_GFun::DQMC_SyncWraps proc~dqmc_hub_sweep->proc~dqmc_syncwraps proc~dqmc_updateg DQMC_GFun::DQMC_UpdateG proc~dqmc_hub_sweep->proc~dqmc_updateg proc~dqmc_updatewraps DQMC_GFun::DQMC_UpdateWraps proc~dqmc_hub_sweep->proc~dqmc_updatewraps proc~dqmc_hub_sweep2->proc~ran0 proc~dqmc_hub_sweep2->proc~dqmc_getg proc~dqmc_hub_sweep2->proc~dqmc_gfun_copyup omp_set_num_threads omp_set_num_threads proc~dqmc_omp_init->omp_set_num_threads blas_dscal blas_dscal proc~dqmc_phy0_avg->blas_dscal proc~dqmc_phy0_avg->proc~dqmc_error interface~dqmc_jackknife DQMC_Util::DQMC_JackKnife proc~dqmc_phy0_geterr->interface~dqmc_jackknife interface~dqmc_signjackknife DQMC_Util::DQMC_SignJackKnife proc~dqmc_phy0_geterr->interface~dqmc_signjackknife dconjg dconjg proc~dqmc_phy0_getft->dconjg zgemm zgemm proc~dqmc_phy0_getft->zgemm zheev zheev proc~dqmc_phy0_getft->zheev proc~dqmc_print_realarray DQMC_Util::DQMC_Print_RealArray proc~dqmc_phy0_print->proc~dqmc_print_realarray proc~dqmc_print_eigenmode DQMC_Util::DQMC_Print_EigenMode proc~dqmc_phy0_printft->proc~dqmc_print_eigenmode proc~dqmc_phy0_printft->proc~dqmc_print_realarray proc~dqmc_phy2_geterr->interface~dqmc_jackknife proc~dqmc_phy2_geterr->interface~dqmc_signjackknife proc~dqmc_phy2_pair DQMC_Phy2::DQMC_Phy2_Pair proc~dqmc_phy2_geterrirrep->proc~dqmc_phy2_pair proc~dqmc_wave_avg DQMC_Phy2::DQMC_Wave_Avg proc~dqmc_phy2_geterrirrep->proc~dqmc_wave_avg proc~dqmc_phy2_print->proc~dqmc_print_realarray proc~dqmc_read_config->proc~dqmc_open_file proc~dqmc_default_def DQMC_Cfg::DQMC_Default_Def proc~dqmc_read_config->proc~dqmc_default_def proc~dqmc_read_config->proc~dqmc_error proc~dqmc_find_param DQMC_Cfg::DQMC_Find_Param proc~dqmc_read_config->proc~dqmc_find_param proc~dqmc_read_def DQMC_Cfg::DQMC_Read_Def proc~dqmc_read_config->proc~dqmc_read_def proc~dqmc_read_config->proc~dqmc_warning dscal dscal proc~dqmc_tdm1_avg->dscal proc~dqmc_tdm1_geterr->interface~dqmc_jackknife proc~dqmc_tdm1_geterr->interface~dqmc_signjackknife proc~dqmc_getftk DQMC_Util::dqmc_getFTk proc~dqmc_tdm1_getkft->proc~dqmc_getftk proc~dqmc_tdm1_initftw DQMC_TDM1::DQMC_TDM1_InitFTw proc~dqmc_tdm1_init->proc~dqmc_tdm1_initftw proc~dqmc_tdm1_initprop DQMC_TDM1::DQMC_TDM1_InitProp proc~dqmc_tdm1_init->proc~dqmc_tdm1_initprop proc~dqmc_change_gtau_time DQMC_GTAU::DQMC_change_gtau_time proc~dqmc_tdm1_meas->proc~dqmc_change_gtau_time proc~dqmc_gtau_copyup DQMC_GTAU::DQMC_Gtau_CopyUp proc~dqmc_tdm1_meas->proc~dqmc_gtau_copyup proc~dqmc_gtau_dumpa DQMC_GTAU::DQMC_Gtau_DumpA proc~dqmc_tdm1_meas->proc~dqmc_gtau_dumpa proc~dqmc_tdm1_compute DQMC_TDM1::DQMC_TDM1_Compute proc~dqmc_tdm1_meas->proc~dqmc_tdm1_compute proc~dqmc_tdm1_meas_para->proc~dqmc_change_gtau_time proc~dqmc_tdm1_meas_para->proc~dqmc_gtau_copyup proc~dqmc_tdm1_meas_para->proc~dqmc_gtau_dumpa proc~dqmc_tdm1_meas_para->proc~dqmc_tdm1_compute interface~dqmc_print_array DQMC_Util::DQMC_Print_Array proc~dqmc_tdm1_print->interface~dqmc_print_array proc~dqmc_tdm1_printkft->interface~dqmc_print_array proc~dqmc_tdm1_selfenergy->interface~dqmc_print_array proc~dqmc_tdm1_selfenergy->proc~dqmc_getftk proc~dqmc_gtau_getg0 DQMC_GTAU::DQMC_Gtau_GetG0 proc~dqmc_tdm1_selfenergy->proc~dqmc_gtau_getg0 zgemv zgemv proc~dqmc_tdm1_selfenergy->zgemv zgetrf zgetrf proc~dqmc_tdm1_selfenergy->zgetrf zgetri zgetri proc~dqmc_tdm1_selfenergy->zgetri dlarnv dlarnv proc~ran0->dlarnv proc~dqmc_config_seti DQMC_Cfg::DQMC_Config_SetI interface~cfg_set->proc~dqmc_config_seti proc~dqmc_config_setpi DQMC_Cfg::DQMC_Config_SetPI interface~cfg_set->proc~dqmc_config_setpi proc~dqmc_config_setpr DQMC_Cfg::DQMC_Config_SetPR interface~cfg_set->proc~dqmc_config_setpr proc~dqmc_config_setr DQMC_Cfg::DQMC_Config_SetR interface~cfg_set->proc~dqmc_config_setr proc~dqmc_config_sets DQMC_Cfg::DQMC_Config_SetS interface~cfg_set->proc~dqmc_config_sets proc~dqmc_jackknife_complex DQMC_Util::DQMC_JackKnife_Complex interface~dqmc_jackknife->proc~dqmc_jackknife_complex proc~dqmc_jackknife_real DQMC_Util::DQMC_JackKnife_Real interface~dqmc_jackknife->proc~dqmc_jackknife_real interface~dqmc_print_array->proc~dqmc_print_realarray proc~dqmc_print_complexarray DQMC_Util::DQMC_Print_ComplexArray interface~dqmc_print_array->proc~dqmc_print_complexarray proc~dqmc_signjackknife_complex DQMC_Util::DQMC_SignJackKnife_Complex interface~dqmc_signjackknife->proc~dqmc_signjackknife_complex proc~dqmc_signjackknife_real DQMC_Util::DQMC_SignJackKnife_Real interface~dqmc_signjackknife->proc~dqmc_signjackknife_real proc~convert_to_fractional DQMC_LATT::convert_to_fractional proc~assign_phase->proc~convert_to_fractional proc~get_det DQMC_Util::get_det proc~assign_phase->proc~get_det proc~get_inverse DQMC_Util::get_inverse proc~assign_phase->proc~get_inverse proc~move_to_record DQMC_Util::move_to_record proc~assign_phase->proc~move_to_record proc~construct_hamilt->interface~cfg_get proc~dqmc_hamilt_groupckb DQMC_HAMILT::dqmc_hamilt_groupckb proc~construct_hamilt->proc~dqmc_hamilt_groupckb proc~find_neighbors DQMC_HAMILT::find_neighbors proc~construct_hamilt->proc~find_neighbors proc~hoptowho DQMC_LATT::hoptowho proc~construct_hamilt->proc~hoptowho proc~construct_hamilt->proc~move_to_record proc~construct_lattice->proc~get_inverse proc~construct_pairs->proc~hoptowho proc~construct_pairs->proc~move_to_record proc~closer_to_zero DQMC_RECLATT::closer_to_zero proc~construct_recip_lattice->proc~closer_to_zero proc~construct_recip_lattice->proc~get_inverse blas_dgemm blas_dgemm proc~dqmc_applyupdate->blas_dgemm proc~dqmc_ccs_compress->proc~dqmc_error proc~dqmc_change_gtau_time->proc~dqmc_gtau_setalias proc~dqmc_change_gtau_time->proc~dqmc_multb_right proc~dqmc_multb_left DQMC_MATB::DQMC_MultB_Left proc~dqmc_change_gtau_time->proc~dqmc_multb_left proc~dqmc_multbi_left DQMC_MATB::DQMC_MultBi_Left proc~dqmc_change_gtau_time->proc~dqmc_multbi_left proc~dqmc_multbi_right DQMC_MATB::DQMC_MultBi_Right proc~dqmc_change_gtau_time->proc~dqmc_multbi_right proc~dqmc_config_geti->proc~dqmc_error proc~dqmc_config_geti->proc~dqmc_find_param proc~dqmc_config_geti->proc~dqmc_warning proc~dqmc_config_getpi->proc~dqmc_error proc~dqmc_config_getpi->proc~dqmc_find_param proc~dqmc_config_getpi->proc~dqmc_warning proc~dqmc_config_getpr->proc~dqmc_error proc~dqmc_config_getpr->proc~dqmc_find_param proc~dqmc_config_getpr->proc~dqmc_warning proc~dqmc_config_getr->proc~dqmc_error proc~dqmc_config_getr->proc~dqmc_find_param proc~dqmc_config_getr->proc~dqmc_warning proc~dqmc_config_gets->proc~dqmc_error proc~dqmc_config_gets->proc~dqmc_find_param proc~dqmc_config_gets->proc~dqmc_warning proc~dqmc_config_isset->proc~dqmc_error proc~dqmc_config_isset->proc~dqmc_find_param proc~dqmc_getb->proc~dqmc_multb_right proc~dqmc_scalerow DQMC_Util::DQMC_ScaleRow proc~dqmc_getb->proc~dqmc_scalerow proc~dqmc_getftk->dconjg blas_dcopy blas_dcopy proc~dqmc_getg->blas_dcopy proc~dqmc_computeg DQMC_GFun::DQMC_ComputeG proc~dqmc_getg->proc~dqmc_computeg proc~dqmc_matdiff DQMC_Util::DQMC_MatDiff proc~dqmc_getg->proc~dqmc_matdiff proc~dqmc_getg->proc~dqmc_multb_left proc~dqmc_getg->proc~dqmc_multbi_right blas_ddot blas_ddot proc~dqmc_gfun_getjj->blas_ddot proc~dqmc_gtau_dumpa->proc~dqmc_gtau_setalias proc~dqmc_gtau_getg0->proc~dqmc_getb dcopy dcopy proc~dqmc_gtau_getg0->dcopy dgemm dgemm proc~dqmc_gtau_getg0->dgemm dsyev dsyev proc~dqmc_gtau_getg0->dsyev proc~dqmc_scalecol DQMC_Util::DQMC_ScaleCol proc~dqmc_gtau_getg0->proc~dqmc_scalecol proc~dqmc_hub_init->proc~dqmc_hub_init_vmat proc~dqmc_hub_init->proc~dqmc_hub_input_hsf proc~dqmc_hub_init->proc~ran0 proc~dqmc_hub_init->proc~dqmc_error proc~dqmc_hub_init->proc~dqmc_getg proc~dqmc_hub_init->proc~dqmc_gfun_clone proc~dqmc_hub_init->proc~dqmc_warning proc~dqmc_b_init DQMC_MATB::DQMC_B_Init proc~dqmc_hub_init->proc~dqmc_b_init proc~dqmc_gfun_init DQMC_GFun::DQMC_GFun_Init proc~dqmc_hub_init->proc~dqmc_gfun_init proc~dqmc_phy0_init DQMC_Phy0::DQMC_Phy0_Init proc~dqmc_hub_init->proc~dqmc_phy0_init proc~dqmc_phy2_init DQMC_Phy2::DQMC_Phy2_Init proc~dqmc_hub_init->proc~dqmc_phy2_init proc~dqmc_seqb_init DQMC_SEQB::DQMC_SeqB_Init proc~dqmc_hub_init->proc~dqmc_seqb_init proc~dqmc_wspace_allocate DQMC_WSpace::DQMC_WSpace_Allocate proc~dqmc_hub_init->proc~dqmc_wspace_allocate proc~ran1 DQMC_Util::ran1 proc~dqmc_hub_init->proc~ran1 proc~dqmc_multb_right->blas_dscal proc~dqmc_multb_right->proc~dqmc_error proc~dqmc_multb_right->blas_dgemm dexp dexp proc~dqmc_multb_right->dexp lapack_dsyev lapack_dsyev proc~dqmc_multb_right->lapack_dsyev proc~dqmc_multb_right->proc~dqmc_scalecol blas_daxpy blas_daxpy proc~dqmc_phy0_meas->blas_daxpy proc~dqmc_phy0_meas->blas_dgemm proc~dqmc_pair_symm DQMC_Phy2::DQMC_Pair_Symm proc~dqmc_phy2_avg_symm->proc~dqmc_pair_symm proc~dqmc_phy2_avg_wave->proc~dqmc_wave_avg proc~dqmc_phy2_getirrep_connected->proc~dqmc_phy2_pair proc~dqmc_phy2_getirrep_connected->lapack_dsyev proc~dqmc_phy2_getirrep_full->lapack_dsyev proc~dqmc_phy2_meas->proc~dqmc_phy2_pair proc~dqmc_phy2_meas->blas_daxpy proc~dqmc_read_def->proc~dqmc_readln proc~dqmc_ccs_free DQMC_STRUCT::DQMC_CCS_Free proc~dqmc_struct_free->proc~dqmc_ccs_free proc~dqmc_updateg->blas_dscal proc~dqmc_updateg->proc~dqmc_applyupdate blas_dgemv blas_dgemv proc~dqmc_updateg->blas_dgemv proc~dqmc_wave_avg->blas_ddot proc~dqmc_wave_avg->blas_dgemm proc~init_lattice->proc~convert_to_fractional proc~count_atom DQMC_LATT::count_atom proc~init_lattice->proc~count_atom proc~init_lattice->proc~get_det proc~init_lattice->proc~get_inverse proc~init_lattice->proc~move_to_record proc~init_recip_latt->interface~cfg_get proc~init_recip_latt->proc~get_inverse proc~map_symm_bonds->proc~get_inverse proc~map_symm_bonds->proc~hoptowho proc~apply_point_symm DQMC_SYMM::apply_point_symm proc~map_symm_lattice->proc~apply_point_symm proc~map_symm_lattice->proc~get_inverse proc~map_symm_recip_lattice->proc~apply_point_symm proc~map_symm_recip_lattice->proc~get_inverse proc~read_bonds->proc~move_to_record proc~count_symmetry DQMC_SYMM::count_symmetry proc~read_symm->proc~count_symmetry proc~read_symm->proc~move_to_record proc~count_atom->proc~move_to_record proc~count_symmetry->proc~move_to_record proc~dqmc_b_expinit DQMC_MATB::DQMC_B_ExpInit proc~dqmc_b_init->proc~dqmc_b_expinit proc~dqmc_computeg->lapack_dgetrf proc~dqmc_computeg->proc~dqmc_error proc~dqmc_computeg->proc~dqmc_warning proc~dqmc_computeg->blas_dcopy proc~dqmc_computeg->proc~dqmc_scalerow lapack_dgetrs lapack_dgetrs proc~dqmc_computeg->lapack_dgetrs proc~dqmc_seqmultb DQMC_SEQB::DQMC_SeqMultB proc~dqmc_computeg->proc~dqmc_seqmultb proc~dqmc_trans DQMC_Util::DQMC_Trans proc~dqmc_computeg->proc~dqmc_trans proc~dqmc_config_seti->proc~dqmc_error proc~dqmc_config_seti->proc~dqmc_find_param proc~dqmc_config_setpi->proc~dqmc_error proc~dqmc_config_setpi->proc~dqmc_find_param proc~dqmc_config_setpr->proc~dqmc_error proc~dqmc_config_setpr->proc~dqmc_find_param proc~dqmc_config_setr->proc~dqmc_error proc~dqmc_config_setr->proc~dqmc_find_param proc~dqmc_config_sets->proc~dqmc_error proc~dqmc_config_sets->proc~dqmc_find_param proc~dqmc_multb_left->blas_dscal proc~dqmc_multb_left->proc~dqmc_error proc~dqmc_multb_left->blas_dgemm proc~dqmc_multb_left->dexp proc~dqmc_multb_left->lapack_dsyev proc~dqmc_multb_left->proc~dqmc_scalerow proc~dqmc_multbi_left->blas_dscal proc~dqmc_multbi_left->proc~dqmc_error proc~dqmc_multbi_left->blas_dgemm proc~dqmc_multbi_left->dexp proc~dqmc_multbi_left->lapack_dsyev proc~dqmc_scalerowinv DQMC_Util::DQMC_ScaleRowInv proc~dqmc_multbi_left->proc~dqmc_scalerowinv proc~dqmc_multbi_right->blas_dscal proc~dqmc_multbi_right->proc~dqmc_error proc~dqmc_multbi_right->blas_dgemm proc~dqmc_multbi_right->dexp proc~dqmc_multbi_right->lapack_dsyev proc~dqmc_scalecolinv DQMC_Util::DQMC_ScaleColInv proc~dqmc_multbi_right->proc~dqmc_scalecolinv proc~dqmc_scalecol->dscal proc~dqmc_scalerow->dscal proc~dqmc_wspace_allocate->lapack_dgetri proc~dqmc_wspace_allocate->lapack_dsyev lapack_dgeqp3 lapack_dgeqp3 proc~dqmc_wspace_allocate->lapack_dgeqp3 lapack_dorgqr lapack_dorgqr proc~dqmc_wspace_allocate->lapack_dorgqr lapack_dormqr lapack_dormqr proc~dqmc_wspace_allocate->lapack_dormqr proc~hoptowho->proc~get_inverse proc~ran1->dlarnv proc~dqmc_b_expinit->blas_dscal proc~dqmc_b_expinit->proc~dqmc_error proc~dqmc_b_expinit->blas_dgemm proc~dqmc_b_expinit->dexp proc~dqmc_b_expinit->lapack_dsyev proc~dqmc_scalecolinv->dscal proc~dqmc_scalerowinv->dscal proc~dqmc_seqmultb->proc~dqmc_getb proc~dqmc_seqmultb->proc~dqmc_multb_left proc~dqmc_eye DQMC_Util::DQMC_Eye proc~dqmc_seqmultb->proc~dqmc_eye proc~dqmc_udtd DQMC_SEQB::DQMC_UDTD proc~dqmc_seqmultb->proc~dqmc_udtd proc~dqmc_udtd->blas_dscal proc~dqmc_udtd->proc~dqmc_error proc~dqmc_udtd->blas_dcopy proc~dqmc_udtd->proc~dqmc_scalecol proc~dqmc_udtd->lapack_dgeqp3 proc~dqmc_udtd->lapack_dorgqr blas_dtrmm blas_dtrmm proc~dqmc_udtd->blas_dtrmm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer :: t1 integer :: t2 integer :: rate type( config ) :: cfg type( Hubbard ) :: Hub type( GeomWrap ) :: Gwrap type( TDM1 ) :: tm type( Gtau ) :: tau type( TDM1 ), pointer :: ptm (:) type( Gtau ), pointer :: ptau (:) character(len=slen) :: gfile logical :: tformat integer :: na integer :: nt integer :: nkt integer :: nkg integer :: i integer :: j integer :: k integer :: slice integer :: nhist integer :: comp_tdm integer :: nBin integer :: nIter character(len=60) :: ofile integer :: OPT integer :: symmetries_output_file_unit integer :: FLD_UNIT integer :: TDM_UNIT real(kind=wp) :: randn (1) integer :: nproc","tags":"","loc":"program/dqmc_ggeom.html"},{"title":"dqmc_geom_wrap.F90 – Quest","text":"This file depends on sourcefile~~dqmc_geom_wrap.f90~~EfferentGraph sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_geom_wrap.f90~~AfferentGraph sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_GEOM_WRAP use DQMC_GEOM_PARAM use DQMC_HAMILT use DQMC_SYMM use DQMC_LATT use DQMC_RECLATT use DQMC_BONDS use DQMC_Cfg use DQMC_STRUCT implicit none type GeomWrap type ( lattice_t ) :: Lattice type ( recip_lattice_t ) :: RecipLattice type ( recip_lattice_t ) :: GammaLattice type ( hamiltonian_t ) :: Hamilt type ( bonds_t ) :: Bonds type ( symm_operations ) :: SymmOp type ( pairing ) :: Pairs end type contains subroutine DQMC_Geom_Fill ( gwrap , gfile , cfg , SOP ) type ( GeomWrap ), intent ( inout ) :: gwrap type ( config ), intent ( inout ) :: cfg character ( len = 60 ), intent ( in ) :: gfile integer , intent ( in ) :: SOP logical :: found , connected inquire ( file = gfile , exist = found ) if ( found ) then !Check whether file is already connected inquire ( file = gfile , opened = connected ) if ( connected ) then !If connected retrieve the unit inquire ( file = gfile , number = inpunit ) rewind ( inpunit ) else !If not connected, find a free unit do inpunit = 7 , 99 inquire ( unit = inpunit , opened = connected ) if (. not . connected ) exit enddo !open file open ( file = gfile , unit = inpunit ) endif else call DQMC_Error ( \"cannot open geom def file \" // gfile , 0 ) endif !Scan file to see which fields are specified call analyze_input !Initialize basic info about real space cluster call init_lattice ( gwrap % Lattice , SOP ) !Construct full lattice call construct_lattice ( gwrap % Lattice , SOP ) !Initialize basic info about reciprocal lattice call init_recip_latt ( gwrap % Lattice , gwrap % RecipLattice ,. true ., cfg ) call init_recip_latt ( gwrap % Lattice , gwrap % GammaLattice ,. false ., cfg ) !construct reciprocal lattice shifted by k-point call construct_recip_lattice ( gwrap % RecipLattice ) !construct reciprocal lattice that includes Gamma call construct_recip_lattice ( gwrap % GammaLattice ) !Construct Hamiltonian call construct_hamilt ( gwrap % Hamilt , gwrap % Lattice , gwrap % RecipLattice , cfg ) !Read point-symmetry (optional) call read_symm ( gwrap % SymmOp ) !pair-to-pair map of action of each symmetry in real space (also translations) call map_symm_lattice ( gwrap % SymmOp , gwrap % Lattice , gwrap % Hamilt , SOP ) !point-to-point map of action of each symmetry in reciprocal space call map_symm_recip_lattice ( gwrap % SymmOp , gwrap % RecipLattice ,. true .) call map_symm_recip_lattice ( gwrap % SymmOp , gwrap % GammaLattice ,. false .) !Group pairs of lattice points into classes call construct_lattice_classes ( gwrap % SymmOp , gwrap % Lattice ) !Group k-points into classes call construct_recip_lattice_classes ( gwrap % SymmOp , gwrap % RecipLattice ,. true .) call construct_recip_lattice_classes ( gwrap % SymmOp , gwrap % GammaLattice ,. false .) ! Fill the matrix of fourier weights call DQMC_Fill_FourierC ( Gwrap % RecipLattice , Gwrap % Lattice ) call DQMC_Fill_FourierC ( Gwrap % GammaLattice , Gwrap % Lattice ) !Group hopping part of Hamiltonian in classes call count_hop_class ( gwrap % Lattice , gwrap % Hamilt ) !Group separately local classes for U and mu call count_local_classes ( gwrap % Lattice , gwrap % Hamilt ) !Assign phase for Green's function call assign_gf_phase ( gwrap % Lattice , gwrap % RecipLattice % ktwist ) !Read Bonds (optional input) call read_bonds ( gwrap % Bonds , SOP ) if ( gwrap % Bonds % initialized ) then !bond-to-bond map of action of symmetry on bonds call map_symm_bonds ( gwrap % Bonds , gwrap % SymmOp , gwrap % Lattice ) !Group pairs of bonds into classes call construct_bond_classes ( gwrap % Bonds , gwrap % SymmOp ) !Map bonds throughout the entire lattice call construct_pairs ( gwrap % Bonds , gwrap % Pairs , gwrap % Lattice , SOP ) !pair-to-pair map of action of symmetry on bonds call map_symm_pairs ( gwrap % Pairs , gwrap % SymmOp ) !Group pairs of pairs into classes call construct_pair_classes ( gwrap % Bonds , gwrap % Pairs ) endif !Assign phase to each atom (optional input) call assign_phase ( gwrap % Lattice ) !Write some info !call write_files(gwrap%Lattice,gwrap%RecipLattice,gwrap%Hamilt) end subroutine DQMC_Geom_Fill !---------------------------------------------------------------------! subroutine DQMC_Geom_Init ( gwrap , S , cfg ) type ( GeomWrap ), intent ( in ) :: gwrap type ( Struct ), intent ( inout ) :: S ! Struct type ( config ), intent ( inout ) :: cfg ! ... local scalar ... integer :: n ! Order of matrix T and D integer :: i , j ! Loop iterator integer :: ic , ib real ( wp ), pointer :: clab (:,:) => null () real ( wp ), pointer :: tupvalue (:) => null () real ( wp ), pointer :: tdnvalue (:) => null () integer , pointer :: tmp (:,:) => null () ! ... Executable ... S % checklist = . false . n = gwrap % Lattice % nsites S % nSite = n S % nCell = gwrap % Lattice % ncell S % nGroup = gwrap % Hamilt % nlocclass S % Name = 'General Geometry - Free Format' allocate ( tmp ( n , n )) !Fill T call group_hopping ( gwrap % Hamilt , n , S % n_t , tmp , tupvalue , tdnvalue ) call DQMC_CCS_Compress ( n , - 1 , tmp , S % T ) S % checklist ( STRUCT_ADJ ) = . true . !Fill ckb tmp = 0 do ib = 0 , size ( gwrap % hamilt % tckb , 2 ) - 1 i = gwrap % hamilt % tckb ( 1 , ib ) + 1 j = gwrap % hamilt % tckb ( 2 , ib ) + 1 tmp ( i , j ) = gwrap % hamilt % tckb ( 3 , ib ) tmp ( j , i ) = gwrap % hamilt % tckb ( 3 , ib ) enddo call DQMC_CCS_Compress ( n , - 1 , tmp , S % ckb ) !Symmetry Classes S % nClass = gwrap % Lattice % nclass allocate ( S % D ( n , n )) allocate ( S % F ( S % nClass )) allocate ( S % clabel ( S % nClass )) S % D ( 1 : n , 1 : n ) = gwrap % Lattice % myclass ( 0 : n - 1 , 0 : n - 1 ) S % F (:) = gwrap % Lattice % class_size (:) clab => gwrap % Lattice % class_label do ic = 1 , S % nClass write ( S % clabel ( ic ), '(2(i5),3(f10.4), i6.3)' ) ( int ( clab ( ic , j )), j = 4 , 5 ),( clab ( ic , j ), j = 1 , 3 ), S % F ( ic ) enddo !store GF phase allocate ( S % gf_phase ( n , n )) do i = 1 , n do j = 1 , n !if(abs(int(gwrap%lattice%gf_phase(i-1,j-1)))/=1)stop 'Problem with gf_phase' !S%gf_phase(i,j)=int(gwrap%Lattice%gf_phase(i-1,j-1)) S % gf_phase ( i , j ) = gwrap % Lattice % gf_phase ( i - 1 , j - 1 ) enddo enddo allocate ( S % chi_phase ( n , n )) S % chi_phase = 1 S % checklist ( STRUCT_CLASS ) = . true . allocate ( S % map ( n )) S % map ( 1 : n ) = gwrap % Hamilt % mylocclass ( 0 : n - 1 ) !Fill B if ( Found_Field ( BONDS_F )) then tmp = 0 S % n_b = gwrap % Pairs % nbond do ic = 0 , size ( gwrap % Pairs % nbondv ) - 1 do ib = 1 , gwrap % Pairs % nbondv ( ic ) i = gwrap % Pairs % bond_origin ( ib , ic ) j = gwrap % Pairs % bond_end ( ib , ic ) tmp ( i + 1 , j + 1 ) = gwrap % Pairs % bond_number ( ib , ic ) enddo enddo call DQMC_CCS_Compress ( n , - 1 , tmp , S % B ) !Store symmetry in S allocate ( S % class_b ( S % n_b , S % n_b ), S % size_b ( gwrap % Pairs % nclass_p )) S % class_b = gwrap % Pairs % myclass_p S % size_b = gwrap % Pairs % class_size_p S % nClass_b = gwrap % Pairs % nclass_p S % checklist ( STRUCT_BOND ) = . true . !Waves S % nWave = gwrap % Pairs % nWave allocate ( S % wlabel ( S % nWave )) S % wlabel (:) = gwrap % Pairs % wave_label (:) if ( Found_Field ( PAIRS_F )) then allocate ( S % W ( S % n_b , S % nWave )) do i = 1 , S % nWave S % W ( 1 : S % n_b , i ) = gwrap % Pairs % bond_wgt ( i , 1 : S % n_b ) enddo S % checklist ( STRUCT_WAVE ) = . true . endif endif deallocate ( tmp ) if ( Found_field ( PHASE_F )) then allocate ( S % P ( n )) S % P ( 1 : n ) = gwrap % Lattice % phase ( 0 : n - 1 ) S % checklist ( STRUCT_PHASE ) = . true . endif !Setting variables !Set variables that are otherwise read from main input call CFG_Set ( cfg , \"n\" , n ) call CFG_Set ( cfg , \"t_up\" , S % n_t , tupvalue ) call CFG_Set ( cfg , \"t_dn\" , S % n_t , tdnvalue ) call CFG_Set ( cfg , \"U\" , S % nGroup , gwrap % Hamilt % Uvalue ) call CFG_Set ( cfg , \"mu_up\" , S % nGroup , gwrap % Hamilt % muupvalue ) call CFG_Set ( cfg , \"mu_dn\" , S % nGroup , gwrap % Hamilt % mudnvalue ) deallocate ( tupvalue ) deallocate ( tdnvalue ) S % checklist ( STRUCT_INIT ) = . true . end subroutine DQMC_Geom_Init !--------------------------------------------------------------------! subroutine DQMC_Print_HeaderFT ( Gwrap , OPT , applytwist ) use dqmc_mpi type ( GeomWrap ), intent ( in ) :: Gwrap integer , intent ( in ) :: OPT logical , intent ( in ) :: applytwist ! ... Local scalar ... integer :: na , nk , ii , i , ik , j , jj , nkpts integer , pointer :: myclass_k (:) real * 8 , pointer :: klist (:,:) ! ... Executable ... if ( qmc_sim % rank . ne . 0 ) return na = Gwrap % Lattice % natom if ( applytwist ) then nk = Gwrap % RecipLattice % nclass_k nkpts = Gwrap % RecipLattice % nkpts myclass_k => Gwrap % RecipLattice % myclass_k klist => Gwrap % RecipLattice % klist else nk = Gwrap % GammaLattice % nclass_k nkpts = Gwrap % GammaLattice % nkpts myclass_k => Gwrap % GammaLattice % myclass_k klist => Gwrap % GammaLattice % klist endif !Print general info about k-space if ( applytwist ) then write ( OPT , '(A)' ) ' Grid for Green''s function' else write ( OPT , '(A)' ) ' Grid for spin/charge correlations' endif write ( OPT , '(A)' ) '  K-points' ii = 0 write ( OPT , '(A)' ) '  Class' do i = 1 , nk jj = 1 do ik = 1 , nkpts if ( myclass_k ( ik ) == i ) then if ( jj == 1 ) then write ( OPT , '(2x,i3,6x,3(f10.5))' ) i ,( klist ( ik , j ), j = 1 , Gwrap % Lattice % ndim ) jj =- 1 else write ( OPT , '(11x,3(f10.5))' )( klist ( ik , j ), j = 1 , Gwrap % Lattice % ndim ) endif endif enddo write ( OPT , * ) enddo write ( OPT , FMT_DBLINE ) end subroutine DQMC_Print_HeaderFT !--------------------------------------------------------------------! end module DQMC_GEOM_WRAP","tags":"","loc":"sourcefile/dqmc_geom_wrap.f90.html"},{"title":"dqmc_hamilt.F90 – Quest","text":"This file depends on sourcefile~~dqmc_hamilt.f90~~EfferentGraph sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_hamilt.f90~~AfferentGraph sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_kbonds.f90 dqmc_kbonds.F90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_HAMILT use DQMC_GEOM_PARAM use DQMC_LATT use DQMC_RECLATT use DQMC_Cfg implicit none type :: Hamiltonian_t !number of sites having a non-zero J,U,t integer :: nJsites , nUsites , ntsites !maximum number of neighbors integer :: maxneig !Number of neighbors of each site (0:nsites-1) integer , pointer :: tnneig (:), Unneig (:), Jnneig (:) !Sites havind a non-zero J,U,t (0:nsites-1) integer , pointer :: tsite (:), Usite (:), Jsite (:) !Sites neighboring each site   (0:nsites-1,nsites) integer , pointer :: tneig (:,:), Uneig (:,:), Jneig (:,:) !Pair of sites associated to each hopping throughout the system integer , pointer :: tckb (:,:) !chemical potential real * 8 :: mu_up , mu_dn !value of U and J for each pair (0:nsites-1, 0:nsites-1) real * 8 , pointer :: Uv (:,:), Jv (:,:) !values of U and mu inequivalent by symmetry (nlocclass) real * 8 , pointer :: Uvalue (:), muupvalue (:), mudnvalue (:) !value of t for each pair (0:nsites-1, 0:nsites-1) complex * 16 , pointer :: hopup (:,:), hopdn (:,:) !values of t inequivalent by symmetry (nhopclass) complex * 16 , pointer :: tupvalue (:), tdnvalue (:) !wave function phase(not used in QMC) complex * 16 , pointer :: phase (:) !number of different hoppings integer :: nhopclass !number of sites with different U/mu integer :: nlocclass !class for each site having U/mu (0:nsites-1) integer , pointer :: mylocclass (:) !hopping class for each pair of neighboring site (0:nsites-1,maxval(tnneig)) integer , pointer :: myhopclass (:,:) !number of primitive links integer :: nplink !sites involved in primitive links (2, 0:nplink-1) !plink(1:2,il) stores the two orbitals involved in the link. !plink(1,il) is always contained in the original primitive cell integer , pointer :: plink (:,:) !array (5,0:nplink-1) containing the following info: ! tlink(1, il) value of up-hopping   on primitive link il ! tlink(2, il) value of down-hopping on primitive link il ! tlink(3:5,il) = R_2 - R_1 real ( wp ), pointer :: tlink (:,:) logical :: constructed logical :: neig_found logical :: analyzed end type contains !-----------------------------------------------------------------! subroutine free_hamilt ( hamilt ) ! ! Free the space taken by pointers in Hamilt. ! type ( hamiltonian_t ), intent ( inout ) :: hamilt if ( associated ( hamilt % tnneig )) deallocate ( hamilt % tnneig ) if ( associated ( hamilt % Unneig )) deallocate ( hamilt % Unneig ) if ( associated ( hamilt % Jnneig )) deallocate ( hamilt % Jnneig ) if ( associated ( hamilt % tsite )) deallocate ( hamilt % tsite ) if ( associated ( hamilt % Usite )) deallocate ( hamilt % Usite ) if ( associated ( hamilt % Jsite )) deallocate ( hamilt % Jsite ) if ( associated ( hamilt % Uvalue )) deallocate ( hamilt % Uvalue ) if ( associated ( hamilt % muupvalue )) deallocate ( hamilt % muupvalue ) if ( associated ( hamilt % mudnvalue )) deallocate ( hamilt % mudnvalue ) if ( associated ( hamilt % tupvalue )) deallocate ( hamilt % tupvalue ) if ( associated ( hamilt % tdnvalue )) deallocate ( hamilt % tdnvalue ) if ( associated ( hamilt % phase )) deallocate ( hamilt % phase ) if ( associated ( hamilt % mylocclass )) deallocate ( hamilt % mylocclass ) if ( associated ( hamilt % tneig )) deallocate ( hamilt % tneig ) if ( associated ( hamilt % Uneig )) deallocate ( hamilt % Uneig ) if ( associated ( hamilt % Jneig )) deallocate ( hamilt % Jneig ) if ( associated ( hamilt % Uv )) deallocate ( hamilt % Uv ) if ( associated ( hamilt % Jv )) deallocate ( hamilt % Jv ) if ( associated ( hamilt % hopup )) deallocate ( hamilt % hopup ) if ( associated ( hamilt % hopdn )) deallocate ( hamilt % hopdn ) if ( associated ( hamilt % myhopclass )) deallocate ( hamilt % myhopclass ) end subroutine free_hamilt !-----------------------------------------------------------------! subroutine construct_hamilt ( hamilt , lattice , recip_lattice , cfg ) ! ! Fill the hamiltonian : Fill all the variables making up ! hamiltonian_t except those whose name end in \"class'. Set ! constructed and neig_found to true ! type ( lattice_t ), target , intent ( in ) :: lattice type ( recip_lattice_t ), intent ( in ) :: recip_lattice type ( Hamiltonian_t ), intent ( out ) :: hamilt type ( config ), intent ( inout ) :: cfg integer :: iat , jat , ios , ihop , jhop , il , it , is , js integer :: natom , nsites , ntcfg , nline , nhop real * 8 :: ktwist ( rdim ), kpoint ( rdim ), hop3d ( rdim ) real * 8 :: tijup , tijdn , U , twisthop logical :: ldum , doeshop character ( len = 50 ) :: string real * 8 , pointer :: pos (:,:), tcfg (:) character ( len =* ), parameter :: mu ( 2 ) = ( / 'mu_up' , 'mu_dn' / ) pos => lattice % cartpos nullify ( tcfg ) if (. not . lattice % constructed ) & stop 'Need to construct lattice before building Hamiltonian' if (. not . recip_lattice % initialized ) & stop 'Need to initialize recip_lattice before building Hamiltonian' !Set local alias natom = lattice % natom nsites = lattice % nsites ktwist ( 1 : rdim ) = recip_lattice % ktwist ( 1 : rdim ) kpoint ( 1 : rdim ) = recip_lattice % kpoint ( 1 : rdim ) allocate ( hamilt % hopup ( 0 : nsites - 1 , 0 : nsites - 1 )) allocate ( hamilt % hopdn ( 0 : nsites - 1 , 0 : nsites - 1 )) allocate ( hamilt % Uv ( 0 : nsites - 1 , 0 : nsites - 1 )) allocate ( hamilt % Jv ( 0 : nsites - 1 , 0 : nsites - 1 )) allocate ( hamilt % phase ( 0 : nsites - 1 )) !Read chemical potential do iat = 1 , 2 call CFG_Get ( cfg , mu ( iat ), ntcfg , tcfg ) if ( ntcfg > 1 ) then write ( * , '(A)' ) 'WARNING: Only 1st entry for mu in input file is considered.' endif if ( iat == 1 ) hamilt % mu_up = tcfg ( 1 ) if ( iat == 2 ) hamilt % mu_dn = tcfg ( 1 ) enddo deallocate ( tcfg ) nullify ( tcfg ) !Find the hamiltonian field ldum = move_to_record ( INPUT_FIELDS ( HAMILT_F ), inpunit ) ! Count lines and hops (hops are off-diagonal matrix elements) nline = 0 nhop = 0 do read ( inpunit , '(A)' ) string read ( string , * , iostat = ios ) iat , jat , hop3d ( 1 : 3 ), tijup , tijdn , U if ( ios . ne . 0 ) exit !Check label are in range if ( iat > lattice % natom - 1 . or . jat > lattice % natom - 1 ) then write ( * , * ) 'One of the atom in hopping is unspecified' stop endif doeshop = hoptowho ( iat , hop3d , jat , lattice ) . ne . iat doeshop = doeshop . and . ( abs ( tijup ). gt . 1.d-6 . or . abs ( tijdn ). gt . 1.d-6 ) if ( doeshop ) nhop = nhop + 1 nline = nline + 1 enddo hamilt % nplink = nhop allocate ( hamilt % tlink ( 5 , 0 : nhop - 1 )) nhop = nhop * lattice % ncell allocate ( hamilt % tckb ( 3 , 0 : nhop - 1 )) allocate ( hamilt % plink ( 2 , 0 : nhop - 1 )) ihop = - 1 jhop = - 1 hamilt % tckb = 0 hamilt % hopup (:,:) = 0.d0 hamilt % hopdn (:,:) = 0.d0 hamilt % Jv (:,:) = 0.d0 hamilt % Uv (:,:) = 0.d0 ldum = move_to_record ( INPUT_FIELDS ( HAMILT_F ), inpunit ) do il = 1 , nline !Read next line in Hamilt read ( inpunit , '(A)' ) string read ( string , * ) iat , jat , hop3d ( 1 : 3 ), tijup , tijdn , U doeshop = hoptowho ( iat , hop3d , jat , lattice ) . ne . iat doeshop = doeshop . and . ( abs ( tijup ). gt . 1.d-6 . or . abs ( tijdn ). gt . 1.d-6 ) do it = 0 , lattice % ncell - 1 is = iat + it * natom js = hoptowho ( is , hop3d , jat , lattice ) if ( doeshop ) then ihop = ihop + 1 hamilt % tckb ( 1 , ihop ) = min ( is , js ) hamilt % tckb ( 2 , ihop ) = max ( is , js ) hamilt % plink ( 1 , ihop ) = is hamilt % plink ( 2 , ihop ) = js if ( it . eq . 0 ) then jhop = jhop + 1 hamilt % tlink ( 1 , jhop ) = tijup hamilt % tlink ( 2 , jhop ) = tijdn hamilt % tlink ( 3 : 5 , jhop ) = hop3d ( 1 : 3 ) endif endif twisthop = sum (( pos (:, js ) - pos (:, is ) - hop3d (:)) * ktwist (:)) hamilt % hopup ( is , js ) = hamilt % hopup ( is , js ) + tijup * exp ( im * twisthop ) hamilt % hopdn ( is , js ) = hamilt % hopdn ( is , js ) + tijdn * exp ( im * twisthop ) hamilt % Uv ( is , js ) = hamilt % Uv ( is , js ) + U if ( is . ne . js ) then hamilt % hopup ( js , is ) = hamilt % hopup ( js , is ) + tijup * exp ( - im * twisthop ) hamilt % hopdn ( js , is ) = hamilt % hopdn ( js , is ) + tijdn * exp ( - im * twisthop ) hamilt % Uv ( js , is ) = hamilt % Uv ( js , is ) + U endif enddo enddo !Define phase on each atom compatibly with BC do iat = 0 , nsites - 1 jat = mod ( iat , natom ) hamilt % phase ( iat ) = exp ( im * sum (( kpoint (:) - ktwist (:)) * ( pos (:, iat ) - pos (:, jat )))) hamilt % phase ( iat ) = hamilt % phase ( iat ) * exp ( im * ( - sum ( ktwist (:) * pos (:, iat )))) enddo hamilt % constructed = . true . call find_neighbors ( hamilt ) hamilt % neig_found = . true . !if (sum(hamilt%tnneig) .ne. 2*nhop) then !   write(*,*) \"neighbors and hops are incompatible. Bug\" !   write(*,*) \"nhop =\", nhop !   write(*,*) \"nneig =\", sum(hamilt%tnneig) !   stop !endif call dqmc_hamilt_groupckb ( hamilt ) end subroutine !-------------------------------------------------------------------! subroutine find_neighbors ( hamilt ) ! ! Given the matrices Uv,Jv and hop it finds which atoms ! are neighbors and classify neighbors as with respect ! to interaction or hopping. Returns tnneig(is): number ! of neighbors of is; tneig(is,j): j-th neighbor of \"is\". ! Analogous definition for Unneig,Uneig and Jnneig,Jneig. ! type ( Hamiltonian_t ), intent ( inout ) :: hamilt integer is , js , ntsites , nUsites , nJsites , n integer , pointer :: tnneig (:), Unneig (:), Jnneig (:) integer , pointer :: tneig (:,:), Uneig (:,:), Jneig (:,:) integer , pointer :: tsite (:), Usite (:), Jsite (:) if (. not . hamilt % constructed ) stop 'Hamiltonian needs to be & &constructed before neig can be found' n = size ( hamilt % hopup , 1 ) nullify ( tnneig , Unneig , Jnneig ) nullify ( tneig , Uneig , Jneig ) nullify ( tsite , Usite , Jsite ) allocate ( tnneig ( 0 : n - 1 ), Unneig ( 0 : n - 1 ), Jnneig ( 0 : n - 1 )) allocate ( tneig ( 0 : n - 1 , n ), Uneig ( 0 : n - 1 , n ), Jneig ( 0 : n - 1 , n )) allocate ( tsite ( n ), Usite ( n ), Jsite ( n )) !Count the number of sites connected to \"is\" by t, U and J and store site label tnneig = 0 Unneig = 0 Jnneig = 0 do is = 0 , n - 1 do js = 0 , n - 1 if ( abs ( hamilt % hopup ( is , js )). gt . 1 d - 9 . and . is /= js ) then tnneig ( is ) = tnneig ( is ) + 1 tneig ( is , tnneig ( is )) = js elseif ( abs ( hamilt % hopdn ( is , js )). gt . 1 d - 9 . and . is /= js ) then tnneig ( is ) = tnneig ( is ) + 1 tneig ( is , tnneig ( is )) = js endif if ( abs ( hamilt % Uv ( is , js )). gt . 1 d - 9 ) then Unneig ( is ) = Unneig ( is ) + 1 Uneig ( is , Unneig ( is )) = js endif if ( abs ( hamilt % Jv ( is , js )). gt . 1 d - 9 ) then Jnneig ( is ) = Jnneig ( is ) + 1 Jneig ( is , Jnneig ( is )) = js endif enddo enddo !Count the number of sites effectively having t,U or J on them ntsites = 0 nUsites = 0 nJsites = 0 do is = 0 , n - 1 if ( tnneig ( is ). gt . 0 ) then ntsites = ntsites + 1 tsite ( ntsites ) = is endif if ( Unneig ( is ). gt . 0 ) then nUsites = nUsites + 1 Usite ( nUsites ) = is endif if ( Jnneig ( is ). gt . 0 ) then nJsites = nJsites + 1 Jsite ( nJsites ) = is endif enddo !Fill hamiltonian variables hamilt % maxneig = max ( maxval ( tnneig ), maxval ( Unneig ), maxval ( Jnneig )) !number of neighbors of each site hamilt % tnneig => tnneig hamilt % Unneig => Unneig hamilt % Jnneig => Jnneig !neighbors of each site hamilt % tneig => tneig hamilt % Uneig => Uneig hamilt % Jneig => Jneig !number of sites on which either t or U or J is different from 0 hamilt % ntsites = ntsites hamilt % nUsites = nUsites hamilt % nJsites = nJsites !sites on which either t or U or J is different from 0 hamilt % tsite => tsite hamilt % Usite => Usite hamilt % Jsite => Jsite end subroutine find_neighbors !-------------------------------------------------------------------! subroutine count_hop_class ( lattice , hamilt ) ! ! Construct a list of only hopping classes. These are a ! subset of all the distance classes for which the hopping ! is non zero. Find which hoppings are equivalent by ! symmetry. nhopsite(iat,iclass) returns how many hoppings ! in class iclass iat has. ordered_neig(iat,ineig) returns ! the ineig-th neighbor of iat. Neighbors are here ordered ! according to classes. So if nhopsite(2,1)=3 the first ! three neigbors of 2 listed in ordered_neig are those ! belonging to class 1. tneig has a similar content but ! neighbors are not ordered. ! type ( Hamiltonian_t ) :: hamilt type ( lattice_t ) :: lattice integer :: isite , ineig , jsite , newclass , ihc integer :: maxtneig , nsites integer :: hopclass ( lattice % nclass ), nhopclass integer , allocatable :: pairhopclass (:,:) complex * 16 :: tvaluetmpup ( lattice % nclass ) complex * 16 :: tvaluetmpdn ( lattice % nclass ) nsites = size ( hamilt % tnneig ) nhopclass = 0 hopclass (:) = 0 allocate ( pairhopclass ( 0 : nsites - 1 , nsites )) !class for the pair (isite, t-neighbour of site). pairhopclass (:,:) = - 1 !Select classes for which hopping is different from 0 !Uses symmetry info found in lattice. do isite = 0 , nsites - 1 do ineig = 1 , hamilt % tnneig ( isite ) jsite = hamilt % tneig ( isite , ineig ) !(isite,jsite) is a pair of sites with non-zero hopping if ( isite == jsite ) cycle newclass = lattice % myclass ( isite , jsite ) !First check that this class has not been already found do ihc = 1 , nhopclass if ( newclass == hopclass ( ihc )) exit enddo !If hopclass is new, increase number of classes if ( ihc == nhopclass + 1 ) then hopclass ( ihc ) = newclass nhopclass = ihc tvaluetmpup ( ihc ) = hamilt % hopup ( isite , jsite ) tvaluetmpdn ( ihc ) = hamilt % hopdn ( isite , jsite ) endif !Assign pair to the class pairhopclass ( isite , ineig ) = ihc enddo enddo hamilt % nhopclass = nhopclass maxtneig = maxval ( hamilt % tnneig (:)) allocate ( hamilt % myhopclass ( 0 : nsites - 1 , maxtneig )) allocate ( hamilt % tupvalue ( nhopclass )) allocate ( hamilt % tdnvalue ( nhopclass )) !Assign t value to each class and class number to each t-pair hamilt % tupvalue ( 1 : nhopclass ) = tvaluetmpup ( 1 : nhopclass ) hamilt % tdnvalue ( 1 : nhopclass ) = tvaluetmpdn ( 1 : nhopclass ) do ineig = 1 , maxtneig hamilt % myhopclass ( 0 : nsites - 1 , ineig ) = pairhopclass ( 0 : nsites - 1 , ineig ) enddo deallocate ( pairhopclass ) end subroutine count_hop_class !-------------------------------------------------------------------! subroutine count_local_classes ( lattice , hamilt ) ! ! Construct a list of only local classes i.e. the subset ! of the distance classes defined on the same site. Note ! that we use the symmetry instead of the value to group ! sites together. This is because local classes refers to ! both U and mu and two sites may have same value of U ! but different mu. If equivalent by symmetry, the two ! sites have, however, necessarily same u and mu. ! type ( Hamiltonian_t ), intent ( inout ) :: hamilt type ( lattice_t ), intent ( in ) :: lattice integer :: isite , iclass , jclass , nsites , nlocclass integer :: localtmp ( lattice % nclass ) real * 8 :: Utmp ( lattice % nclass ) real * 8 :: muup ( lattice % nclass ) real * 8 :: mudn ( lattice % nclass ) nlocclass = 0 nsites = size ( hamilt % tnneig ) allocate ( hamilt % mylocclass ( 0 : nsites - 1 )) !Loop over all sites do isite = 0 , nsites - 1 iclass = lattice % myclass ( isite , isite ) !Check whether class was already found do jclass = 1 , nlocclass if ( iclass . eq . localtmp ( jclass )) exit enddo !if not augment the number of local classes if ( jclass > nlocclass ) then nlocclass = nlocclass + 1 localtmp ( jclass ) = iclass !Save value of mu and U for this class Utmp ( jclass ) = hamilt % Uv ( isite , isite ) muup ( jclass ) = - dble ( hamilt % hopup ( isite , isite )) + hamilt % mu_up mudn ( jclass ) = - dble ( hamilt % hopdn ( isite , isite )) + hamilt % mu_dn endif !assign site to a class hamilt % mylocclass ( isite ) = jclass enddo !Store the number of different classes hamilt % nlocclass = nlocclass !Store the value of U and on-site energy (shifted by mu) for each class allocate ( hamilt % Uvalue ( nlocclass )) allocate ( hamilt % muupvalue ( nlocclass )) allocate ( hamilt % mudnvalue ( nlocclass )) hamilt % Uvalue ( 1 : nlocclass ) = Utmp ( 1 : nlocclass ) hamilt % muupvalue ( 1 : nlocclass ) = muup ( 1 : nlocclass ) hamilt % mudnvalue ( 1 : nlocclass ) = mudn ( 1 : nlocclass ) end subroutine !-------------------------------------------------------------------! subroutine dqmc_hamilt_groupckb ( hamilt ) type ( hamiltonian_t ), intent ( inout ) :: hamilt integer :: nh , ickb , ih , jh , kh , ns , hop ( 3 ) logical :: skip logical , pointer :: vs (:) ! Allocate array for visited sites (vs) ns = 1 + maxval ( hamilt % tckb ) allocate ( vs ( 0 : ns - 1 )) ! Count the number of hoopings nh = size ( hamilt % tckb , 2 ) ickb = 0 do ih = 0 , nh - 1 ! Check whether hopping has been already assigned if ( hamilt % tckb ( 3 , ih ) . gt . 0 ) cycle ! \"ih\" is the first of group ickb ickb = ickb + 1 ! mark all sites as not visited ... vs ( 0 : ns - 1 ) = . false . ! ... except for those of \"ih\" vs ( hamilt % tckb ( 1 : 2 , ih )) = . true . ! save ckb group hamilt % tckb ( 3 , ih ) = ickb ! Start finding other hopping do jh = 0 , nh - 1 ! If hopping already include or... skip = hamilt % tckb ( 3 , jh ) . gt . 0 ! if one of the site was already visited then... skip = skip . or . vs ( hamilt % tckb ( 1 , jh )) skip = skip . or . vs ( hamilt % tckb ( 2 , jh )) ! do not include \"jh\" in ickb if ( skip ) cycle ! otherwise do it and... hamilt % tckb ( 3 , jh ) = ickb ! mark the sites as visited vs ( hamilt % tckb ( 1 : 2 , jh )) = . true . enddo enddo deallocate ( vs ) ! Sort them so that hops in same group are neighbors do ih = 1 , nh - 1 hop ( 1 : 3 ) = hamilt % tckb ( 1 : 3 , ih ) do jh = 0 , ih - 1 if ( hop ( 3 ) < hamilt % tckb ( 3 , jh )) exit enddo do kh = ih - 1 , jh , - 1 hamilt % tckb ( 1 : 3 , kh + 1 ) = hamilt % tckb ( 1 : 3 , kh ) enddo hamilt % tckb ( 1 : 3 , jh ) = hop ( 1 : 3 ) enddo !do ih = 0, nh-1 !   write(*,*) hamilt%tckb(1:3, ih) !enddo end subroutine dqmc_hamilt_groupckb !-------------------------------------------------------------------! subroutine group_hopping ( hamilt , n , nt , tmap , tupvalue , tdnvalue ) ! !  Assign to every non-zero hopping a class based !  on its value. Equal hopping matrix elements belong !  to the same class : tmap(i,j)=it. !  tvalue(it) contains the value for a given class. !  Exclude local site energies. ! type ( Hamiltonian_t ), intent ( in ) :: hamilt integer , intent ( in ) :: n integer , intent ( out ) :: tmap ( n , n ), nt real * 8 , pointer , intent ( inout ) :: tupvalue (:) real * 8 , pointer , intent ( inout ) :: tdnvalue (:) integer :: is , js , it , jn real * 8 :: tup , tdn !Initialize tmap = 0 nt = 0 if ( associated ( tupvalue )) deallocate ( tupvalue ) if ( associated ( tdnvalue )) deallocate ( tdnvalue ) if ( maxval ( hamilt % tnneig ) > 0 ) then allocate ( tupvalue ( hamilt % ntsites * hamilt % maxneig )) allocate ( tdnvalue ( hamilt % ntsites * hamilt % maxneig )) !Assign same class to identical matrix elements do is = 0 , n - 1 do jn = 1 , hamilt % tnneig ( is ) js = hamilt % tneig ( is , jn ) if ( is . eq . js ) cycle tup = dble ( hamilt % hopup ( is , js )) tdn = dble ( hamilt % hopdn ( is , js )) do it = 1 , nt if ( abs ( tup - tupvalue ( it )) < 1.d-6 . and . & & abs ( tdn - tdnvalue ( it )) < 1.d-6 ) exit enddo if ( it . eq . nt + 1 ) then nt = it tupvalue ( it ) = tup tdnvalue ( it ) = tdn endif tmap ( is + 1 , js + 1 ) = it enddo enddo else nt = 1 allocate ( tupvalue ( 1 )) allocate ( tdnvalue ( 1 )) tupvalue = 0.d0 tdnvalue = 0.d0 do is = 1 , n tmap ( is , is ) = 1 enddo endif end subroutine group_hopping !-------------------------------------------------------------------! end module DQMC_HAMILT","tags":"","loc":"sourcefile/dqmc_hamilt.f90.html"},{"title":"dqmc_struct.F90 – Quest","text":"This file depends on sourcefile~~dqmc_struct.f90~~EfferentGraph sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_struct.f90~~AfferentGraph sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_checkerboard.f90 dqmc_checkerboard.F90 sourcefile~dqmc_checkerboard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_geom.f90 dqmc_geom.F90 sourcefile~dqmc_geom.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_struct.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_STRUCT #include \"dqmc_include.h\" use DQMC_UTIL use DQMC_CFG implicit none ! ! This module defines the data type for describing underline lattice ! struture used in DQMC. Basically, it contains six arrays. ! Suppose the lattice has N sites. ! !   1. Adjacenty (T) is an NxK array, where K is the !      maximum number of adjacent sites (=max_adj). T(0,i) records !      the number of adjacency of site i. T(1:T(0,i),i) records !      the sites that are adjacent to site i. The order of !      these adjacency information is important if the 'checkboard !      method' is used to construct Green's function. See DQMC_Gfun !      for more details. ! !   2. Distance (D) is an NxN symmetric matrix. D(i,j) records the !      distance information between site i and site j. However, the !      data stored in D is not 'real distance' in any mathematical !      sense. It is just an index of a distance table, which classifies !      all the possible distance in the lattice. In other words, !      if two elements in D have the same id, they have the same !      distance. The total number of possible distance is nClass. ! !   3. Frequency (F) is a length nClass vector, which stores the !      counts for each unique distance. For example, F(i)=5 means !      there are 5 elements in D whose distance class is indexed i. ! !   4. Phase (P) is also an NxN matrix, which is used in computing !      some phiscal measurements and Green's function. See DQMC_Phy0 !      and DQMC_Phy2 for more details. ! !   5. Neighborhood (N) is a NxB array, where B is the maximum !      number of neighbors (=max_nbr). !      N(0,i) records the number of neighbors !      of site i. N(1:N(0,i),i) is a list of sites neighboring to !      site i. The order of neighbor should be consistant. ! !   6. Wave (W) is a BxB matrix where B is the maximum number of !      neighbors. This function is used in computing pair measurements. !      See DQMC_Phy2 for more details. ! !  Data Type !  ========= ! ! Compressed Column Storage for sparse matrices. ! This is used for hopping and neighbor matrices. ! The detail of CCS can be found on http://www.netlib.org/ type CCS integer :: n ! dimension of matrix integer :: nnz ! number of nonzeros integer , pointer :: A (:) ! nonzeros elements, dim = nnz integer , pointer :: row (:) ! row index, dim = nnz integer , pointer :: cstart (:) ! start position of columns, dim = n end type CCS ! The entire geometry related data structures. integer , parameter :: N_CHECKLIST = 8 integer , parameter :: STRUCT_INIT = 1 integer , parameter :: STRUCT_DIM = 2 integer , parameter :: STRUCT_ADJ = 3 integer , parameter :: STRUCT_CLASS = 4 integer , parameter :: STRUCT_WAVE = 5 integer , parameter :: STRUCT_BOND = 6 integer , parameter :: STRUCT_PHASE = 7 integer , parameter :: STRUCT_FT = 8 integer , parameter :: label_len = 47 integer , parameter :: gname_len = 80 type Struct integer :: nSite ! number of sites integer :: nCell character ( gname_len ) :: name ! Name of the structure integer , pointer :: dim (:) ! dim of the geometry integer :: n_t ! number of hopping types type ( CCS ) :: T ! hopping matrix integer :: nClass ! number of unique distance integer , pointer :: D (:,:) ! Distance integer , pointer :: F (:) ! Frequency integer :: nGroup integer , pointer :: map (:) ! site classification integer , pointer :: gf_phase (:,:) integer , pointer :: chi_phase (:,:) integer :: n_b ! number of neighbors types type ( CCS ) :: B ! Neighborhood matrix integer :: nClass_b integer , pointer :: class_b (:,:) ! pair of bonds class integer , pointer :: size_b (:) ! size of bonds classes type ( CCS ) :: ckb integer :: nckb real ( wp ), pointer :: W (:,:) ! Wave integer :: nWave integer :: nirrep ! number of irreducible representations integer , pointer :: wrepr (:) ! symmetry group of wave integer :: nwclass ! number of classes in the group integer , pointer :: wclass (:) ! symmetry group of wave character ( label_len ), pointer :: clabel (:) ! Label for the distance table. character ( label_len ), pointer :: wlabel (:) ! Label for the distance table. real ( wp ), pointer :: P (:) ! Phase real ( wp ), pointer :: FT (:,:) ! FT matrix for Green logical :: checklist ( N_CHECKLIST ) end type Struct integer , parameter :: N_GEO_PARAM = 15 integer , parameter :: GEMO_B = 1 integer , parameter :: GEMO_D = 2 integer , parameter :: GEMO_FT = 3 integer , parameter :: GEMO_P = 4 integer , parameter :: GEMO_T = 5 integer , parameter :: GEMO_W = 6 integer , parameter :: GEMO_CLabel = 7 integer , parameter :: GEMO_dim = 8 integer , parameter :: GEMO_nClass = 9 integer , parameter :: GEMO_nSite = 10 integer , parameter :: GEMO_nWave = 11 integer , parameter :: GEMO_n_b = 12 integer , parameter :: GEMO_n_t = 13 integer , parameter :: GEMO_Name = 14 integer , parameter :: GEMO_wLabel = 15 character ( len =* ), parameter :: GEO_PARAM ( N_GEO_Param ) = & &( / \"B      \" , & & \"D      \" , & & \"FT     \" , & & \"P      \" , & & \"T      \" , & & \"W      \" , & & \"cLabel \" , & & \"dim    \" , & & \"nClass \" , & & \"nSite  \" , & & \"nWave  \" , & & \"n_b    \" , & & \"n_t    \" , & & \"name   \" , & & \"wLabel \" / ) contains !---------------------------------------------------------------------! subroutine DQMC_CCS_Free ( sparA ) ! ! Purpose ! ======= !    This subroutine deallocates arrays in CCS ! ! Arguments ! ========= ! type ( CCS ), intent ( inout ) :: sparA ! ... Executable ... if ( sparA % nnz . gt . 0 ) then deallocate ( sparA % A ) deallocate ( sparA % row ) deallocate ( sparA % cstart ) end if sparA % nnz = 0 sparA % n = 0 end subroutine DQMC_CCS_Free !---------------------------------------------------------------------! subroutine DQMC_CCS_Print ( sparA , OPT ) ! ! Purpose ! ======= !    This subroutine deallocates arrays in CCS ! ! Arguments ! ========= ! type ( CCS ), intent ( in ) :: sparA integer , intent ( in ) :: OPT ! ... Local ... integer :: i , j ! ... Executable ... do i = 1 , sparA % n do j = sparA % cstart ( i ), sparA % cstart ( i + 1 ) - 1 write ( OPT , \"(i5, i5, i5)\" ) sparA % row ( j ), i , sparA % A ( j ) end do end do end subroutine DQMC_CCS_Print !---------------------------------------------------------------------! subroutine DQMC_CCS_Compress ( n , nnz , A , sparA ) ! ! Purpose ! ======= !    This subroutine converts a dense A to a sparse A in CCS format. !    If nnz is unknown, passed nnz=-1 ! ! Arguments ! ========= ! integer , intent ( in ) :: n , nnz integer , intent ( in ) :: A (:,:) type ( CCS ), intent ( inout ) :: sparA ! ... Local varaibles ... integer :: i , j , k ! ... Executable ... ! two pass process if ( nnz . lt . 0 ) then sparA % nnz = 0 do i = 1 , n do j = 1 , n if ( A ( j , i ) . ne . 0 ) then sparA % nnz = sparA % nnz + 1 end if end do end do else sparA % nnz = nnz end if ! allocate space for sparse A sparA % n = n allocate ( sparA % A ( sparA % nnz )) allocate ( sparA % row ( sparA % nnz )) allocate ( sparA % cstart ( n + 1 )) ! fillin data k = 1 do i = 1 , n sparA % cstart ( i ) = k do j = 1 , n if ( A ( j , i ) . ne . 0 ) then sparA % row ( k ) = j sparA % A ( k ) = A ( j , i ) k = k + 1 end if end do end do ! validate if ( k . ne . sparA % nnz + 1 ) then print * , k , sparA % nnz + 1 call DQMC_Error ( \"The passing in nnz does not match actual & & number of nonzeros\" , 0 ) end if sparA % cstart ( n + 1 ) = k end subroutine DQMC_CCS_Compress !---------------------------------------------------------------------! subroutine DQMC_CCS_Fill ( n , A , sparA ) ! ! Purpose ! ======= !    This subroutine converts a sparse A to a dense A. ! ! Arguments ! ========= ! integer , intent ( in ) :: n integer , intent ( inout ) :: A (:,:) type ( CCS ), intent ( in ) :: sparA ! ... Local varaibles ... integer :: i , j ! ... Executable ... A = 0 do i = 1 , n do j = sparA % cstart ( i ), sparA % cstart ( i + 1 ) - 1 A ( sparA % row ( j ), i ) = sparA % A ( j ) end do end do end subroutine DQMC_CCS_Fill !---------------------------------------------------------------------! subroutine DQMC_Struct_Free ( S ) ! ! Purpose ! ======= !    This subroutine deallocates arrays in S ! ! Arguments ! ========= ! type ( struct ), intent ( inout ) :: S ! Struct ! ... Executable ... if ( S % checklist ( STRUCT_INIT )) then if ( S % checklist ( STRUCT_DIM )) deallocate ( S % dim ) if ( S % checklist ( STRUCT_ADJ )) call DQMC_CCS_Free ( S % T ) if ( S % checklist ( STRUCT_CLASS )) deallocate ( S % D , S % F , S % cLabel ) if ( S % checklist ( STRUCT_BOND )) call DQMC_CCS_Free ( S % B ) if ( S % checklist ( STRUCT_WAVE )) deallocate ( S % W , S % wLabel ) if ( S % checklist ( STRUCT_PHASE )) deallocate ( S % P ) if ( S % checklist ( STRUCT_FT )) deallocate ( S % FT ) end if S % checklist = . false . end subroutine DQMC_Struct_Free !---------------------------------------------------------------------! subroutine DQMC_Geom_Read_Def ( S , gfile , tableFormat ) ! ! Purpose ! ======= !    This subrotine reads in parameters from a config file. ! ! Arguments ! ========= ! type ( struct ), intent ( inout ) :: S ! geometry structure character ( * ), intent ( in ) :: gfile ! Input file handle logical , intent ( out ) :: tableFormat ! ... Local Variable ... integer :: stat , i , j , line , pos , idx , cnt , row , col , ielm real ( wp ) :: relm character ( len = llen ) :: str , attr , val logical :: found , def_n , def_w , def_b , def_c integer , parameter :: funit = 11 integer , allocatable :: tmp (:,:) ! ... Executable ... ! satinize S % checklist = . false . ! open file inquire ( file = gfile , exist = found ) if (. not . found ) then call DQMC_Error ( \"cannot open geom def file \" // gfile , 0 ) end if open ( unit = funit , file = gfile ) !check whether this is in the \"table\" format tableFormat = . true . do read ( funit , '(A)' , iostat = stat ) str if ( stat . eq . 0 ) then pos = index ( str , '#HAMILT' ) if ( pos . ne . 0 ) then tableFormat = . false . write ( * , '(A)' ) ' Detected Geometry Free Format.' exit endif else rewind ( funit ) exit endif enddo if (. not . tableFormat ) return ! read geom def ! for fast access, sort records by name ! using insertion sort stat = STAT_COMMENT def_n = . false . def_b = . false . def_w = . false . def_c = . false . nullify ( S % wlabel ) nullify ( S % clabel ) line = 1 S % name = \"Not defined\" do while ( stat . ne . STAT_EOF ) call DQMC_ReadLn ( str , funit , stat ) ! read in a geom definition if ( stat . eq . STAT_NORMAL ) then pos = scan ( str , SEPARAT , . false .) if ( pos . ne . 0 ) then ! read name and data attr = adjustl ( str ( 1 : pos - 1 )) val = adjustl ( str ( pos + 1 : llen )) ! search the name (linear search) found = . false . do idx = 1 , N_GEO_PARAM if ( attr . eq . GEO_PARAM ( idx )) then found = . true . exit end if end do ! found the name if ( found ) then select case ( idx ) case ( GEMO_B ) ! n*n if ( def_n ) then read ( val , * ) cnt tmp = 0 do i = 1 , cnt read ( funit , * ) row , col , ielm tmp ( row , col ) = ielm line = line + 1 end do ! compress call DQMC_CCS_Compress ( S % nSite , cnt , tmp , S % B ) else call DQMC_Error ( \"nSite & & need be defined before Bond\" , 0 ) end if S % checklist ( STRUCT_BOND ) = . true . case ( GEMO_D ) ! n*n if ( def_n ) then read ( val , * ) cnt allocate ( S % D ( S % nSite , S % nSite )) S % D = 0 do i = 1 , cnt read ( funit , * ) row , col , ielm S % D ( row , col ) = ielm line = line + 1 end do else call DQMC_Error ( \"nSite & & need be defined before D-class\" , 0 ) end if S % checklist ( STRUCT_CLASS ) = . true . case ( GEMO_FT ) ! nclass*nclass if ( def_c ) then read ( val , * ) cnt allocate ( S % FT ( S % nClass , S % nClass )) do i = 1 , cnt read ( funit , * ) row , col , relm S % FT ( row , col ) = relm line = line + 1 end do else call DQMC_Error ( \"nClass & & need be defined before Fourier Trans\" , 0 ) end if S % checklist ( STRUCT_FT ) = . true . case ( GEMO_P ) ! check n read ( val , * ) cnt allocate ( S % P ( cnt )) do i = 1 , cnt read ( funit , * ) S % P ( i ) line = line + 1 end do S % checklist ( STRUCT_PHASE ) = . true . case ( GEMO_T ) ! n*n if ( def_n ) then read ( val , * ) cnt tmp = 0 do i = 1 , cnt read ( funit , * ) row , col , ielm tmp ( row , col ) = ielm line = line + 1 end do ! compress call DQMC_CCS_Compress ( S % nSite , cnt , tmp , S % T ) else call DQMC_Error ( \"nSite & & need be defined before Hopping\" , 0 ) end if S % checklist ( STRUCT_ADJ ) = . true . case ( GEMO_W ) ! n_b*nwave if ( def_w . and . def_b ) then read ( val , * ) cnt allocate ( S % W ( S % n_b , S % nWave )) S % W = ZERO do i = 1 , cnt read ( funit , * ) row , col , relm S % W ( row , col ) = relm line = line + 1 end do else call DQMC_Error ( \"n_b and nWave & & need be defined before Wave funs\" , 0 ) end if S % checklist ( STRUCT_WAVE ) = . true . case ( GEMO_CLabel ) read ( val , * ) cnt allocate ( S % clabel ( cnt )) do i = 1 , cnt read ( funit , '(A)' ) S % clabel ( i ) line = line + 1 end do case ( GEMO_dim ) read ( val , * ) cnt allocate ( S % dim ( cnt )) do i = 1 , cnt read ( funit , * ) S % dim ( i ) line = line + 1 end do S % checklist ( STRUCT_DIM ) = . true . case ( GEMO_nClass ) read ( val , * ) S % nClass def_c = . true . case ( GEMO_nSite ) read ( val , * ) S % nSite def_n = . true . allocate ( tmp ( S % nSite , S % nSite )) case ( GEMO_nWave ) read ( val , * ) S % nWave def_w = . true . case ( GEMO_n_b ) read ( val , * ) S % n_b case ( GEMO_n_t ) read ( val , * ) S % n_t def_b = . true . case ( GEMO_Name ) read ( val , * ) S % name case ( GEMO_wLabel ) read ( val , * ) cnt allocate ( S % wlabel ( cnt )) do i = 1 , cnt read ( funit , '(A)' ) S % wlabel ( i ) line = line + 1 end do end select else call DQMC_Warning ( \"Warning: unknown geom input:\" // trim ( str ), 1 ) end if else call DQMC_Warning ( \"cannot recog geom input line :\" , line ) end if end if line = line + 1 end do ! do some simple verification if (. not . def_n ) then call DQMC_Error ( \"nSite must be defined.\" , 0 ) end if if ( S % checklist ( STRUCT_PHASE )) then if ( size ( S % P ) . ne . S % nSite ) then call DQMC_Error ( \"The length of phase assignment is not & & equal to nSite\" , 0 ) end if end if ! default class assignment if (. not . S % checklist ( STRUCT_CLASS )) then allocate ( S % D ( S % nSite , S % nSite )) cnt = 0 do i = 1 , S % nSite do j = i , S % nSite cnt = cnt + 1 S % D ( i , j ) = cnt S % D ( j , i ) = cnt end do end do S % nClass = cnt def_c = . true . S % checklist ( STRUCT_CLASS ) = . true . end if ! nClass = max(D) if (. not . def_c ) then cnt = 1 do i = 1 , S % nSite do j = 1 , S % nSite if ( cnt . lt . S % D ( i , j )) then cnt = S % D ( i , j ) end if end do end do S % nClass = cnt end if ! discover F and Map allocate ( S % F ( S % nClass )) allocate ( S % map ( S % nSite )) call DQMC_Geom_Discover_Map ( S % nSite , S % D , S % F , S % map , S % nGroup ) call DQMC_Geom_Discover_F ( S % nSite , S % D , S % F ) if (. not . associated ( S % clabel )) then allocate ( S % clabel ( S % nClass )) do i = 1 , S % nClass write ( s % clabel ( i ), \"('Class ',i3)\" ) i end do end if ! wave label if ( S % checklist ( STRUCT_Wave )) then if (. not . associated ( S % wlabel )) then allocate ( S % wlabel ( S % nWave )) do i = 1 , S % nWave write ( s % wlabel ( i ), \"('Wave ',i3)\" ) i end do end if end if ! release temp variable deallocate ( tmp ) ! finish initialization S % checklist ( STRUCT_INIT ) = . true . close ( funit ) end subroutine DQMC_Geom_Read_Def !---------------------------------------------------------------------! subroutine DQMC_Geom_Discover_F ( n , D , F ) ! ! Purpose ! ======= !    This subroutine generate F ! ! Arguments ! ========= ! integer , intent ( in ) :: n integer , intent ( in ) :: D (:,:) integer , intent ( inout ) :: F (:) ! ... Local ... integer :: i , j , k ! ... Executable ... F = 0 do i = 1 , n do j = 1 , n k = D ( i , j ) F ( k ) = F ( k ) + 1 end do end do end subroutine DQMC_Geom_Discover_F !---------------------------------------------------------------------! subroutine DQMC_Geom_Discover_Map ( n , D , F , Map , idx ) ! ! Purpose ! ======= !    This subroutine generate F ! ! Arguments ! ========= ! integer , intent ( in ) :: n integer , intent ( in ) :: D (:,:) integer , intent ( inout ) :: F (:) ! working space integer , intent ( inout ) :: Map (:) integer , intent ( out ) :: idx ! ... Local ... integer :: i , k ! ... Executable ... F = 0 map = 0 idx = 0 do i = 1 , n k = D ( i , i ) if ( F ( k ) . eq . 0 ) then idx = idx + 1 map ( i ) = idx F ( k ) = idx else map ( i ) = F ( k ) end if end do end subroutine DQMC_Geom_Discover_Map !---------------------------------------------------------------------! subroutine DQMC_Geom_Print ( S , OPT ) ! ! Purpose ! ======= !    This subroutine generate F ! ! Arguments ! ========= ! type ( struct ), intent ( in ) :: S ! geometry structure integer , intent ( in ) :: OPT ! ... Local ... integer :: i , j , n ! ... Executable ... n = S % nSite write ( OPT , \"(a, a)\" ) \"name  = \" , S % name write ( OPT , \"(a,i5)\" ) \"nSite = \" , S % nSite write ( OPT , \"(a,i5)\" ) \"nWave = \" , S % nWave if ( S % checklist ( STRUCT_DIM )) then write ( OPT , \"(a,i5)\" ) \"dim   = \" , size ( S % dim ) do i = 1 , size ( S % dim ) write ( OPT , \"(i5)\" ) S % dim ( i ) end do write ( OPT , * ) end if if ( S % checklist ( STRUCT_ADJ )) then write ( OPT , \"(a,i5)\" ) \"n_t   = \" , S % n_t write ( OPT , \"(a,i5)\" ) \"T     = \" , S % T % nnz call DQMC_CCS_Print ( S % T , OPT ) write ( OPT , * ) end if if ( S % checklist ( STRUCT_BOND )) then write ( OPT , \"(a,i5)\" ) \"n_b   = \" , S % n_b write ( OPT , \"(a,i5)\" ) \"B     = \" , S % B % nnz call DQMC_CCS_Print ( S % B , OPT ) write ( OPT , * ) end if if ( S % checklist ( STRUCT_CLASS )) then write ( OPT , \"(a,i5)\" ) \"nClass= \" , S % nClass write ( OPT , \"(a,i5)\" ) \"D     = \" , S % nSite * S % nSite do i = 1 , n do j = 1 , n write ( OPT , \"(i5, i5, i5)\" ) i , j , S % D ( i , j ) end do end do write ( OPT , * ) write ( OPT , \"(a,i5)\" ) \"cLabel = \" , S % nClass do i = 1 , S % nClass write ( OPT , * ) S % clabel ( i ) end do write ( OPT , * ) end if if ( S % checklist ( STRUCT_PHASE )) then write ( OPT , \"(a,i5)\" ) \"P      = \" , n do i = 1 , n write ( OPT , * ) S % P ( i ) end do write ( OPT , * ) end if if ( S % checklist ( STRUCT_WAVE )) then write ( OPT , \"(a,i5)\" ) \"nWave = \" , S % nWave write ( OPT , \"(a,i5)\" ) \"nBond = \" , S % n_b write ( OPT , \"(a,i5)\" ) \"W = \" , S % nWave * S % n_b do i = 1 , S % nWave do j = 1 , S % n_b write ( OPT , \"(i5, i5, f15.8)\" ) j , i , S % W ( j , i ) end do end do write ( OPT , * ) write ( OPT , \"(a,i5)\" ) \"wLabel  = \" , S % nWave do i = 1 , S % nWave write ( OPT , * ) S % wlabel ( i ) end do write ( OPT , * ) end if if ( S % checklist ( STRUCT_FT )) then write ( OPT , \"(a,i5)\" ) \"FT = \" , S % nClass * S % nClass do i = 1 , S % nClass do j = 1 , S % nClass write ( OPT , * ) i , j , S % FT ( i , j ) end do end do end if end subroutine DQMC_Geom_Print end module DQMC_STRUCT","tags":"","loc":"sourcefile/dqmc_struct.f90.html"},{"title":"dqmc_cfg.F90 – Quest","text":"This file depends on sourcefile~~dqmc_cfg.f90~~EfferentGraph sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_cfg.f90~~AfferentGraph sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_cfg.f90 sourcefile~ggeom.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_checkerboard.f90 dqmc_checkerboard.F90 sourcefile~dqmc_checkerboard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_geom.f90 dqmc_geom.F90 sourcefile~dqmc_geom.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_kbonds.f90 dqmc_kbonds.F90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_struct.f90 sourcefile~verify.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_Cfg use DQMC_util implicit none ! ! This module contains subroutines to read input parameters. ! ! Parameters ! ========== ! string parameters character , parameter :: COMMENT = \"#\" character , parameter :: SEPARAT = \"=\" character , parameter :: COMMA = \",\" ! string length integer , parameter :: slen = 60 integer , parameter :: llen = 256 integer , parameter :: alen = 10 ! array limit ! status param integer , parameter :: STAT_EOF = - 1 integer , parameter :: STAT_COMMENT = 0 integer , parameter :: STAT_NORMAL = 1 ! type def character ( 8 ), parameter :: TYPE_STR ( 3 ) = ( / \"Real*8  \" , \"Integer \" , \"Char(60)\" / ) integer , parameter :: TYPE_REAL = 1 integer , parameter :: TYPE_INTEGER = 2 integer , parameter :: TYPE_STRING = 3 ! default parameters integer , parameter :: N_Param = 40 ! name of parameters character ( len =* ), parameter :: PARAM_NAME ( N_Param ) = & &( / \"HSF    \" , & ! methods of how HSF are generated & \"HSFin  \" , & ! File name of HSF input, if HSF = HSF_FROM_FILE & \"HSFout \" , & ! File name of HSF output & \"HSFtype\" , & ! HSF type, 0 = discrete, 1 = continuous & \"L      \" , & ! Number of time slides & \"U      \" , & ! Parameter for potential energy & \"accept \" , & ! accept counts & \"bcond  \" , & ! boundary conditions & \"debug  \" , & ! flag for debug information output & \"delta1 \" , & ! parameter for continous HSF & \"delta2 \" , & ! parameter for continous HSF & \"difflim\" , & ! limit of tolerable difference & \"dmu    \" , & ! perturbation of mu & \"dtau   \" , & ! discritize parameter & \"errrate\" , & ! tolerable error & \"fixwrap\" , & ! fix nwrap to input value & \"gamma  \" , & ! correction of Metropolis ratio & \"gfile  \" , & ! geometry definition & \"mu_dn  \" , & ! parameter for chemical potential & \"mu_up  \" , & ! parameter for chemical potential & \"n      \" , & ! number of particles & \"nbin   \" , & ! number of statisitical bins & \"nhist  \" , & ! print history or not & \"nitvl  \" , & ! number of interval, for continuous FT integration & \"north  \" , & ! frequence of orthogonalization & \"npass  \" , & ! number of measurement sweeps & \"ntry   \" , & ! number of global moves per sweeps & \"nwarm  \" , & ! number of warmup sweeps & \"nwrap  \" , & ! frequence of recomputing H & \"nx     \" , & ! number of sites in x direction & \"ny     \" , & ! number of sites in y direction & \"nz     \" , & ! number of sites in y direction & \"ofile  \" , & ! prefix of output files & \"reject \" , & ! rejection counts & \"seed   \" , & ! random seed & \"ssxx   \" , & ! use iterative refinement during sweep & \"t_dn   \" , & ! parameter for kinetic energy & \"t_up   \" , & ! parameter for kinetic energy & \"tausk  \" , & ! frequence of unequal time measurement & \"tdm    \" / ) ! compute time dependent measurement ! default values character ( len =* ), parameter :: PARAM_DVAL ( N_Param ) = & &( / \"-1      \" , & ! HSF & \"HSF.in  \" , & ! HSFin & \"HSF.out \" , & ! HSFout & \"0       \" , & ! HSFtype & \"12      \" , & ! L & \"0.0     \" , & ! U & \"0       \" , & ! accept & \"0,0,0   \" , & ! bcond & \"0       \" , & ! debug & \"1.0     \" , & ! delta1 & \"1.0     \" , & ! delta2 & \"0.001   \" , & ! difflim & \"0.0     \" , & ! dmu & \"0.125   \" , & ! dtau & \"0.001   \" , & ! errrate & \"0       \" , & ! fixwrap & \"0.0     \" , & ! gamma & \"geom.def\" , & ! gfile & \"0.0     \" , & ! mu_up & \"0.0     \" , & ! mu_dn & \"16      \" , & ! n & \"10      \" , & ! nbin & \"0       \" , & ! nhist & \"4       \" , & ! nitvl & \"12      \" , & ! north & \"5000    \" , & ! npass & \"0       \" , & ! ntry & \"1000    \" , & ! nwarm & \"12      \" , & ! nwrap & \"4       \" , & ! nx & \"4       \" , & ! ny & \"2       \" , & ! nz & \"quest   \" , & ! ofile & \"0       \" , & ! reject & \"0       \" , & ! seed & \"0       \" , & ! ssxx & \"1.0     \" , & ! t_up & \"1.0     \" , & ! t_dn & \"10      \" , & ! tausk & \"0       \" / ) ! tdm ! parameter type integer , parameter :: PARAM_TYPE ( N_Param ) = & &( / TYPE_INTEGER , & ! HSF & TYPE_STRING , & ! HSFin & TYPE_STRING , & ! HSFout & TYPE_INTEGER , & ! HSFtype & TYPE_INTEGER , & ! L & TYPE_REAL , & ! U & TYPE_INTEGER , & ! accept & TYPE_REAL , & ! bcond & TYPE_INTEGER , & ! debug & TYPE_REAL , & ! delta1 & TYPE_REAL , & ! delta2 & TYPE_REAL , & ! difflim & TYPE_REAL , & ! dmu & TYPE_REAL , & ! dtau & TYPE_REAL , & ! errrate & TYPE_INTEGER , & ! fixwrap & TYPE_REAL , & ! gamma & TYPE_STRING , & ! gfile & TYPE_REAL , & ! mu_up & TYPE_REAL , & ! mu_dn & TYPE_INTEGER , & ! n & TYPE_INTEGER , & ! nbin & TYPE_INTEGER , & ! nhist & TYPE_INTEGER , & ! nitvl & TYPE_INTEGER , & ! north & TYPE_INTEGER , & ! npass & TYPE_INTEGER , & ! ntry & TYPE_INTEGER , & ! nwarm & TYPE_INTEGER , & ! nwrap & TYPE_INTEGER , & ! nx & TYPE_INTEGER , & ! ny & TYPE_INTEGER , & ! nz & TYPE_STRING , & ! ofile & TYPE_INTEGER , & ! reject & TYPE_INTEGER , & ! seed & TYPE_INTEGER , & ! ssxx & TYPE_REAL , & ! t_up & TYPE_REAL , & ! t_dn & TYPE_INTEGER , & ! tausk & TYPE_INTEGER / ) ! tdm ! is array parameter logical , parameter :: PARAM_ARRAY ( N_Param ) = & &( / . false .,& ! HSF & . false .,& ! HSFin & . false .,& ! HSFout & . false .,& ! HSFtype & . false .,& ! L & . true . ,& ! U & . false .,& ! accept & . true . ,& ! bcond & . false .,& ! debug & . false .,& ! delta1 & . false .,& ! delta2 & . false .,& ! difflim & . false .,& ! dmu & . false .,& ! dtau & . false .,& ! errrate & . false .,& ! fixwrap & . false .,& ! gamma & . false .,& ! gfile & . true . ,& ! mu_up & . true . ,& ! mu_dn & . false .,& ! n & . false .,& ! nbin & . false .,& ! nhist & . false .,& ! nitvl & . false .,& ! north & . false .,& ! npass & . false .,& ! ntry & . false .,& ! nwarm & . false .,& ! nwrap & . false .,& ! nx & . false .,& ! ny & . false .,& ! nz & . false .,& ! ofile & . false .,& ! reject & . false .,& ! seed & . false .,& ! ssxx & . true . ,& ! t_up & . true . ,& ! t_dn & . false .,& ! tausk & . false . / ) ! tdm ! ! Data Type ! ========= ! type Param integer :: id ! hashcode from name character ( len = slen ) :: pname ! parameter name integer :: ptype ! type of parameter logical :: isArray ! is the param an array? logical :: isSet ! is the parameter been set? character ( len = slen ) :: defaultval ! default value type ( Param ), pointer :: next ! values integer :: ival real ( wp ) :: rval integer , pointer :: iptr (:) real ( wp ), pointer :: rptr (:) end type Param type config type ( Param ), pointer :: record (:) ! head of the linked list integer :: nParam logical :: hasDef = . false . end type config ! ================ ! Access functions ! ================ interface CFG_Set module procedure DQMC_Config_SetI , DQMC_Config_SetR module procedure DQMC_Config_SetS , DQMC_Config_SetPR module procedure DQMC_Config_SetPI end interface interface CFG_Get module procedure DQMC_Config_GetI , DQMC_Config_GetR module procedure DQMC_Config_GetS , DQMC_Config_GetPR module procedure DQMC_Config_GetPI end interface contains !---------------------------------------------------------------------! subroutine DQMC_ReadLn ( str , IPT , status ) ! ! Purpose ! ======= !    This subrotine reads in a line from file. !    It will get rid of #. ! ! Arguments ! ========= ! character ( len = llen ) :: str integer :: status intent ( inout ) :: str , status integer , intent ( in ) :: IPT ! ... Local Variables ... integer :: ios , pos ! ... Executable ... read ( unit = IPT , FMT = \"(a)\" , iostat = ios ) str status = STAT_COMMENT ! end of file if ( ios . ne . 0 ) then status = STAT_EOF return end if ! find comment # and get rid of the tailing part pos = scan ( str , COMMENT , . false .) if ( pos . ne . 0 ) then ! find the comment sign if ( pos . ge . 2 ) then str = str ( 1 : pos - 1 ) else str = \"\" end if end if if ( len_trim ( str ) . gt . 0 ) then status = STAT_NORMAL end if end subroutine DQMC_ReadLn !---------------------------------------------------------------------! subroutine DQMC_Default_Def ( cfg ) ! ! Purpose ! ======= !    This subrotine initializes default configuration def. !    when the config.def is missing. ! ! Arguments ! ========= ! type ( config ), intent ( inout ) :: cfg ! configuration ! ... Local Variable ... type ( Param ), pointer :: curr integer :: i ! ... Executable ... cfg % nParam = N_Param allocate ( cfg % record ( cfg % nParam )) do i = 1 , N_Param curr => cfg % record ( i ) curr % id = i curr % pname = PARAM_NAME ( i ) curr % ptype = PARAM_TYPE ( i ) curr % isArray = PARAM_ARRAY ( i ) curr % defaultval = PARAM_DVAL ( i ) if ( curr % ptype . eq . TYPE_REAL ) then read ( curr % defaultval , * ) curr % rval elseif ( curr % ptype . eq . TYPE_INTEGER ) then read ( curr % defaultval , * ) curr % ival end if curr % isSet = . false . nullify ( curr % iptr ) nullify ( curr % rptr ) nullify ( curr % next ) end do end subroutine DQMC_Default_Def !---------------------------------------------------------------------! subroutine DQMC_Config_Free ( cfg ) ! ! Purpose ! ======= !    This subrotine initializes default configuration def. !    when the config.def is missing. ! ! Arguments ! ========= ! type ( config ), intent ( inout ) :: cfg ! configuration ! ... Local ... integer :: i ! ... Executable ... do i = 1 , cfg % nParam if ( associated ( cfg % record ( i )% rptr )) then deallocate ( cfg % record ( i )% rptr ) end if if ( associated ( cfg % record ( i )% iptr )) then deallocate ( cfg % record ( i )% iptr ) end if end do deallocate ( cfg % record ) end subroutine DQMC_Config_Free !---------------------------------------------------------------------! subroutine DQMC_Read_Def ( cfg , IPT ) ! ! Purpose ! ======= !    This subrotine reads in parameters from a config file. ! ! Arguments ! ========= ! type ( config ), intent ( inout ) :: cfg ! configuration integer , intent ( in ) :: IPT ! Input file handle ! ... Local Variable ... integer :: stat , i , cnt character ( len = llen ) :: str type ( Param ), pointer :: head type ( Param ), pointer :: curr type ( Param ), pointer :: tmp logical :: found ! ... Executable ... ! satinize nullify ( curr ) nullify ( head ) cnt = 0 stat = STAT_COMMENT ! read config def ! for fast access, sort records by name ! using insertion sort do while ( stat . ne . STAT_EOF ) call DQMC_ReadLn ( str , IPT , stat ) ! read in a parameter definition if ( stat . eq . STAT_NORMAL ) then ! allocate space if ( cnt . eq . 0 ) then allocate ( head ) curr => head else allocate ( curr ) end if nullify ( curr % next ) cnt = cnt + 1 ! read in [name][type][is array][is critical][default value] read ( str , * ) curr % pname , curr % ptype , curr % isArray , curr % defaultval if ( cnt . gt . 1 ) then ! insertion sort ! if curr < head, put it as the first one if ( LGT ( head % pname , curr % pname )) then curr % next => head head => curr else ! curr >= head ! find a record tmp, which is > curr, but its next is < curr. tmp => head found = . false . do while (. not . found . and . associated ( tmp % next )) ! tmp > curr if ( LGT ( tmp % next % pname , curr % pname )) then curr % next => tmp % next tmp % next => curr found = . true . else tmp => tmp % next end if end do ! curr is the largest if (. not . found ) then tmp % next => curr end if end if end if end if end do ! allocate space for records cfg % nParam = cnt allocate ( cfg % record ( cnt )) tmp => head do i = 1 , cnt curr => cfg % record ( i ) curr % id = i curr % pname = tmp % pname curr % ptype = tmp % ptype curr % isArray = tmp % isArray curr % defaultval = tmp % defaultval if ( curr % ptype . eq . TYPE_REAL ) then read ( curr % defaultval , * ) curr % rval elseif ( curr % ptype . eq . TYPE_INTEGER ) then read ( curr % defaultval , * ) curr % ival end if curr % isSet = . false . nullify ( curr % iptr ) nullify ( curr % rptr ) nullify ( curr % next ) ! free allocated space tmp => head % next deallocate ( head ) head => tmp end do cfg % hasDef = . true . end subroutine DQMC_Read_Def !---------------------------------------------------------------------! subroutine DQMC_Print_Def ( cfg , OPT ) ! ! Purpose ! ======= !    This subrotine prints condifuration definitions. ! ! Arguments ! ========= ! type ( config ), intent ( inout ) :: cfg ! configuration integer , intent ( in ) :: OPT ! Input file handle ! ... Local Variable ... integer :: i type ( Param ), pointer :: curr ! ... Executable ... write ( OPT , 200 ) \"ID\" , \" Name\" , \"Default\" , \"Type\" write ( OPT , \"(53('='))\" ) do i = 1 , cfg % nParam curr => cfg % record ( i ) if ( curr % isArray ) then write ( OPT , 100 ) curr % id , curr % pname , curr % defaultval , & TYPE_STR ( curr % ptype ), \"Array  \" else write ( OPT , 100 ) curr % id , curr % pname , curr % defaultval , & TYPE_STR ( curr % ptype ), \"Scalar \" end if end do 100 format ( i5 , 2 X , a10 , 2 X , a10 , 2 X , a10 , 2 X , a10 ) 200 format ( a5 , 1 X , a5 , 5 X , a10 , 1 X , a10 ) end subroutine DQMC_Print_Def !---------------------------------------------------------------------! function DQMC_Find_Param ( cfg , pname ) result ( id ) ! ! Purpose ! ======= !    This subrotine returns the id of given parameter name. !    It will return -1 if no match is found. ! ! Arguments ! ========= ! type ( config ), intent ( in ) :: cfg ! configuration character ( * ), intent ( in ) :: pname ! Parameter name integer :: id character ( len ( pname )) :: uppname , uprecord ! ... Local Variable ... integer :: high , low logical :: found ! ... Executable ... ! binary search low = 1 high = cfg % nParam uppname = uppercase ( pname ) found = . false . do id = 1 , high uprecord = uppercase ( cfg % record ( id )% pname ) if ( uppname . eq . uprecord ) then found = . true . exit endif enddo !do while (.not. found .and. (low .le. high)) !   id = (low+high)/2 !   ! pname > param(id) !   if (LGT(pname, cfg%record(id)%pname)) then !      low  = id + 1 !      ! pname < param(id) !   elseif (LLT(pname, cfg%record(id)%pname)) then !      high = id - 1 !      ! !   else !      found = .true. !   end if !end do if (. not . found ) then id = - 1 end if contains function uppercase ( string ) result ( newstring ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: newstring integer :: j do j = 1 , len ( string ) if ( string ( j : j ) >= \"a\" . and . string ( j : j ) <= \"z\" ) then newstring ( j : j ) = achar ( iachar ( string ( j : j )) - 32 ) else newstring ( j : j ) = string ( j : j ) end if end do newstring = adjustl ( newstring ) end function uppercase end function DQMC_Find_Param !---------------------------------------------------------------------! subroutine DQMC_Read_Config ( cfg ) ! ! Purpose ! ======= !    This subrotine reads in parameters from a config file. ! ! Arguments ! ========= ! type ( config ), intent ( inout ) :: cfg ! configuration ! ... Local Variable ... integer :: ios , pos , line , j , id character ( len = llen ) :: str , attr , val logical :: found real ( wp ) :: tmp ( alen ) ! for reading t type ( Param ), pointer :: curr integer , parameter :: funit = 10 character ( len = 60 ) :: iname integer :: IPT , status ! ... Executable ... ! Fetch input file name from command line call get_command_argument ( 1 , iname , STATUS = status ) if ( status > 0 ) then call DQMC_Error ( \"failed to retrieve input file argument\" , 0 ) elseif ( status == - 1 ) then call DQMC_Error ( \"String 'iname' is too small to hold input file name, recompile me with a larger ifile!\" , 0 ) end if ! Open input file call DQMC_open_file ( iname , 'old' , IPT ) ! read def first if (. not . cfg % hasDef ) then ! read def file inquire ( file = \"config.def\" , exist = found ) if ( found ) then open ( unit = funit , file = \"config.def\" ) call DQMC_Read_Def ( cfg , funit ) close ( funit ) else ! use default def call DQMC_Default_Def ( cfg ) end if end if ! read real config file line = 0 do line = line + 1 read ( unit = IPT , FMT = \"(a)\" , iostat = ios ) str ! end of file if ( ios . ne . 0 ) then exit end if ! find comment  # and get rid of the tailing part pos = scan ( str , COMMENT , . false .) if ( pos . ne . 0 ) then ! find the comment sign if ( pos . ge . 2 ) then str = str ( 1 : pos - 1 ) else str = \"\" end if end if ! trim the read in string if ( len_trim ( str ) . gt . 0 ) then ! find separator = pos = scan ( str , SEPARAT , . false .) if ( pos . ne . 0 ) then ! read name and data attr = adjustl ( str ( 1 : pos - 1 )) val = adjustl ( str ( pos + 1 : llen )) ! search parameter definition id = DQMC_Find_Param ( cfg , attr ) ! found it if ( id . gt . 0 ) then curr => cfg % record ( id ) if ( curr % isArray ) then ! array case if ( curr % ptype . eq . TYPE_REAL . or . & curr % ptype . eq . TYPE_INTEGER ) then j = 1 pos = scan ( val , COMMA , . false .) ! For more than one t do while ( pos . gt . 0 ) read ( val ( 1 : pos - 1 ), * ) tmp ( j ) val = val ( pos + 1 : llen ) j = j + 1 pos = scan ( val , COMMA , . false .) end do ! the last one read ( val , * ) tmp ( j ) ! copy to new allocated PR if ( curr % ptype . eq . TYPE_REAL ) then allocate ( curr % rptr ( j )) curr % ival = j curr % rptr = tmp ( 1 : j ) else allocate ( curr % iptr ( j )) curr % ival = j curr % iptr = int ( tmp ( 1 : j )) end if else call DQMC_Warning ( \"Array only for real and integer\" , 1 ) end if else ! scalar case select case ( curr % ptype ) case ( TYPE_REAL ) read ( val , * ) curr % rval case ( TYPE_INTEGER ) read ( val , * ) curr % ival case ( TYPE_STRING ) curr % defaultval = val ( 1 : slen ) end select end if ! mark the flag curr % isSet = . true . else call DQMC_Warning ( \"Warning: unknown input:\" // trim ( str ), 1 ) end if else call DQMC_Warning ( \"cannot recog input line :\" , line ) end if end if end do end subroutine DQMC_Read_Config !---------------------------------------------------------------------! ! Access functions !---------------------------------------------------------------------! subroutine DQMC_Config_SetI ( cfg , name , value ) ! ! Purpose ! ======= !    This subrotine set configurations. ! ! Arguments ! ========= ! type ( config ), intent ( inout ) :: cfg ! configuration character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: value ! ! ... Local variables... integer :: id ! ... Executable ... id = DQMC_Find_Param ( cfg , name ) if ( id . gt . 0 ) then cfg % record ( id )% ival = value cfg % record ( id )% isSet = . true . else call DQMC_Error ( \"cannot find parameter \" // name , 0 ) end if end subroutine DQMC_Config_SetI !---------------------------------------------------------------------! subroutine DQMC_Config_SetR ( cfg , name , value ) ! ! Purpose ! ======= !    This subrotine set configurations. ! ! Arguments ! ========= ! type ( config ), intent ( inout ) :: cfg ! configuration character ( len =* ), intent ( in ) :: name real ( wp ), intent ( in ) :: value ! ... Local variables... integer :: id ! ... Executable ... id = DQMC_Find_Param ( cfg , name ) if ( id . gt . 0 ) then cfg % record ( id )% rval = value cfg % record ( id )% isSet = . true . else call DQMC_Error ( \"cannot find parameter \" // name , 0 ) end if end subroutine DQMC_Config_SetR !---------------------------------------------------------------------! subroutine DQMC_Config_SetPR ( cfg , name , n , value ) ! ! Purpose ! ======= !    This subrotine set configurations. ! ! Arguments ! ========= ! type ( config ), intent ( inout ) :: cfg ! configuration character ( len =* ), intent ( in ) :: name real ( wp ), intent ( in ) :: value ( n ) integer , intent ( in ) :: n ! ... Local variables... integer :: id ! ... Executable ... id = DQMC_Find_Param ( cfg , name ) if ( id . gt . 0 ) then cfg % record ( id )% ival = n if ( associated ( cfg % record ( id )% rptr )) then deallocate ( cfg % record ( id )% rptr ) end if allocate ( cfg % record ( id )% rptr ( n )) cfg % record ( id )% rptr = value cfg % record ( id )% isSet = . true . else call DQMC_Error ( \"cannot find parameter \" // name , 0 ) end if end subroutine DQMC_Config_SetPR !---------------------------------------------------------------------! subroutine DQMC_Config_SetPI ( cfg , name , n , value ) ! ! Purpose ! ======= !    This subrotine set configurations. ! ! Arguments ! ========= ! type ( config ), intent ( inout ) :: cfg ! configuration character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: value ( n ) integer , intent ( in ) :: n ! ... Local variables... integer :: id ! ... Executable ... id = DQMC_Find_Param ( cfg , name ) if ( id . gt . 0 ) then cfg % record ( id )% ival = n if ( associated ( cfg % record ( id )% iptr )) then deallocate ( cfg % record ( id )% iptr ) end if allocate ( cfg % record ( id )% iptr ( n )) cfg % record ( id )% iptr = value cfg % record ( id )% isSet = . true . else call DQMC_Error ( \"cannot find parameter \" // name , 0 ) end if end subroutine DQMC_Config_SetPI !---------------------------------------------------------------------! subroutine DQMC_Config_SetS ( cfg , name , value ) ! ! Purpose ! ======= !    This subrotine set configurations. ! ! Arguments ! ========= ! type ( config ), intent ( inout ) :: cfg ! configuration character ( * ), intent ( in ) :: name character ( * ), intent ( in ) :: value ! ... Local variables... integer :: id ! ... Executable ... id = DQMC_Find_Param ( cfg , name ) if ( id . gt . 0 ) then cfg % record ( id )% defaultval = value cfg % record ( id )% isSet = . true . else call DQMC_Error ( \"cannot find parameter \" // name , 0 ) end if end subroutine DQMC_Config_SetS !---------------------------------------------------------------------! function DQMC_Config_isSet ( cfg , name ) result ( isSet ) ! ! Purpose ! ======= !    This subrotine set configurations. ! ! Arguments ! ========= ! type ( config ), intent ( in ) :: cfg ! configuration character ( * ), intent ( in ) :: name logical :: isSet ! ! ... local variables integer :: id ! ... Executable ... id = DQMC_Find_Param ( cfg , name ) isSet = . false . if ( id . gt . 0 ) then isSet = cfg % record ( id )% isSet else call DQMC_Error ( \"cannot find parameter \" // name , 0 ) end if end function DQMC_Config_isSet !---------------------------------------------------------------------! subroutine DQMC_Config_GetI ( cfg , name , value ) ! ! Purpose ! ======= !    This subrotine set configurations. ! ! Arguments ! ========= ! type ( config ), intent ( in ) :: cfg ! configuration character ( * ), intent ( in ) :: name integer , intent ( out ) :: value ! ! ... Local variables... integer :: id ! ... Executable ... id = DQMC_Find_Param ( cfg , name ) if ( id . gt . 0 ) then if (. not . cfg % record ( id )% isSet ) then call DQMC_Warning ( name // \" wasn't initialized,& & used default setting.\" , 1 ) read ( cfg % record ( id )% defaultval , * ) value else value = cfg % record ( id )% ival end if else call DQMC_Error ( \"cannot find parameter \" // name , 0 ) end if end subroutine DQMC_Config_GetI !---------------------------------------------------------------------! subroutine DQMC_Config_GetR ( cfg , name , value ) ! ! Purpose ! ======= !    This subrotine set configurations. ! ! Arguments ! ========= ! type ( config ), intent ( in ) :: cfg ! configuration character ( * ), intent ( in ) :: name real ( wp ), intent ( out ) :: value ! ! ... local variables integer :: id ! ... Executable ... id = DQMC_Find_Param ( cfg , name ) if ( id . gt . 0 ) then if (. not . cfg % record ( id )% isSet ) then call DQMC_Warning ( name // \" wasn't initialized, & & used default setting.\" , 1 ) read ( cfg % record ( id )% defaultval , * ) value else value = cfg % record ( id )% rval end if else call DQMC_Error ( \"cannot find parameter \" // name , 0 ) end if end subroutine DQMC_Config_GetR !---------------------------------------------------------------------! subroutine DQMC_Config_GetPR ( cfg , name , n , value ) ! ! Purpose ! ======= !    This subrotine set configurations. ! ! Arguments ! ========= ! type ( config ), intent ( in ) :: cfg ! configuration character ( * ), intent ( in ) :: name real ( wp ), pointer , intent ( inout ) :: value (:) integer , intent ( out ) :: n ! ... local variables integer :: id ! ... Executable ... id = DQMC_Find_Param ( cfg , name ) !    write(*,*) \"in DQMC_Config_GetPR, id=\",id !    write(*,*) \"in DQMC_Config_GetPR, name=\",name !    write(*,*) \"in DQMC_Config_GetPR, value associated?\",associated(value) if ( id . gt . 0 ) then if (. not . cfg % record ( id )% isSet ) then call DQMC_Warning ( name // \" wasn't initialized,& & used default setting.\" , 1 ) n = 1 if ( associated ( value )) then deallocate ( value ) end if allocate ( value ( n )) read ( cfg % record ( id )% defaultval , * ) value ( 1 ) else n = cfg % record ( id )% ival if ( associated ( value )) then deallocate ( value ) end if allocate ( value ( n )) value ( 1 : n ) = cfg % record ( id )% rptr ( 1 : n ) end if else call DQMC_Error ( \"cannot find parameter \" // name , 0 ) end if end subroutine DQMC_Config_GetPR !---------------------------------------------------------------------! subroutine DQMC_Config_GetPI ( cfg , name , n , value ) ! ! Purpose ! ======= !    This subrotine set configurations. ! ! Arguments ! ========= ! type ( config ), intent ( in ) :: cfg ! configuration character ( * ), intent ( in ) :: name integer , pointer , intent ( inout ) :: value (:) integer , intent ( out ) :: n ! ... local variables integer :: id ! ... Executable ... id = DQMC_Find_Param ( cfg , name ) !    write(*,*) \"in DQMC_Config_GetPI, id=\",id !    write(*,*) \"in DQMC_Config_GetPI, name=\",name !    write(*,*) \"in DQMC_Config_GetPI, value associated?\",associated(value) if ( id . gt . 0 ) then if (. not . cfg % record ( id )% isSet ) then call DQMC_Warning ( name // \" wasn't initialized, & & used default setting.\" , 1 ) n = 1 read ( cfg % record ( id )% defaultval , * ) value ( 1 ) else n = cfg % record ( id )% ival if ( associated ( value )) then deallocate ( value ) end if allocate ( value ( n )) value ( 1 : n ) = cfg % record ( id )% iptr ( 1 : n ) end if else call DQMC_Error ( \"cannot find parameter \" // name , 0 ) end if end subroutine DQMC_Config_GetPI !---------------------------------------------------------------------! subroutine DQMC_Config_GetS ( cfg , name , value ) ! ! Purpose ! ======= !    This subrotine set configurations. ! ! Arguments ! ========= ! type ( config ), intent ( in ) :: cfg ! configuration character ( * ), intent ( in ) :: name character ( len = slen ) :: value ! ... local variables integer :: id ! ... Executable ... id = DQMC_Find_Param ( cfg , name ) if ( id . gt . 0 ) then if (. not . cfg % record ( id )% isSet ) then call DQMC_Warning ( name // \" wasn't initialized, & & used default setting.\" , 1 ) end if value = cfg % record ( id )% defaultval else call DQMC_Error ( \"cannot find parameter \" // name , 0 ) end if end subroutine DQMC_Config_GetS !---------------------------------------------------------------------! end module DQMC_Cfg","tags":"","loc":"sourcefile/dqmc_cfg.f90.html"},{"title":"dqmc_kbonds.F90 – Quest","text":"This file depends on sourcefile~~dqmc_kbonds.f90~~EfferentGraph sourcefile~dqmc_kbonds.f90 dqmc_kbonds.F90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_KBONDS use dqmc_reclatt implicit none type :: kbonds_t integer :: nak integer :: nbonds integer :: nmomenta integer , pointer :: map_symm_ak (:,:) integer , pointer :: map_symm_bak (:,:,:) integer , pointer :: class_size (:,:) integer , pointer :: myclass (:,:,:) integer , pointer :: nclass (:) integer , pointer :: bond_origin (:, :) integer , pointer :: bond_target (:, :) integer , pointer :: bmap (:, :, :) real ( wp ), pointer :: ksum (:,:) end type contains !-----------------------------------------------------------------! subroutine init_kbonds ( symm , lattice , reclatt , kbonds ) use dqmc_symm use dqmc_latt ! This subroutine defines the action of symmetry operation on ! the pair (iat, k) where k is one of the k-points and iat is ! one of the orbital in the primitive cell. To each pair (iat,k) ! it is associated the integer iatk = (iat-1)*nk + k. The routine ! constructs the matrix map_symm_ak(iatk, isymm) that given the ! symmetry operation isymm returns the pair (jat, k') where (iat,k) ! is mapped. type ( symm_operations ), intent ( in ) :: symm type ( lattice_t ), intent ( in ) :: lattice type ( recip_lattice_t ), intent ( in ) :: reclatt type ( kbonds_t ), intent ( inout ) :: kbonds integer :: iak , ia , ik , jk , ja , jak , na , nk , ns , is , nm , nd , id character ( len = 1 ) :: snd character ( len = 50 ) :: sfmt na = lattice % natom nk = reclatt % nkpts ns = Symm % nsymm nm = reclatt % nmomenta nd = reclatt % ndim kbonds % nak = na * nk kbonds % nbonds = na * na * nk kbonds % nmomenta = nm allocate ( kbonds % map_symm_ak ( na * nk , ns )) !Loop over atom types do ia = 0 , na - 1 !Loop over k-points do ik = 1 , nk !Construct state label iak = ia * nk + ik !Act with symmetry operation do is = 1 , ns !Act on k-point jk = symm % map_symm_k ( ik , is ) !Act on site ja = symm % map_symm ( ia , is ) !Check this is an allowed mapping if ( ja >= na ) then write ( * , * ) 'Only symmetry operations mapping sites   & &  in the primitive cell to sites in the             & &  primitive cell are allowed.' stop endif !Get the new state jak = ja * nk + jk !Store the mapping kbonds % map_symm_ak ( iak , is ) = jak enddo enddo enddo write ( snd , '(i1)' ) nd write ( sfmt , '(5A)' ) '(i2,1x,' , snd , 'f9.5,1x,\"->\",1x,i2,1x,' , snd , 'f9.5)' open ( unit = 25 , file = 'symmetry_map.info' , status = 'unknown' , position = 'append' ) do is = 1 , ns id = symm % valid_symm ( is ) write ( 25 , * ) 'Mapping of Symmetry :' , id , symm % Symmlabel ( id ) do ia = 0 , na - 1 do ik = 1 , nk iak = ia * nk + ik jak = kbonds % map_symm_ak ( iak , is ) jk = mod ( jak , nk ) if ( jk == 0 ) jk = nk ja = ( jak - jk ) / nk write ( 25 , sfmt ) ia , ( reclatt % klist ( ik , id ), id = 1 , nd ),& & ja , ( reclatt % klist ( jk , id ), id = 1 , nd ) enddo enddo enddo close ( 25 ) !Store total pair momenta in kbonds (handy). allocate ( kbonds % ksum ( nm , rdim )) kbonds % ksum = reclatt % ksum end subroutine init_kbonds !-----------------------------------------------------------------! subroutine construct_kbonds ( reclatt , kbonds ) ! Given the total number of momenta for the pair, ! construct bonds amongst states (iat,k) and (jat,k') ! that have a total momentum k+k' that sums up to the ! requested one. Note that a bond has a direction: ! it goes from (iat,k), where an up spin particle is ! created, to (jat,k), where a down one is created. ! It is possible for some of the pairs to be identical ! (overcounting). This, however, does not pose any major ! problem apart from a small overhead during the computation ! of the 2-particle GF. type ( recip_lattice_t ), intent ( in ) :: reclatt type ( kbonds_t ), intent ( inout ) :: kbonds integer :: nak , nmom , nb , nat , nk integer :: im , iak , jat , ik , jk , jak , ib integer :: nbond_from ( kbonds % nak ) logical :: assigned ( kbonds % nak , kbonds % nak ) nak = kbonds % nak nb = kbonds % nbonds nmom = reclatt % nmomenta nk = reclatt % nkpts nat = nak / nk allocate ( kbonds % bmap ( nak , nak , nmom )) allocate ( kbonds % bond_origin ( nb , nmom )) allocate ( kbonds % bond_target ( nb , nmom )) kbonds % bmap = - 1 !Loop over pair total momenta do im = 1 , nmom ib = 0 assigned = . false . nbond_from = 0 !Loop over state do iak = 1 , nak !Find k-point for the state ik = mod ( iak - 1 , nk ) + 1 !and its mate jk i.e. the one that summed to ik gives ! the im-th total momentum. jk = reclatt % kmate ( ik , im ) !Loop over atom types do jat = 0 , nat - 1 !and construct all states with momentum jk jak = jat * nk + jk !assign a number to the pair iak, jak if (. not . assigned ( iak , jak )) then ib = ib + 1 nbond_from ( iak ) = nbond_from ( iak ) + 1 kbonds % bond_origin ( ib , im ) = iak kbonds % bond_target ( ib , im ) = jak kbonds % bmap ( iak , jak , im ) = ib assigned ( iak , jak ) = . true . endif !and to the pair jak, iak if (. not . assigned ( jak , iak )) then ib = ib + 1 nbond_from ( jak ) = nbond_from ( jak ) + 1 kbonds % bond_origin ( ib , im ) = jak kbonds % bond_target ( ib , im ) = iak kbonds % bmap ( jak , iak , im ) = ib assigned ( jak , iak ) = . true . endif enddo enddo !Check the number of pair equals the number of states if ( ib /= nb ) then write ( * , * ) 'Pair momentum: ' ,( kbonds % ksum ( im , ik ), ik = 1 , 3 ) write ( * , * ) 'nb /= ib. Suspicious. Stop.' stop endif enddo end subroutine construct_kbonds !-----------------------------------------------------------------! subroutine map_symm_kbond ( kbonds ) ! Given a pair (iat,k),(jat,k') this routines set up a matrix ! that map the action of all symmetry operations into the ! label of the final pair. type ( kbonds_t ), intent ( inout ) :: kbonds integer :: im , ib , jb , iak , jak , isymm , inew , jnew , nsymm , nb , nm nsymm = size ( kbonds % map_symm_ak , 2 ) nb = kbonds % nbonds nm = kbonds % nmomenta allocate ( kbonds % map_symm_bak ( nb , nsymm , nm )) !Loop over all pair momenta do im = 1 , kbonds % nmomenta !Loop over all pairs with momenta im do ib = 1 , nb !Get the two states iak = kbonds % bond_origin ( ib , im ) jak = kbonds % bond_target ( ib , im ) !Loop over all symmetries do isymm = 1 , nsymm !Get the two new states inew = kbonds % map_symm_ak ( iak , isymm ) jnew = kbonds % map_symm_ak ( jak , isymm ) !and their pair number jb = kbonds % bmap ( inew , jnew , im ) if ( jb < 0 ) stop 'Symmetry map is wrong' !Store the mapping kbonds % map_symm_bak ( ib , isymm , im ) = jb enddo enddo enddo end subroutine map_symm_kbond !-----------------------------------------------------------------! subroutine construct_kbond_classes ( kbonds ) ! This routine construct my_class_b(ib,jb) where ib and jb are two bonds. ! my_class contains the symmetry class of the pair (ib,jb) type ( kbonds_t ), intent ( inout ) :: kbonds integer :: nclass , ntotbond integer :: ib , isymm , iclass , istart , im , ak1 , ak2 integer :: csize , csizenew , maxclass , nsymm integer :: id , bx , by , jclass , jstart , idj , mclass , jb , i , j integer , pointer :: myclass (:,:) integer , allocatable :: bond1 (:,:), bond2 (:,:), csizev (:) integer , pointer :: map_symm_b (:,:) ntotbond = kbonds % nbonds nsymm = size ( kbonds % map_symm_ak , 2 ) allocate ( myclass ( ntotbond , ntotbond )) allocate ( kbonds % myclass ( ntotbond , ntotbond , kbonds % nmomenta )) allocate ( kbonds % nclass ( kbonds % nmomenta )) do im = 1 , kbonds % nmomenta nclass = ( ntotbond ** 2 + ntotbond ) / 2 allocate ( csizev ( nclass )) allocate ( bond1 ( 2 , nclass )) allocate ( bond2 ( 2 , nclass )) map_symm_b => kbonds % map_symm_bak (:,:, im ) !Initially Define classes as if all bonds were different !the pair (bond1(ix,iclass) , bond2(ix,iclass)) is the ix-th member !of class \"iclass\" nclass = 0 !Classes made up by a bond and itself do ib = 1 , ntotbond nclass = nclass + 1 myclass ( ib , ib ) = nclass bond1 ( 1 , nclass ) = ib bond2 ( 1 , nclass ) = ib csizev ( nclass ) = 1 enddo !Classes made up by distinct bonds do ib = 1 , ntotbond do jb = ib + 1 , ntotbond nclass = nclass + 1 myclass ( ib , jb ) = nclass myclass ( jb , ib ) = nclass bond1 ( 1 , nclass ) = ib bond2 ( 1 , nclass ) = jb bond1 ( 2 , nclass ) = jb bond2 ( 2 , nclass ) = ib csizev ( nclass ) = 2 enddo enddo !Try all symmetry operations. The \"+1\" operation corresponds to !the symmetry between up-dn-dn-up and dn-up-up-dn. do isymm = 1 , nsymm + 1 !on all classes do iclass = 1 , nclass istart = 1 !we now loop over the elements of a class. !This number is increased as we found new equivalent !elements. do csize = csizev ( iclass ) csizenew = csize do id = istart , csize !map the two bonds if ( isymm == nsymm + 1 ) then ak1 = kbonds % bond_origin ( bond1 ( id , iclass ), im ) ak2 = kbonds % bond_target ( bond1 ( id , iclass ), im ) bx = kbonds % bmap ( ak2 , ak1 , im ) ak1 = kbonds % bond_origin ( bond2 ( id , iclass ), im ) ak2 = kbonds % bond_target ( bond2 ( id , iclass ), im ) by = kbonds % bmap ( ak2 , ak1 , im ) else bx = map_symm_b ( bond1 ( id , iclass ), isymm ) by = map_symm_b ( bond2 ( id , iclass ), isymm ) endif !Find the new class jclass = myclass ( bx , by ) if ( jclass /= iclass ) then !Classes are different: merge them jstart = csizenew !Increase size of iclass csizenew = csizenew + csizev ( jclass ) call resize_class () !transfer jclass member to iclass do idj = 1 , csizev ( jclass ) bx = bond1 ( idj , jclass ) by = bond2 ( idj , jclass ) myclass ( bx , by ) = iclass bond1 ( jstart + idj , iclass ) = bx bond2 ( jstart + idj , iclass ) = by enddo !annihilate jclass csizev ( jclass ) = 0 endif enddo !Size has not changed so we cannot merge any other class into iclass if ( csizenew == csize ) exit !Update loop boundary to find new equivalence due to newly added classes. istart = csizev ( iclass ) + 1 csizev ( iclass ) = csizenew enddo enddo enddo !Exclude empty classes mclass = 0 do i = 1 , nclass if ( csizev ( i ) > 0 ) mclass = mclass + 1 do j = 1 , csizev ( i ) bx = bond1 ( j , i ) by = bond2 ( j , i ) myclass ( bx , by ) = mclass enddo enddo !Save classes in Bonds and determine class size kBonds % nclass ( im ) = mclass kBonds % myclass (:,:, im ) = myclass (:,:) deallocate ( bond1 , bond2 , csizev ) enddo ! npairk deallocate ( myclass ) maxclass = maxval ( kbonds % nclass ) allocate ( kbonds % class_size ( maxclass , kbonds % nmomenta )) kbonds % class_size = 0 do im = 1 , kbonds % nmomenta do ib = 1 , ntotbond do jb = 1 , ntotbond id = kbonds % myclass ( ib , jb , im ) kbonds % class_size ( id , im ) = kbonds % class_size ( id , im ) + 1 enddo enddo enddo contains subroutine resize_class () implicit none ! ... Local vars ... integer :: curr_csize integer , allocatable :: tmpbond (:,:) ! ... Executable ... curr_csize = size ( bond1 , 1 ) if ( csizenew > curr_csize ) then !Initially allocate temp array allocate ( tmpbond ( csizenew , nclass )) !Update size of patom without loosing its content tmpbond ( 1 : curr_csize ,:) = bond1 ( 1 : curr_csize ,:) deallocate ( bond1 ) allocate ( bond1 ( csizenew , nclass )) bond1 = tmpbond !Update size of satom without loosing its content tmpbond ( 1 : curr_csize ,:) = bond2 ( 1 : curr_csize ,:) deallocate ( bond2 ); allocate ( bond2 ( csizenew , nclass )) bond2 = tmpbond !deallocate temp array deallocate ( tmpbond ) end if end subroutine resize_class end subroutine construct_kbond_classes end module DQMC_KBONDS","tags":"","loc":"sourcefile/dqmc_kbonds.f90.html"},{"title":"dqmc_tdm2.F90 – Quest","text":"This file depends on sourcefile~~dqmc_tdm2.f90~~EfferentGraph sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_wspace.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_TDM2 #include \"dqmc_include.h\" use DQMC_UTIL use DQMC_STRUCT use DQMC_Phy2 use DQMC_TDM1 implicit none ! ! This module is to compute susceptibility. ! Susceptibility is stored in a 3 dimensional array. The first two ! dimensions are for pair of neighbors of any two pair of particles. ! The third dimension is for different time slice. ! When aggregated, ! type TDM2 real ( wp ), pointer :: Pair (:,:,:) ! working real ( wp ), pointer :: Apair (:,:,:) ! accumulated real ( wp ), pointer :: Bpair (:,:,:) ! sus in wave form real ( wp ), pointer :: Npair (:,:,:) ! no vertex sus integer :: n integer :: nClass integer :: nB integer :: nWave integer :: L integer :: itvl real ( wp ) :: dtau type ( CCS ), pointer :: Bond ! bonds integer , pointer :: D (:,:,:) ! nonvertex info integer , pointer :: SD (:,:) ! neighbor info real ( wp ), pointer :: Wave (:,:) real ( wp ), pointer :: T (:,:) ! working space for getting wave integer :: ldt character ( label_len ), pointer :: label (:) end type TDM2 contains ! Subroutines ! ================================================================== subroutine DQMC_TDM2_Init ( n , L , nBin , T2 , S , T ) ! ! Purpose ! ======= !    This subroutine initializes TDM2. ! ! Arguments ! ========= ! type ( TDM2 ), intent ( inout ) :: T2 ! time dependent measurement integer , intent ( in ) :: n ! No. of sites integer , intent ( in ) :: L ! No of time slice integer , intent ( in ) :: nBin ! No of Bins type ( Struct ), intent ( in ) :: S real ( wp ), intent ( in ) :: T (:,:) target :: S , T ! ... local variables ... integer :: i , nb1 , nb2 , n1 , n2 , r1 , r2 , nb , nWave ! ... Executable ... T2 % n = n nB = S % n_b nWave = S % nWave T2 % nWave = S % nWave T2 % nB = nB T2 % L = L ! Allocate storages allocate ( T2 % pair ( nB , nB , L + 1 )) allocate ( T2 % Apair ( nB , nB , L + 1 )) allocate ( T2 % Bpair ( nWave , L + 1 , nBin + 2 )) allocate ( T2 % Npair ( nWave , L + 1 , nBin + 2 )) allocate ( T2 % D ( nB , nB , n )) T2 % Wave => S % W T2 % Bond => S % B T2 % SD => S % D T2 % label => S % wlabel T2 % T => T T2 % ldt = size ( T , 1 ) T2 % pair = ZERO T2 % Apair = ZERO ! Build D table, which is used in computing no vertex suscetibility. ! D is a 3 dim array nB*nB*nClass. ! The meaning of entry D(i,j,k) is as follows. ! In a distance class k, there are two sites, say site1 and site2. ! D(i,j,k) is the distance class of the ith neighbor of site1 and the ! jth neighbor of site2. ! Both i and j are indexed from 1 to 9. do i = 1 , n ! we use two sites to simulate the neighboring ! structure on a reduced lattice. one is site 1, another is ! the site in the reduced geometry. ! For all site1's neighbors and all site2's neighbors ! find their cooresponding do nb1 = S % B % cstart ( 1 ), S % B % cstart ( 2 ) - 1 n1 = S % B % A ( nb1 ) r1 = S % B % row ( nb1 ) do nb2 = S % B % cstart ( i ), S % B % cstart ( i + 1 ) - 1 n2 = S % B % A ( nb2 ) r2 = S % B % row ( nb2 ) T2 % D ( n2 , n1 , i ) = S % D ( r2 , r1 ) end do end do end do end subroutine DQMC_TDM2_Init !--------------------------------------------------------------------! subroutine DQMC_TDM2_Free ( T2 ) ! ! Purpose ! ======= !    This subroutine frees TDM2. ! ! Arguments ! ========= ! type ( TDM2 ), intent ( inout ) :: T2 ! TDM to be freed ! ... Executable ... deallocate ( T2 % Pair , T2 % Apair , T2 % Bpair , T2 % Npair , T2 % D ) end subroutine DQMC_TDM2_Free !--------------------------------------------------------------------! !--------------------------------------------------------------------! subroutine DQMC_TDM2_Meas ( T2 , upt0 , up0t , dnt0 , dn0t , ti ) ! ! Purpose ! ======= !    This subroutine frees TDM2. ! ! Arguments ! ========= ! type ( TDM2 ), intent ( inout ) :: T2 real ( wp ), intent ( in ) :: up0t (:,:), upt0 (:,:) real ( wp ), intent ( in ) :: dnt0 (:,:), dn0t (:,:) integer , intent ( in ) :: ti ! ... Local scalar ... integer :: n ! ... Executable ... ! Initialization n = T2 % n !  This computes the following code !  For all time slice ti=1,2,...L !     For all pair of sites (i,j) !        For all pair of (i's neighbors, j's neighbor) = (k,l) !           susnl(N_i,N_j, ti) += upt0(k,l,ti)*dnt0(i,j,ti) ! !  The last time slice needs special treatment !      susnl(N_i,N_j, L+1) += up0t(k,l,1)*dn0t(i,j,1) ! call DQMC_Phy2_Pair ( n , T2 % pair (:,:, ti ), upt0 (:,:), dnt0 (:,:), T2 % Bond ) if ( ti . eq . 1 ) then call DQMC_Phy2_Pair ( n , T2 % pair (:,:, ti ), up0t (:,:), dn0t (:,:), T2 % Bond ) end if end subroutine DQMC_TDM2_Meas !--------------------------------------------------------------------! subroutine DQMC_TDM2_Acc ( T2 , sgn ) ! ! Purpose ! ======= !    This subroutine frees TDM2. ! ! Arguments ! ========= ! type ( TDM2 ), intent ( inout ) :: T2 real ( wp ), intent ( in ) :: sgn ! ... Local scalar ... integer :: n real ( wp ) :: factor ! ... Executable ... ! Initialization n = ( T2 % L + 1 ) * T2 % nB * T2 % nB ! Average for sus factor = sgn / T2 % n ! Apair += factor*pair call blas_daxpy ( n , factor , T2 % pair , 1 , T2 % Apair , 1 ) ! accumulate sign T2 % pair = ZERO end subroutine DQMC_TDM2_Acc !--------------------------------------------------------------------! subroutine DQMC_TDM2_Avg ( T2 , gnl , idx , factor ) ! ! Purpose ! ======= !    This subroutine averges the pair measurements. !    which is stored in T2%sus2. !    The averaging process runs as follows. !    1. Let T = sus2*W !    2. Compute b(i) = W(:,i)'*T(:,i) !    3. Averaging b  = b/nMeas !    4. Store b into sus3(:,idx) ! ! Arguments ! ========= ! type ( TDM2 ), intent ( inout ) :: T2 ! T2 real ( wp ), intent ( in ) :: gnl (:,:) real ( wp ), intent ( in ) :: factor integer , intent ( in ) :: idx ! ... BLAS function ... real ( wp ), external :: ddot ! ... local scalar ... real ( wp ), pointer :: susnl (:,:,:) integer , pointer :: D (:,:,:) integer , pointer :: SD (:,:) integer :: ti , i , j , nWave , L , nB , inbr , jnbr ! ... Executable ... nWave = T2 % nWave L = T2 % L nB = T2 % nB susnl => T2 % pair D => T2 % D SD => T2 % SD ! For suscetibility do j = 1 , L + 1 call DQMC_Wave_Avg ( nB , nWave , T2 % Wave , T2 % T , T2 % Apair (:,:, j ), & T2 % Bpair ( 1 : nWave , j , idx ), factor , T2 % ldt ) end do ! For non vertex suscetibility ! we use averaged G_nl to compute the sus susnl = ZERO do ti = 1 , L + 1 do i = 1 , T2 % n do inbr = 1 , nB do jnbr = 1 , nB susnl ( jnbr , inbr , ti ) = susnl ( jnbr , inbr , ti ) + & gnl ( D ( jnbr , inbr , i ), ti ) * gnl ( SD ( i , 1 ), ti ) end do end do end do end do ! non vertex FT do j = 1 , L + 1 call DQMC_Wave_Avg ( nB , nWave , T2 % Wave , T2 % T , susnl (:,:, j ), & T2 % Npair ( 1 : nWave , j , idx ), ONE , T2 % ldt ) end do ! Sanitize T2 % Apair = ZERO end subroutine DQMC_TDM2_Avg !--------------------------------------------------------------------! end module DQMC_TDM2","tags":"","loc":"sourcefile/dqmc_tdm2.f90.html"},{"title":"dqmc_hubbard.F90 – Quest","text":"This file depends on sourcefile~~dqmc_hubbard.f90~~EfferentGraph sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_hubbard.f90~~AfferentGraph sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_Hubbard #include \"dqmc_include.h\" use DQMC_UTIL use DQMC_CFG use DQMC_PHY0 use DQMC_PHY2 #ifdef DQMC_CKB use DQMC_CheckerBoard #else use DQMC_MATB #endif use DQMC_SEQB use DQMC_GFUN use DQMC_STRUCT implicit none ! ! This module contains the data type and subroutines for ! computing DQMC.  This should be the only module that user ! program need to include. ! ! The data type is consisted of four parts !    1. Parameters of Hubbard's model and Green's function. !    2. Parameters for Monte Carlo algorithm. !    3. Physical measurements. !    4. Working space. ! ! There are only four subroutines for user program to call !    1. DQMC_Readin  : read input !    2. DQMC_Run     : execute DQMC !    3. DQMC_Dump    : write output !    4. DQMC_Current_Config : output current Hubbard-Stratonovich !                             configuration. ! ! References ! ========== !    [1] Z. Bai, W.Chen, R. Scalettar, I. Yamazaki, \"Lecture Notes !        on Advances of Numerical Methods for Hubbard Quantum Monte !        Carlo Simulation.\" ! ! List of subroutines ! =================== !    DQMC_Default(Hub) : set the default value of the data type !    DQMC_Readin(Hub, IPT, OPT, ReadStruct) : read in parameters !    DQMC_Init(Hub) : Initialize the data type. !    DQMC_Dump(Hub, OPT) : output the parameters. !    DQMC_Sweep(Hub, nMeas0, v1, v2) : Metropolis algorithm. !    DQMC_Run(Hub) : the main subroutine of DQMC. ! ! ! Data Type ! ========= ! type Hubbard ! Part 1: Parameters of Hubbard's model and Green's function ! ========================================================== ! Parameters for problem size integer :: n ! Number of sites integer :: L ! Number of time slices ! Parameters for Hubbard model integer :: n_U real ( wp ), pointer :: U (:) ! Param of Potential energy integer :: n_t ! Number of hopping real ( wp ), pointer :: t_up (:) ! Param of Kinetic energy real ( wp ), pointer :: t_dn (:) ! Param of Kinetic energy integer :: n_mu real ( wp ), pointer :: mu_up (:) ! Param of Chemical energy real ( wp ), pointer :: mu_dn (:) ! Param of Chemical energy real ( wp ) :: dtau ! size of time slice integer , pointer :: HSF (:,:) ! Hubbard-Stratonovich Field real ( wp ), pointer :: CHSF (:,:) ! continuous Hubbard-Stratonovich Field integer :: HSFtype logical :: outputHSF ! flag for output HSF logical :: continuous ! flag for continuous HSF real ( wp ) :: delta1 ! parameter for contunuous HSF real ( wp ) :: delta2 ! parameter for contunuous HSF real ( wp ), pointer :: lambda (:) ! parameter for contunuous HSF integer :: n_start , n_end ! Underline structure type ( Struct ) :: S ! Lattice structure ! For Green function computation type ( matB ) :: B_up ! type ( seqB ) :: SB_up ! Sequential Bs type ( matB ) :: B_dn ! type ( seqB ) :: SB_dn ! Sequential Bs type ( G_fun ) :: G_up ! Green's fun for spin up type ( G_fun ) :: G_dn ! Green's fun for spin down real ( wp ), pointer :: V_up (:,:) ! real ( wp ), pointer :: V_dn (:,:) ! ! Parameters for random number integer :: idum ! random seed for ran2 integer :: seed ( 4 ) ! random seed for ran1 ! Auxiliary variables real ( wp ), pointer :: explook (:,:) ! Lookup table for computing V logical :: comp_dn ! indicator for wheather computing ! G_dn or not logical :: neg_u ! are all U_i < 0 ? ! CAVEAT: mixed sign may not work ! Part 2: Parameters for Monte Carlo algorithm ! ============================================ integer :: nWarm ! Number of warm up step integer :: nPass ! Number of measurement step integer :: nTry ! Number of global move real ( wp ) :: gamma ! Parameters for Metopolis alg integer :: nAccept ! The following parameters integer :: nReject ! are used to dynamically ! adjust gamma. integer :: nAcceptGlobal ! global move acceptance integer :: nRejectGlobal ! Part 3: Physical measurements ! ============================= type ( Phy0 ) :: P0 ! Meas0 type ( Phy2 ) :: P2 ! MeasPair integer :: nMeas integer :: tausk ! Frequency of performing Phy0 measurement logical :: meas2 ! Part 4: Working space ! ============================= type ( Wspace ) :: WS ! Part 5: file units ! ============================= integer :: OUT_UNIT end type Hubbard integer , parameter :: NO_MEAS0 = - 1 ! HSF parameter integer , parameter :: HSF_OUTPUT_UNIT = 28 integer , parameter :: HSF_INPUT_UNIT = 27 integer , parameter :: HSF_RANDOM_GEN = - 1 ! generate HS fields randomly integer , parameter :: HSF_FROM_FILE = 1 ! load HS fields from file integer , parameter :: HSF_RESTORE = 2 ! load HS field and RNG state from file integer , parameter :: HSF_FROM_MEMORY = 0 integer , parameter :: HSF_DISC = 0 integer , parameter :: HSF_CONT = 1 contains !---------------------------------------------------------------------! subroutine DQMC_Hub_Config ( Hub , cfg ) use dqmc_mpi ! ! Purpose ! ======= !    This subrotine initializes Hubbard model from the configuration. ! ! ! Pre-assumption ! ============== !    DQMC_default should be called before this. !    Geometry information should be iniitialized before calling this. ! ! ! Arguments ! ========= ! type ( config ), intent ( inout ) :: cfg type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model ! ... Local Variables ... integer :: n_t , n_U , n_mu , L , HSF , nWarm , nPass integer :: accept , reject , HSFtype , fixw , tdm integer :: seed , nOrth , nWrap , nTry , nBin , nMeas , ntausk , ssxx character ( len = slen ) :: HSF_ipt , HSF_opt logical :: valid real ( wp ), pointer :: t_up (:) => null () real ( wp ), pointer :: t_dn (:) => null () real ( wp ), pointer :: U (:) => null () real ( wp ), pointer :: mu_up (:) => null () real ( wp ), pointer :: mu_dn (:) => null () real ( wp ) :: dtau , errrate , difflim , gamma , delta1 , delta2 ! ... Executable ... ! 05/09/2012: Removed by C.C. ! !Open output file !call CFG_Get(cfg, \"gfile\", fname) !outname=trim(adjustl(fname))//\".out\" !call DQMC_open_file(outname, 'unknown', Hub%OUT_UNIT) ! integer parameters call CFG_Get ( cfg , \"HSF\" , HSF ) call CFG_Get ( cfg , \"L\" , L ) call CFG_Get ( cfg , \"nwarm\" , nWarm ) call CFG_Get ( cfg , \"npass\" , nPass ) call CFG_Get ( cfg , \"tdm\" , tdm ) call CFG_Get ( cfg , \"nbin\" , nBin ) call CFG_Get ( cfg , \"ntry\" , nTry ) call CFG_Get ( cfg , \"seed\" , seed ) call CFG_Get ( cfg , \"nwrap\" , nWrap ) call CFG_Get ( cfg , \"north\" , nOrth ) call CFG_Get ( cfg , \"gamma\" , gamma ) call CFG_Get ( cfg , \"accept\" , accept ) call CFG_Get ( cfg , \"reject\" , reject ) call CFG_Get ( cfg , \"HSFtype\" , HSFtype ) call CFG_Get ( cfg , \"delta1\" , delta1 ) call CFG_Get ( cfg , \"delta2\" , delta2 ) call CFG_Get ( cfg , \"ssxx\" , ssxx ) call CFG_Get ( cfg , \"fixwrap\" , fixw ) call CFG_Get ( cfg , \"tausk\" , ntausk ) ! Array parameters call CFG_Get ( cfg , \"t_up\" , n_t , t_up ) call CFG_Get ( cfg , \"t_dn\" , n_t , t_dn ) call CFG_Get ( cfg , \"U\" , n_U , U ) call CFG_Get ( cfg , \"mu_up\" , n_mu , mu_up ) call CFG_Get ( cfg , \"mu_dn\" , n_mu , mu_dn ) ! Real parameters call CFG_Get ( cfg , \"dtau\" , dtau ) call CFG_Get ( cfg , \"difflim\" , difflim ) call CFG_Get ( cfg , \"errrate\" , errrate ) !Change nbin to 1 if we are using more than 1 CPU. !Results collected on each CPU will be used as bins. if ( qmc_sim % aggr_size > 1 ) then nBin = 1 call CFG_set ( cfg , \"nbin\" , nBin ) endif if ( HSF == HSF_FROM_FILE . or . HSF == HSF_RESTORE ) then ! open input file if ( DQMC_Config_isSet ( cfg , \"HSFin\" )) then call CFG_Get ( cfg , \"HSFin\" , HSF_ipt ) inquire ( FILE = trim ( HSF_ipt ), EXIST = valid ) if ( valid ) then open ( HSF_INPUT_UNIT , FILE = trim ( HSF_ipt )) else call DQMC_Warning ( \"HSF input file does not exist.\" , 1 ) HSF = HSF_RANDOM_GEN end if end if elseif ( HSF /= HSF_FROM_MEMORY . and . HSF /= HSF_RANDOM_GEN ) then call DQMC_Warning ( \"Invalid HSF input: Use default\" , HSF ) HSF = HSF_RANDOM_GEN end if ! open output file Hub % outputHSF = DQMC_Config_isSet ( cfg , \"HSFout\" ) if ( Hub % outputHSF ) then call CFG_Get ( cfg , \"HSFout\" , HSF_opt ) open ( HSF_OUTPUT_UNIT , FILE = trim ( HSF_opt )) end if ! Deactivate measurements during sweep if tdm is on nmeas = 1 ; if ( tdm > 0 ) nmeas = 0 ! call the function call DQMC_Hub_Init ( Hub , U , t_up , t_dn , mu_up , mu_dn , L , n_t , n_U , n_mu , dtau , & HSF , nWarm , nPass , nMeas , nTry , nBin , ntausk , seed , nOrth , nWrap , fixw , & errrate , difflim , gamma , accept , reject , delta1 , delta2 , ssxx , HSFtype ) call CFG_Set ( cfg , \"n\" , Hub % n ) deallocate ( t_up , t_dn , mu_up , mu_dn , U ) end subroutine DQMC_Hub_Config !---------------------------------------------------------------------! subroutine DQMC_Hub_Init ( Hub , U , t_up , t_dn , mu_up , mu_dn , L , n_t , n_U , n_mu , dtau , & HSF_IPT , nWarm , nPass , nMeas , nTry , nBin , ntausk , seed , nOrth , nWrap , fixw , & errrate , difflim , gamma , accept , reject , delta1 , delta2 , ssxx , HSFtype ) ! ! Purpose ! ======= !    This subrotine initializes Hubbard model. ! ! Pre-assumption ! ============== !    DQMC_default should be called before this. !    Geometry information should be iniitialized before calling this. ! ! ! Arguments ! ========= ! use dqmc_mpi #ifdef __INTEL_COMPILER use IFPORT , only : getpid #else if __PGI integer :: getpid #endif #   ifdef _QMC_MPI #      define SIMPLE_SPRNG #      define USE_MPI #      include \"sprng_f.h\" #   endif type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model real ( wp ), intent ( in ) :: U (:), t_up (:), t_dn (:) real ( wp ), intent ( in ) :: mu_up (:), mu_dn (:), dtau ! Parameters integer , intent ( in ) :: L , n_t , n_U , n_mu integer , intent ( in ) :: HSF_IPT , seed , ssxx integer , intent ( in ) :: nWarm , nPass , nOrth , nTry , HSFtype integer , intent ( in ) :: nMeas , nBin , ntausk , nWrap , fixw , accept , reject real ( wp ), intent ( in ) :: errrate , difflim , gamma , delta1 , delta2 ! ... Local scalar ... integer :: n , i , j , HSF , ilb , val ( 8 ) real ( wp ) :: temp , lambda real ( wp ) :: Map_up ( Hub % S % nSite ), Map_dn ( Hub % S % nSite ) logical :: lex character ( 80 ) :: msg #   ifdef _QMC_MPI SPRNG_POINTER junkPtr #   endif ! ... Executable ... if (. not . Hub % S % checklist ( STRUCT_INIT )) then call DQMC_Error ( \"Must initialize lattice geometry first\" , 0 ) end if Hub % n = Hub % S % nSite n = Hub % n Hub % L = L Hub % dtau = dtau Hub % delta1 = delta1 Hub % delta2 = delta2 ! t parameter if ( n_t /= Hub % S % n_t ) then if ( n_t == 1 . and . Hub % S % n_t > 1 ) then ! special case for checkerboard method Hub % n_t = Hub % S % n_t allocate ( Hub % t_up ( Hub % S % n_t )) allocate ( Hub % t_dn ( Hub % S % n_t )) Hub % t_up = t_up ( 1 ) Hub % t_dn = t_dn ( 2 ) else write ( msg , \"(a,i5, a, i5)\" ) \"Input lattice requires \" , Hub % S % n_t , & \" hoppings, but only reads \" , n_t call DQMC_Error ( msg , 0 ) end if else Hub % n_t = n_t allocate ( Hub % t_up ( n_t )) allocate ( Hub % t_dn ( n_t )) Hub % t_up = t_up Hub % t_dn = t_dn end if ! U parameter Hub % n_U = n_U allocate ( Hub % U ( n_U )) Hub % U = U ! mu parameter Hub % n_mu = n_mu allocate ( Hub % mu_up ( n_mu )) allocate ( Hub % mu_dn ( n_mu )) Hub % mu_up = mu_up Hub % mu_dn = mu_dn do i = 1 , n Map_up ( i ) = mu_up ( Hub % S % Map ( i )) Map_dn ( i ) = mu_dn ( Hub % S % Map ( i )) end do Hub % comp_dn = . true . if ( all ( U < ZERO + 1.d-6 ) ) then !Negative U and U=0 Hub % neg_u = . true . if ( maxval ( abs ( t_up - t_dn )) < 1.d-6 . and . maxval ( abs ( mu_up - mu_dn )) < 1.d-6 ) then !Gup and Gdn are identical. Do not compute Gdn. Hub % comp_dn = . false . endif elseif ( all ( U > ZERO - 1.d-6 )) then !Positive U Hub % neg_u = . false . if ( all ( abs ( mu_up ) < 1.d-6 ) . and . all ( abs ( mu_dn ) < 1.d-6 ) . and . & maxval ( abs ( t_up - t_dn )) < 1.d-6 . and . Hub % S % checklist ( STRUCT_PHASE ) ) then Hub % comp_dn = . false . end if else stop 'All U''s must have the same sign (or be zero)' end if !write(*,*) !write(*,*) \"DEBUG info -- In DQMC_Hub_Init():\" !write(*,*) \"  Hub%comp_dn=\",Hub%comp_dn !write(*,*) \"  Hub%neg_u=\",Hub%neg_u !write(*,*) \"  S%P defined? \",Hub%S%checklist(STRUCT_PHASE) !write(*,*) ! Parameters for MC loop Hub % nWarm = nWarm Hub % nPass = nPass Hub % nMeas = nMeas Hub % nTry = nTry Hub % tausk = ntausk ! Initialize random seeds Hub % idum = seed if ( Hub % idum == 0 ) then call date_and_time ( VALUES = val ) Hub % idum = getpid () + val ( 8 ) * val ( 7 ) + val ( 6 ) ** mod ( val ( 5 ), 5 ) end if ! LAPACK random variable generation Hub % seed = Hub % idum * ( / 1 , 2 , 3 , 4 / ) Hub % seed = mod ( abs ( Hub % seed ), 4095 ) if ( mod ( Hub % seed ( 4 ), 2 ) == 0 ) then Hub % seed ( 4 ) = Hub % seed ( 4 ) + 1 end if #   ifdef _QMC_MPI junkPtr = init_sprng ( SPRNG_LCG , Hub % seed ( 4 ), SPRNG_DEFAULT ) #   endif ! Initialize auxiliary variables Hub % gamma = gamma Hub % nAccept = accept Hub % nReject = reject ! Initialize working space call DQMC_WSpace_Allocate ( n , Hub % S % n_b , Hub % WS ) ! Initialize Hubbard-Stratonovich Field HSF = HSF_IPT Hub % HSFtype = HSFtype if ( HSF == HSF_FROM_MEMORY ) then ilb = Hub % G_up % ilb ! discrete case if ( HSFtype == HSF_DISC ) then if (. not . associated ( Hub % HSF )) then call DQMC_Warning ( \"Cannot use current HSF. \" , 0 ) HSF = HSF_RANDOM_GEN else print * , \"Read HSF from memory.\" end if else ! contnuous case if (. not . associated ( Hub % CHSF )) then call DQMC_Warning ( \"Cannot use current HSF. \" , 0 ) HSF = HSF_RANDOM_GEN else print * , \"Read HSF from memory.\" end if end if end if if ( HSF == HSF_FROM_FILE . or . HSF == HSF_RESTORE ) then inquire ( UNIT = HSF_INPUT_UNIT , EXIST = lex ) if ( lex ) then ! If a valid input file handle is provided, ! read HSF from the file if ( HSFtype == HSF_DISC ) then allocate ( Hub % HSF ( n , L )) call DQMC_Hub_Input_HSF ( Hub , HSF == HSF_RESTORE , ilb , HSF_INPUT_UNIT ) else ! TODO: input continuous HSF from file call DQMC_Error ( \"reading continuous HSF from file is not supported\" , HSF ) end if print * , \"Read HSF from a file.\" else ! If file does not exist, give a warning message. call DQMC_Warning ( \"HSF file does not exist. & & Use random generated values.\" , HSF ) HSF = HSF_RANDOM_GEN end if end if ! generate HSF randomly if ( HSF == HSF_RANDOM_GEN ) then ilb = 1 ! discrete case if ( HSFtype == HSF_DISC ) then allocate ( Hub % HSF ( n , L )) Hub % HSF = 1 do i = 1 , Hub % L call ran0 ( n , Hub % WS % R5 , Hub % seed ) where ( Hub % WS % R5 > HALF ) Hub % HSF (:, i ) = - 1 end do else ! continuous case allocate ( Hub % CHSF ( n , L )) Hub % HSF = 1 do i = 1 , Hub % L call ran1 ( n , Hub % CHSF (:, i ), Hub % seed ) end do end if end if ! Initialize lookup table if ( HSFtype == HSF_DISC ) then nullify ( Hub % explook ) allocate ( Hub % explook ( - 2 : 2 , 1 : n_U )) do j = 1 , n_U temp = exp ( dtau * abs ( U ( j )) * HALF ) lambda = log ( temp + sqrt ( temp * temp - ONE )) do i = - 2 , 2 Hub % explook ( i , j ) = exp ( i * lambda ) end do ! for use by U<0, save lambda in explook(0, j) Hub % explook ( 0 , j ) = lambda end do else allocate ( Hub % lambda ( n_U )) do j = 1 , n_U Hub % lambda ( j ) = sqrt ( dtau * U ( j )) end do end if ! Initialize V matrices call DQMC_Hub_Init_Vmat ( Hub ) ! Initialize Green functions call DQMC_B_Init ( n , Hub % B_up , Hub % WS , Hub % S % T , Hub % S % ckb , Hub % t_up , Map_up , dtau ) call DQMC_B_Init ( n , Hub % B_dn , Hub % WS , Hub % S % T , Hub % S % ckb , Hub % t_dn , Map_dn , dtau ) call DQMC_SeqB_Init ( n , Hub % L , nOrth , Hub % B_up , Hub % SB_up , Hub % WS ) call DQMC_SeqB_Init ( n , Hub % L , nOrth , Hub % B_dn , Hub % SB_dn , Hub % WS ) ! Initialize G call DQMC_GFun_Init ( n , L , Hub % G_up , Hub % V_up , Hub % WS , & nWrap , difflim , errrate , GMAT_UP , ssxx , fixw ) ! for positive U or H_dn/=H_up we need to construct G_dn implicitly if ( Hub % comp_dn . or . . not . Hub % neg_u ) then call DQMC_GFun_Init ( n , L , Hub % G_dn , Hub % V_dn , Hub % WS , & nWrap , difflim , errrate , GMAT_DN , ssxx , fixw ) else ! Negative U or U=0, G_dn is a clone of G_up call DQMC_Gfun_Clone ( Hub % G_dn , Hub % G_up ) end if !Fill G call DQMC_GetG ( ilb , Hub % G_up , Hub % SB_up ) if ( Hub % comp_dn . or . . not . Hub % neg_u ) then call DQMC_GetG ( ilb , Hub % G_dn , Hub % SB_dn ) end if ! Initialize measurements temp = Hub % dtau * Hub % L call DQMC_Phy0_Init ( Hub % P0 , Hub % S , temp , nBin , Hub % WS ) call DQMC_Phy2_Init ( Hub % P2 , nBin , Hub % S , Hub % WS , Hub % meas2 ) ! Initialize simulation range Hub % n_start = 1 Hub % n_end = n end subroutine DQMC_Hub_Init !---------------------------------------------------------------------! subroutine DQMC_Hub_Free ( Hub ) ! ! Purpose ! ======= !    This subrotine deallocate variables in Hubbard ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model ! ... Executable ... call DQMC_B_Free ( Hub % B_up ) call DQMC_B_Free ( Hub % B_dn ) call DQMC_Gfun_Free ( Hub % G_up ) call DQMC_Gfun_Free ( Hub % G_dn ) call DQMC_Phy0_Free ( Hub % P0 ) call DQMC_Phy2_Free ( Hub % P2 ) if ( associated ( Hub % V_up )) deallocate ( Hub % V_up ) if (. not . Hub % neg_u . and . associated ( Hub % V_dn )) deallocate ( Hub % V_dn ) deallocate ( Hub % t_up , Hub % t_dn , Hub % mu_up , Hub % mu_dn , Hub % U ) if ( Hub % HSFtype == HSF_DISC ) then deallocate ( Hub % HSF ) deallocate ( Hub % explook ) else deallocate ( Hub % CHSF ) deallocate ( Hub % lambda ) end if call DQMC_WSpace_Free ( Hub % WS ) call DQMC_SeqB_Free ( Hub % SB_up ) call DQMC_SeqB_Free ( Hub % SB_dn ) call DQMC_Struct_Free ( Hub % S ) end subroutine DQMC_Hub_Free !---------------------------------------------------------------------! subroutine DQMC_Hub_Output_HSF ( Hub , restore , slice , OPT ) ! ! Purpose ! ======= !    This subrotine outputs Hubbard-Stratonovich Field to a !    output file OPT. ! ! Arguments ! ========= ! use dqmc_mpi #   ifdef _QMC_MPI #      include \"sprng_f.h\" #   endif type ( Hubbard ), intent ( in ) :: Hub !     integer, intent(in) :: n, L         ! dim of HSF !     integer, intent(in) :: HSF(n,L)     ! Hubbard-Stratonovich Field !     integer, intent(in) :: seed(4)      ! RNG state integer , intent ( in ) :: OPT ! output handle logical , intent ( in ) :: restore integer , intent ( in ) :: slice ! ... local variables ... integer :: i , j , k , h , nproc , nL integer :: HSF ( Hub % n * Hub % L + 1 ) #   ifdef _QMC_MPI character :: rndbuf ( MAX_PACKED_LENGTH ) character ( len = 60 ) :: fname integer :: stat #   endif ! ... Executable .... nL = Hub % n * Hub % L nproc = qmc_sim % aggr_size if ( qmc_sim % rank == qmc_sim % aggr_root ) then !loop over processors do j = 0 , nproc - 1 ! Collect data from processor \"j\" if ( j /= qmc_sim % aggr_root ) then #            ifdef _QMC_MPI call mpi_recv ( HSF , nL + 1 , MPI_INT , j , j , MPI_COMM_WORLD , stat , k ) #            endif else call pack_fields endif !Write data to disk do k = 1 , nL write ( OPT , '(i1)' , advance = 'no' ) HSF ( k ) enddo write ( OPT , * ) HSF ( nL + 1 ) enddo else !Send data to root node call pack_fields #     ifdef _QMC_MPI ! Send field to root processor call mpi_send ( HSF , nL + 1 , MPI_INT , qmc_sim % aggr_root , qmc_sim % rank , MPI_COMM_WORLD , k ) #     endif endif !If restore is true, write the random number generator status if ( restore ) then #      ifdef _QMC_MPI k = pack_sprng ( rndbuf ) inquire ( unit = OPT , name = fname ) close ( OPT ) !This would be better done with send/recv (see commented code below) ! but there appears to be a problem with the written rndbuf (!?) do i = 0 , nproc - 1 if ( i == qmc_sim % aggr_rank ) then open ( file = fname , form = 'formatted' , unit = OPT , position = 'append' ) write ( OPT , '(i8,1x)' , advance = 'no' ) k do j = 1 , k write ( OPT , '(A1)' , advance = 'no' ) rndbuf ( j ) enddo write ( OPT , * ) close ( OPT ) endif call mpi_barrier ( MPI_COMM_WORLD , j ) enddo open ( file = fname , form = 'formatted' , unit = OPT , position = 'append' ) #      else !Simply write the seed if MPI is off write ( OPT , * ) Hub % seed #      endif write ( OPT , * ) Hub % gamma , Hub % naccept , Hub % nreject endif !    if (DQMC_MPI_Is_Root(qmc_sim, CHANNEL_AGGR) .and. restore) then !#      ifdef _QMC_MPI !          do j = 0, nproc - 1 !             ! Collect data from processor \"j\" !             if (j /= qmc_sim%aggr_root) then !                call mpi_recv(k, 1, MPI_INT, j, j, MPI_COMM_WORLD, stat, i) !                call mpi_recv(rndbuf, k, MPI_CHARACTER, j, j, MPI_COMM_WORLD, stat, i) !             else !                k = pack_sprng(rndbuf) !             endif !             !Write data to disk !             write(OPT,'(i8,1x)',advance='no') k !             do i = 1, k !                write(OPT,'(A1)',advance='no') rndbuf(i) !             enddo !             write(OPT,*) !          enddo !#      else !          !Simply write the seed if MPI is off !          write(OPT, *) Hub%seed !#      endif !       !Write info to reastablish acceptance rate !       write(OPT, *) Hub%gamma, Hub%naccept, Hub%nreject !    elseif (restore) then !#      ifdef _QMC_MPI !          k = pack_sprng(rndbuf) !          call mpi_send(k, 1, MPI_INT, qmc_sim%aggr_root, qmc_sim%rank, MPI_COMM_WORLD, k) !          call mpi_send(rndbuf, k, MPI_CHARACTER, qmc_sim%aggr_root, qmc_sim%rank, MPI_COMM_WORLD, k) !#      endif !    endif #   ifdef _QMC_MPI call mpi_barrier ( MPI_COMM_WORLD , i ) #   endif contains subroutine pack_fields !Fill the vector of fields to write k = 1 do i = 1 , Hub % L do h = 1 , Hub % n HSF ( k ) = ( Hub % HSF ( h , i ) + 1 ) / 2 k = k + 1 enddo enddo !Last element is the time slice if ( slice <= 0 ) then HSF ( k ) = Hub % G_up % ilb else HSF ( k ) = slice endif end subroutine pack_fields end subroutine DQMC_Hub_Output_HSF !---------------------------------------------------------------------! subroutine DQMC_Hub_Input_HSF ( Hub , restore , slice , IPT ) ! ! Purpose ! ======= !    This subrotine reads Hubbard-Stratonovich Field from a !    file OPT. ! ! Arguments ! ========= ! use dqmc_mpi #   ifdef _QMC_MPI #      include \"sprng_f.h\" #   endif type ( Hubbard ), intent ( inout ) :: Hub logical , intent ( in ) :: restore ! restore RNG? integer , intent ( in ) :: IPT ! input handle integer , intent ( out ) :: slice ! ... local varaible ... Integer :: i , j , k , ip , nproc , nL integer :: HSF ( Hub % n * Hub % L + 1 ) #   ifdef _QMC_MPI character :: rndbuf ( MAX_PACKED_LENGTH ) SPRNG_POINTER :: junkPtr #   endif ! ... Executable .... nL = Hub % n * Hub % L nproc = qmc_sim % size do ip = 0 , nproc - 1 if ( qmc_sim % aggr_rank == ip ) then k = 1 do i = 1 , Hub % L do j = 1 , Hub % n read ( IPT , '(i1)' , advance = 'no' , ERR = 100 ) HSF ( k ) k = k + 1 enddo write ( 98 , * ) enddo read ( IPT , * ) HSF ( k ) else read ( IPT , * ) endif k = 1 do i = 1 , Hub % L do j = 1 , Hub % n Hub % HSF ( j , i ) = 2 * HSF ( k ) - 1 k = k + 1 enddo enddo slice = HSF ( k ) enddo if ( restore ) then do ip = 0 , nproc - 1 if ( qmc_sim % aggr_rank == ip ) then #            ifdef _QMC_MPI read ( IPT , '(i8,1x)' , advance = 'no' ) k do j = 1 , k read ( IPT , '(A1)' , advance = 'no' ) rndbuf ( j ) enddo read ( IPT , * ) #            else read ( IPT , * ) Hub % seed #            endif else read ( IPT , * ) endif enddo read ( IPT , * , ERR = 102 ) Hub % gamma , Hub % naccept , Hub % nreject #      ifdef _QMC_MPI junkPtr = unpack_sprng ( rndbuf ) #      endif endif return 100 call DQMC_Error ( \"cannot read HSF input file:\" , HSF_INPUT_UNIT ) 102 call DQMC_Error ( \"cannot read gamma/naccept/nreject from HSF input file\" , HSF_INPUT_UNIT ) end subroutine DQMC_Hub_Input_HSF !---------------------------------------------------------------------! subroutine DQMC_Hub_OutputParam ( Hub , OPT ) use dqmc_mpi ! ! Purpose ! ======= !    This subrotine outputs parameters of Hubbard model and !    computed results. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( in ) :: Hub ! Hubbard model integer , intent ( in ) :: OPT ! output handle ! ... Local ... character ( 35 ) :: FMT logical :: lex integer , parameter :: slice = 0 logical , parameter :: restore = . true . ! ... Executable .... if ( qmc_sim % rank == qmc_sim % aggr_root ) then write ( OPT , * ) Hub % S % Name (:) if ( Hub % n_U == 1 ) then FMT = FMT_STRDBL else write ( FMT , \"('(a30,f19.6,(',I3,'(f12.6)))')\" ) Hub % n_U - 1 end if write ( OPT , FMT ) \"                          U : \" , Hub % U if ( Hub % n_t == 1 ) then FMT = FMT_STRDBL else write ( FMT , \"('(a30,f19.6,(',I3,'(f12.6)))')\" ) Hub % n_t - 1 end if write ( OPT , FMT ) \"                       t_up : \" , Hub % t_up write ( OPT , FMT ) \"                       t_dn : \" , Hub % t_dn if ( Hub % n_mu == 1 ) then FMT = FMT_STRDBL else write ( FMT , \"('(a30,f19.6,(',I3,'(f12.6)))')\" ) Hub % n_mu - 1 end if write ( OPT , FMT ) \"                      mu_up : \" , Hub % mu_up write ( OPT , FMT ) \"                      mu_dn : \" , Hub % mu_dn write ( OPT , FMT_STRINT ) \"             Time slice - L : \" , Hub % L write ( OPT , FMT_STRINT ) \"            Number of sites : \" , Hub % n write ( OPT , FMT_STRDBL ) \"                       dtau : \" , Hub % dtau write ( OPT , FMT_STRDBL ) \"                       beta : \" , Hub % dtau * Hub % L write ( OPT , FMT_STRINT ) \"     Number of warmup sweep : \" , Hub % nWarm write ( OPT , FMT_STRINT ) \"Number of measurement sweep : \" , Hub % nPass write ( OPT , FMT_STRINT ) \"   Frequency of measurement : \" , Hub % nMeas write ( OPT , FMT_STRINT ) \"                Random seed : \" , Hub % idum write ( OPT , FMT_STRINT ) \" Frequency of recomputing G : \" , Hub % G_up % nWrap write ( OPT , FMT_STRINT ) \"Global move number of sites : \" , Hub % nTry write ( OPT , FMT_STRINT ) \"               Accept count : \" , Hub % naccept write ( OPT , FMT_STRINT ) \"               Reject count : \" , Hub % nreject write ( OPT , FMT_STRDBL ) \"    Approximate accept rate : \" , & dble ( Hub % naccept ) / dble ( Hub % naccept + Hub % nreject ) write ( OPT , FMT_STRDBL ) \"                      gamma : \" , Hub % gamma if ( Hub % nTry > 0 ) then write ( OPT , FMT_STRINT ) \"   Global move accept count : \" , Hub % nAcceptGlobal write ( OPT , FMT_STRINT ) \"   Global move reject count : \" , Hub % nRejectGlobal write ( OPT , FMT_STRDBL ) \"    Global move accept rate : \" , & dble ( Hub % nAcceptGlobal ) / dble ( Hub % nAcceptGlobal + Hub % nRejectGlobal ) end if write ( OPT , * ) \"          Type of matrix B : \" , Hub % B_up % name if ( Hub % HSFtype == HSF_DISC ) then write ( OPT , * ) \"        Type of matrix HSF : discrete\" else write ( OPT , * ) \"        Type of matrix HSF : continuous\" write ( OPT , * ) \"                   delta 1 : \" , Hub % delta1 write ( OPT , * ) \"                   delta 2 : \" , Hub % delta2 end if endif ! Check if the file is valid. if ( Hub % outputHSF ) then inquire ( UNIT = HSF_OUTPUT_UNIT , EXIST = lex ) if ( lex ) then call DQMC_Hub_Output_HSF ( Hub , restore , slice , HSF_OUTPUT_UNIT ) else if ( qmc_sim % rank == qmc_sim % aggr_root ) & call DQMC_Warning ( \"HSF output file is not initialized.\" , 1 ) end if end if end subroutine DQMC_Hub_OutputParam !---------------------------------------------------------------------! subroutine DQMC_Hub_Print ( Hub , OPT ) implicit none ! ! Purpose ! ======= !    This subrotine outputs parameters of Hubbard model and !    computed results. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( in ) :: Hub ! Hubbard model integer , intent ( in ) :: OPT ! output handle ! ... Executable .... call DQMC_Hub_OutputParam ( Hub , OPT ) write ( OPT , FMT_DBLINE ) call DQMC_Phy0_Print ( Hub % P0 , Hub % S , OPT ) call DQMC_Phy2_Print ( Hub % P2 , Hub % S % wlabel , OPT ) end subroutine DQMC_Hub_Print ! --------------------------------------------------------------------! subroutine DQMC_Hub_Sweep ( Hub , nMeas0 ) use dqmc_mpi ! ! Purpose ! ======= !   This subroutine performs the DQMC sweep, which is consisted of !   four steps. (See [1] for more details.) ! !      1. Swap the slice of G and recompute G if necessary. !      2. Metropolis Algorithm !      3. Update the model and perform physical measurement. !      4. Adjust parameters. ! !   The first three steps are within a big loop, which run !   through each time slice of G. The major part is the second !   step, which is explained below. ! !      1. Try the new configuration by single spin-flip sampling !         at site j at time slice i. !      2. Compute the probability of this new configuration. ! !             p =  r/(1+gamma*r)    if r < 1 !             p =  r/(gamma+r)      if r >=1 ! !         where r is the ratio of determinants of Green's function !         of spin up and spin down. !      3. If p > ran, a uniform random number in [0,1], then change !         the configuration and update the Green's function. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ), target :: Hub ! Hubbard model integer , intent ( in ) :: nMeas0 ! Duration of measurement ! ... paremeters ... integer , parameter :: DQMC_CHECK_ITER = 10000 integer , parameter :: DQMC_ADJUST = 100 real ( wp ), parameter :: DQMC_ACC_UP = 0.52_wp real ( wp ), parameter :: DQMC_ACC_LO = 0.48_wp ! ... local scalar ... integer :: i , j , n , L , m ! Loop iterator integer :: accept_cnt ! Counter for accept in Met-alg integer :: reject_cnt ! Counter for accept in Met-alg real ( wp ) :: accrat real ( wp ) :: alpha_up , alpha_dn = 0 ! Change of configuration real ( wp ) :: p , randn ! Probability of changing real ( wp ) :: r_up , r_dn , r ! Ratio of determinant real ( wp ) :: gjj ! (j,j) element of G_up or G_dn #   ifdef _QMC_MPI integer :: send_cnt ( 2 ) integer :: recv_cnt ( 2 ) #   endif ! To speed up the computation real ( wp ), pointer :: G_up (:,:) real ( wp ), pointer :: G_dn (:,:) real ( wp ), pointer :: U_up (:,:) real ( wp ), pointer :: U_dn (:,:) real ( wp ), pointer :: W_up (:,:) real ( wp ), pointer :: W_dn (:,:) real ( wp ), pointer :: V_up (:,:) real ( wp ), pointer :: V_dn (:,:) integer , pointer :: blksz_up integer , pointer :: blksz_dn real ( wp ), pointer :: sgn_up real ( wp ), pointer :: sgn_dn real ( wp ), pointer :: ranlist (:) real ( wp ), pointer :: explook (:,:) integer , pointer :: HSF (:,:) integer , pointer :: map (:) real ( wp ) :: gamma logical :: comp_dn , neg_u ! ... Executable ... !=====================! ! Step 0: Setup alias ! !=====================! G_up => Hub % G_up % G U_up => Hub % G_up % U W_up => Hub % G_up % W V_up => Hub % G_up % V blksz_up => Hub % G_up % blksz sgn_up => Hub % G_up % sgn G_dn => Hub % G_dn % G U_dn => Hub % G_dn % U W_dn => Hub % G_dn % W V_dn => Hub % G_dn % V blksz_dn => Hub % G_dn % blksz sgn_dn => Hub % G_dn % sgn ranlist => Hub % WS % R7 gamma = Hub % gamma explook => Hub % explook HSF => Hub % HSF comp_dn = Hub % comp_dn neg_u = Hub % neg_u map => Hub % S % map n = Hub % n L = Hub % L i = Hub % G_up % ilb accept_cnt = 0 reject_cnt = 0 #   ifdef _QMC_MPI send_cnt ( 1 ) = Hub % naccept send_cnt ( 2 ) = Hub % nreject #   endif do m = 1 , L !First thing see if you can make a measurement on a freshly computed G if ( Hub % G_up % wps == Hub % G_up % nWrap ) then if ( nmeas0 > 0 ) then ! Construct G_dn for mu = 0 and U > 0 using particle-hole symmetry ! 05/15/2012, C.C.: ! Note that ( .not.neg_u .and. not.comp_dn ) implies that S%P is defined, i.e. ! S%checklist(STRUCT_PHASE) = 'T'. if (. not . neg_u . and . . not . comp_dn ) call DQMC_GFun_CopyUp ( Hub % G_dn , Hub % G_up , Hub % S % P ) !Fill GS in Hub%Gfun call DQMC_GetG_2nd_order ( Hub % G_up , Hub % B_up ) if ( comp_dn . or . . not . neg_u ) then call DQMC_GetG_2nd_order ( Hub % G_dn , Hub % B_dn ) endif ! Basic measurement call DQMC_Phy0_Meas ( Hub % n , Hub % P0 , Hub % G_up % GS , Hub % G_dn % GS , Hub % U , & Hub % mu_up , Hub % mu_dn , Hub % t_up , Hub % t_dn , sgn_up , sgn_dn , Hub % S ) if ( Hub % meas2 ) then ! Pair measurement r = sgn_up * sgn_dn call DQMC_Phy2_Meas ( n , Hub % P2 % M1 , Hub % P2 % M2 , & Hub % P2 , Hub % S % B , Hub % G_up % GS , Hub % G_dn % GS , r ) end if endif end if i = i + 1 if ( i > L . or . i < 0 ) i = 1 !==============================! ! Step 1: Swap the slice of G  ! !==============================! call DQMC_GetG ( i , Hub % G_up , Hub % SB_up ) if ( comp_dn ) then call DQMC_GetG ( i , Hub % G_dn , Hub % SB_dn ) else sgn_dn = sgn_up end if !==============================! ! Step 2: Metropolis Algorithm ! !==============================! call ran0 ( n , ranlist , Hub % seed ) do j = Hub % n_start , Hub % n_end ! Try the new configuration by single spin-flip sampling ! at site j at time slice i. ! See reference [1] for more detail for these formula if ( neg_u ) then alpha_up = explook ( - 2 * HSF ( j , i ), map ( j )) - ONE alpha_dn = alpha_up else alpha_up = explook ( - 2 * HSF ( j , i ), map ( j )) - ONE alpha_dn = explook ( 2 * HSF ( j , i ), map ( j )) - ONE end if gjj = DQMC_Gfun_Getjj ( n , j , blksz_up , G_up , U_up , W_up ) r_up = ONE + ( ONE - gjj ) * alpha_up if ( comp_dn ) then gjj = DQMC_Gfun_Getjj ( n , j , blksz_dn , G_dn , U_dn , W_dn ) r_dn = ONE + ( ONE - gjj ) * alpha_dn elseif ( neg_u ) then r_dn = r_up else r_dn = ONE + gjj * alpha_dn end if r = abs ( r_up * r_dn ) if ( neg_u ) then r = r * explook ( + 2 * HSF ( j , i ), map ( j )) end if ! Compute the probability if ( r <= ONE ) then p = r / ( ONE + gamma * r ) else p = r / ( gamma + r ) end if randn = ranlist ( j ) ! Accept if ( p > randn ) then accept_cnt = accept_cnt + 1 if ( r_up < ZERO ) sgn_up = - sgn_up if ( r_dn < ZERO ) sgn_dn = - sgn_dn HSF ( j , i ) = - HSF ( j , i ) ! Update G_up call DQMC_UpdateG ( j , alpha_up / r_up , Hub % G_up ) ! invalidate the cache for B_i #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , i ) #endif V_up ( j , i ) = V_up ( j , i ) * ( alpha_up + ONE ) Hub % G_up % nModify = i Hub % G_up % det = Hub % G_up % det - log ( abs ( r_up )) ! If mu /= zero, then update G_dn as well. if ( comp_dn ) then ! Update G_dn call DQMC_UpdateG ( j , alpha_dn / r_dn , Hub % G_dn ) Hub % G_dn % det = Hub % G_dn % det - log ( abs ( r_dn )) end if if (. not . neg_u ) then #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , i ) #endif V_dn ( j , i ) = V_dn ( j , i ) * ( alpha_dn + ONE ) end if Hub % G_dn % nModify = i else reject_cnt = reject_cnt + 1 endif end do !============================! ! Step 3: Update and Measure ! !============================! ! update G_up/G_dn if there are some updates not applied. call DQMC_ApplyUpdate ( Hub % G_up , forced = . true .) if ( comp_dn ) then call DQMC_ApplyUpdate ( Hub % G_dn , forced = . true .) end if end do #   ifdef _QMC_MPI send_cnt ( 1 ) = accept_cnt send_cnt ( 2 ) = reject_cnt call mpi_allreduce ( send_cnt , recv_cnt , 2 , MPI_INT , MPI_SUM , MPI_COMM_WORLD , m ) accept_cnt = recv_cnt ( 1 ) reject_cnt = recv_cnt ( 2 ) #   endif ! update accept and reject counts Hub % naccept = Hub % naccept + accept_cnt Hub % nreject = Hub % nreject + reject_cnt !===========================! ! Step 4: Adjust parameters ! !===========================! if ( Hub % naccept + Hub % nreject > DQMC_CHECK_ITER ) then accrat = dble ( Hub % naccept ) / dble ( Hub % naccept + Hub % nreject ) if ( accrat > DQMC_ACC_UP . or . accrat < DQMC_ACC_LO ) then Hub % gamma = Hub % gamma + ( accrat - HALF ) Hub % gamma = dmax1 ( ZERO , Hub % gamma ) Hub % gamma = dmin1 ( ONE , Hub % gamma ) Hub % naccept = int ( DQMC_ADJUST * accrat ) Hub % nreject = int ( DQMC_ADJUST * ( ONE - accrat )) endif endif !Update nwrap. Stop doing it if measurements are performed !every nwrap to ensure bins contains same number of measurements. if ( nmeas0 <= 0 ) then call DQMC_UpdateWraps ( Hub % G_up ) if ( comp_dn ) then call DQMC_UpdateWraps ( Hub % G_dn ) call DQMC_SyncWraps ( Hub % G_up , Hub % G_dn ) end if endif end subroutine DQMC_Hub_Sweep !---------------------------------------------------------------------! subroutine DQMC_Hub_Sweep2 ( Hub , numTry ) ! ! Purpose ! ======= !   This subroutine performs the global moves of DQMC sweep, in which !   all the Hub(i) on some selected sites are flipped for all slice. ! !      1. Try the new configuration. !      2. Compute the probability of this new configuration. ! !             p =  r/(1+gamma*r)    if r < 1 !             p =  r/(gamma+r)      if r >=1 ! !         where r is the ratio of determinants of Green's function !         of spin up and spin down. !      3. If p > ran, a uniform random number in [0,1], then change !         the configuration and update the Green's function. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model integer , intent ( in ) :: numTry ! Number of Try ! ... Local Variables ... real ( wp ) :: ranList ( numTry ), rat , ratexp , ranSlice ( 1 ) integer :: i , j , n , L , accept , tmp , nSite , tslice real ( wp ) :: det_up , det_dn , new_up , new_dn real ( wp ) :: copy_sgn_up , copy_sgn_dn integer , pointer :: map (:) integer :: siteList ( Hub % n ), site ( numTry ) integer :: hs_sum ! sum over HS fields at site, for U<0 ! ... Executable ... n = Hub % n L = Hub % L accept = 0 if ( numTry <= 0 ) return Map => Hub % S % Map call ran0 ( 1 , ranSlice , Hub % seed ) tslice = ceiling ( ranSlice ( 1 ) * L ) ! Compute the Green's matrix and the sign Hub % G_up % ilb = - 1 call DQMC_GetG ( tslice , Hub % G_up , Hub % SB_up ) det_up = Hub % G_up % det if ( Hub % comp_dn ) then Hub % G_dn % ilb = - 1 call DQMC_GetG ( tslice , Hub % G_dn , Hub % SB_dn ) det_dn = Hub % G_dn % det elseif ( Hub % neg_u ) then det_dn = det_up Hub % G_dn % sgn = Hub % G_up % sgn else ! 05/15/2012, C.C.: ! Note that here we have .not.neg_u and not.comp_dn. ! This implies that S%P is defined, i.e. S%checklist(STRUCT_PHASE) = 'T'. ! So we can safely call DQMC_Gfun_CopyUp() which uses particle-hole symmetry. call DQMC_Gfun_CopyUp ( Hub % G_dn , Hub % G_up , Hub % S % P ) det_dn = Hub % G_dn % det end if ! get random numbers call ran0 ( numTry , ranList , Hub % seed ) nsite = Hub % n_End - Hub % n_start + 1 siteList ( 1 : nSite ) = Hub % n_Start + ( / ( i , i = 0 , nSite - 1 ) / ) ! generate sites do i = 1 , numtry tmp = int ( ranList ( i ) * nSite ) + 1 site ( i ) = siteList ( tmp ) ! compress the list do j = tmp + 1 , nSite siteList ( j - 1 ) = siteList ( j ) end do nSite = nSite - 1 end do call ran0 ( numTry , ranList , Hub % seed ) ! Global move do i = 1 , numTry ! Flip its HS field for all the slices do j = 1 , L tmp = - Hub % HSF ( site ( i ), j ) Hub % HSF ( site ( i ), j ) = tmp #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , j ) #endif Hub % V_up ( site ( i ), j ) = Hub % explook ( tmp , map ( site ( i ))) if (. not . Hub % neg_u ) then #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , j ) #endif Hub % V_dn ( site ( i ), j ) = Hub % explook ( - tmp , map ( site ( i ))) end if end do ! Store the value of G first Hub % G_up % tmp = Hub % G_up % G if ( Hub % comp_dn ) then Hub % G_dn % tmp = Hub % G_dn % G end if copy_sgn_up = Hub % G_up % sgn copy_sgn_dn = Hub % G_dn % sgn ! Compute G with new configuration Hub % G_up % ilb = - 1 call DQMC_GetG ( tslice , Hub % G_up , Hub % SB_up ) new_up = Hub % G_up % det if ( Hub % comp_dn ) then Hub % G_dn % ilb = - 1 call DQMC_GetG ( tslice , Hub % G_dn , Hub % SB_dn ) new_dn = Hub % G_dn % det elseif ( Hub % neg_u ) then Hub % G_dn % sgn = Hub % G_up % sgn new_dn = new_up else ! 05/15/2012, C.C.: ! Note that here we have (.not.neg_u) and (.not.comp_dn). ! This implies that S%P is defined, i.e. S%checklist(STRUCT_PHASE) = 'T'. ! So we can safely call DQMC_Gfun_CopyUp() which uses particle-hole symmetry. call DQMC_Gfun_CopyUp ( Hub % G_dn , Hub % G_up , Hub % S % P ) new_dn = Hub % G_dn % det end if ! Compute the Det ratio ! NB: the determinant computed by GetG is log(abs(det(G))) !     Here we need log(abs(Z))= -log(abs(det(G))) rat = det_up + det_dn - new_up - new_dn if ( Hub % neg_u ) then hs_sum = 0 do j = 1 , L hs_sum = hs_sum + Hub % HSF ( site ( i ), j ) end do ! extra factor for U<0: exp(2 * lambda * Sum(l, s_new(i, l))) rat = rat - 2 * Hub % explook ( 0 , map ( site ( i ))) * hs_sum end if if ( rat > ZERO ) then ratexp = ONE else ratexp = exp ( rat ) end if ! Compare the ratio to a random number if ( ratexp >= ranList ( i )) then ! accept det_up = new_up det_dn = new_dn accept = accept + 1 else ! reject ! recover the old values Hub % G_up % G = Hub % G_up % tmp if ( Hub % comp_dn ) then Hub % G_dn % G = Hub % G_dn % tmp end if Hub % G_up % sgn = copy_sgn_up Hub % G_dn % sgn = copy_sgn_dn do j = 1 , L tmp = - Hub % HSF ( site ( i ), j ) Hub % HSF ( site ( i ), j ) = tmp #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , j ) #endif Hub % V_up ( site ( i ), j ) = Hub % explook ( tmp , map ( site ( i ))) if (. not . Hub % neg_u ) then #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , j ) #endif Hub % V_dn ( site ( i ), j ) = Hub % explook ( - tmp , map ( site ( i ))) end if end do end if end do !Update determinant value Hub % G_up % det = det_up if ( Hub % comp_dn ) then Hub % G_dn % det = det_dn endif ! update G's counter Hub % G_up % wps = Hub % G_up % nWrap Hub % G_dn % wps = Hub % G_dn % nWrap ! update accept and reject counts Hub % nAcceptGlobal = Hub % nAcceptGlobal + accept Hub % nRejectGlobal = Hub % nRejectGlobal + ( numTry - accept ) end subroutine DQMC_Hub_Sweep2 !---------------------------------------------------------------------! ! sweep for continuous HSF ! --------------------------------------------------------------------! subroutine DQMC_Hub_Sweep_Cont ( Hub , nMeas0 ) ! ! Purpose ! ======= !   This subroutine performs the DQMC sweep, which is consisted of !   four steps. (See [1] for more details.) ! !      1. Swap the slice of G and recompute G if necessary. !      2. Metropolis Algorithm !      3. Update the model and perform physical measurement. !      4. Adjust parameters. ! !   The first three steps are within a big loop, which run !   through each time slice of G. The major part is the second !   step, which is explained below. ! !      1. Try the new configuration by single spin-flip sampling !         at site j at time slice i. !      2. Compute the probability of this new configuration. ! !             p =  r/(1+gamma*r)    if r < 1 !             p =  r/(gamma+r)      if r >=1 ! !         where r is the ratio of determinants of Green's function !         of spin up and spin down. !      3. If p > ran, a uniform random number in [0,1], then change !         the configuration and update the Green's function. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ), target :: Hub ! Hubbard model integer , intent ( in ) :: nMeas0 ! Duration of measurement ! ... paremeters ... integer , parameter :: DQMC_CHECK_ITER = 10000 integer , parameter :: DQMC_ADJUST = 100 real ( wp ), parameter :: DQMC_ACC_UP = 0.52_wp real ( wp ), parameter :: DQMC_ACC_LO = 0.48_wp ! ... local scalar ... integer :: i , j , k , n , L ! Loop iterator integer :: cnt ! Counter for measurement integer :: accept_cnt ! Counter for accept in Met-alg real ( wp ) :: accrat real ( wp ) :: alpha_up , alpha_dn ! Change of configuration real ( wp ) :: p , randn ! Probability of changing real ( wp ) :: r_up , r_dn , r ! Ratio of determinant real ( wp ) :: gjj ! (j,j) element of G_up or G_dn ! To speed up the computation real ( wp ), pointer :: G_up (:,:) real ( wp ), pointer :: G_dn (:,:) real ( wp ), pointer :: U_up (:,:) real ( wp ), pointer :: U_dn (:,:) real ( wp ), pointer :: W_up (:,:) real ( wp ), pointer :: W_dn (:,:) real ( wp ), pointer :: V_up (:,:) real ( wp ), pointer :: V_dn (:,:) integer , pointer :: blksz_up integer , pointer :: blksz_dn real ( wp ), pointer :: sgn_up real ( wp ), pointer :: sgn_dn real ( wp ), pointer :: ranlist (:) real ( wp ), pointer :: CHSF (:,:) real ( wp ), pointer :: lambda (:) integer , pointer :: map (:) real ( wp ) :: gamma , edx , delta , dx , dE logical :: comp_dn ! ... Executable ... !=====================! ! Step 0: Setup alias ! !=====================! G_up => Hub % G_up % G U_up => Hub % G_up % U W_up => Hub % G_up % W V_up => Hub % G_up % V blksz_up => Hub % G_up % blksz sgn_up => Hub % G_up % sgn G_dn => Hub % G_dn % G U_dn => Hub % G_dn % U W_dn => Hub % G_dn % W V_dn => Hub % G_dn % V blksz_dn => Hub % G_dn % blksz sgn_dn => Hub % G_dn % sgn ranlist => Hub % WS % R7 gamma = Hub % gamma CHSF => Hub % CHSF comp_dn = Hub % comp_dn map => Hub % S % map n = Hub % n cnt = nMeas0 L = Hub % L lambda => Hub % lambda delta = Hub % delta1 do i = 1 , L !==============================! ! Step 1: Swap the slice of G  ! !==============================! call DQMC_GetG ( i , Hub % G_up , Hub % SB_up ) if ( comp_dn ) then call DQMC_GetG ( i , Hub % G_dn , Hub % SB_dn ) else sgn_dn = sgn_up end if !==============================! ! Step 2: Metropolis Algorithm ! !==============================! accept_cnt = 0 call ran0 ( 2 * n , ranlist , Hub % seed ) do j = Hub % n_start , Hub % n_end ! Try the new configuration by single spin-flip sampling ! at site j at time slice i. ! ! propose a new move dx = delta * ( ranlist ( j + n ) - HALF ) edx = exp ( lambda ( map ( j )) * dx ) alpha_up = edx - ONE alpha_dn = ONE / edx - ONE gjj = DQMC_Gfun_Getjj ( n , j , blksz_up , G_up , U_up , W_up ) r_up = ONE + ( ONE - gjj ) * alpha_up if ( comp_dn ) then gjj = DQMC_Gfun_Getjj ( n , j , blksz_dn , G_dn , U_dn , W_dn ) r_dn = ONE + ( ONE - gjj ) * alpha_dn else r_dn = ONE + gjj * alpha_dn end if ! Computing the Gaussian ! dE = [(x+dx)&#94;2-x&#94;2]/2 = x*dx + dx*dx/2 dE = CHSF ( j , i ) * dx - dx * dx / 2 r = abs ( r_up * r_dn ) * exp ( dE ) ! Compute the probability if ( r <= ONE ) then p = r / ( ONE + gamma * r ) else p = r / ( gamma + r ) end if randn = ranlist ( j ) ! Accept if ( p > randn ) then accept_cnt = accept_cnt + 1 if ( r_up < ZERO ) sgn_up = - sgn_up if ( r_dn < ZERO ) sgn_dn = - sgn_dn CHSF ( j , i ) = CHSF ( j , i ) + dx ! Update G_up call DQMC_UpdateG ( j , alpha_up / r_up , Hub % G_up ) #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , i ) #endif V_up ( j , i ) = V_up ( j , i ) * ( alpha_up + ONE ) Hub % G_up % nModify = i ! If mu /= zero, then update G_dn as well. if ( comp_dn ) then ! Update G_dn call DQMC_UpdateG ( j , alpha_dn / r_dn , Hub % G_dn ) end if #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , i ) #endif V_dn ( j , i ) = V_dn ( j , i ) * ( alpha_dn + ONE ) Hub % G_dn % nModify = i endif ! If reject, do nothing, move on. end do !============================! ! Step 3: Update and Measure ! !============================! ! update G_up/G_dn if there are some updates not applied. call DQMC_ApplyUpdate ( Hub % G_up , forced = . true .) if ( comp_dn ) then call DQMC_ApplyUpdate ( Hub % G_dn , forced = . true .) end if ! update accept and reject counts Hub % naccept = Hub % naccept + accept_cnt Hub % nreject = Hub % nreject + ( n - accept_cnt ) cnt = cnt - 1 if ( cnt == 0 ) then ! construct G_dn for mu = 0 if (. not . Hub % neg_u . and . . not . Hub % comp_dn ) then do k = 1 , n do j = 1 , n G_dn ( k , j ) = - Hub % S % P ( k ) * Hub % S % P ( j ) * G_up ( j , k ) end do G_dn ( k , k ) = G_dn ( k , k ) + ONE end do end if ! Basic measurement call DQMC_Phy0_Meas ( Hub % n , Hub % P0 , G_up , G_dn , & Hub % U , Hub % mu_up , Hub % mu_dn , Hub % t_up , Hub % t_dn , sgn_up , sgn_dn , Hub % S ) if ( Hub % meas2 ) then ! Pair measurement r = sgn_up * sgn_dn call DQMC_Phy2_Meas ( n , Hub % P2 % M1 , Hub % P2 % M2 , & Hub % P2 , Hub % S % B , G_up , G_dn , r ) ! Reset the counter end if cnt = nMeas0 end if end do !===========================! ! Step 4: Adjust parameters ! !===========================! if ( Hub % naccept + Hub % nreject > DQMC_CHECK_ITER ) then accrat = dble ( Hub % naccept ) / dble ( Hub % naccept + Hub % nreject ) if ( accrat > DQMC_ACC_UP . or . accrat < DQMC_ACC_LO ) then Hub % gamma = Hub % gamma + ( accrat - HALF ) Hub % gamma = dmax1 ( ZERO , Hub % gamma ) Hub % gamma = dmin1 ( ONE , Hub % gamma ) Hub % naccept = int ( DQMC_ADJUST * accrat ) Hub % nreject = int ( DQMC_ADJUST * ( ONE - accrat )) endif endif call DQMC_UpdateWraps ( Hub % G_up ) call DQMC_UpdateWraps ( Hub % G_dn ) end subroutine DQMC_Hub_Sweep_Cont !---------------------------------------------------------------------! subroutine DQMC_Hub_Sweep2_Cont ( Hub , numTry ) ! ! Purpose ! ======= !   This subroutine performs the global moves of DQMC sweep, in which !   all the Hub(i) on some selected sites are flipped for all slice. ! !      1. Try the new configuration. !      2. Compute the probability of this new configuration. ! !             p =  r/(1+gamma*r)    if r < 1 !             p =  r/(gamma+r)      if r >=1 ! !         where r is the ratio of determinants of Green's function !         of spin up and spin down. !      3. If p > ran, a uniform random number in [0,1], then change !         the configuration and update the Green's function. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model integer , intent ( in ) :: numTry ! Number of Try ! ... Local Variables ... real ( wp ) :: ranList ( 2 * numTry ), rat , ratexp integer :: i , j , n , L , accept , tmp , nSite real ( wp ) :: det_up , det_dn , new_up , new_dn real ( wp ) :: copy_sgn_up , copy_sgn_dn , delta , dx integer , pointer :: map (:) integer :: siteList ( Hub % n ), site ( numTry ), si , sj integer :: slice ( numTry ) real ( wp ), pointer :: CHSF (:,:) logical :: compute_dn real ( wp ) :: G_dn_tmp ( Hub % n , Hub % n ) ! ... Executable ... n = Hub % n L = Hub % L accept = 0 delta = Hub % delta2 if ( numTry <= 0 ) return Map => Hub % S % Map CHSF => Hub % CHSF compute_dn = Hub % comp_dn . or . . not . Hub % neg_u ! Compute the Green's matrix and the sign #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( Hub % G_up % cpp_data , L , Hub % G_up % sgn , & Hub % G_up % G , Hub % V_up , Hub % SB_up % B % B , & Hub % SB_up % nOrth , det_up ) #else call DQMC_ComputeG ( L , n , Hub % G_up % sgn , Hub % G_up % G , Hub % V_up , & Hub % SB_up , Hub % G_up % pvt , . true ., det_up , HUb % G_up % sxx ) #endif if ( compute_dn ) then #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( Hub % G_dn % cpp_data , L , Hub % G_dn % sgn , & Hub % G_dn % G , Hub % V_dn , Hub % SB_dn % B % B , & Hub % SB_dn % nOrth , det_dn ) #else call DQMC_ComputeG ( L , n , Hub % G_dn % sgn , Hub % G_dn % G , Hub % V_dn , & Hub % SB_dn , Hub % G_dn % pvt , . true ., det_dn , Hub % G_dn % sxx ) #endif else det_dn = det_up Hub % G_dn % sgn = Hub % G_up % sgn end if ! get random numbers call ran0 ( 2 * numTry , ranList , Hub % seed ) nsite = Hub % n_End - Hub % n_start + 1 siteList ( 1 : nSite ) = Hub % n_Start + ( / ( i , i = 0 , nSite - 1 ) / ) ! generate sites do i = 1 , numtry tmp = int ( ranList ( i ) * nSite ) + 1 site ( i ) = siteList ( tmp ) ! compress the list do j = tmp + 1 , nSite siteList ( j - 1 ) = siteList ( j ) end do nSite = nSite - 1 end do ! generate slice do i = 1 , numtry tmp = int ( ranList ( i + numTry ) * L ) + 1 slice ( i ) = tmp end do call ran0 ( numTry , ranList , Hub % seed ) ! Global move do i = 1 , numTry ! Flip its HS field for all the slices si = site ( i ) sj = slice ( i ) do j = 0 , L - 1 dx = delta * cos ( dble ( 2 * n * j ) / L ) CHSF ( si , sj ) = CHSF ( site ( i ), sj ) + dx #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , sj ) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , sj ) #endif Hub % V_up ( si , sj ) = exp ( Hub % lambda ( Hub % S % map ( sj )) * CHSF ( si , sj )) Hub % V_dn ( si , sj ) = exp ( - Hub % lambda ( Hub % S % map ( sj )) * CHSF ( si , sj )) sj = sj + 1 if ( sj > Hub % L ) then sj = 1 end if end do ! Store the value of G first Hub % G_up % tmp = Hub % G_up % G if ( compute_dn ) then G_dn_tmp = Hub % G_dn % G end if copy_sgn_up = Hub % G_up % sgn copy_sgn_dn = Hub % G_dn % sgn ! Compute G with new configuration #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( Hub % G_up % cpp_data , L , n , & Hub % G_up % sgn , Hub % G_up % G , Hub % V_up , Hub % SB_up % B % B , & Hub % SB_up % L , Hub % SB_up % nOrth , new_up ) #else call DQMC_ComputeG ( L , n , Hub % G_up % sgn , Hub % G_up % G , Hub % V_up , & Hub % SB_up , Hub % G_up % pvt , . true ., new_up , Hub % G_up % sxx ) #endif if ( compute_dn ) then #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( Hub % G_up % cpp_data , L , n , & Hub % G_dn % sgn , Hub % G_dn % G , Hub % V_dn , Hub % SB_dn % B % B , & Hub % SB_dn % L , Hub % SB_dn % nOrth , new_dn ) #else call DQMC_ComputeG ( L , n , Hub % G_dn % sgn , Hub % G_dn % G , Hub % V_dn , & Hub % SB_dn , Hub % G_dn % pvt , . true ., new_dn , Hub % G_up % sxx ) #endif else new_dn = new_up Hub % G_dn % sgn = Hub % G_up % sgn end if ! Compute the Det ratio ! rat = abs((det_up*det_dn)/(new_up*new_dn)) rat = det_up + det_dn - new_up - new_dn if ( rat > ZERO ) then ratexp = ONE else ratexp = exp ( rat ) end if ! Compare the ratio to a random number ! add random number if ( ratexp >= ranList ( i )) then ! accept det_up = new_up det_dn = new_dn accept = accept + 1 ! update G's counter Hub % G_up % wps = Hub % G_up % nWrap Hub % G_dn % wps = Hub % G_dn % nWrap else ! reject ! recover the old values Hub % G_up % G = Hub % G_up % tmp if ( compute_dn ) then Hub % G_dn % G = G_dn_tmp end if Hub % G_up % sgn = copy_sgn_up Hub % G_dn % sgn = copy_sgn_dn sj = slice ( i ) do j = 0 , L - 1 dx = delta * cos ( dble ( 2 * n * j ) / L ) CHSF ( si , sj ) = CHSF ( si , sj ) - dx #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , sj ) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , sj ) #endif Hub % V_up ( si , sj ) = exp ( Hub % lambda ( Hub % S % map ( sj )) * CHSF ( si , sj )) Hub % V_dn ( si , sj ) = exp ( - Hub % lambda ( Hub % S % map ( sj )) * CHSF ( si , sj )) sj = sj + 1 if ( sj > Hub % L ) then sj = 1 end if end do end if end do ! update accept and reject counts Hub % naccept = Hub % naccept + accept Hub % nreject = Hub % nreject + ( numTry - accept ) end subroutine DQMC_Hub_Sweep2_Cont !---------------------------------------------------------------------! subroutine DQMC_Hub_Run ( Hub , Info ) ! ! Purpose ! ======= !   This subroutine is the main subroutine for DQMC. !   There are four major wroks ! !      1. Compute Green function. !      2. Perform warmup sweep. !      3. Perform actual sweep. !      4. Analyze the measurement. (see DQMC_Phy0) ! ! Arguments ! ========= ! !   05/08/2012: Add by C.C. !   Info == 1: Print runtime information !   Info == 0: Silent mode ! type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model ! ... local scalar ... integer :: i , j , nIter , nBin , Info ! ... Executable ... ! Warmup sweep do i = 1 , Hub % nWarm if ( Info == 1 . and . mod ( i , 10 ) == 0 ) write ( * , '(A,i6,1x,i3)' ) ' Warmup Sweep, nwrap  : ' , i , Hub % G_up % nwrap ! The second parameter means no measurement should be made. call DQMC_Hub_Sweep ( Hub , NO_MEAS0 ) call DQMC_Hub_Sweep2 ( Hub , Hub % nTry ) end do ! We divide all the measurement into nBin, ! each having nPass/nBin pass. nBin = Hub % P0 % nBin nIter = Hub % nPass / nBin do i = 1 , nBin do j = 1 , nIter call DQMC_Hub_Sweep ( Hub , Hub % nMeas ) call DQMC_Hub_Sweep2 ( Hub , Hub % nTry ) end do ! Accumulate results for each bin if ( Info == 1 ) write ( * , '(a,2i6)' ) ' Measurement Sweep, bin, iter : ' , i , j call DQMC_Phy0_Avg ( Hub % P0 ) if ( Hub % meas2 ) then if ( Hub % P2 % diagonalize ) then call DQMC_Phy2_Avg ( Hub % P2 , Hub % S ) else call DQMC_Phy2_Avg ( Hub % P2 , Hub % S % W ) endif end if end do ! Get average result call DQMC_Phy0_GetErr ( Hub % P0 ) if ( Hub % meas2 ) then call DQMC_Phy2_GetErr ( Hub % P2 ) end if end subroutine DQMC_Hub_Run !--------------------------------------------------------------------! subroutine DQMC_Hub_FullMeas ( Hub , nnb , A_up , A_dn , sgn_up , sgn_dn ) !type(Hubbard), target, intent(inout) :: Hub type ( Hubbard ), intent ( inout ) :: Hub integer , intent ( in ) :: nnb real ( wp ), intent ( in ) :: A_up ( nnb , nnb ) real ( wp ), intent ( in ) :: A_dn ( nnb , nnb ) real ( wp ), intent ( in ) :: sgn_up real ( wp ), intent ( in ) :: sgn_dn integer :: it , i , j , nb ! Extra space for dtau&#94;2-correct estimate type ( G_fun ), target :: G_up_local , G_dn_local real ( wp ), pointer :: G_up (:,:) real ( wp ), pointer :: G_dn (:,:) !Duplicate the Green's function call DQMC_Gfun_Duplicate ( G_up_local , Hub % G_up ) if (. not . Hub % neg_u . or . Hub % comp_dn ) then call DQMC_Gfun_Duplicate ( G_dn_local , Hub % G_dn ) else call DQMC_Gfun_clone ( G_dn_local , G_up_local ) endif G_up => G_up_local % G G_dn => G_dn_local % G !write(*,*) \"Hub%S%checklist(PHASE)=\",Hub%S%checklist(STRUCT_PHASE) nb = nnb / Hub % n !Perform static measurement on all stored time slices do it = 0 , nb - 1 !Load the diagonal of Aup/Adn in G_up/G_dn i = it * Hub % n + 1 j = i + Hub % n - 1 G_up = A_up ( i : j , i : j ) ! 05/15/2012, C.C. ! Modified in order to take into account U < 0 model on non-bipartite lattices. ! Before the modification, the code calls DQMC_Gfun_CopyUp() which assumes bipartite lattice. ! This causes segmentation fault on, for example, triagular lattices which lacks particle-hole ! symmetry. As a result, S%P is not defined. We fix it by separating U < 0 model from the rest ! of the if-else statements, and calling calling DQMC_Gfun_clone(). if ( Hub % comp_dn ) then ! Get G_dn directly when : !     1) U > 0, mu_up .neq. 0, or mu_dn .neq. 0. !     2) U > 0, mu_up = mu_dn = 0, but \"PHASE\" S%P is not defined. E.g. non-bipartite lattice or S%P is simply lacking. !     3) U > 0, mu_up = mu_dn = 0, but t_up .neq. t_dn. !     4) U < 0, but mu_up .neq. mu_dn, or t_up .neq. t_dn. !     5) U = 0, but mu_up .neq. mu_dn, or t_up .neq. t_dn. G_dn = A_dn ( i : j , i : j ) else if ( Hub % neg_u ) then ! G_dn and G_up are identical when : !     1) U < 0, mu_up = mu_dn, and t_up = t_dn !     2) U = 0, mu_up = mu_dn, and t_up = t_dn call DQMC_Gfun_Clone ( G_dn_local , G_up_local ) else ! Note that here we are left with the last condition: (.not.neg_u) and (.not.comp_dn). ! This implies that S%P is defined, i.e. S%checklist(STRUCT_PHASE) = 'T'. ! So we can safely call DQMC_Gfun_CopyUp() which uses particle-hole symmetry. ! Use particle-hole symmetry to get G_dn when : !     1) U > 0, at half-filling, t_up = t_dn, and \"PHASE\" S%P is defined. call DQMC_Gfun_CopyUp ( G_dn_local , G_up_local , Hub % S % P ) endif call DQMC_GetG_2nd_order ( G_up_local , Hub % B_up ) if ( Hub % comp_dn . or . . not . Hub % neg_u ) then call DQMC_GetG_2nd_order ( G_dn_local , Hub % B_dn ) endif call DQMC_Phy0_Meas ( Hub % n , Hub % P0 , G_up_local % GS , G_dn_local % GS , Hub % U , & Hub % mu_up , Hub % mu_up , Hub % t_up , Hub % t_dn , sgn_up , sgn_dn , Hub % S ) if ( Hub % meas2 ) then ! Pair measurement call DQMC_Phy2_Meas ( Hub % n , Hub % P2 % M1 , Hub % P2 % M2 , Hub % P2 , Hub % S % B , & G_up_local % GS , G_dn_local % GS , sgn_up * sgn_dn ) end if enddo call DQMC_Gfun_Free ( G_up_local ) call DQMC_Gfun_Free ( G_dn_local ) end subroutine !-------------------------------------------------------------------! subroutine DQMC_Hub_Meas ( Hub , slice ) !type(Hubbard), target, intent(inout) :: Hub type ( Hubbard ), intent ( inout ) :: Hub integer , intent ( inout ) :: slice type ( G_fun ), target :: G_up_local , G_dn_local real ( wp ), pointer :: G_up (:,:) real ( wp ), pointer :: G_dn (:,:) real ( wp ), pointer :: sgn_up real ( wp ), pointer :: sgn_dn real ( wp ) :: randn ( 1 ) ! 05/10/2012, CC ! Warning: if slice = 0, DQMC_Hub_Meas() would return meaningless results. if ( slice <= 0 . or . slice > Hub % L ) then write ( * , * ) \" In subroutine DQMC_Hub_Meas(Hub, slice), the argument 'slice' is out of bound.\" write ( * , * ) \" It will now be reset randomly.\" call ran0 ( 1 , randn , Hub % seed ) slice = ceiling ( randn ( 1 ) * Hub % L ) write ( * , * ) \" New time slice index is\" , slice end if !Duplicate the Green's function call DQMC_Gfun_Duplicate ( G_up_local , Hub % G_up ) if (. not . Hub % neg_u . or . Hub % comp_dn ) then call DQMC_Gfun_Duplicate ( G_dn_local , Hub % G_dn ) else call DQMC_Gfun_clone ( G_dn_local , G_up_local ) endif G_up => G_up_local % G G_dn => G_dn_local % G sgn_up => G_up_local % sgn sgn_dn => G_dn_local % sgn !Recompute G from scratch G_up_local % ilb = - 1 call DQMC_GetG ( slice , G_up_local , Hub % SB_up ) if ( Hub % comp_dn ) then G_dn_local % ilb = - 1 call DQMC_GetG ( slice , G_dn_local , Hub % SB_dn ) elseif ( Hub % neg_u ) then sgn_dn = sgn_up else ! 05/15/2012, C.C.: ! Note that here we have (.not.neg_u) and (.not.comp_dn). ! This implies that S%P is defined, i.e. S%checklist(STRUCT_PHASE) = 'T'. ! So we can safely call DQMC_Gfun_CopyUp() which uses particle-hole symmetry. call DQMC_Gfun_CopyUp ( G_dn_local , G_up_local , Hub % S % P ) endif !Get G correct to 2nd order call DQMC_GetG_2nd_order ( G_up_local , Hub % B_up ) if ( Hub % comp_dn . or . . not . Hub % neg_u ) then call DQMC_GetG_2nd_order ( G_dn_local , Hub % B_dn ) endif ! Basic measurement call DQMC_Phy0_Meas ( Hub % n , Hub % P0 , G_up_local % GS , G_dn_local % GS , Hub % U , & Hub % mu_up , Hub % mu_dn , Hub % t_up , Hub % t_dn , sgn_up , sgn_dn , Hub % S ) if ( Hub % meas2 ) then ! Pair measurement call DQMC_Phy2_Meas ( Hub % n , Hub % P2 % M1 , Hub % P2 % M2 , Hub % P2 , Hub % S % B , & G_up_local % GS , G_dn_local % GS , sgn_up * sgn_dn ) end if call DQMC_Gfun_Free ( G_up_local ) call DQMC_Gfun_Free ( G_dn_local ) end subroutine DQMC_Hub_Meas !-------------------------------------------------------------------! subroutine DQMC_Hub_Init_Vmat ( Hub ) ! ! Purpose ! ======= !    The element of V(i) is either exp(nu) or exp(-nu) !    where nu = acosh(exp(U*dtau/2)). (see reference [1].) !    The values of exp(nu) and exp(-nu) are stored in a lookup !    table explook.  The decision of wheather V(i,j) is exp(nu) !    or exp(-nu) is given by the list hub, which is a list !    or random +1 and -1. Matrix V for spin up and down have !    opposite selection decision. ! ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ) :: Hub ! ... Local variables ... integer :: i , j real ( wp ) :: temp ! ... Executable ... if (. not . associated ( Hub % V_up )) then allocate ( Hub % V_up ( Hub % n , Hub % L )) endif ! 05/10/2012: Added by C.C. ! This fix is required to make test program in /EXAMPLE/test work. ! Without the fix, the array size of Hub%V_up and Hub%V_dn would be 1 rather then n * L. ! This causes segmentation fault when running the test program. I'm not clear why this ! happens ONLY to test, but not, say, verify and ggeom. if ( size ( Hub % V_up ) /= Hub % n * Hub % L ) then allocate ( Hub % V_up ( Hub % n , Hub % L )) end if if ( Hub % HSFtype == HSF_DISC ) then ! discrete case do i = 1 , Hub % L do j = 1 , Hub % n Hub % V_up ( j , i ) = Hub % explook ( Hub % HSF ( j , i ), Hub % S % map ( j )) end do end do if ( Hub % neg_u ) then if (. not . associated ( Hub % V_dn )) then Hub % V_dn => Hub % V_up endif else if (. not . associated ( Hub % V_dn )) then allocate ( Hub % V_dn ( Hub % n , Hub % L )) endif ! 05/10/2012: Added by C.C. ! This fix is required to make test program in /EXAMPLE/test work. ! Without the fix, the array size of Hub%V_up and Hub%V_dn would be 1 rather then n * L. ! This causes segmentation fault when running the test program. I'm not clear why this ! happens ONLY to test, but not, say, verify and gggeom. if ( size ( Hub % V_dn ) /= Hub % n * Hub % L ) then allocate ( Hub % V_dn ( Hub % n , Hub % L )) end if do i = 1 , Hub % L do j = 1 , Hub % n Hub % V_dn ( j , i ) = Hub % explook ( - Hub % HSF ( j , i ), Hub % S % map ( j )) end do end do end if else ! continuous case do i = 1 , Hub % L do j = 1 , Hub % n temp = Hub % CHSF ( j , i ) Hub % V_up ( j , i ) = exp ( Hub % lambda ( Hub % S % map ( j )) * temp ) end do end do if ( Hub % neg_u ) then if (. not . associated ( Hub % V_dn )) then Hub % V_dn => Hub % V_up endif else if (. not . associated ( Hub % V_dn )) then allocate ( Hub % V_dn ( Hub % n , Hub % L )) endif ! 05/10/2012: Added by C.C. ! This fix is required to make test program in /EXAMPLE/test work. ! Without the fix, the array size of Hub%V_up and Hub%V_dn would be 1 rather then n * L. ! This causes segmentation fault when running the test program. I'm not clear why this ! happens ONLY to test, but not, say, verify and gggeom. if ( size ( Hub % V_dn ) /= Hub % n * Hub % L ) then allocate ( Hub % V_dn ( Hub % n , Hub % L )) end if do i = 1 , Hub % L do j = 1 , Hub % n temp = Hub % CHSF ( j , i ) Hub % V_dn ( j , i ) = exp ( - Hub % lambda ( Hub % S % map ( j )) * temp ) end do end do end if end if end subroutine DQMC_Hub_Init_Vmat !-------------------------------------------------------------------! end module DQMC_Hubbard","tags":"","loc":"sourcefile/dqmc_hubbard.f90.html"},{"title":"dqmc_reclatt.F90 – Quest","text":"This file depends on sourcefile~~dqmc_reclatt.f90~~EfferentGraph sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_reclatt.f90~~AfferentGraph sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_kbonds.f90 dqmc_kbonds.F90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_RECLATT use DQMC_GEOM_PARAM use DQMC_LATT use DQMC_CFG implicit none type :: recip_lattice_t integer :: ndim integer :: nkpts !number of k-points (equal to ncell) real * 8 , pointer :: klist (:,:) !list of k-points(nkpts,rdim) real * 8 :: kpoint ( rdim ) !Input k-point real * 8 :: ktwist ( rdim ) !Twist vector real * 8 :: kcs ( rdim , rdim ) !cartesian component of reciprocal superlattice*** real * 8 :: ks ( rdim , rdim ) !fractional components of reciprocal superlattice*** real * 8 :: kc ( rdim , rdim ) !cartesian components of reciprocal unit cell*** !*** rows of these matrices are the vectors integer :: nmomenta !number of momenta for pair of particles real * 8 , pointer :: ksum (:,:) !list of momentum of pair of particles(nmomenta,rdim) integer , pointer :: kmate (:,:) !mate of each k-points that gives total momentum ksum !(nkpts, nmomenta) integer :: nclass_k !number of inequivalent k-points integer , pointer :: myclass_k (:) !class for each k-point (nkpts) integer , pointer :: class_size_k (:) !number of equivalent k-points in each class (nclass_k) integer , pointer :: class_repr_k (:) !representative k-point for each class (nclass_k) complex * 16 , pointer :: FourierC (:,:) logical :: initialized logical :: constructed logical :: analyzed end type recip_lattice_t contains !----------------------------------------------------------------------! subroutine free_reclatt ( reclatt ) type ( recip_lattice_t ), intent ( inout ) :: reclatt if ( associated ( reclatt % klist )) deallocate ( reclatt % klist ) if ( associated ( reclatt % FourierC )) deallocate ( reclatt % FourierC ) if ( associated ( reclatt % myclass_k )) deallocate ( reclatt % myclass_k ) if ( associated ( reclatt % class_size_k )) deallocate ( reclatt % class_size_k ) if ( associated ( reclatt % class_repr_k )) deallocate ( reclatt % class_repr_k ) end subroutine free_reclatt !--------------------------------------------------------------------- ! Read and fill most of the variables that define the lattices in ! real and reciprocal space. !--------------------------------------------------------------------- subroutine init_recip_latt ( lattice , recip_lattice , applytwist , cfg ) integer :: ndim , i , j real * 8 :: projk ( rdim ) real * 8 , pointer :: kc (:,:) real * 8 , pointer :: kcs (:,:) real * 8 , pointer :: ktwist (:) real * 8 , pointer :: kpoint (:) real * 8 , pointer :: ac (:,:) real * 8 , pointer :: scc (:,:) type ( lattice_t ), intent ( in ), target :: lattice type ( recip_lattice_t ), intent ( out ), target :: recip_lattice type ( config ), intent ( in ), target :: cfg logical , intent ( in ) :: applytwist if (. not . lattice % initialized ) stop 'Need to initialize lattice before recip_lattice' !alias arrays scc => lattice % scc ac => lattice % ac kc => recip_lattice % kc kcs => recip_lattice % kcs ktwist => recip_lattice % ktwist nullify ( kpoint ) ndim = lattice % ndim !twist of the boundary condition in untis of pi recip_lattice % kpoint = 0.d0 if ( applytwist ) then call cfg_get ( cfg , 'bcond' , i , kpoint ) if ( i < ndim ) stop 'Number of boundary condition must at least equal ndim' recip_lattice % kpoint ( 1 : ndim ) = kpoint ( 1 : ndim ) !Since QUEST cannot handle complex hoppings we stop if the k-point is /=0. if ( sum (( kpoint ( 1 : ndim ) - nint ( kpoint ( 1 : ndim ))) ** 2 ) > toll ) then write ( * , * ) 'Only integer twists are possible' stop endif deallocate ( kpoint ) endif kpoint => recip_lattice % kpoint !Take care of k-space cells !Rows of kc are reciprocal lattice basis vectors in cartesian coordinates call get_inverse ( ac , kc ) kc (:,:) = kc * 2.d0 * pi !find reciprocal lattice vectors of the supercell call get_inverse ( scc , kcs ) kcs (:,:) = kcs (:,:) * 2.d0 * pi !convert twist in k-vector in cartesion coordinates do j = 1 , rdim ktwist ( j ) = 0.5 * sum ( kpoint (:) * kcs ( j ,:)) enddo kpoint (:) = ktwist (:) !and project it inside the reciprocal supercell do i = 1 , rdim projk ( i ) = sum ( kpoint (:) * scc (:, i )) / ( 2.0 * pi ) enddo projk (:) = projk (:) - nint ( projk (:)) !then find its cartesian coordinates do i = 1 , rdim ktwist ( i ) = sum ( projk (:) * kcs (:, i )) enddo !find components of kcs in units of kc do i = 1 , 3 do j = 1 , 3 recip_lattice % ks ( i , j ) = sum ( kcs ( i ,:) * ac (:, j )) / ( 2.d0 * pi ) enddo enddo recip_lattice % ndim = ndim !number of k-points is equal to number of cell in supercell recip_lattice % nkpts = lattice % ncell recip_lattice % initialized = . true . !write to stdout ! if(applytwist)then !    write(*,*) !    write(*,*)' Reciprocal lattice basis vectors' !    write(*,'(3f14.7)')((kc(i,j),j=1,rdim),i=1,rdim) !    write(*,*) !    write(*,*)' Reciprocal super-lattice basis vectors' !    write(*,'(3f14.7)')((kcs(i,j),j=1,rdim),i=1,rdim) !    write(*,*) !    write(*,*)'Twist vector' !    write(*,'(3f14.7)')(ktwist(i),i=1,rdim) !    write(*,*)'================================================================' ! endif end subroutine init_recip_latt !---------------------------------------------------------------------------- ! construct the list of k-vectors inside the 1st BZ (klist). !---------------------------------------------------------------------------- subroutine construct_recip_lattice ( recip_lattice ) integer :: nkx , nky , nkz , ndim , ikx , iky , ikz , ikv ( rdim ), ncubex , ncubey , ncubez , & & ilist , nedge , nfound , nkpts , i , j integer * 8 , allocatable :: indedge (:) real * 8 :: invkc ( rdim , rdim ) real * 8 , allocatable :: kset (:,:) real * 8 , pointer :: klist (:,:) type ( recip_lattice_t ), intent ( inout ) :: recip_lattice if (. not . recip_lattice % initialized ) stop 'Need to initialize recip_lattice before construction' call get_inverse ( recip_lattice % kc , invkc ) ndim = recip_lattice % ndim allocate ( klist ( recip_lattice % nkpts , rdim )) nkx = 0 ; if ( ndim > 0 ) nkx = 1 nky = 0 ; if ( ndim > 1 ) nky = 1 nkz = 0 ; if ( ndim > 2 ) nkz = 1 !Define kset as the set of points surrouding the origin. !26 in 3D, 8 in 2D, 2 in 2D. This helps definining the !1st brillouin zone. allocate ( kset ( 3 ** ndim - 1 , rdim ), indedge ( recip_lattice % nkpts )) i = 0 do ikx =- nkx , nkx ; ikv ( 1 ) = ikx do iky =- nky , nky ; ikv ( 2 ) = iky do ikz =- nkz , nkz ; ikv ( 3 ) = ikz if ( sum ( ikv ** 2 ) > 0 ) then i = i + 1 do j = 1 , rdim kset ( i , j ) = sum ( ikv (:) * recip_lattice % kc (:, j )) enddo endif enddo enddo enddo ncubex = 0 ; ncubey = 0 ; ncubez = 0 !Start by including the ktwist vector ilist = 1 ; klist ( ilist ,:) = recip_lattice % ktwist (:); nedge = 0 if ( ndim > 0 ) then do !Look at increasingly large \"cubes\" around the k-space origin. ncubex = ncubex + 1 if ( ndim > 1 ) ncubey = ncubey + 1 if ( ndim > 2 ) ncubez = ncubez + 1 nfound = 0 do ikz =- ncubez , ncubez ikv ( 3 ) = ikz !constant y edges : kz constant equal to ikz, ky constant equal to -ncubey !or ncubey, and ikx varying between +/-ncubex if ( ncubey /= 0 ) then do iky =- ncubey , ncubey , 2 * ncubey ikv ( 2 ) = iky do ikx =- ncubex , ncubex ikv ( 1 ) = ikx !Include k-point associated to ikv(:) in klist if it belongs to 1st BZ call check_and_update enddo enddo endif !constant x edges : kz constant equal to ikz, kx constant equal to -ncubex !or ncubex, and ky varying in +/-(ncubey-1) (special care when ncubey=0 i.e. 1D) do ikx =- ncubex , ncubex , 2 * ncubex ikv ( 1 ) = ikx do iky = min ( 0 , - ncubey + 1 ), max ( 0 , ncubey - 1 ) ikv ( 2 ) = iky !Include k-point associated to ikv(:) in klist if it belongs to 1st BZ call check_and_update enddo enddo enddo !constant kz faces i.e. kz=-ncubez,ncubez if ( ncubez > 0 ) then do ikz =- ncubez , ncubez , 2 * ncubez ikv ( 3 ) = ikz do iky =- ncubey + 1 , ncubey - 1 ikv ( 2 ) = iky do ikx =- ncubex + 1 , ncubex - 1 ikv ( 1 ) = ikx !Include k-point associated to ikv(:) in klist if it belongs to 1st BZ call check_and_update enddo enddo enddo endif !no new k-points were found : exit if ( nfound == 0 ) exit enddo endif nkpts = ilist !Store k-vectors in asceding order of length call vsort ( klist , nkpts ) recip_lattice % klist => klist ! write(*,*)'Reciprocal lattice (1st Brillouin zone)' ! write(*,'(/,A,1x,i4)')' Number of k-points found: ',nkpts ! if(nkpts/=recip_lattice%nkpts)then !  write(*,*)'This is different from', recip_lattice%nkpts !  stop ! endif ! write(*,'(3f12.6)')((klist(i,j),j=1,rdim),i=1,recip_lattice%nkpts) ! write(*,*)'================================================================' recip_lattice % constructed = . true . contains subroutine check_and_update integer i , ie real * 8 :: kpt ( rdim ), projk ( rdim ), diff ( rdim ) logical on_edge , included !Get k-point associated to ikv(:) do i = 1 , 3 kpt ( i ) = sum ( ikv (:) * recip_lattice % kcs (:, i )) + recip_lattice % ktwist ( i ) enddo if ( closer_to_zero ( kpt , kset , on_edge , ndim )) then !kpt is either inside or on edge of BZ included = . false . if ( on_edge ) then !Need to see whether equivalent was already included do ie = 1 , nedge !compute the distance with other points on edge. diff (:) = klist ( indedge ( ie ),:) - kpt (:) !convert it in units of primitive reciprocal lattice do i = 1 , 3 projk ( i ) = sum ( diff (:) * invkc (:, i )) enddo !If all integers than point was already included projk (:) = projk (:) - nint ( projk (:)) if ( sum ( projk ** 2 ) < 1.d-6 ) then included = . true . endif enddo endif if (. not . included ) then !Include the point in klist nfound = nfound + 1 ilist = ilist + 1 klist ( ilist ,:) = kpt (:) !save info if k-point was on edge if ( on_edge ) then nedge = nedge + 1 indedge ( nedge ) = ilist endif endif endif end subroutine check_and_update subroutine vsort ( vvec , n ) integer n , i , j , k real * 8 vvec ( n , rdim ), vlen ( n ), av ( rdim ), a do i = 1 , n vlen ( i ) = sum ( vvec ( i ,:) ** 2 ) enddo do i = 2 , n a = vlen ( i ) av (:) = vvec ( i ,:) do j = 1 , i - 1 if ( a + 1.d-10 < vlen ( j )) exit enddo do k = i - 1 , j , - 1 vlen ( k + 1 ) = vlen ( k ) vvec ( k + 1 ,:) = vvec ( k ,:) enddo vlen ( j ) = a vvec ( j ,:) = av (:) enddo end subroutine end subroutine !---------------------------------------------------------- !Determine whether a k-point (kpt) is closer to k=0 than !to any of the points in kset. If half way set to true !but also set on_edge to true. !---------------------------------------------------------- logical function closer_to_zero ( ktp , kset , on_edge , ndim ) integer , intent ( in ) :: ndim real * 8 , intent ( in ) :: ktp ( rdim ), kset ( 3 ** ndim - 1 , rdim ) real * 8 :: diff ( rdim ), dist0 , dist logical :: on_edge integer :: i on_edge = . false . diff (:) = ktp (:) ** 2 !Distance from origin dist0 = sum ( diff ) !Loop over the points surrounding the origin do i = 1 , 3 ** ndim - 1 diff (:) = ( ktp (:) - kset ( i ,:)) ** 2 !distance from kset(i,:) dist = sum ( diff ) if ( dist + toll < dist0 ) then !ktp is closer to kset(i,:) than to k=0.0 : outside 1st BZ closer_to_zero = . false . return else !ktp is rougly equidistant from kset(i,:) and k=0.0 : on edge of 1st BZ if ( dist - toll < dist0 ) on_edge = . true . endif enddo closer_to_zero = . true . end function closer_to_zero !--------------------------------------------------------------------! subroutine DQMC_init_kmate ( reclatt , nmom , ksum ) type ( recip_lattice_t ), intent ( inout ) :: reclatt integer , intent ( in ) :: nmom real ( wp ), intent ( in ) :: ksum ( nmom , rdim ) integer :: ik , jk , i , im real ( wp ), dimension ( rdim ) :: kpt , kdiff , kproj real ( wp ) :: kcinv ( rdim , rdim ) reclatt % nmomenta = nmom allocate ( reclatt % kmate ( reclatt % nkpts , nmom )) allocate ( reclatt % ksum ( nmom , rdim )) reclatt % ksum = ksum call get_inverse ( reclatt % kc , kcinv ) !Loop over all k-points and find their partner do im = 1 , reclatt % nmomenta do ik = 1 , reclatt % nkpts !Compute k-point so that sum equals totk. kpt (:) = reclatt % ksum ( im ,:) - reclatt % klist ( ik ,:) !Find k-point in 1st BZ that corresponds to kpt do jk = 1 , reclatt % nkpts !Compute difference in units of Primitive cell k-vectors kdiff (:) = kpt (:) - reclatt % klist ( jk ,:) do i = 1 , rdim kproj ( i ) = sum ( kdiff (:) * kcinv ( i ,:)) enddo !If everything is an integer, we found the vector if ( sum (( kproj - nint ( kproj )) ** 2 ) < 1.d-6 ) then reclatt % kmate ( ik , im ) = jk exit endif enddo enddo enddo !Check do im = 1 , reclatt % nmomenta do ik = 1 , reclatt % nkpts jk = reclatt % kmate ( ik , im ) if ( reclatt % kmate ( jk , im ) /= ik ) then write ( * , * ) 'K-mates do not match. Stop.' stop endif enddo enddo do im = 1 , reclatt % nmomenta write ( * , * ) 'Total momentum :' , ( ksum ( im , i ), i = 1 , rdim ) write ( * , * ) 'Pairs :' do ik = 1 , reclatt % nkpts jk = reclatt % kmate ( ik , im ) write ( * , '(3(i3, 3f10.5,10x))' ) ik , ( reclatt % klist ( ik , i ), i = 1 , rdim ),& jk , ( reclatt % klist ( jk , i ), i = 1 , rdim ) enddo write ( * , * ) '===============================================================' enddo end subroutine !--------------------------------------------------------------------! subroutine DQMC_Fill_FourierC ( Reciplattice , lattice ) ! Fill the matrix of Fourier coefficients type ( lattice_t ), intent ( in ), target :: lattice type ( recip_lattice_t ), intent ( inout ), target :: Reciplattice integer :: nt , nk , i , ii , j real * 8 , pointer :: tr (:,:) real * 8 , pointer :: kpts (:,:) integer , pointer :: indx (:) !initialize tr => lattice % translation kpts => RecipLattice % klist indx => RecipLattice % class_repr_k nt = lattice % ncell nk = RecipLattice % nclass_k allocate ( Reciplattice % FourierC ( nt , nk )) !compute do i = 0 , nt - 1 ii = i + 1 do j = 1 , nk Reciplattice % FourierC ( ii , j ) = exp ( im * sum ( tr (:, i ) * kpts ( indx ( j ),:))) enddo enddo Reciplattice % FourierC = Reciplattice % FourierC / sqrt ( dble ( nt )) end subroutine DQMC_Fill_FourierC end module DQMC_RECLATT","tags":"","loc":"sourcefile/dqmc_reclatt.f90.html"},{"title":"dqmc_matb.F90 – Quest","text":"This file depends on sourcefile~~dqmc_matb.f90~~EfferentGraph sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_matb.f90~~AfferentGraph sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_MATB #include \"dqmc_include.h\" use DQMC_UTIL use DQMC_Struct use DQMC_WSPACE implicit none ! ! This module defines the type and subroutines for propagator B. ! !  Data Type !  ========= ! type matB integer :: n ! dim of B real ( wp ), pointer :: K (:,:) ! The Hamiltonian real ( wp ), pointer :: B (:,:) ! Matrix B real ( wp ), pointer :: Bi (:,:) ! Inverse of matrix B real ( wp ), pointer :: rtB (:,:) ! Matrix B real ( wp ), pointer :: rtBi (:,:) ! Inverse of matrix B character ( 12 ) :: name logical :: exactb end type matB !----------------------------------------------------------------------! #ifdef DQMC_PROFILE #define PROF_BEGIN if (matb_profile) call get_time(matb_t1) #define PROF_END(c, t) if (matb_profile) call matb_end(c, t) real ( wp ) :: MultB_Left_time = 0 , MultBi_Left_time = 0 real ( wp ) :: MultB_Right_time = 0 , MultBi_Right_time = 0 double precision :: matb_t1 , matb_t2 logical :: matb_profile = . false . integer :: MultB_Left_count = 0 , MultBi_Left_count = 0 integer :: MultB_Right_count = 0 , MultBi_Right_count = 0 contains subroutine matb_end ( c , t ) integer :: c real ( wp ) :: t call get_time ( matb_t2 ) c = c + 1 t = t + matb_t2 - matb_t1 end subroutine matb_end subroutine matb_print () write ( * , * ) \"MultB_Left    \" , MultB_Left_count , MultB_Left_time write ( * , * ) \"MultBi_Left   \" , MultBi_Left_count , MultBi_Left_time write ( * , * ) \"MultB_Right   \" , MultB_Right_count , MultB_Right_time write ( * , * ) \"MultBi_Right  \" , MultBi_Right_count , MultBi_Right_time end subroutine matb_print #else #define PROF_BEGIN #define PROF_END(c, t) contains #endif subroutine DQMC_B_Init ( n , B , WS , Adj , ckb , t , mu , dtau ) ! ! Purpose ! ======= !    This subroutine getnerates exponentional matrices of [-]dtau*T. ! !         Ek  = exp(dtau*T) !         Eki = exp(-dtau*T) ! !    The steps are !    1. Compute the Spectral Decomposition of T = USU&#94;T !    2. Exponent the diagonal matrix S and -S !    3. Assemble B = U*exp(S)*U&#94;T, Bi=U*exp(-S)*U&#94;T ! !    The parameters for checkboard method are also initialized !    in this subroutine. For the checkboard method, see [1] for !    more detail. ! !    [1] W. Hanke and Yu.V. Kopaev, \"Stable Numerical Simulation !        of Models of Interating Electrons in Condensed-Matter Physics.\" !        Chapter 4. Elsevier Science Pub. ! ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! Number of sites type ( MatB ), intent ( inout ) :: B ! MatB type ( WSpace ), intent ( inout ), target :: WS ! shared working space type ( CCS ), intent ( in ) :: adj ! adjacent info type ( CCS ), intent ( out ) :: ckb real ( wp ), intent ( in ) :: t (:) ! model parameter real ( wp ), intent ( in ) :: mu ( n ), dtau ! ... local scalars    ... integer :: i , j ! iterator real ( wp ), pointer :: H (:,:) integer , pointer :: start (:) integer , pointer :: r (:) integer , pointer :: A (:) ! ... Executable ... B % n = n ckb % n = 0 ckb % nnz = 0 B % exactb = . false . ! test if allocated allocate ( B % K ( n , n )) allocate ( B % B ( n , n )) allocate ( B % Bi ( n , n )) allocate ( B % rtB ( n , n )) allocate ( B % rtBi ( n , n )) B % name = \"Dense MatB\" ! Compute the B matrix H => WS % R1 H = ZERO start => Adj % cstart r => Adj % row A => Adj % A do i = 1 , n do j = start ( i ), start ( i + 1 ) - 1 H ( r ( j ), i ) = t ( A ( j )) * dtau end do H ( i , i ) = mu ( i ) * dtau end do B % K = H call DQMC_B_ExpInit ( B , H , WS ) end subroutine DQMC_B_Init !----------------------------------------------------------------------! subroutine DQMC_B_ExpInit ( B , K , WS ) ! ! Purpose ! ======= !    This subroutine getnerates exponentional matrices of [-]dtau*T. ! !         Ek  = exp(dtau*T) !         Eki = exp(-dtau*T) ! !    The steps are !    1. Compute the Spectral Decomposition of T = USU&#94;T !    2. Exponent the diagonal matrix S and -S !    3. Assemble B = U*exp(S)*U&#94;T, Bi=U*exp(-S)*U&#94;T ! !    The parameters for checkboard method are also initialized !    in this subroutine. For the checkboard method, see [1] for !    more detail. ! !    [1] W. Hanke and Yu.V. Kopaev, \"Stable Numerical Simulation !        of Models of Interating Electrons in Condensed-Matter Physics.\" !        Chapter 4. Elsevier Science Pub. ! ! ! Arguments ! ========= ! type ( MatB ), intent ( inout ) :: B ! MatB real ( wp ), intent ( inout ) :: K (:,:) ! model parameter type ( WSpace ), intent ( inout ), target :: WS ! shared working space ! ... local scalars    ... integer :: i , info , n ! iterator real ( wp ), pointer :: W5 (:) real ( wp ), pointer :: W4 (:) ! ... Executable ... W5 => WS % R5 W4 => WS % R7 n = B % n ! Compute the Spectral Decomposition of W1 call lapack_dsyev ( 'V' , 'L' , n , K , n , W5 , W4 , WS % lw ( LA_SYEV ), info ) !! Check error message if ( info . ne . 0 ) then call DQMC_Error ( \"Error: from dsyev, dqmc_getek\" , info ) end if ! Exponent the diagonal elements and scale the right eigenmatrix WS % R2 = K !! Scale the right eigenmatrix do i = 1 , n call blas_dscal ( n , dexp ( W5 ( i )), WS % R2 (:, i ), 1 ) end do ! Assemble B call blas_dgemm ( 'N' , 'T' , n , n , n , ONE , K , n , WS % R2 , n , ZERO , B % B , n ) ! For the inverse part, do the same thing WS % R2 = K do i = 1 , n call blas_dscal ( n , dexp ( - W5 ( i )), WS % R2 (:, i ), 1 ) end do ! Assemble Bi call blas_dgemm ( 'N' , 'T' , n , n , n , ONE , K , n , WS % R2 , n , ZERO , B % Bi , n ) ! square root of B WS % R2 = K !! Scale the right eigenmatrix do i = 1 , n call blas_dscal ( n , sqrt ( dexp ( W5 ( i ))), WS % R2 (:, i ), 1 ) end do ! Assemble B call blas_dgemm ( 'N' , 'T' , n , n , n , ONE , K , n , WS % R2 , n , ZERO , B % rtB , n ) ! square root of inv(B) WS % R2 = K !! Scale the right eigenmatrix do i = 1 , n call blas_dscal ( n , sqrt ( dexp ( - W5 ( i ))), WS % R2 (:, i ), 1 ) end do ! Assemble B call blas_dgemm ( 'N' , 'T' , n , n , n , ONE , K , n , WS % R2 , n , ZERO , B % rtBi , n ) end subroutine DQMC_B_ExpInit !----------------------------------------------------------------------! subroutine DQMC_B_Free ( B ) ! ! Purpose ! ======= !    This subroutine frees memory of B. ! ! Arguments ! ========= ! type ( MatB ), intent ( inout ) :: B ! MatB ! ... Executable ... deallocate ( B % B , B % Bi , B % rtB , B % rtBi ) end subroutine DQMC_B_Free !----------------------------------------------------------------------! subroutine DQMC_MultB_Left ( n , M , B , V_i , C ) ! ! Purpose ! ======= !    This subroutine mulitplies matrix M by the matrix B_i from !    leftside. ! ! Pre-assumption ! ============== !    1. Matrix M, B and C are square with the same order n. !    2. Vector V_i is of length n. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M real ( wp ), intent ( inout ) :: M ( n , n ) ! type ( MatB ), intent ( in ) :: B ! real ( wp ), intent ( in ) :: V_i ( n ) ! real ( wp ), intent ( inout ) :: C ( n , n ) ! working space integer :: i integer :: lwork real ( wp ), pointer :: W1 (:) real ( wp ), pointer :: W2 (:) real ( wp ), pointer :: W3 (:,:) ! ... executable ... PROF_BEGIN if ( B % exactb ) then lwork = 3 * n allocate ( W1 ( lwork ), W2 ( n ), W3 ( n , n )) ! Hamiltonian at time slice C = B % K do i = 1 , n C ( i , i ) = C ( i , i ) + log ( V_i ( i )) enddo ! Compute the Spectral Decomposition call lapack_dsyev ( 'V' , 'L' , n , C , n , W2 , W1 , lwork , i ) !! Check error message if ( i . ne . 0 ) then call DQMC_Error ( \"Error: from dsyev, dqmc_getek\" , i ) end if ! Compute M&#94;T U call blas_dgemm ( 'T' , 'N' , n , n , n , ONE , M , n , C , n , ZERO , W3 , n ) ! Compute M&#94;T U D do i = 1 , n call blas_dscal ( n , dexp ( W2 ( i )), W3 (:, i ), 1 ) end do ! Compute U (M&#94;T U D)&#94;T = U D U&#94;T M = B M call blas_dgemm ( 'N' , 'T' , n , n , n , ONE , C , n , W3 , n , ZERO , M , n ) deallocate ( W1 , W2 , W3 ) else ! Copy M to C C = M ! M = B*C call blas_dgemm ( 'N' , 'N' , n , n , n , ONE , B % B , n , C , n , ZERO , M , n ) ! M = Vi*M call DQMC_ScaleRow ( n , M , V_i ) endif PROF_END ( MultB_Left_count , MultB_Left_time ) end subroutine DQMC_MultB_Left !-----------------------------------------------------------------------! subroutine DQMC_MultBi_Left ( n , M , B , V_i , C ) ! ! Purpose ! ======= !    This subroutine mulitplies matrix M by the matrix B_i from !    leftside. ! ! Pre-assumption ! ============== !    1. Matrix M, B and C are square with the same order n. !    2. Vector V_i is of length n. !    3. Flag lr is either 'l' or 'r'. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M real ( wp ), intent ( inout ) :: M ( n , n ) ! type ( MatB ), intent ( in ) :: B ! MatB real ( wp ), intent ( in ) :: V_i ( n ) ! real ( wp ), intent ( inout ) :: C ( n , n ) ! working space integer :: i integer :: lwork real ( wp ), pointer :: W1 (:) real ( wp ), pointer :: W2 (:) real ( wp ), pointer :: W3 (:,:) ! ... executable ... PROF_BEGIN if ( B % exactb ) then lwork = 3 * n allocate ( W1 ( lwork ), W2 ( n ), W3 ( n , n )) ! Hamiltonian at time slice C = B % K do i = 1 , n C ( i , i ) = C ( i , i ) + log ( V_i ( i )) enddo ! Compute the Spectral Decomposition call lapack_dsyev ( 'V' , 'L' , n , C , n , W2 , W1 , lwork , i ) !! Check error message if ( i . ne . 0 ) then call DQMC_Error ( \"Error: from dsyev, dqmc_getek\" , i ) end if ! Compute M&#94;T U call blas_dgemm ( 'T' , 'N' , n , n , n , ONE , M , n , C , n , ZERO , W3 , n ) ! Compute M&#94;T U D do i = 1 , n call blas_dscal ( n , dexp ( - W2 ( i )), W3 (:, i ), 1 ) end do ! Compute U (M&#94;T U D)&#94;T = U D U&#94;T M = B M call blas_dgemm ( 'N' , 'T' , n , n , n , ONE , C , n , W3 , n , ZERO , M , n ) deallocate ( W1 , W2 , W3 ) else ! Multiply B from left-hand-side ! M = inv(V_i)*M call DQMC_ScaleRowInv ( n , M , V_i ) ! Copy M to C C = M ! M = B*C call blas_dgemm ( 'N' , 'N' , n , n , n , ONE , B % Bi , n , C , n , ZERO , M , n ) endif PROF_END ( MultBi_Left_count , MultBi_Left_time ) end subroutine DQMC_MultBi_Left !----------------------------------------------------------------------! subroutine DQMC_MultB_Right ( n , M , B , V_i , C ) ! ! Purpose ! ======= !    This subroutine mulitplies matrix M by the matrix B_i from !    leftside. ! ! Pre-assumption ! ============== !    1. Matrix M, B and C are square with the same order n. !    2. Vector V_i is of length n. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M real ( wp ), intent ( inout ) :: M ( n , n ) ! type ( MatB ), intent ( in ) :: B ! real ( wp ), intent ( in ) :: V_i ( n ) ! real ( wp ), intent ( inout ) :: C ( n , n ) ! working space integer :: i integer :: lwork real ( wp ), pointer :: W1 (:) real ( wp ), pointer :: W2 (:) real ( wp ), pointer :: W3 (:,:) ! ... executable ... PROF_BEGIN if ( B % exactb ) then lwork = 3 * n allocate ( W1 ( lwork ), W2 ( n ), W3 ( n , n )) ! Generate H at time slice C = B % K do i = 1 , n C ( i , i ) = C ( i , i ) + log ( V_i ( i )) enddo ! Compute the Spectral Decomposition of W1 call lapack_dsyev ( 'V' , 'L' , n , C , n , W2 , W1 , lwork , i ) !! Check error message if ( i . ne . 0 ) then call DQMC_Error ( \"Error: from dsyev, dqmc_getek\" , i ) end if ! Compute M U call blas_dgemm ( 'N' , 'N' , n , n , n , ONE , M , n , C , n , ZERO , W3 , n ) ! Compute M U D do i = 1 , n call blas_dscal ( n , dexp ( W2 ( i )), W3 (:, i ), 1 ) end do ! Compute M U D U&#94;T = M B call blas_dgemm ( 'N' , 'T' , n , n , n , ONE , W3 , n , C , n , ZERO , M , n ) deallocate ( W1 , W2 , W3 ) else ! M = M*V_i call DQMC_ScaleCol ( n , M , V_i ) ! Copy M to C C = M ! M = C*B call blas_dgemm ( 'N' , 'N' , n , n , n , ONE , C , n , B % B , n , ZERO , M , n ) endif PROF_END ( MultB_Right_count , MultB_Right_time ) end subroutine DQMC_MultB_Right !-----------------------------------------------------------------------! subroutine DQMC_MultBi_Right ( n , M , B , V_i , C ) ! ! Purpose ! ======= !    This subroutine mulitplies matrix M by the matrix B_i from !    rightside. ! ! Pre-assumption ! ============== !    1. Matrix M, B and C are square with the same order n. !    2. Vector V_i is of length n. !    3. Flag lr is either 'l' or 'r'. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M real ( wp ), intent ( inout ) :: M ( n , n ) ! type ( MatB ), intent ( in ) :: B ! MatB real ( wp ), intent ( in ) :: V_i ( n ) ! real ( wp ), intent ( inout ) :: C ( n , n ) ! working space integer :: i integer :: lwork real ( wp ), pointer :: W1 (:) real ( wp ), pointer :: W2 (:) real ( wp ), pointer :: W3 (:,:) ! ... executable ... PROF_BEGIN if ( B % exactb ) then lwork = 3 * n allocate ( W1 ( lwork ), W2 ( n ), W3 ( n , n )) ! Generate H at time slice C = B % K do i = 1 , n C ( i , i ) = C ( i , i ) + log ( V_i ( i )) enddo ! Compute the Spectral Decomposition of W1 call lapack_dsyev ( 'V' , 'L' , n , C , n , W2 , W1 , lwork , i ) !! Check error message if ( i . ne . 0 ) then call DQMC_Error ( \"Error: from dsyev, dqmc_getek\" , i ) end if ! Compute M U call blas_dgemm ( 'N' , 'N' , n , n , n , ONE , M , n , C , n , ZERO , W3 , n ) ! Compute M U D do i = 1 , n call blas_dscal ( n , dexp ( - W2 ( i )), W3 (:, i ), 1 ) end do ! Compute M U D U&#94;T = M B call blas_dgemm ( 'N' , 'T' , n , n , n , ONE , W3 , n , C , n , ZERO , M , n ) deallocate ( W1 , W2 , W3 ) else ! Multiply B from right-hand-side ! Copy M to C C = M ! M = C*B call blas_dgemm ( 'N' , 'N' , n , n , n , ONE , C , n , B % Bi , n , ZERO , M , n ) ! M = M*V_i call DQMC_ScaleColInv ( n , M , V_i ) PROF_END ( MultBi_Right_count , MultBi_Right_time ) endif end subroutine DQMC_MultBi_Right !-----------------------------------------------------------------------! subroutine DQMC_MultrtB0_Left ( n , M , B , C ) ! ! Purpose ! ======= !    This subroutine mulitplies matrix M by the matrix sqrt(B0) from !    leftside. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M real ( wp ), intent ( inout ) :: M ( n , n ) ! type ( MatB ), intent ( in ) :: B ! real ( wp ), intent ( inout ) :: C ( n , n ) ! working space ! ... executable ... ! Multiply B from left-hand-side ! Copy M to C C = M ! M = B*C call blas_dgemm ( 'N' , 'N' , n , n , n , ONE , B % rtB , n , C , n , ZERO , M , n ) end subroutine DQMC_MultrtB0_Left !----------------------------------------------------------------------! subroutine DQMC_MultrtB0i_Right ( n , M , B , C ) ! ! Purpose ! ======= !    This subroutine mulitplies matrix M by the matrix sqrt(B0_i) from !    rightside. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M real ( wp ), intent ( inout ) :: M ( n , n ) ! type ( MatB ), intent ( in ) :: B ! real ( wp ), intent ( inout ) :: C ( n , n ) ! working space ! ... executable ... ! Copy M to C C = M ! M = C*B call blas_dgemm ( 'N' , 'N' , n , n , n , ONE , C , n , B % rtBi , n , ZERO , M , n ) end subroutine DQMC_MultrtB0i_Right !-----------------------------------------------------------------------! subroutine DQMC_GetB ( n , M , B , V_i , C ) ! ! Purpose ! ======= !    This subroutine returns M = V_iB ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M real ( wp ), intent ( inout ) :: M ( n , n ) ! type ( MatB ), intent ( in ) :: B ! real ( wp ), intent ( in ) :: V_i ( n ) ! real ( wp ), intent ( inout ) :: C ( n , n ) ! working space integer :: i ! ... executable ... if ( B % exactb ) then M = ZERO do i = 1 , n M ( i , i ) = ONE enddo call DQMC_MultB_Right ( n , M , B , V_i , C ) else C ( n , n ) = 0.d0 M = B % B ! M = Vi*M call DQMC_ScaleRow ( n , M , V_i ) endif end subroutine DQMC_GetB !-----------------------------------------------------------------------! subroutine DQMC_GetBi ( n , M , B , V_i , C ) ! ! Purpose ! ======= !    This subroutine returns M = inv(B)inv(V_i) ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M real ( wp ), intent ( inout ) :: M ( n , n ) ! type ( MatB ), intent ( in ) :: B ! MatB real ( wp ), intent ( in ) :: V_i ( n ) ! real ( wp ), intent ( inout ) :: C ( n , n ) ! working space integer :: i ! ... executable ... if ( B % exactb ) then M = ZERO do i = 1 , n M ( i , i ) = ONE enddo call DQMC_MultBi_Right ( n , M , B , V_i , C ) else ! ... executable ... C ( n , n ) = 0.d0 M = B % Bi ! M = Vi*M call DQMC_ScaleColInv ( n , M , V_i ) endif end subroutine DQMC_GetBi !----------------------------------------------------------------------! end module DQMC_MATB","tags":"","loc":"sourcefile/dqmc_matb.f90.html"},{"title":"dqmc_symm.F90 – Quest","text":"This file depends on sourcefile~~dqmc_symm.f90~~EfferentGraph sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_symm.f90~~AfferentGraph sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_kbonds.f90 dqmc_kbonds.F90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_SYMM use DQMC_GEOM_PARAM use DQMC_UTIL implicit none type :: symm_operations integer :: ntotsymm !number of symmetry read from input integer :: nsymm !number of symmetries compatible with supercell integer :: ntransl !number of translations integer , pointer :: map_symm (:,:) !action of symmetry on site (0:nsites-1, nsymm) !map_symm(i,j) returns the site where site \"i\" is mapped !by symmetry operation 'j\" integer , pointer :: map_symm_k (:,:) !action of symmetry on k-point (nkpts, msymm) !map_symm_k(i,j) returns the k-point where k-point \"i\" is mapped !by symmetry operation 'j\" integer , pointer :: map_symm_g (:,:) !action of symmetry on k-point (nkpts, msymm) !map_symm_k(i,j) returns the k-point where k-point \"i\" is mapped !by symmetry operation 'j\" !msymm is equal to nsymm if addTimeRev==false. Otherwise msymm=nsymm+1 integer , pointer :: map_symm_b (:,:) !action of symmetry on bond (ntotbond, nsymm) !A bond is a pair of sites where the first site is inside the unit cell integer , pointer :: map_symm_p (:,:) !action of symmetry on pair (nbond, nsymm) !Pairs are a subset of bonds used to describe pairing properties. !Their symmetry property are derived from those of bonds. integer , pointer :: translback (:) !number of the translation mapping a site into its untranslated !image inside the primitive cell (0:nsites-1) integer , pointer :: translate (:,:) !action of translations on site (0:nsites-1,0:ntransl-1) integer , pointer :: valid_symm (:) !label of valid symmetry operation(nsymm) !It returns a number between 1 and ntotsymm real * 8 , pointer :: symmangle (:) !Angle of rotation of symmetry operation (ntotsymm) in radiants !rotations real * 8 , pointer :: symmpoint (:,:) !point which symmetry operation goes through (rdim,ntotsymm) !rotations, reflections and inversions real * 8 , pointer :: symmaxis (:,:) !direction of the axis (rdim,ntotsymm) !rotations and reflections character * 1 , pointer :: symmlabel (:) !label of operation: C, D, I ,S (ntotsymm) !rotation, mirror plane, inversion center, rotoreflection logical :: initialized logical :: lattice_mapped logical :: recip_lattice_mapped logical :: bonds_mapped logical :: addTimeRev end type contains !------------------------------------------------------------------------------ subroutine free_symm ( symm ) type ( symm_operations ), intent ( inout ) :: symm if ( associated ( symm % map_symm )) deallocate ( symm % map_symm ) if ( associated ( symm % symmaxis )) deallocate ( symm % symmaxis ) if ( associated ( symm % symmlabel )) deallocate ( symm % symmlabel ) if ( associated ( symm % translate )) deallocate ( symm % translate ) if ( associated ( symm % symmangle )) deallocate ( symm % symmangle ) if ( associated ( symm % symmpoint )) deallocate ( symm % symmpoint ) if ( associated ( symm % map_symm_k )) deallocate ( symm % map_symm_k ) if ( associated ( symm % map_symm_g )) deallocate ( symm % map_symm_g ) if ( associated ( symm % map_symm_b )) deallocate ( symm % map_symm_b ) if ( associated ( symm % map_symm_p )) deallocate ( symm % map_symm_p ) if ( associated ( symm % translback )) deallocate ( symm % translback ) if ( associated ( symm % valid_symm )) deallocate ( symm % valid_symm ) end subroutine free_symm !------------------------------------------------------------------------------ ! Read the point-symmetries from input. ! Rotation-axis : CN x y z x1 y1 z1 !  2\\pi/N is the rotation angle !  x y z specify a point belonging to the axis in cartesian coordinates !  x1 y1 z1 specify the axis direction in cartesian coordinates ! Rotorefelction-axis : SN x y z x1 y1 z1 !  2\\pi/N is the rotation angle !  x y z specify a point belonging to the axis in cartesian coordinates !  x1 y1 z1 specify the axis direction in cartesian coordinates ! Mirror plane : D x y z x1 y1 z1 !  x y z specify a point belonging to the plane in cartesian coordinate !  x1 y1 z1 specify the direction normal to the plane in cartesian coordinates ! Inversion : I x y z !  x y z specify position of inversion point in cartesian coordinates !------------------------------------------------------------------ subroutine read_symm ( SymmOp ) integer isymm , axis_order , ios1 , ios2 , i , nsymm real * 8 xpoint ( 3 ), xaxis ( 3 ), xnorm character * 50 string character * 1 label logical dum character * 1 , pointer :: symmlabel (:) real * 8 , pointer :: symmangle (:) real * 8 , pointer :: symmpoint (:,:) real * 8 , pointer :: symmaxis (:,:) type ( symm_operations ), intent ( out ) :: SymmOp !Count the symmetry operation specified in input nsymm = count_symmetry () SymmOp % initialized = . false . SymmOp % nsymm = nsymm SymmOp % ntotsymm = nsymm SymmOp % addTimeRev = . true . if ( nsymm /= 0 ) then !allocate angle, points and axis for all symmetry operations allocate ( symmangle ( nsymm ), symmpoint ( 3 , nsymm ), symmaxis ( 3 , nsymm ), symmlabel ( nsymm )) dum = move_to_record ( INPUT_FIELDS ( SYMM_F ), inpunit ) do isymm = 1 , nsymm !read entire line read ( inpunit , '(A)' ) string string = adjustl ( string ) !read very first character read ( string , '(A1)' ) label if ( label == 'C' . or . label == 'c' . or . label == 'S' . or . label == 's' ) then !Found a rotation or rotoreflection read ( string , '(A1,i1)' , iostat = ios1 ) label , axis_order read ( string ( 4 : 50 ), * , iostat = ios2 )( xpoint ( i ), i = 1 , 3 ),( xaxis ( i ), i = 1 , 3 ) if ( ios1 . ne . 0. or . ios2 . ne . 0 ) then write ( * , * ) 'Problem reading axis symmetry. Stop. Line:' , isymm stop endif symmlabel ( isymm ) = label ( 1 : 1 ) symmpoint (:, isymm ) = xpoint (:) !angle is 2pi/order symmangle ( isymm ) = 4.d0 * acos ( 0.d0 ) / axis_order !Save axis after normalizing it to 1.d0. xnorm = sqrt ( sum ( xaxis (:) ** 2 )) symmaxis (:, isymm ) = xaxis (:) / xnorm elseif ( label == 'D' . or . label == 'd' ) then !Found mirror plane read ( string ( 3 : 50 ), * , iostat = ios2 )( xpoint ( i ), i = 1 , 3 ),( xaxis ( i ), i = 1 , 3 ) if ( ios2 . ne . 0 ) then write ( * , * ) 'Problem reading plane symmetry. Stop. Line:' , isymm stop endif symmlabel ( isymm ) = label ( 1 : 1 ) symmpoint (:, isymm ) = xpoint (:) !Save axis after normalizing it to 1.d0. xnorm = sqrt ( sum ( xaxis (:) ** 2 )) symmaxis (:, isymm ) = xaxis (:) / xnorm !Setting angle to 0.d0 symmangle ( isymm ) = 0.d0 elseif ( label == 'I' . or . label == 'i' ) then read ( string ( 3 : 50 ), * , iostat = ios2 )( xpoint ( i ), i = 1 , 3 ) if ( ios2 . ne . 0 ) then write ( * , * ) 'Problem reading parity symmetry. Stop. Line:' , isymm stop endif symmlabel ( isymm ) = label ( 1 : 1 ) symmpoint (:, isymm ) = xpoint (:) !Setting angle and axis to 0.d0 symmangle ( isymm ) = 0.d0 symmaxis (:, isymm ) = 0.d0 SymmOp % addTimeRev = . false . else write ( * , * ) 'Unknown label for symmetry. Stop' stop endif enddo !Fill SymmOp SymmOp % initialized = . true . SymmOp % nsymm = nsymm SymmOp % ntotsymm = nsymm !Save pointers SymmOp % symmlabel => symmlabel SymmOp % symmaxis => symmaxis SymmOp % symmpoint => symmpoint SymmOp % symmangle => symmangle endif end subroutine read_symm !-------------------------------------------------------- !Count how many point-symmetries are specified in input !-------------------------------------------------------- integer function count_symmetry () integer msymm character * 1 label character * 30 string logical ldum msymm = 0 if ( Found_Field ( SYMM_F )) then ldum = move_to_record ( INPUT_FIELDS ( SYMM_F ), inpunit ) do read ( inpunit , '(A)' ) string string = adjustl ( string ) read ( string , '(A1)' ) label if ( label == 'C' . or . label == 'c' & & . or . label == 'S' . or . label == 's' & & . or . label == 'D' . or . label == 'd' & & . or . label == 'I' . or . label == 'i' ) then msymm = msymm + 1 else exit endif enddo else write ( * , * ) 'No symmetries have been specified' endif count_symmetry = msymm end function count_symmetry !---------------------------------------------------------------------- ! Apply point-symmetry operation. label specifis the kind of ! symmetry (C, S, D or I). Point and axis specify the \"position\" of ! the symmetry operation (see comments to read_symmetry). set is a set ! of 3D vectors in cartesian coordinates upon which the symmetry acts. ! newset returns the transformed set. !----------------------------------------------------------------------- subroutine apply_point_symm ( label , point , axis , theta , set , new_set , nset , reciprocal ) ! label : C, S, D or I ! point, axis and theta specify the symmetry operation ! set is the set of point to be transformed (the lattice in real or k-space) ! nset is the number of points in set ! reciprocal is a flag specifying whether the set is made of k-vectors integer , intent ( in ) :: nset real * 8 , intent ( in ) :: point ( 3 ), axis ( 3 ), theta , set ( 3 * nset ) logical , intent ( in ) :: reciprocal real * 8 , intent ( out ) :: new_set ( 3 , nset ) integer irefl , iset , alp , bet , gam , del , i , j real * 8 trans_set ( 3 , nset ), d , a1 , a2 , rot1 ( 3 , 3 ), rot2 ( 3 , 3 ), rot3 ( 3 , 3 ), globrot ( 3 , 3 ), & & cost , sint , dpoint ( 3 ), dset ( 3 , nset ), dset2 ( nset , 3 ) character * 1 label !If transformation is in k-space symmetry operation necessarily goes through 0.d0 !dpoint is the \"origin\" if ( reciprocal ) then dpoint (:) = 0.d0 dset = reshape ( set , shape = ( / 3 , nset / ), order = ( / 2 , 1 / )) else dpoint (:) = point (:) dset = reshape ( set , shape = ( / 3 , nset / ), order = ( / 1 , 2 / )) endif if ( label == 'i' . or . label == 'I' ) then !Deal with inversion around dpoint do iset = 1 , nset new_set (:, iset ) = 2 * dpoint (:) - dset (:, iset ) enddo else !Deal with rotations, reflections or rotoreflections if ( label == 'c' . or . label == 'C' ) then irefl = 1 else irefl =- 1 endif !Note that cost and sint are 1 and 0 for mirror planes cost = cos ( theta ); sint = sin ( theta ) !translate the set do iset = 1 , nset trans_set (:, iset ) = dset (:, iset ) - dpoint (:) enddo !Define matrix that line up z-axis with rotation axis d = sqrt ( axis ( 1 ) ** 2 + axis ( 2 ) ** 2 ) if ( d > 1.d-6 ) then a1 = axis ( 1 ) / d ; a2 = axis ( 2 ) / d else a1 = 1.d0 ; a2 = 0.d0 endif !First rotate reference frame around z : R1 rot1 ( 1 , 1 ) = a1 ; rot1 ( 1 , 2 ) = a2 ; rot1 ( 1 , 3 ) = 0.d0 rot1 ( 2 , 1 ) =- a2 ; rot1 ( 2 , 2 ) = a1 ; rot1 ( 2 , 3 ) = 0.d0 rot1 ( 3 , 1 ) = 0.d0 ; rot1 ( 3 , 2 ) = 0.d0 ; rot1 ( 3 , 3 ) = 1.d0 !then Rotate reference frame around y : R2 rot2 ( 1 , 1 ) = axis ( 3 ) ; rot2 ( 1 , 2 ) = 0.d0 ; rot2 ( 1 , 3 ) = - d rot2 ( 2 , 1 ) = 0.d0 ; rot2 ( 2 , 2 ) = 1.d0 ; rot2 ( 2 , 3 ) = 0.d0 rot2 ( 3 , 1 ) = d ; rot2 ( 3 , 2 ) = 0.d0 ; rot2 ( 3 , 3 ) = axis ( 3 ) !Finally rotate around z and/or reflect perpendicularly to xy (when irefl=-1): R3 rot3 ( 1 , 1 ) = cost ; rot3 ( 1 , 2 ) =- sint ; rot3 ( 1 , 3 ) = 0.d0 rot3 ( 2 , 1 ) = sint ; rot3 ( 2 , 2 ) = cost ; rot3 ( 2 , 3 ) = 0.d0 rot3 ( 3 , 1 ) = 0.d0 ; rot3 ( 3 , 2 ) = 0.d0 ; rot3 ( 3 , 3 ) = 1.d0 * irefl !compute globrot as R1&#94;-1 R2&#94;-1 R3 R2 R1 (undoing frame rotations) globrot (:,:) = 0.d0 do i = 1 , 3 ; do j = 1 , 3 do alp = 1 , 3 ; do bet = 1 , 3 ; do gam = 1 , 3 ; do del = 1 , 3 globrot ( i , j ) = globrot ( i , j ) + rot1 ( alp , i ) * rot2 ( bet , alp ) * rot3 ( bet , gam ) * rot2 ( gam , del ) * rot1 ( del , j ) enddo ; enddo ; enddo ; enddo enddo ; enddo !Apply symmetry operation new_set (:,:) = 0.d0 do iset = 1 , nset do i = 1 , 3 do j = 1 , 3 new_set ( i , iset ) = new_set ( i , iset ) + globrot ( i , j ) * trans_set ( j , iset ) enddo enddo enddo !Translate back to the origin do iset = 1 , nset new_set (:, iset ) = new_set (:, iset ) + dpoint (:) enddo endif !If reciprocal transpose the matrix to follow the convention if ( reciprocal ) then !Fancy way to get transpose dset2 = reshape ( new_set , shape = ( / nset , 3 / ), order = ( / 2 , 1 / )) new_set = reshape ( dset2 , shape = ( / 3 , nset / )) endif end subroutine apply_point_symm !--------------------------------------------------------------------- ! Map the action of the point-operation into the vector map_symm: !map_symm(ifrom,isymm) returns the orbital on which orbital ifrom !is transformed by isymm. Symmetries that are incompatible with the !supercell are discarded. msymm is the number of compatible point !symmetries. ! Construct translate(ifrom,itrans). Analogous to map_symm but returns !the orbital to which ifrom is mapped by translation itrans. ! Construct translback(ifrom). It returns the translation that applied !to ifrom reduces the latter to the equivalent orbital inside the !primitive cell. !--------------------------------------------------------------------- subroutine map_symm_lattice ( SymmOp , lattice , hamilt , SOP ) use DQMC_LATT use DQMC_HAMILT type ( symm_operations ) :: SymmOp type ( lattice_t ), intent ( in ) :: lattice type ( hamiltonian_t ), intent ( in ) :: hamilt integer , intent ( in ) :: SOP integer :: i , istart , ipat , jpat , iat , jat , ii , it , itl , is integer :: nsites , ntotsymm , ndim , msymm , nsymm , ntransl , natom integer :: valid_symm ( SymmOp % ntotsymm ) integer :: tmp_symm ( 0 : lattice % nsites - 1 , SymmOp % ntotsymm ) real * 8 :: diff ( rdim ), projsc ( rdim ), invscc ( rdim , rdim ) real * 8 :: newpos ( rdim , 0 : lattice % nsites - 1 ) real * 8 , pointer :: symmangle (:) real * 8 , pointer :: symmpoint (:,:) real * 8 , pointer :: symmaxis (:,:) logical :: mapped ( 0 : lattice % nsites - 1 , SymmOp % ntotsymm ) logical :: mappedt ( 0 : lattice % nsites - 1 , 0 : lattice % ncell - 1 ) logical :: equal character * 1 , pointer :: symmlabel (:) !Assign pointers symmlabel => SymmOp % symmlabel symmangle => SymmOp % symmangle symmpoint => SymmOp % symmpoint symmaxis => SymmOp % symmaxis !Initializa local variables ntransl = lattice % ncell nsites = lattice % nsites natom = lattice % natom ntotsymm = SymmOp % ntotsymm ndim = lattice % ndim call get_inverse ( lattice % scc , invscc ) !Apply symmetry operations to sites... mapped (:,:) = . false . do i = 1 , ntotsymm call apply_point_symm ( symmlabel ( i ), symmpoint (:, i ), symmaxis (:, i ), symmangle ( i ), lattice % cartpos , newpos , nsites ,. false .) !Find where \"iat\" was mapped by the symmetry operation do iat = 0 , nsites - 1 ipat = mod ( iat , natom ) !Compare the new position (newpos) with the original one of all sites do jat = 0 , nsites - 1 jpat = mod ( iat , natom ) !if jat was already \"mapped onto\" or label is different, skip jat if ( mapped ( jat , i ) . or . lattice % olabel ( jpat ) /= lattice % olabel ( ipat )) cycle !Compute distance in units of the supercell vectors diff (:) = newpos (:, iat ) - lattice % cartpos (:, jat ) do ii = 1 , 3 projsc ( ii ) = sum ( diff (:) * invscc ( ii ,:)) enddo !project inside the supercell - only along the \"extended\" dimensions projsc ( 1 : ndim ) = projsc ( 1 : ndim ) - nint ( projsc ( 1 : ndim )) if ( sqrt ( sum ( projsc ( 1 : rdim ) ** 2 )) < toll ) then tmp_symm ( iat , i ) = jat mapped ( jat , i ) = . true . exit endif enddo enddo enddo !Check whether symmetry is compatible with supercell msymm = 0 do i = 1 , ntotsymm do iat = 0 , nsites - 1 if (. not . mapped ( iat , i )) exit enddo !if all components of mapped(:,i) are true we have a valid symmetry if ( iat == nsites ) then msymm = msymm + 1 valid_symm ( msymm ) = i endif enddo !Check whether symmetry is compatible with hamiltonian nsymm = msymm do i = msymm , 1 , - 1 ii = valid_symm ( i ) equal = . true . !Transform the 3 pieces of the hamiltonian do iat = 0 , nsites - 1 ipat = tmp_symm ( iat , ii ) do jat = 0 , nsites - 1 jpat = tmp_symm ( jat , ii ) equal = equal . and .( abs ( hamilt % hopup ( ipat , jpat ) - hamilt % hopup ( iat , jat )) < 1.d-3 ) equal = equal . and .( abs ( hamilt % hopdn ( ipat , jpat ) - hamilt % hopdn ( iat , jat )) < 1.d-3 ) equal = equal . and .( abs ( hamilt % Uv ( ipat , jpat ) - hamilt % Uv ( iat , jat )) < 1.d-3 ) equal = equal . and .( abs ( hamilt % Jv ( ipat , jpat ) - hamilt % Jv ( iat , jat )) < 1.d-3 ) enddo enddo !Exclude symmetry if incompatible with H if (. not . equal ) then valid_symm ( i ) = valid_symm ( nsymm ) nsymm = nsymm - 1 endif enddo msymm = nsymm !Store which symmetries are valid and their action in the map_symm table if ( msymm > 0 ) & & allocate ( SymmOp % map_symm ( 0 : nsites - 1 , msymm ), SymmOp % valid_symm ( msymm )) do i = 1 , msymm SymmOp % valid_symm ( i ) = valid_symm ( i ) SymmOp % map_symm (:, i ) = tmp_symm (:, valid_symm ( i )) enddo !Save the number of valid symmetry operations SymmOp % nsymm = msymm !Deal with translation SymmOp % ntransl = ntransl if ( ntransl > 0 ) allocate ( SymmOp % translate ( 0 : nsites - 1 , 0 : ntransl - 1 ), SymmOp % translback ( 0 : nsites - 1 )) mappedt (:,:) = . false . do it = 0 , ntransl - 1 itl = it * natom !Apply translation to each site do iat = 0 , nsites - 1 newpos (:, iat ) = lattice % cartpos (:, iat ) + lattice % translation (:, it ) enddo !Find the site \"jat\" where \"iat\" is mapped by translation \"it\" do iat = 0 , nsites - 1 istart = mod ( iat , natom ) do jat = istart , nsites - 1 , natom if ( mappedt ( jat , it )) cycle diff (:) = newpos (:, iat ) - lattice % cartpos (:, jat ) do ii = 1 , 3 projsc ( ii ) = sum ( diff (:) * invscc ( ii ,:)) enddo projsc ( 1 : ndim ) = projsc ( 1 : ndim ) - nint ( projsc ( 1 : ndim )) if ( sum ( projsc ( 1 : rdim ) ** 2 ) < toll ) then SymmOp % translate ( iat , it ) = jat mappedt ( jat , it ) = . true . exit endif enddo enddo enddo !Check correctness and construct \"translback\" do is = 0 , nsites - 1 do it = 0 , ntransl - 1 !Check that mapping was done properly if (. not . mappedt ( is , it )) then write ( * , '(A,i3,A)' ) 'Translation ' , it , ' could not be mapped correctly' stop endif !Store the translation that maps \"is\" inside the primitive cell iat = SymmOp % translate ( is , it ) if ( iat < natom ) then SymmOp % translback ( is ) = it exit endif enddo enddo !Write out symmetry mappings write ( SOP , * ) 'Number of symmetry operations in input: ' , ntotsymm write ( SOP , * ) 'Number of valid symmetry operations   : ' , msymm do i = 1 , msymm write ( SOP , * ) 'Mapping of Symmetry :' , valid_symm ( i ), Symmlabel ( valid_symm ( i )) do iat = 0 , nsites - 1 write ( SOP , * ) iat , '->' , SymmOp % map_symm ( iat , i ) enddo enddo do it = 0 , ntransl - 1 write ( SOP , * ) 'Mapping of Translation' , it do iat = 0 , nsites - 1 write ( SOP , * ) iat , '->' , SymmOp % translate ( iat , it ) enddo enddo write ( SOP , * ) 'Label of Translation mapping site in primitive cell' do iat = 0 , nsites - 1 write ( SOP , * ) iat , '->' , SymmOp % translback ( iat ) enddo SymmOp % lattice_mapped = . true . end subroutine map_symm_lattice !-------------------------------------------------------------------------------- !k-space symmetry !-------------------------------------------------------------------------------- subroutine map_symm_recip_lattice ( SymmOp , recip_lattice , applytwist ) use DQMC_RECLATT type ( symm_operations ) :: SymmOp type ( recip_lattice_t ), intent ( in ) :: recip_lattice logical , intent ( in ) :: applytwist integer :: i , j , ii , nsymm , ndim , ik , jk real * 8 :: diff ( rdim ), projsc ( rdim ), invkc ( rdim , rdim ), & newklist ( recip_lattice % nkpts , rdim ), zerovec ( rdim ) logical :: mapped ( recip_lattice % nkpts ), includesymm character * 1 , pointer :: symmlabel (:) real * 8 , pointer :: symmangle (:) real * 8 , pointer :: symmpoint (:,:) real * 8 , pointer :: symmaxis (:,:) integer :: msymm , nsites , valid_symm ( SymmOp % nsymm ) integer , pointer :: tmp_symm (:,:) integer , pointer :: tmp_symm_k (:,:) integer , pointer :: tmp_valid (:) if (. not . SymmOp % lattice_mapped ) stop 'Need to map lattice symmetries before recip lattice ones' !Assign pointers symmlabel => SymmOp % symmlabel symmangle => SymmOp % symmangle symmpoint => SymmOp % symmpoint symmaxis => SymmOp % symmaxis !Only the \"valid\" symmetries will be considered nsymm = SymmOp % nsymm !Check whether we need to additionally apply time-reversal symmetry !If there was no inversion add it for k-space if (. not . SymmOp % addTimeRev ) then do i = 1 , nsymm j = SymmOp % valid_symm ( i ) if ( SymmOp % symmlabel ( j ) == 'i' . or . SymmOp % symmlabel ( j ) == 'I' ) exit enddo if ( i > nsymm ) SymmOp % addTimeRev = . true . endif if ( SymmOp % addTimeRev ) nsymm = nsymm + 1 ndim = recip_lattice % ndim call get_inverse ( recip_lattice % kc , invkc ) if ( nsymm > 0 ) then if ( applytwist ) then allocate ( SymmOp % map_symm_k ( recip_lattice % nkpts , nsymm )) else allocate ( SymmOp % map_symm_g ( recip_lattice % nkpts , nsymm )) endif endif !Loop over all valid symmetries msymm = 0 do j = 1 , SymmOp % nsymm i = SymmOp % valid_symm ( j ) mapped (:) = . false . includesymm = . true . !Apply point symmetry to all k-points call apply_point_symm ( symmlabel ( i ), symmpoint (:, i ), symmaxis (:, i ), symmangle ( i ),& recip_lattice % klist , newklist , recip_lattice % nkpts ,. true .) do ik = 1 , recip_lattice % nkpts !Find which k-point, \"jk\", \"ik\" is mapped onto by symmetry \"j\" do jk = 1 , recip_lattice % nkpts !For each k-point compute distance in unit of k-space unit cell if ( mapped ( jk )) cycle diff (:) = newklist ( ik ,:) - recip_lattice % klist ( jk ,:) do ii = 1 , rdim projsc ( ii ) = sum ( diff (:) * invkc (:, ii )) enddo !project inside the unit cell - only along the \"extended\" dimensions projsc ( 1 : ndim ) = projsc ( 1 : ndim ) - nint ( projsc ( 1 : ndim )) if ( sum ( projsc ( 1 : rdim ) ** 2 ) < toll ) then if ( applytwist ) then SymmOp % map_symm_k ( ik , j ) = jk else SymmOp % map_symm_g ( ik , j ) = jk endif mapped ( jk ) = . true . exit endif enddo if ( jk > recip_lattice % nkpts ) then if ( applytwist ) then includesymm = . false . else stop 'Problem with symmetry in k-space' endif endif enddo if ( includesymm ) then msymm = msymm + 1 valid_symm ( msymm ) = j endif enddo !Modify list of valid symmetry if twist spoils some of them if ( msymm /= SymmOp % nsymm . and . applytwist ) then nsites = size ( SymmOp % map_symm , 1 ) allocate ( tmp_symm ( 0 : nsites - 1 , SymmOp % nsymm ), tmp_symm_k ( recip_lattice % nkpts , nsymm ), & tmp_valid ( SymmOp % nsymm )) !Save symmetry mapping table tmp_symm = SymmOp % map_symm tmp_symm_k = SymmOp % map_symm_k tmp_valid = SymmOp % valid_symm !deallocate the old table deallocate ( SymmOp % map_symm , SymmOp % map_symm_k , SymmOp % valid_symm ) if ( msymm > 0 ) then !allocate new tables allocate ( SymmOp % map_symm ( 0 : nsites - 1 , msymm )) allocate ( SymmOp % valid_symm ( msymm )) nsymm = msymm if ( SymmOp % addTimeRev ) nsymm = nsymm + 1 allocate ( SymmOp % map_symm_k ( recip_lattice % nkpts , nsymm )) !copy valid symmetries do i = 1 , msymm SymmOp % map_symm (:, i ) = tmp_symm (:, valid_symm ( i )) SymmOp % valid_symm ( i ) = tmp_valid ( valid_symm ( i )) SymmOp % map_symm_k (:, i ) = tmp_symm_k (:, valid_symm ( i )) enddo !Save the number of valid symmetry operations SymmOp % nsymm = msymm endif deallocate ( tmp_valid , tmp_symm , tmp_symm_k ) endif !Add the additional symmetry time reversal symmetry when \"I\" is not a symmetry !operation specified in input if ( SymmOp % addTimeRev ) then mapped (:) = . false . zerovec ( 1 : 3 ) = ( / 0.d0 , 0.d0 , 0.d0 / ) call apply_point_symm ( 'I' , zerovec , zerovec , 0.d0 ,& recip_lattice % klist , newklist , recip_lattice % nkpts ,. true .) do ik = 1 , recip_lattice % nkpts !Find which k-point, \"jk\", \"ik\" is mapped onto by symmetry \"j\" do jk = 1 , recip_lattice % nkpts !For each k-point compute distance in unit of k-space unit cell if ( mapped ( jk )) cycle diff (:) = newklist ( ik ,:) - recip_lattice % klist ( jk ,:) do ii = 1 , rdim projsc ( ii ) = sum ( diff (:) * invkc (:, ii )) enddo !project inside the unit cell - only along the \"extended\" dimensions projsc ( 1 : ndim ) = projsc ( 1 : ndim ) - nint ( projsc ( 1 : ndim )) if ( sum ( projsc ( 1 : rdim ) ** 2 ) < toll ) then if ( applytwist ) then SymmOp % map_symm_k ( ik , nsymm ) = jk else SymmOp % map_symm_g ( ik , nsymm ) = jk endif mapped ( jk ) = . true . exit endif enddo if ( jk > recip_lattice % nkpts ) stop 'Problem with symmetry in k-space' enddo endif SymmOp % recip_lattice_mapped = . true . end subroutine map_symm_recip_lattice !--------------------------------------------------------------------------------- ! Given the list of bonds read from input, this routines does the following: ! 1) complete the list with the bonds which are equivalent, by symmetry, !    to those specified in input. ! 2) Create a mapping (map_symm_b) that, given, bond \"b\" and a symmetry operation \"s\", !    returns a the bond on which \"b\" is mapped by \"s\". !--------------------------------------------------------------------------------- subroutine map_symm_bonds ( Bonds , SymmOp , Lattice ) use DQMC_BONDS type ( symm_operations ), intent ( inout ) :: SymmOp type ( bonds_t ), intent ( inout ) :: Bonds type ( lattice_t ), intent ( in ) :: Lattice integer :: nbclass , ibond , iat , jat , ntotpair , natom , nsites , bcl , newlabel , jbond , it , & & isymm , ndim integer , allocatable :: class (:), tag (:), pair_origin (:), pair_target (:), pair_label (:) integer , pointer :: bond_origin (:) integer , pointer :: bond_target (:) integer , pointer :: map_symm (:,:) real * 8 :: invscc ( rdim , rdim ), proj ( rdim ) real * 8 , allocatable :: xxpair (:,:) logical , allocatable :: bond_on (:,:) if (. not . lattice % analyzed ) stop 'Need to analyze lattice before mapping bonds' if ( Bonds % ntotbond == 0 ) return natom = Lattice % natom ; nsites = Lattice % nsites ; ndim = Lattice % ndim call get_inverse ( lattice % scc , invscc ) nbclass = 0 newlabel = maxval ( Bonds % bond_label ) allocate ( class ( Bonds % ntotbond ), tag ( Bonds % ntotbond ), bond_on ( 0 : natom - 1 , 0 : nsites - 1 ), bond_target ( Bonds % ntotbond )) bond_origin => Bonds % bond_origin bond_on (:,:) = . false . !Assign to each bond a class based on lattice classes for distances do ibond = 1 , Bonds % ntotbond iat = bond_origin ( ibond ) jat = hoptowho ( iat , Bonds % xxbond ( 1 : rdim , ibond ), Bonds % bond_target ( ibond ), Lattice ) bond_target ( ibond ) = jat bond_on ( iat , jat ) = . true . class ( ibond ) = Lattice % myclass ( iat , jat ) !See if bond belongs to an already found class do jbond = 1 , ibond - 1 if ( class ( ibond ) == class ( jbond )) exit enddo if ( jbond == ibond ) then !if not, create a new class nbclass = nbclass + 1 tag ( nbclass ) = class ( ibond ) endif enddo !Include all bonds which were left out but that are equivalent by symmetry... ntotpair = 2 * natom * nsites allocate ( pair_label ( ntotpair ), pair_origin ( ntotpair ), pair_target ( ntotpair ), xxpair ( 3 , ntotpair )) !Save bond attribute in temporary \"pair\" variables ntotpair = Bonds % ntotbond pair_origin ( 1 : ntotpair ) = bond_origin ( 1 : ntotpair ) pair_target ( 1 : ntotpair ) = bond_target ( 1 : ntotpair ) pair_label ( 1 : ntotpair ) = Bonds % bond_label ( 1 : ntotpair ) xxpair (:, 1 : ntotpair ) = Bonds % xxbond (:, 1 : ntotpair ) !... But only if there was no PAIR field specified in input if (. not . Found_Field ( PAIRS_F )) then !Loop over all pairs having the first atom inside the unit cell do iat = 0 , natom - 1 do jat = 0 , nsites - 1 !If bond is already \"on\" on this pair cycle if ( bond_on ( iat , jat )) cycle !Otherwise loop over classes and found other bonds which belongs to same class do bcl = 1 , nbclass if ( tag ( bcl ) == Lattice % myclass ( iat , jat )) then !We found a bond that needs to be included! !Assign a label to the bond newlabel = newlabel + 1 !Increase the number of total bonds ntotpair = ntotpair + 1 !Save its attribute pair_origin ( ntotpair ) = iat pair_target ( ntotpair ) = jat pair_label ( ntotpair ) = newlabel xxpair (:, ntotpair ) = lattice % cartpos (:, jat ) - lattice % cartpos (:, iat ) !make xxpair as small as possible do it = 1 , rdim proj ( it ) = sum ( xxpair (:, ntotpair ) * invscc ( it ,:)) enddo proj ( 1 : ndim ) = proj ( 1 : ndim ) - nint ( proj ( 1 : ndim )) do it = 1 , rdim xxpair ( it , ntotpair ) = sum ( lattice % scc ( it ,:) * proj (:)) enddo !Switch on the bond flag bond_on ( iat , jat ) = . true . !Construct the opposite bond if ( iat /= jat ) then ntotpair = ntotpair + 1 pair_label ( ntotpair ) =- newlabel !Find the translation that maps iat inside the unit cell it = SymmOp % translback ( jat ) !Translate jat and iat. jat returns the origin of the bond. pair_origin ( ntotpair ) = SymmOp % translate ( jat , it ) pair_target ( ntotpair ) = SymmOp % translate ( iat , it ) xxpair (:, ntotpair ) =- xxpair (:, ntotpair - 1 ) !Switch on the bond flag bond_on ( SymmOp % translate ( jat , it ), SymmOp % translate ( iat , it )) = . true . endif !We switch this bons on. Stop looking over classes. exit endif enddo enddo enddo endif deallocate ( class , tag , bond_target , bond_on ) !Reload Bonds (new set completed with newly found bonds) if ( Bonds % ntotbond /= ntotpair ) then !First deallocate old stuff deallocate ( Bonds % bond_origin , Bonds % xxbond , Bonds % bond_label , Bonds % bond_target ) !Allocate and store temporary \"pair\" variable in \"Bonds\" allocate ( Bonds % bond_origin ( ntotpair ), Bonds % bond_target ( ntotpair ), & Bonds % xxbond ( 3 , ntotpair ), Bonds % bond_label ( ntotpair )) Bonds % ntotbond = ntotpair Bonds % bond_origin ( 1 : ntotpair ) = pair_origin ( 1 : ntotpair ) Bonds % bond_target ( 1 : ntotpair ) = mod ( pair_target ( 1 : ntotpair ), natom ) Bonds % xxbond (:, 1 : ntotpair ) = xxpair (:, 1 : ntotpair ) Bonds % bond_label ( 1 : ntotpair ) = pair_label ( 1 : ntotpair ) endif !Store how a bond transforms under point symmetry allocate ( map_symm ( ntotpair , SymmOp % nsymm )) do isymm = 1 , SymmOp % nsymm do ibond = 1 , ntotpair !Find the two sites where the bond origin and target are mapped into iat = SymmOp % map_symm ( pair_origin ( ibond ), isymm ) jat = SymmOp % map_symm ( pair_target ( ibond ), isymm ) !Translate them back do that origin is inside unit cell it = SymmOp % translback ( iat ) iat = SymmOp % translate ( iat , it ) jat = SymmOp % translate ( jat , it ) !Find which bond is defined by (iat,jat) do jbond = 1 , ntotpair if ( pair_origin ( jbond ) == iat . and . pair_target ( jbond ) == jat ) exit enddo if ( jbond > ntotpair ) stop 'Symmetry analysis : Cannot find equivalent bond' !Save the action of the symmetry operation map_symm ( ibond , isymm ) = jbond enddo enddo deallocate ( pair_origin , pair_target , pair_label , xxpair ) SymmOp % map_symm_b => map_symm SymmOp % bonds_mapped = . true . !Write Info ! write(*,*) ! write(*,*)'Bonds (Set completed using symmetry)' ! do ibond=1,Bonds%ntotbond !  write(*,'(3i4,3f12.7)')ibond,Bonds%bond_label(ibond),Bonds%bond_origin(ibond),Bonds%xxbond(1:rdim,ibond) ! enddo !write(*,*) !write(*,*)'BOND MAPPING' !do isymm=1,SymmOp%nsymm ! write(*,*)'Symmetry',isymm ! do ibond=1,Bonds%ntotbond !  write(*,*)ibond,'-->',map_symm(ibond,isymm) ! enddo !enddo ! write(*,*)'=====================================================================' Bonds % analyzed = . true . end subroutine !-------------------------------------------------------------------------------- ! Map symmetry for pairs. !-------------------------------------------------------------------------------- subroutine map_symm_pairs ( Pairs , SymmOp ) use DQMC_BONDS type ( symm_operations ), intent ( inout ) :: SymmOp type ( pairing ), intent ( inout ) :: Pairs integer :: isymm , ib , jb , newjb allocate ( SymmOp % map_symm_p ( Pairs % nbond , SymmOp % nsymm )) do isymm = 1 , SymmOp % nsymm !loops over bonds defining the pairs do ib = 1 , Pairs % nbond !find the bond jb = Pairs % bond_map ( ib ) !map the bond newjb = SymmOp % map_symm_b ( jb , isymm ) !map the bond back into the pair list jb = Pairs % pair_map ( newjb ) if ( jb == 0 ) stop 'Symmetry analysis : Cannot find equivalent pair' !save it SymmOp % map_symm_p ( ib , isymm ) = jb enddo enddo end subroutine !------------------------------------------------------------------------------ !  Construct myclass(i,j). Given to sites i and j (not necessarily different) ! returns the class to which they belong. A class contains pairs of orbitals ! that, because of symmetry, are going to have identical pair-correlation ! functions. !  Returns nclass, the number of classes, and class_size(iclass), the ! number of pairs inside class iclass. !  Returns class_label. This is a 4-components array. The first three are the ! cartesian separation of the two orbitals in the pair. The last component is ! the number of the atom inside the primitive cell that belongs to the pair. !------------------------------------------------------------------------------ subroutine construct_lattice_classes ( SymmOp , lattice ) use DQMC_LATT integer :: i , it , ip , is , j , isymm , iclass , istart , csize , csizenew , itransl ,& & jclass , idj , id , mclass , ip_transl , is_transl , ip2 , is2 , jstart ,& & nclass , nsites , natom , nsymm , ntransl integer , allocatable :: patom (:,:), satom (:,:), csizev (:) integer , pointer :: myclass (:,:) type ( symm_operations ) :: SymmOp type ( lattice_t ) :: lattice if (. not . SymmOp % lattice_mapped ) stop 'Need to map symmetries over lattice before classes' !initialize local variables natom = lattice % natom nsites = lattice % nsites nsymm = SymmOp % nsymm ntransl = SymmOp % ntransl !allocate internal arrays nclass = ( natom * ( natom + 1 )) / 2 + natom * ( nsites - natom ) allocate ( patom ( 2 , nclass ), satom ( 2 , nclass ), csizev ( nclass )) !At the beginning each distance is a separate class and only !pairs with at least one atom in the primitive cell are considered. !The pair (patom(ix,iclass) , satom(ix,iclas)) is the ix-th !element of class \"iclass\" allocate ( myclass ( 0 : nsites - 1 , 0 : nsites - 1 )) nclass = 0 do ip = 0 , natom - 1 !first loop over sites inside primitive cell do is = ip , natom - 1 nclass = nclass + 1 if ( is /= ip ) then csizev ( nclass ) = 2 patom ( 1 , nclass ) = ip ; satom ( 1 , nclass ) = is patom ( 2 , nclass ) = is ; satom ( 2 , nclass ) = ip myclass ( ip , is ) = nclass ; myclass ( is , ip ) = nclass else csizev ( nclass ) = 1 patom ( 1 , nclass ) = ip ; satom ( 1 , nclass ) = is myclass ( ip , is ) = nclass endif enddo do is = natom , nsites - 1 nclass = nclass + 1 patom ( 1 , nclass ) = ip ; satom ( 1 , nclass ) = is csizev ( nclass ) = 1 myclass ( ip , is ) = nclass enddo enddo !Loop over symmetry operations. The \"+1\" symm op is pair permutation. do isymm = 1 , nsymm + 1 !do isymm=1,nsymm !Loop over classes (for the first symm op, classes are made !of all individual atom pairs in which the first atom lies !in the primitive cell and the second anywhere inside the supercell) do iclass = 1 , nclass istart = 1 do csize = csizev ( iclass ) csizenew = csize do id = istart , csize !Map the atoms in the class under the symm operation if ( isymm == nsymm + 1 ) then ip = satom ( id , iclass ) is = patom ( id , iclass ) else ip = SymmOp % map_symm ( patom ( id , iclass ), isymm ) is = SymmOp % map_symm ( satom ( id , iclass ), isymm ) endif !Find the transformed pair translated such that the firts site is inside the !primitive cell itransl = SymmOp % translback ( ip ) ip2 = SymmOp % translate ( ip , itransl ) is2 = SymmOp % translate ( is , itransl ) !Find the class to which the pair belongs to jclass = myclass ( ip2 , is2 ) !if classes are different they need to be merged if ( jclass /= iclass ) then !all pairs of class jclass are transfered in class \"iclass\" jstart = csizenew csizenew = csizenew + csizev ( jclass ) call resize_class () do idj = 1 , csizev ( jclass ) ip = patom ( idj , jclass ); is = satom ( idj , jclass ) myclass ( ip , is ) = iclass patom ( jstart + idj , iclass ) = ip satom ( jstart + idj , iclass ) = is enddo !Size of jclass is nullified csizev ( jclass ) = 0 endif enddo !if class size did not change we have found all the classes equivalent !to \"iclass\" if ( csizenew == csize ) exit !Update loop bounds to find new equivalence due to newly added elements istart = csizev ( iclass ) + 1 csizev ( iclass ) = csizenew enddo enddo enddo !Assign a class to all the remaining pair of atoms using translational symmetry !redifine nclass as the number of final classes mclass = 0 do i = 1 , nclass if ( csizev ( i ) > 0 ) mclass = mclass + 1 do j = 1 , csizev ( i ) ip = patom ( j , i ) is = satom ( j , i ) myclass ( ip , is ) = mclass do it = 1 , ntransl - 1 ip_transl = SymmOp % translate ( ip , it ) is_transl = SymmOp % translate ( is , it ) myclass ( ip_transl , is_transl ) = mclass enddo enddo enddo deallocate ( patom , satom , csizev ) nclass = mclass !Define a class label using the distance between the sites allocate ( lattice % class_label ( nclass , 5 )) do iclass = 1 , nclass prim : do i = 0 , natom - 1 super : do j = 0 , nsites - 1 if ( myclass ( i , j ) == iclass ) then lattice % class_label ( iclass , 1 : 3 ) = lattice % cartpos ( 1 : 3 , j ) - lattice % cartpos ( 1 : 3 , i ) ! 03/26/2013: added the second orbital index in lattice%class_label(iclass,5) lattice % class_label ( iclass , 4 ) = dble ( i ) lattice % class_label ( iclass , 5 ) = mod ( j , natom ) exit prim endif enddo super enddo prim enddo !Compute the size of each class allocate ( lattice % class_size ( nclass )) lattice % class_size (:) = 0 do i = 0 , nsites - 1 do j = 0 , nsites - 1 iclass = myclass ( i , j ) lattice % class_size ( iclass ) = lattice % class_size ( iclass ) + 1 enddo enddo !Save parameter in lattice lattice % nclass = nclass lattice % myclass => myclass lattice % analyzed = . true . contains subroutine resize_class () implicit none integer :: curr_csize integer , allocatable :: tmpatom (:,:) curr_csize = size ( patom , 1 ) if ( csizenew > curr_csize ) then !Initially allocate temp array allocate ( tmpatom ( csizenew , nclass )) !Update size of patom without loosing its content tmpatom ( 1 : curr_csize ,:) = patom ( 1 : curr_csize ,:) deallocate ( patom ); allocate ( patom ( csizenew , nclass )) patom = tmpatom !Update size of satom without loosing its content tmpatom ( 1 : curr_csize ,:) = satom ( 1 : curr_csize ,:) deallocate ( satom ); allocate ( satom ( csizenew , nclass )) satom = tmpatom !deallocate temp array deallocate ( tmpatom ) endif end subroutine resize_class end subroutine construct_lattice_classes !---------------------------------------------------------------------------------------- ! Create classes of equivalent k-points. !---------------------------------------------------------------------------------------- subroutine construct_recip_lattice_classes ( SymmOp , recip_lattice , applytwist ) use DQMC_RECLATT integer :: i , ip , j , isymm , iclass , istart , csize , csizenew ,& & jclass , idj , id , mclass , ip2 , jstart ,& & nsymm , nkpts integer , allocatable :: patom (:,:), csizev (:) integer , pointer :: myclass_k (:) integer , pointer :: map_symm (:,:) type ( symm_operations ) :: SymmOp type ( recip_lattice_t ) :: recip_lattice logical , intent ( in ) :: applytwist if (. not . SymmOp % recip_lattice_mapped ) stop 'Need to map symmetries over lattice before classes (reciprocal)' !initialize local variables nsymm = SymmOp % nsymm nkpts = recip_lattice % nkpts if ( SymmOp % addTimeRev ) nsymm = nsymm + 1 !Classes in k-space allocate ( csizev ( nkpts ), myclass_k ( nkpts ), patom ( nkpts , nkpts )) !Each class initially contains one k-point csizev (:) = 1 do ip = 1 , nkpts csizev ( ip ) = 1 myclass_k ( ip ) = ip patom ( 1 , ip ) = ip enddo if ( applytwist ) then map_symm => SymmOp % map_symm_k else map_symm => SymmOp % map_symm_g endif !loop over symmetry operations do isymm = 1 , nsymm !loop over classes do iclass = 1 , nkpts istart = 1 do csize = csizev ( iclass ) csizenew = csize do id = istart , csize ip2 = map_symm ( patom ( id , iclass ), isymm ) jclass = myclass_k ( ip2 ) if ( jclass /= iclass ) then !The two classes need to merged jstart = csizenew !increase class size for iclass csizenew = csizenew + csizev ( jclass ) !transfer jclass elements into iclass do idj = 1 , csizev ( jclass ) ip = patom ( idj , jclass ) myclass_k ( ip ) = iclass patom ( jstart + idj , iclass ) = ip enddo !annihilate jclass csizev ( jclass ) = 0 endif enddo !no new class was merged change iclass if ( csizenew == csize ) exit istart = csizev ( iclass ) + 1 csizev ( iclass ) = csizenew enddo enddo enddo !relabel classes to exclude classes which were annihilated mclass = 0 do i = 1 , nkpts if ( csizev ( i ) > 0 ) mclass = mclass + 1 do j = 1 , csizev ( i ) ip = patom ( j , i ) myclass_k ( ip ) = mclass enddo enddo !Associate to each class a representative and a size allocate ( recip_lattice % class_size_k ( mclass ), recip_lattice % class_repr_k ( mclass )) j = 0 do i = 1 , nkpts if ( csizev ( i ) > 0 ) then j = j + 1 recip_lattice % class_repr_k ( j ) = i recip_lattice % class_size_k ( j ) = csizev ( i ) endif enddo deallocate ( patom , csizev ) !Save in recip_lattice recip_lattice % nclass_k = mclass recip_lattice % myclass_k => myclass_k recip_lattice % analyzed = . true . end subroutine construct_recip_lattice_classes !--------------------------------------------------------------------------------- ! This routines construct my_class_b(ib,jb) where ib and jb are two bonds. ! my_class contains the symmetry class of the pair (ib,jb) !--------------------------------------------------------------------------------- subroutine construct_bond_classes ( Bonds , SymmOp ) use DQMC_BONDS type ( symm_operations ), intent ( in ) :: SymmOp type ( bonds_t ), intent ( inout ) :: Bonds integer :: ib , nclass , ntotbond , ntotbondsq , isymm , iclass , istart , csize , csizenew ,& & id , bx , by , jclass , jstart , idj , mclass , jb , i , j integer , pointer :: myclass (:,:) integer , allocatable :: bond1 (:,:), bond2 (:,:), csizev (:) if (. not . SymmOp % bonds_mapped ) stop 'Need to map bonds before analyzing symmetry' ntotbond = size ( SymmOp % map_symm_b , 1 ) ntotbondsq = ( ntotbond ** 2 + ntotbond ) / 2 allocate ( myclass ( ntotbond , ntotbond ), bond1 ( 2 , ntotbondsq ), & & bond2 ( 2 , ntotbondsq ), csizev ( ntotbondsq )) !Initially Define classes as if all bonds were different !the pair (bond1(ix,iclass) , bond2(ix,iclass)) is the ix-th member !of class \"iclass\" nclass = 0 do ib = 1 , ntotbond nclass = nclass + 1 myclass ( ib , ib ) = nclass bond1 ( 1 , nclass ) = ib bond2 ( 1 , nclass ) = ib csizev ( nclass ) = 1 enddo do ib = 1 , ntotbond do jb = ib + 1 , ntotbond nclass = nclass + 1 myclass ( ib , jb ) = nclass myclass ( jb , ib ) = nclass bond1 ( 1 , nclass ) = ib bond2 ( 1 , nclass ) = jb bond1 ( 2 , nclass ) = jb bond2 ( 2 , nclass ) = ib csizev ( nclass ) = 2 enddo enddo !Try all symmetry operations do isymm = 1 , SymmOp % nsymm !on all classes do iclass = 1 , nclass istart = 1 !we now loop over the elements of a class. !This number is increased as we found new equivalent !elements. That's why the loop is split in !1! and !2! do !1! csize = csizev ( iclass ) csizenew = csize do id = istart , csize !2! !map the two bonds bx = SymmOp % map_symm_b ( bond1 ( id , iclass ), isymm ) by = SymmOp % map_symm_b ( bond2 ( id , iclass ), isymm ) !Find the new class jclass = myclass ( bx , by ) if ( jclass /= iclass ) then !Classes are different: merge them jstart = csizenew !Increase size of iclass csizenew = csizenew + csizev ( jclass ) call resize_class () !transfer jclass member to iclass do idj = 1 , csizev ( jclass ) bx = bond1 ( idj , jclass ); by = bond2 ( idj , jclass ) myclass ( bx , by ) = iclass bond1 ( jstart + idj , iclass ) = bx bond2 ( jstart + idj , iclass ) = by enddo !annihilate jclass csizev ( jclass ) = 0 endif enddo !Size has not changed so we cannot merge any other class into iclass if ( csizenew == csize ) exit !Update loop boundary to find new equivalence due to newly added classes. istart = csizev ( iclass ) + 1 csizev ( iclass ) = csizenew enddo enddo enddo !Exclude empty classes mclass = 0 do i = 1 , nclass if ( csizev ( i ) > 0 ) mclass = mclass + 1 do j = 1 , csizev ( i ) bx = bond1 ( j , i ) by = bond2 ( j , i ) myclass ( bx , by ) = mclass enddo enddo deallocate ( bond1 , bond2 , csizev ) !Save classes in Bonds and determine class size Bonds % nclass_b = mclass Bonds % myclass_b => myclass allocate ( Bonds % class_size_b ( mclass )) Bonds % class_size_b (:) = 0 do ib = 1 , ntotbond do jb = 1 , ntotbond Bonds % class_size_b ( myclass ( ib , jb )) = Bonds % class_size_b ( myclass ( ib , jb )) + 1 enddo enddo Bonds % analyzed = . true . contains subroutine resize_class () implicit none ! ... Local vars ... integer :: curr_csize integer , allocatable :: tmpbond (:,:) ! ... Executable ... curr_csize = size ( bond1 , 1 ) if ( csizenew > curr_csize ) then !Initially allocate temp array allocate ( tmpbond ( csizenew , nclass )) !Update size of patom without loosing its content tmpbond ( 1 : curr_csize ,:) = bond1 ( 1 : curr_csize ,:) deallocate ( bond1 ) allocate ( bond1 ( csizenew , nclass )) bond1 = tmpbond !Update size of satom without loosing its content tmpbond ( 1 : curr_csize ,:) = bond2 ( 1 : curr_csize ,:) deallocate ( bond2 ); allocate ( bond2 ( csizenew , nclass )) bond2 = tmpbond !deallocate temp array deallocate ( tmpbond ) end if end subroutine resize_class end subroutine !--------------------------------------------------------------------------------- ! Construct classes for pairs !--------------------------------------------------------------------------------- subroutine construct_pair_classes ( Bonds , Pairs ) use DQMC_BONDS type ( bonds_t ), intent ( in ) :: Bonds type ( pairing ), intent ( inout ) :: Pairs integer :: nc , np , ip , jp , ib , jb , ic , jc integer , allocatable :: bclass (:) nc = 0 np = Pairs % nbond allocate ( Pairs % myclass_p ( np , np ), bclass ( Bonds % nclass_b )) !bclass maps bond classes on pair classes. When 0 it means the !bond class has yet to be mapped bclass = 0 !loop over all pairs do ip = 1 , np !Find the corresponding one in Bonds ib = Pairs % bond_map ( ip ) do jp = ip , np jb = Pairs % bond_map ( jp ) !Find the class for pair (ib,jb) ic = Bonds % myclass_b ( ib , jb ) jc = bclass ( ic ) if ( jc == 0 ) then !we found a new class for pairs nc = nc + 1 !Save it Pairs % myclass_p ( ip , jp ) = nc Pairs % myclass_p ( jp , ip ) = nc bclass ( ic ) = nc else !assign existing class Pairs % myclass_p ( ip , jp ) = jc Pairs % myclass_p ( jp , ip ) = jc endif enddo enddo Pairs % nclass_p = nc deallocate ( bclass ) !Determine size of pair class allocate ( Pairs % class_size_p ( nc )) Pairs % class_size_p = 0 do ip = 1 , np do jp = 1 , np jc = Pairs % myclass_p ( ip , jp ) Pairs % class_size_p ( jc ) = Pairs % class_size_p ( jc ) + 1 enddo enddo end subroutine end module DQMC_SYMM","tags":"","loc":"sourcefile/dqmc_symm.f90.html"},{"title":"test.F90 – Quest","text":"This file depends on sourcefile~~test.f90~~EfferentGraph sourcefile~test.f90 test.F90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~test.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program dqmc_test ! This program checks the execution time for ! QUEST on a 2-dimensional PEriodic Reactangular ! Lattice (2DPERL) use DQMC_2DPERL use DQMC_MPI implicit none integer :: t1 , t2 , rate #ifdef DQMC_PROFILE !gfun_profile = .true. !matb_profile = .true. call profile_enable () #endif call system_clock ( t1 ) !count number of processors call DQMC_MPI_Init ( qmc_sim , PLEVEL_1 ) call DQMC_Comp_2DPerl call system_clock ( t2 , rate ) write ( STDOUT , * ) \"Running time:\" , ( t2 - t1 ) / REAL ( rate ), \"(second)\" #ifdef DQMC_PROFILE !call gfun_print() !call matb_print() call profile_print () #endif end program dqmc_test","tags":"","loc":"sourcefile/test.f90.html"},{"title":"dqmc_holstein.F90 – Quest","text":"This file depends on sourcefile~~dqmc_holstein.f90~~EfferentGraph sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_Hubbard #include \"dqmc_include.h\" use DQMC_UTIL use DQMC_CFG use DQMC_PHY0 use DQMC_PHY2 #ifdef DQMC_CKB use DQMC_CheckerBoard #else use DQMC_MATB #endif use DQMC_SEQB use DQMC_GFUN use DQMC_STRUCT implicit none ! ! This module contains the data type and subroutines for ! computing DQMC.  This should be the only module that user ! program need to include. ! ! The data type is consisted of four parts !    1. Parameters of Hubbard's model and Green's function. !    2. Parameters for Monte Carlo algorithm. !    3. Physical measurements. !    4. Working space. ! ! There are only four subroutines for user program to call !    1. DQMC_Readin  : read input !    2. DQMC_Run     : execute DQMC !    3. DQMC_Dump    : write output !    4. DQMC_Current_Config : output current Hubbard-Stratonovich !                             configuration. ! ! References ! ========== !    [1] Z. Bai, W.Chen, R. Scalettar, I. Yamazaki, \"Lecture Notes !        on Advances of Numerical Methods for Hubbard Quantum Monte !        Carlo Simulation.\" ! ! List of subroutines ! =================== !    DQMC_Default(Hub) : set the default value of the data type !    DQMC_Readin(Hub, IPT, OPT, ReadStruct) : read in parameters !    DQMC_Init(Hub) : Initialize the data type. !    DQMC_Dump(Hub, OPT) : output the parameters. !    DQMC_Sweep(Hub, nMeas0, v1, v2) : Metropolis algorithm. !    DQMC_Run(Hub) : the main subroutine of DQMC. ! ! ! Data Type ! ========= ! type Hubbard ! Part 1: Parameters of Hubbard's model and Green's function ! ========================================================== ! Parameters for problem size integer :: n ! Number of sites integer :: L ! Number of time slices ! Parameters for Hubbard model integer :: n_U real ( wp ), pointer :: U (:) ! Hubbard U, or el-ph coupling in the case of Holstein model integer :: n_t ! Number of hoppings real ( wp ), pointer :: t_up (:) ! spin-up hopping real ( wp ), pointer :: t_dn (:) ! spin-down hopping integer :: n_mu real ( wp ), pointer :: mu_up (:) ! spin-up chemical potential real ( wp ), pointer :: mu_dn (:) ! spin-down chemical potential real ( wp ) :: dtau ! imaginary time step size integer , pointer :: HSF (:,:) ! discrete Hubbard-Stratonovich Fields real ( wp ), pointer :: CHSF (:,:) ! continuous Hubbard-Stratonovich Fields integer :: HSFtype ! flag for HSF type logical :: outputHSF ! flag for output HSF logical :: continuous ! flag for continuous HSF real ( wp ) :: delta1 ! continuous field local move step size real ( wp ) :: delta2 ! continuous field global move step size real ( wp ), pointer :: lambda (:) ! parameter for contunuous HSF integer :: n_start , n_end real ( wp ) :: omega ! phonon dispersion ! Underline structure type ( Struct ) :: S ! Lattice structure ! For Green function computation type ( matB ) :: B_up ! type ( seqB ) :: SB_up ! Sequential Bs type ( matB ) :: B_dn ! type ( seqB ) :: SB_dn ! Sequential Bs type ( G_fun ) :: G_up ! Green's fun for spin up type ( G_fun ) :: G_dn ! Green's fun for spin down real ( wp ), pointer :: V_up (:,:) real ( wp ), pointer :: V_dn (:,:) ! Parameters for random number integer :: idum ! random seed for ran2 integer :: seed ( 4 ) ! random seed for ran1 ! Auxiliary variables real ( wp ), pointer :: explook (:,:) ! Lookup table for computing V logical :: comp_dn ! indicator for wheather computing ! G_dn or not logical :: neg_u ! are all U_i < 0 ? ! CAVEAT: mixed sign may not work ! Part 2: Parameters for Monte Carlo algorithm ! ============================================ integer :: nWarm ! Number of warm up step integer :: nPass ! Number of measurement step integer :: nTry ! Number of global move real ( wp ) :: gamma ! Parameters for Metopolis alg integer :: nAccept ! The following parameters integer :: nReject ! are used to dynamically ! adjust gamma. integer :: nAcceptGlobal ! global move acceptance integer :: nRejectGlobal integer :: nAcceptGlobal2 ! global move 2 acceptance integer :: nRejectGlobal2 ! Part 3: Physical measurements ! ============================= type ( Phy0 ) :: P0 ! Meas0 type ( Phy2 ) :: P2 ! MeasPair integer :: nMeas integer :: tausk ! Frequency of performing Phy0 measurement logical :: meas2 ! Part 4: Working space ! ============================= type ( Wspace ) :: WS ! Part 5: file units ! ============================= integer :: OUT_UNIT end type Hubbard integer , parameter :: NO_MEAS0 = - 1 ! HSF parameter integer , parameter :: HSF_OUTPUT_UNIT = 28 integer , parameter :: HSF_INPUT_UNIT = 27 integer , parameter :: HSF_RANDOM_GEN = - 1 ! generate HS fields randomly integer , parameter :: HSF_FROM_FILE = 1 ! load HS fields from file integer , parameter :: HSF_RESTORE = 2 ! load HS field and RNG state from file integer , parameter :: HSF_FROM_MEMORY = 0 integer , parameter :: HSF_DISC = 0 integer , parameter :: HSF_CONT = 1 integer :: SimType ! model selection flag. !   SimType == 0: Hubbard model !   SimType == 1: Holstein model real ( wp ) :: CHSF0 ! phonon field overall scale real ( wp ) :: norm_phonon ( 2 ) ! normalization factor of phonon terms !   1 => kinetic energy term !   2 => potential energy term contains !---------------------------------------------------------------------! subroutine DQMC_Hub_Config ( Hub , cfg ) use dqmc_mpi ! ! Purpose ! ======= !    This subrotine initializes Hubbard model from the configuration. ! ! ! Pre-assumption ! ============== !    DQMC_default should be called before this. !    Geometry information should be iniitialized before calling this. ! ! ! Arguments ! ========= ! type ( config ), intent ( inout ) :: cfg type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model ! ... Local Variables ... integer :: n_t , n_U , n_mu , L , HSF , nWarm , nPass integer :: accept , reject , HSFtype , fixw , tdm integer :: seed , nOrth , nWrap , nTry , nBin , nMeas , ntausk , ssxx character ( len = slen ) :: HSF_ipt , HSF_opt logical :: valid real ( wp ), pointer :: t_up (:) => null () real ( wp ), pointer :: t_dn (:) => null () real ( wp ), pointer :: U (:) => null () real ( wp ), pointer :: mu_up (:) => null () real ( wp ), pointer :: mu_dn (:) => null () real ( wp ) :: dtau , errrate , difflim , gamma , delta1 , delta2 , omega ! ... Executable ... !Open output file !call CFG_Get(cfg, \"gfile\", fname) !outname=trim(adjustl(fname))//\".out\" !call DQMC_open_file(outname, 'unknown', Hub%OUT_UNIT) ! integer parameters call CFG_Get ( cfg , \"HSF\" , HSF ) call CFG_Get ( cfg , \"L\" , L ) call CFG_Get ( cfg , \"nwarm\" , nWarm ) call CFG_Get ( cfg , \"npass\" , nPass ) call CFG_Get ( cfg , \"tdm\" , tdm ) call CFG_Get ( cfg , \"nbin\" , nBin ) call CFG_Get ( cfg , \"ntry\" , nTry ) call CFG_Get ( cfg , \"seed\" , seed ) call CFG_Get ( cfg , \"nwrap\" , nWrap ) call CFG_Get ( cfg , \"north\" , nOrth ) call CFG_Get ( cfg , \"gamma\" , gamma ) call CFG_Get ( cfg , \"accept\" , accept ) call CFG_Get ( cfg , \"reject\" , reject ) call CFG_Get ( cfg , \"HSFtype\" , HSFtype ) call CFG_Get ( cfg , \"delta1\" , delta1 ) call CFG_Get ( cfg , \"delta2\" , delta2 ) call CFG_Get ( cfg , \"ssxx\" , ssxx ) call CFG_Get ( cfg , \"fixwrap\" , fixw ) call CFG_Get ( cfg , \"tausk\" , ntausk ) call CFG_Get ( cfg , \"SimType\" , SimType ) call CFG_Get ( cfg , \"omega\" , omega ) ! Array parameters call CFG_Get ( cfg , \"t_up\" , n_t , t_up ) call CFG_Get ( cfg , \"t_dn\" , n_t , t_dn ) call CFG_Get ( cfg , \"U\" , n_U , U ) call CFG_Get ( cfg , \"mu_up\" , n_mu , mu_up ) call CFG_Get ( cfg , \"mu_dn\" , n_mu , mu_dn ) ! Real parameters call CFG_Get ( cfg , \"dtau\" , dtau ) call CFG_Get ( cfg , \"difflim\" , difflim ) call CFG_Get ( cfg , \"errrate\" , errrate ) !Change nbin to 1 if we are using more than 1 CPU. !Results collected on each CPU will be used as bins. if ( qmc_sim % aggr_size > 1 ) then nBin = 1 call CFG_set ( cfg , \"nbin\" , nBin ) endif if ( SimType . eq . Holstein_model . and . HSFtype . eq . 0 ) then write ( * , * ) write ( * , \"(' Input parameter error:')\" ) write ( * , \"('   SimType =', i3)\" ) SimType write ( * , \"('   HSFtype =', i3)\" ) HSFtype call DQMC_Error ( \" Must set HSFtype=1 in Holstein mode (SimType=1).\" , 1 ) end if if ( HSF == HSF_FROM_FILE . or . HSF == HSF_RESTORE ) then ! open input file if ( DQMC_Config_isSet ( cfg , \"HSFin\" )) then call CFG_Get ( cfg , \"HSFin\" , HSF_ipt ) inquire ( FILE = trim ( HSF_ipt ), EXIST = valid ) if ( valid ) then open ( HSF_INPUT_UNIT , FILE = trim ( HSF_ipt )) else call DQMC_Warning ( \"HSF input file does not exist.\" , 1 ) HSF = HSF_RANDOM_GEN end if end if elseif ( HSF /= HSF_FROM_MEMORY . and . HSF /= HSF_RANDOM_GEN ) then call DQMC_Warning ( \"Invalid HSF input: Use default\" , HSF ) HSF = HSF_RANDOM_GEN end if ! open output file Hub % outputHSF = DQMC_Config_isSet ( cfg , \"HSFout\" ) if ( Hub % outputHSF ) then call CFG_Get ( cfg , \"HSFout\" , HSF_opt ) open ( HSF_OUTPUT_UNIT , FILE = trim ( HSF_opt )) end if nmeas = 1 ! Deactivate measurements during sweep if tdm is on if ( tdm > 0 ) nmeas = 0 ! call the function call DQMC_Hub_Init ( Hub , U , t_up , t_dn , mu_up , mu_dn , L , n_t , n_U , n_mu , dtau , & HSF , nWarm , nPass , nMeas , nTry , nBin , ntausk , seed , nOrth , nWrap , fixw , & errrate , difflim , gamma , accept , reject , delta1 , delta2 , ssxx , HSFtype , omega ) call CFG_Set ( cfg , \"n\" , Hub % n ) deallocate ( t_up , t_dn , mu_up , mu_dn , U ) end subroutine DQMC_Hub_Config !---------------------------------------------------------------------! subroutine DQMC_Hub_Init ( Hub , U , t_up , t_dn , mu_up , mu_dn , L , n_t , n_U , n_mu , dtau , & HSF_IPT , nWarm , nPass , nMeas , nTry , nBin , ntausk , seed , nOrth , nWrap , fixw , & errrate , difflim , gamma , accept , reject , delta1 , delta2 , ssxx , HSFtype , omega ) ! ! Purpose ! ======= !    This subrotine initializes Hubbard model. ! ! Pre-assumption ! ============== !    DQMC_default should be called before this. !    Geometry information should be iniitialized before calling this. ! ! ! Arguments ! ========= ! use dqmc_mpi #ifdef __INTEL_COMPILER use IFPORT , only : getpid #elif __PGI integer :: getpid #endif #   ifdef _QMC_MPI #      define SIMPLE_SPRNG #      define USE_MPI #      include \"sprng_f.h\" #   endif type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model real ( wp ), intent ( in ) :: U (:), t_up (:), t_dn (:) real ( wp ), intent ( in ) :: mu_up (:), mu_dn (:), dtau ! Parameters integer , intent ( in ) :: L , n_t , n_U , n_mu integer , intent ( in ) :: HSF_IPT , seed , ssxx integer , intent ( in ) :: nWarm , nPass , nOrth , nTry , HSFtype integer , intent ( in ) :: nMeas , nBin , ntausk , nWrap , fixw , accept , reject real ( wp ), intent ( in ) :: errrate , difflim , gamma , delta1 , delta2 , omega ! ... Local scalar ... integer :: n , i , j , HSF , ilb , val ( 8 ) real ( wp ) :: temp , lambda real ( wp ) :: Map_up ( Hub % S % nSite ), Map_dn ( Hub % S % nSite ), Uhubb ( Hub % S % nSite ) logical :: lex character ( 80 ) :: msg ! phonon field related real ( wp ), allocatable :: CHSFtmp (:) #   ifdef _QMC_MPI SPRNG_POINTER junkPtr #   endif ! ... Executable ... if (. not . Hub % S % checklist ( STRUCT_INIT )) then call DQMC_Error ( \"Must initialize lattice geometry first\" , 0 ) end if Hub % n = Hub % S % nSite n = Hub % n Hub % L = L Hub % dtau = dtau Hub % delta1 = delta1 Hub % delta2 = delta2 Hub % omega = omega allocate ( CHSFtmp ( n )) ! t parameter if ( n_t /= Hub % S % n_t ) then if ( n_t == 1 . and . Hub % S % n_t > 1 ) then ! special case for checkerboard method Hub % n_t = Hub % S % n_t allocate ( Hub % t_up ( Hub % S % n_t )) allocate ( Hub % t_dn ( Hub % S % n_t )) Hub % t_up = t_up ( 1 ) Hub % t_dn = t_dn ( 2 ) else write ( msg , \"(a,i5, a, i5)\" ) \"Input lattice requires \" , Hub % S % n_t , & \" hoppings, but only reads \" , n_t call DQMC_Error ( msg , 0 ) end if else Hub % n_t = n_t allocate ( Hub % t_up ( n_t )) allocate ( Hub % t_dn ( n_t )) Hub % t_up = t_up Hub % t_dn = t_dn end if ! U parameter Hub % n_U = n_U allocate ( Hub % U ( n_U )) Hub % U = U ! mu parameter Hub % n_mu = n_mu allocate ( Hub % mu_up ( n_mu )) allocate ( Hub % mu_dn ( n_mu )) Hub % mu_up = mu_up Hub % mu_dn = mu_dn do i = 1 , n Map_up ( i ) = mu_up ( Hub % S % Map ( i )) Map_dn ( i ) = mu_dn ( Hub % S % Map ( i )) Uhubb ( i ) = abs ( Hub % U ( Hub % S % Map ( i ))) end do if ( SimType . eq . Hubbard_model ) then Hub % comp_dn = . true . if ( all ( U < ZERO + 1.d-6 ) ) then !Negative U and U=0 Hub % neg_u = . true . ! G_up and G_dn are identical. Do not compute G_dn. if ( maxval ( abs ( t_up - t_dn )) < 1.d-6 . and . maxval ( abs ( mu_up - mu_dn )) < 1.d-6 ) then Hub % comp_dn = . false . endif elseif ( all ( U > ZERO - 1.d-6 )) then !Positive U Hub % neg_u = . false . ! Don't compute G_dn on half-filled (mu=0) bipartite lattices if ( all ( abs ( mu_up ) < 1.d-6 ) . and . all ( abs ( mu_dn ) < 1.d-6 ) . and . & maxval ( abs ( t_up - t_dn )) < 1.d-6 . and . Hub % S % checklist ( STRUCT_PHASE ) ) then Hub % comp_dn = . false . end if else stop 'All U''s must have the same sign (or be zero)' end if else if ( SimType . eq . Holstein_model ) then if ( any ( U < - 1.d-6 ) ) then write ( * , * ) write ( * , * ) ' Electron-phonon couplings must be positive.' write ( * , * ) ' Stop.' stop end if ! No need to compute G_dn for in the Holstein mode. Hub % comp_dn = . false . Hub % neg_u = . true . ! Normalization factors of the phonon action norm_phonon ( 1 ) = 0.5_wp / dtau norm_phonon ( 2 ) = 0.5_wp * omega * omega * dtau ! Length scale of phonon displacement CHSF0 = 1.0_wp / omega / ( exp ( float ( L ) * dtau * omega ) - 1.0_wp ) + 0.5_wp / omega CHSF0 = 2.0_wp * sqrt ( CHSF0 ) end if !write(*,*) !write(*,*) \"DEBUG info -- In DQMC_Hub_Init():\" !write(*,*) \"  Hub%comp_dn=\",Hub%comp_dn !write(*,*) \"  Hub%neg_u=\",Hub%neg_u !write(*,*) \"  S%P defined? \",Hub%S%checklist(STRUCT_PHASE) !write(*,*) ! Parameters for MC loop Hub % nWarm = nWarm Hub % nPass = nPass Hub % nMeas = nMeas Hub % nTry = nTry Hub % tausk = ntausk ! Initialize random seeds Hub % idum = seed if ( Hub % idum == 0 ) then call date_and_time ( VALUES = val ) Hub % idum = getpid () + val ( 8 ) * val ( 7 ) + val ( 6 ) ** mod ( val ( 5 ), 5 ) end if ! LAPACK random variable generation Hub % seed = Hub % idum * ( / 1 , 2 , 3 , 4 / ) Hub % seed = mod ( abs ( Hub % seed ), 4095 ) if ( mod ( Hub % seed ( 4 ), 2 ) == 0 ) then Hub % seed ( 4 ) = Hub % seed ( 4 ) + 1 end if #   ifdef _QMC_MPI junkPtr = init_sprng ( SPRNG_LCG , Hub % seed ( 4 ), SPRNG_DEFAULT ) #   endif ! Initialize auxiliary variables Hub % gamma = gamma Hub % nAccept = accept Hub % nReject = reject ! Initialize working space call DQMC_WSpace_Allocate ( n , Hub % S % n_b , Hub % WS ) ! Initialize Hubbard-Stratonovich Field HSF = HSF_IPT Hub % HSFtype = HSFtype if ( HSF == HSF_FROM_MEMORY ) then ilb = Hub % G_up % ilb ! discrete case if ( HSFtype == HSF_DISC ) then if (. not . associated ( Hub % HSF )) then call DQMC_Warning ( \"Cannot use current HSF. \" , 0 ) HSF = HSF_RANDOM_GEN else print * , \"Read HSF from memory.\" end if else ! contnuous case if (. not . associated ( Hub % CHSF )) then call DQMC_Warning ( \"Cannot use current HSF. \" , 0 ) HSF = HSF_RANDOM_GEN else print * , \"Read HSF from memory.\" end if end if end if if ( HSF == HSF_FROM_FILE . or . HSF == HSF_RESTORE ) then inquire ( UNIT = HSF_INPUT_UNIT , EXIST = lex ) if ( lex ) then ! If a valid input file handle is provided, ! read HSF from the file if ( HSFtype == HSF_DISC ) then allocate ( Hub % HSF ( n , L )) call DQMC_Hub_Input_HSF ( Hub , HSF == HSF_RESTORE , ilb , HSF_INPUT_UNIT ) else ! TODO: input continuous HSF from file call DQMC_Error ( \"reading continuous HSF from file is not supported\" , HSF ) end if print * , \"Read HSF from a file.\" else ! If file does not exist, give a warning message. call DQMC_Warning ( \"HSF file does not exist. & & Use randomly generated values.\" , HSF ) HSF = HSF_RANDOM_GEN end if end if ! generate HSF randomly if ( HSF == HSF_RANDOM_GEN ) then ilb = 1 ! discrete case if ( HSFtype . eq . HSF_DISC ) then allocate ( Hub % HSF ( n , L )) Hub % HSF = 1 do i = 1 , Hub % L call ran0 ( n , Hub % WS % R5 , Hub % seed ) where ( Hub % WS % R5 > HALF ) Hub % HSF (:, i ) = - 1 end do else if ( HSFtype . eq . HSF_CONT ) then ! continuous case allocate ( Hub % CHSF ( n , L )) if ( SimType . eq . Hubbard_model ) then do i = 1 , Hub % L call ran1 ( n , Hub % CHSF (:, i ), Hub % seed ) end do else if ( SimType . eq . Holstein_model ) then call ran1 ( n , CHSFtmp , Hub % seed ) do i = 1 , Hub % L Hub % CHSF (:, i ) = CHSF0 * CHSFtmp end do end if end if end if ! Initialize lookup table if ( HSFtype . eq . HSF_DISC ) then nullify ( Hub % explook ) allocate ( Hub % explook ( - 2 : 2 , 1 : n_U )) do j = 1 , n_U temp = exp ( dtau * abs ( U ( j )) * HALF ) lambda = log ( temp + sqrt ( temp * temp - ONE )) do i = - 2 , 2 Hub % explook ( i , j ) = exp ( float ( i ) * lambda ) end do ! for use by U<0, save lambda in explook(0, j) Hub % explook ( 0 , j ) = lambda end do else if ( HSFtype . eq . HSF_CONT ) then allocate ( Hub % lambda ( n_U )) ! Hubbard model mode. if ( SimType . eq . Hubbard_model ) then do j = 1 , n_U Hub % lambda ( j ) = sqrt ( dtau * abs ( U ( j ))) end do ! Holstein model mode. Here U should be understood as the electron-phonon couplings. elseif ( simType . eq . Holstein_model ) then do j = 1 , n_U Hub % lambda ( j ) = U ( j ) * dtau end do end if end if ! Initialize V matrices call DQMC_Hub_Init_Vmat ( Hub ) ! Initialize Green functions if (( SimType . eq . Hubbard_model ) . and . Hub % neg_u . and . ( HSFType . eq . HSF_CONT )) then call DQMC_B_Init ( n , Hub % B_up , Hub % WS , Hub % S % T , Hub % S % ckb , Hub % t_up , Map_up , dtau , Uhubb ) call DQMC_B_Init ( n , Hub % B_dn , Hub % WS , Hub % S % T , Hub % S % ckb , Hub % t_dn , Map_dn , dtau , Uhubb ) else call DQMC_B_Init ( n , Hub % B_up , Hub % WS , Hub % S % T , Hub % S % ckb , Hub % t_up , Map_up , dtau ) call DQMC_B_Init ( n , Hub % B_dn , Hub % WS , Hub % S % T , Hub % S % ckb , Hub % t_dn , Map_dn , dtau ) end if call DQMC_SeqB_Init ( n , Hub % L , nOrth , Hub % B_up , Hub % SB_up , Hub % WS ) call DQMC_SeqB_Init ( n , Hub % L , nOrth , Hub % B_dn , Hub % SB_dn , Hub % WS ) ! Initialize G call DQMC_GFun_Init ( n , L , Hub % G_up , Hub % V_up , Hub % WS , & nWrap , difflim , errrate , GMAT_UP , ssxx , fixw ) ! for positive U or H_dn/=H_up we need to construct G_dn implicitly if ( Hub % comp_dn . or . . not . Hub % neg_u ) then call DQMC_GFun_Init ( n , L , Hub % G_dn , Hub % V_dn , Hub % WS , & nWrap , difflim , errrate , GMAT_DN , ssxx , fixw ) else ! Negative U or U=0, G_dn is a clone of G_up call DQMC_Gfun_Clone ( Hub % G_dn , Hub % G_up ) end if !Fill G call DQMC_GetG ( ilb , Hub % G_up , Hub % SB_up ) if ( Hub % comp_dn . or . . not . Hub % neg_u ) then call DQMC_GetG ( ilb , Hub % G_dn , Hub % SB_dn ) end if ! Initialize measurements temp = Hub % dtau * Hub % L call DQMC_Phy0_Init ( Hub % P0 , Hub % S , temp , nBin , Hub % WS ) call DQMC_Phy2_Init ( Hub % P2 , nBin , Hub % S , Hub % WS , Hub % meas2 ) ! Initialize simulation range Hub % n_start = 1 Hub % n_end = n deallocate ( CHSFtmp ) end subroutine DQMC_Hub_Init !---------------------------------------------------------------------! subroutine DQMC_Hub_Free ( Hub ) ! ! Purpose ! ======= !    This subrotine deallocate variables in Hubbard ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model ! ... Executable ... call DQMC_B_Free ( Hub % B_up ) call DQMC_B_Free ( Hub % B_dn ) call DQMC_Gfun_Free ( Hub % G_up ) call DQMC_Gfun_Free ( Hub % G_dn ) call DQMC_Phy0_Free ( Hub % P0 ) call DQMC_Phy2_Free ( Hub % P2 ) if ( associated ( Hub % V_up )) deallocate ( Hub % V_up ) if (. not . Hub % neg_u . and . associated ( Hub % V_dn )) deallocate ( Hub % V_dn ) deallocate ( Hub % t_up , Hub % t_dn , Hub % mu_up , Hub % mu_dn , Hub % U ) if ( Hub % HSFtype == HSF_DISC ) then deallocate ( Hub % HSF ) deallocate ( Hub % explook ) else deallocate ( Hub % CHSF ) deallocate ( Hub % lambda ) end if call DQMC_WSpace_Free ( Hub % WS ) call DQMC_SeqB_Free ( Hub % SB_up ) call DQMC_SeqB_Free ( Hub % SB_dn ) call DQMC_Struct_Free ( Hub % S ) end subroutine DQMC_Hub_Free !---------------------------------------------------------------------! subroutine DQMC_Hub_Output_HSF ( Hub , restore , slice , OPT ) ! ! Purpose ! ======= !    This subrotine outputs Hubbard-Stratonovich Field to a !    output file OPT. ! ! Arguments ! ========= ! use dqmc_mpi #   ifdef _QMC_MPI #      include \"sprng_f.h\" #   endif type ( Hubbard ), intent ( in ) :: Hub !     integer, intent(in) :: n, L         ! dim of HSF !     integer, intent(in) :: HSF(n,L)     ! Hubbard-Stratonovich Field !     integer, intent(in) :: seed(4)      ! RNG state integer , intent ( in ) :: OPT ! output handle logical , intent ( in ) :: restore integer , intent ( in ) :: slice ! ... local variables ... integer :: i , j , k , h , nproc , nL integer :: HSF ( Hub % n * Hub % L + 1 ) #   ifdef _QMC_MPI character :: rndbuf ( MAX_PACKED_LENGTH ) character ( len = 60 ) :: fname integer :: stat #   endif ! ... Executable .... nL = Hub % n * Hub % L nproc = qmc_sim % aggr_size if ( qmc_sim % rank == qmc_sim % aggr_root ) then !loop over processors do j = 0 , nproc - 1 ! Collect data from processor \"j\" if ( j /= qmc_sim % aggr_root ) then #            ifdef _QMC_MPI call mpi_recv ( HSF , nL + 1 , MPI_INT , j , j , MPI_COMM_WORLD , stat , k ) #            endif else call pack_fields endif !Write data to disk do k = 1 , nL write ( OPT , '(i1)' , advance = 'no' ) HSF ( k ) enddo write ( OPT , * ) HSF ( nL + 1 ) enddo else !Send data to root node call pack_fields #     ifdef _QMC_MPI ! Send field to root processor call mpi_send ( HSF , nL + 1 , MPI_INT , qmc_sim % aggr_root , qmc_sim % rank , MPI_COMM_WORLD , k ) #     endif endif !If restore is true, write the random number generator status if ( restore ) then #      ifdef _QMC_MPI k = pack_sprng ( rndbuf ) inquire ( unit = OPT , name = fname ) close ( OPT ) !This would be better done with send/recv (see commented code below) ! but there appears to be a problem with the written rndbuf (!?) do i = 0 , nproc - 1 if ( i == qmc_sim % aggr_rank ) then open ( file = fname , form = 'formatted' , unit = OPT , position = 'append' ) write ( OPT , '(i8,1x)' , advance = 'no' ) k do j = 1 , k write ( OPT , '(A1)' , advance = 'no' ) rndbuf ( j ) enddo write ( OPT , * ) close ( OPT ) endif call mpi_barrier ( MPI_COMM_WORLD , j ) enddo open ( file = fname , form = 'formatted' , unit = OPT , position = 'append' ) #      else !Simply write the seed if MPI is off write ( OPT , * ) Hub % seed #      endif write ( OPT , * ) Hub % gamma , Hub % naccept , Hub % nreject endif !    if (DQMC_MPI_Is_Root(qmc_sim, CHANNEL_AGGR) .and. restore) then !#      ifdef _QMC_MPI !          do j = 0, nproc - 1 !             ! Collect data from processor \"j\" !             if (j /= qmc_sim%aggr_root) then !                call mpi_recv(k, 1, MPI_INT, j, j, MPI_COMM_WORLD, stat, i) !                call mpi_recv(rndbuf, k, MPI_CHARACTER, j, j, MPI_COMM_WORLD, stat, i) !             else !                k = pack_sprng(rndbuf) !             endif !             !Write data to disk !             write(OPT,'(i8,1x)',advance='no') k !             do i = 1, k !                write(OPT,'(A1)',advance='no') rndbuf(i) !             enddo !             write(OPT,*) !          enddo !#      else !          !Simply write the seed if MPI is off !          write(OPT, *) Hub%seed !#      endif !       !Write info to reastablish acceptance rate !       write(OPT, *) Hub%gamma, Hub%naccept, Hub%nreject !    elseif (restore) then !#      ifdef _QMC_MPI !          k = pack_sprng(rndbuf) !          call mpi_send(k, 1, MPI_INT, qmc_sim%aggr_root, qmc_sim%rank, MPI_COMM_WORLD, k) !          call mpi_send(rndbuf, k, MPI_CHARACTER, qmc_sim%aggr_root, qmc_sim%rank, MPI_COMM_WORLD, k) !#      endif !    endif #   ifdef _QMC_MPI call mpi_barrier ( MPI_COMM_WORLD , i ) #   endif contains subroutine pack_fields !Fill the vector of fields to write k = 1 do i = 1 , Hub % L do h = 1 , Hub % n HSF ( k ) = ( Hub % HSF ( h , i ) + 1 ) / 2 k = k + 1 enddo enddo !Last element is the time slice if ( slice <= 0 ) then HSF ( k ) = Hub % G_up % ilb else HSF ( k ) = slice endif end subroutine pack_fields end subroutine DQMC_Hub_Output_HSF !---------------------------------------------------------------------! subroutine DQMC_Hub_Input_HSF ( Hub , restore , slice , IPT ) ! ! Purpose ! ======= !    This subrotine reads Hubbard-Stratonovich Field from a !    file OPT. ! ! Arguments ! ========= ! use dqmc_mpi #   ifdef _QMC_MPI #      include \"sprng_f.h\" #   endif type ( Hubbard ), intent ( inout ) :: Hub logical , intent ( in ) :: restore ! restore RNG? integer , intent ( in ) :: IPT ! input handle integer , intent ( out ) :: slice ! ... local varaible ... Integer :: i , j , k , ip , nproc , nL integer :: HSF ( Hub % n * Hub % L + 1 ) #   ifdef _QMC_MPI character :: rndbuf ( MAX_PACKED_LENGTH ) SPRNG_POINTER :: junkPtr #   endif ! ... Executable .... nL = Hub % n * Hub % L nproc = qmc_sim % size do ip = 0 , nproc - 1 if ( qmc_sim % aggr_rank == ip ) then k = 1 do i = 1 , Hub % L do j = 1 , Hub % n read ( IPT , '(i1)' , advance = 'no' , ERR = 100 ) HSF ( k ) k = k + 1 enddo write ( 98 , * ) enddo read ( IPT , * ) HSF ( k ) else read ( IPT , * ) endif k = 1 do i = 1 , Hub % L do j = 1 , Hub % n Hub % HSF ( j , i ) = 2 * HSF ( k ) - 1 k = k + 1 enddo enddo slice = HSF ( k ) enddo if ( restore ) then do ip = 0 , nproc - 1 if ( qmc_sim % aggr_rank == ip ) then #            ifdef _QMC_MPI read ( IPT , '(i8,1x)' , advance = 'no' ) k do j = 1 , k read ( IPT , '(A1)' , advance = 'no' ) rndbuf ( j ) enddo read ( IPT , * ) #            else read ( IPT , * ) Hub % seed #            endif else read ( IPT , * ) endif enddo read ( IPT , * , ERR = 102 ) Hub % gamma , Hub % naccept , Hub % nreject #      ifdef _QMC_MPI junkPtr = unpack_sprng ( rndbuf ) #      endif endif return 100 call DQMC_Error ( \"cannot read HSF input file:\" , HSF_INPUT_UNIT ) 102 call DQMC_Error ( \"cannot read gamma/naccept/nreject from HSF input file\" , HSF_INPUT_UNIT ) end subroutine DQMC_Hub_Input_HSF !---------------------------------------------------------------------! subroutine DQMC_Hub_OutputParam ( Hub , OPT ) use dqmc_mpi ! ! Purpose ! ======= !    This subrotine outputs parameters of Hubbard model and !    computed results. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( in ) :: Hub ! Hubbard model integer , intent ( in ) :: OPT ! output handle ! ... Local ... character ( 35 ) :: FMT logical :: lex integer , parameter :: slice = 0 logical , parameter :: restore = . true . ! ... Executable .... if ( qmc_sim % rank == qmc_sim % aggr_root ) then write ( OPT , * ) Hub % S % Name (:) if ( Hub % n_U == 1 ) then FMT = FMT_STRDBL else write ( FMT , \"('(a30,f19.6,(',I3,'(f12.6)))')\" ) Hub % n_U - 1 end if if ( SimType . eq . Hubbard_model ) then write ( OPT , FMT ) \"                          U : \" , Hub % U elseif ( SimType . eq . Holstein_model ) then write ( OPT , FMT ) \"      el-ph coupling lambda : \" , Hub % U write ( OPT , FMT ) \"     phonon frequency omega : \" , Hub % omega end if if ( Hub % n_t == 1 ) then FMT = FMT_STRDBL else write ( FMT , \"('(a30,f19.6,(',I3,'(f12.6)))')\" ) Hub % n_t - 1 end if write ( OPT , FMT ) \"                       t_up : \" , Hub % t_up write ( OPT , FMT ) \"                       t_dn : \" , Hub % t_dn if ( Hub % n_mu == 1 ) then FMT = FMT_STRDBL else write ( FMT , \"('(a30,f19.6,(',I3,'(f12.6)))')\" ) Hub % n_mu - 1 end if write ( OPT , FMT ) \"                      mu_up : \" , Hub % mu_up write ( OPT , FMT ) \"                      mu_dn : \" , Hub % mu_dn write ( OPT , FMT_STRINT ) \"             Time slice - L : \" , Hub % L write ( OPT , FMT_STRINT ) \"            Number of sites : \" , Hub % n write ( OPT , FMT_STRDBL ) \"                       dtau : \" , Hub % dtau write ( OPT , FMT_STRDBL ) \"                       beta : \" , Hub % dtau * Hub % L write ( OPT , FMT_STRINT ) \"     Number of warmup sweep : \" , Hub % nWarm write ( OPT , FMT_STRINT ) \"Number of measurement sweep : \" , Hub % nPass write ( OPT , FMT_STRINT ) \"   Frequency of measurement : \" , Hub % nMeas write ( OPT , FMT_STRINT ) \"                Random seed : \" , Hub % idum write ( OPT , FMT_STRINT ) \" Frequency of recomputing G : \" , Hub % G_up % nWrap if ( Hub % nTry . gt . 0 ) then write ( OPT , FMT_STRINT ) \"Global move number of sites : \" , Hub % nTry end if write ( OPT , FMT_STRINT ) \"               Accept count : \" , Hub % naccept write ( OPT , FMT_STRINT ) \"               Reject count : \" , Hub % nreject write ( OPT , FMT_STRDBL ) \"    Approximate accept rate : \" , & dble ( Hub % naccept ) / dble ( Hub % naccept + Hub % nreject ) write ( OPT , FMT_STRDBL ) \"                      gamma : \" , Hub % gamma if ( Hub % nTry > 0 ) then write ( OPT , FMT_STRINT ) \"   Global move accept count : \" , Hub % nAcceptGlobal write ( OPT , FMT_STRINT ) \"   Global move reject count : \" , Hub % nRejectGlobal write ( OPT , FMT_STRDBL ) \"    Global move accept rate : \" , & dble ( Hub % nAcceptGlobal ) / dble ( Hub % nAcceptGlobal + Hub % nRejectGlobal ) end if if ( SimType . eq . Holstein_model ) then write ( OPT , FMT_STRINT ) \" Global move 2 accept count : \" , Hub % nAcceptGlobal2 write ( OPT , FMT_STRINT ) \" Global move 2 reject count : \" , Hub % nRejectGlobal2 write ( OPT , FMT_STRDBL ) \"  Global move 2 accept rate : \" , & dble ( Hub % nAcceptGlobal2 ) / dble ( Hub % nAcceptGlobal2 + Hub % nRejectGlobal2 ) end if write ( OPT , * ) \"          Type of matrix B : \" , Hub % B_up % name if ( Hub % HSFtype == HSF_DISC ) then write ( OPT , * ) \"        Type of matrix HSF : discrete\" else write ( OPT , * ) \"        Type of matrix HSF : continuous\" write ( OPT , * ) \"                   delta 1 : \" , Hub % delta1 write ( OPT , * ) \"                   delta 2 : \" , Hub % delta2 end if if ( SimType . eq . Holstein_model ) then write ( OPT , * ) \"        phonon field scale : \" , CHSF0 end if endif ! Check if the file is valid. if ( Hub % outputHSF ) then inquire ( UNIT = HSF_OUTPUT_UNIT , EXIST = lex ) if ( lex ) then call DQMC_Hub_Output_HSF ( Hub , restore , slice , HSF_OUTPUT_UNIT ) else if ( qmc_sim % rank == qmc_sim % aggr_root ) & call DQMC_Warning ( \"HSF output file is not initialized.\" , 1 ) end if end if end subroutine DQMC_Hub_OutputParam !---------------------------------------------------------------------! subroutine DQMC_Hub_Print ( Hub , OPT ) implicit none ! ! Purpose ! ======= !    This subrotine outputs parameters of Hubbard model and !    computed results. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( in ) :: Hub ! Hubbard model integer , intent ( in ) :: OPT ! output handle ! ... Executable .... call DQMC_Hub_OutputParam ( Hub , OPT ) write ( OPT , FMT_DBLINE ) call DQMC_Phy0_Print ( Hub % P0 , Hub % S , SimType , OPT ) call DQMC_Phy2_Print ( Hub % P2 , Hub % S % wlabel , OPT ) end subroutine DQMC_Hub_Print ! --------------------------------------------------------------------! subroutine DQMC_Hub_Sweep ( Hub , nMeas0 ) use dqmc_mpi ! ! Purpose ! ======= !   This subroutine performs the DQMC sweep, which is consisted of !   four steps. (See [1] for more details.) ! !      1. Swap the slice of G and recompute G if necessary. !      2. Metropolis Algorithm !      3. Update the model and perform physical measurement. !      4. Adjust parameters. ! !   The first three steps are within a big loop, which run !   through each time slice of G. The major part is the second !   step, which is explained below. ! !      1. Try the new configuration by single spin-flip sampling !         at site j at time slice i. !      2. Compute the probability of this new configuration. ! !             p =  r/(1+gamma*r)    if r < 1 !             p =  r/(gamma+r)      if r >=1 ! !         where r is the ratio of determinants of Green's function !         of spin up and spin down. !      3. If p > ran, a uniform random number in [0,1], then change !         the configuration and update the Green's function. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ), target :: Hub ! Hubbard class integer , intent ( in ) :: nMeas0 ! Duration of measurement ! ... paremeters ... integer , parameter :: DQMC_CHECK_ITER = 10000 integer , parameter :: DQMC_ADJUST = 100 real ( wp ), parameter :: DQMC_ACC_UP = 0.52_wp real ( wp ), parameter :: DQMC_ACC_LO = 0.48_wp ! ... local scalar ... integer :: i , j , n , L , m ! Loop iterator integer :: accept_cnt ! Counter for accept in Met-alg integer :: reject_cnt ! Counter for accept in Met-alg real ( wp ) :: accrat real ( wp ) :: alpha_up , alpha_dn = 0 ! Change of configuration real ( wp ) :: p , randn ! Probability of changing real ( wp ) :: r_up , r_dn , r ! Ratio of determinant real ( wp ) :: gjj ! (j,j) element of G_up or G_dn #   ifdef _QMC_MPI integer :: send_cnt ( 2 ) integer :: recv_cnt ( 2 ) #   endif ! To speed up the computation real ( wp ), pointer :: G_up (:,:) real ( wp ), pointer :: G_dn (:,:) real ( wp ), pointer :: U_up (:,:) real ( wp ), pointer :: U_dn (:,:) real ( wp ), pointer :: W_up (:,:) real ( wp ), pointer :: W_dn (:,:) real ( wp ), pointer :: V_up (:,:) real ( wp ), pointer :: V_dn (:,:) integer , pointer :: blksz_up integer , pointer :: blksz_dn real ( wp ), pointer :: sgn_up real ( wp ), pointer :: sgn_dn real ( wp ), pointer :: ranlist (:) real ( wp ), pointer :: explook (:,:) integer , pointer :: HSF (:,:) integer , pointer :: map (:) real ( wp ) :: gamma logical :: comp_dn , neg_u ! ... Executable ... !=====================! ! Step 0: Setup alias ! !=====================! G_up => Hub % G_up % G U_up => Hub % G_up % U W_up => Hub % G_up % W V_up => Hub % G_up % V blksz_up => Hub % G_up % blksz sgn_up => Hub % G_up % sgn G_dn => Hub % G_dn % G U_dn => Hub % G_dn % U W_dn => Hub % G_dn % W V_dn => Hub % G_dn % V blksz_dn => Hub % G_dn % blksz sgn_dn => Hub % G_dn % sgn ranlist => Hub % WS % R7 explook => Hub % explook HSF => Hub % HSF map => Hub % S % map gamma = Hub % gamma comp_dn = Hub % comp_dn neg_u = Hub % neg_u n = Hub % n L = Hub % L i = Hub % G_up % ilb accept_cnt = 0 reject_cnt = 0 #   ifdef _QMC_MPI send_cnt ( 1 ) = Hub % naccept send_cnt ( 2 ) = Hub % nreject #   endif do m = 1 , L !First thing see if you can make a measurement on a freshly computed G if ( Hub % G_up % wps == Hub % G_up % nWrap ) then if ( nmeas0 > 0 ) then ! Construct G_dn for mu = 0 and U > 0 using particle-hole symmetry ! Note that ( .not.neg_u .and. not.comp_dn ) implies that S%P is defined, i.e. ! S%checklist(STRUCT_PHASE) = 'T'. if (. not . neg_u . and . . not . comp_dn ) call DQMC_GFun_CopyUp ( Hub % G_dn , Hub % G_up , Hub % S % P ) !Fill GS in Hub%Gfun call DQMC_GetG_2nd_order ( Hub % G_up , Hub % B_up ) if ( comp_dn . or . . not . neg_u ) then call DQMC_GetG_2nd_order ( Hub % G_dn , Hub % B_dn ) endif ! Basic measurement call DQMC_Phy0_Meas ( Hub % n , Hub % P0 , Hub % G_up % GS , Hub % G_dn % GS , Hub % U , & Hub % mu_up , Hub % mu_dn , Hub % t_up , Hub % t_dn , sgn_up , sgn_dn , Hub % S ) if ( Hub % meas2 ) then ! Pair measurement r = sgn_up * sgn_dn call DQMC_Phy2_Meas ( n , Hub % P2 % M1 , Hub % P2 % M2 , & Hub % P2 , Hub % S % B , Hub % G_up % GS , Hub % G_dn % GS , r ) end if endif end if i = i + 1 if ( i > L . or . i < 0 ) i = 1 !==============================! ! Step 1: Swap the slice of G  ! !==============================! call DQMC_GetG ( i , Hub % G_up , Hub % SB_up ) if ( comp_dn ) then call DQMC_GetG ( i , Hub % G_dn , Hub % SB_dn ) else sgn_dn = sgn_up end if !==============================! ! Step 2: Metropolis Algorithm ! !==============================! call ran0 ( n , ranlist , Hub % seed ) ! Loop over lattice sites do j = Hub % n_start , Hub % n_end ! Try the new configuration by single spin-flip sampling ! at site j at time slice i. ! See reference [1] for more detail for these formula if ( neg_u ) then alpha_up = explook ( - 2 * HSF ( j , i ), map ( j )) - ONE alpha_dn = alpha_up else alpha_up = explook ( - 2 * HSF ( j , i ), map ( j )) - ONE alpha_dn = explook ( 2 * HSF ( j , i ), map ( j )) - ONE end if gjj = DQMC_Gfun_Getjj ( n , j , blksz_up , G_up , U_up , W_up ) r_up = ONE + ( ONE - gjj ) * alpha_up if ( comp_dn ) then gjj = DQMC_Gfun_Getjj ( n , j , blksz_dn , G_dn , U_dn , W_dn ) r_dn = ONE + ( ONE - gjj ) * alpha_dn elseif ( neg_u ) then r_dn = r_up else r_dn = ONE + gjj * alpha_dn end if r = abs ( r_up * r_dn ) if ( neg_u ) then r = r * explook ( + 2 * HSF ( j , i ), map ( j )) end if ! Compute the probability if ( r <= ONE ) then p = r / ( ONE + gamma * r ) else p = r / ( gamma + r ) end if randn = ranlist ( j ) ! Accept if ( p > randn ) then accept_cnt = accept_cnt + 1 if ( r_up < ZERO ) sgn_up = - sgn_up if ( r_dn < ZERO ) sgn_dn = - sgn_dn HSF ( j , i ) = - HSF ( j , i ) ! Update G_up call DQMC_UpdateG ( j , alpha_up / r_up , Hub % G_up ) ! invalidate the cache for B_i #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , i ) #endif V_up ( j , i ) = V_up ( j , i ) * ( alpha_up + ONE ) Hub % G_up % nModify = i Hub % G_up % det = Hub % G_up % det - log ( abs ( r_up )) ! If mu /= zero, then update G_dn as well. if ( comp_dn ) then ! Update G_dn call DQMC_UpdateG ( j , alpha_dn / r_dn , Hub % G_dn ) Hub % G_dn % det = Hub % G_dn % det - log ( abs ( r_dn )) end if if (. not . neg_u ) then #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , i ) #endif V_dn ( j , i ) = V_dn ( j , i ) * ( alpha_dn + ONE ) end if Hub % G_dn % nModify = i else reject_cnt = reject_cnt + 1 endif end do !============================! ! Step 3: Update and Measure ! !============================! ! update G_up/G_dn if there are some updates not applied. call DQMC_ApplyUpdate ( Hub % G_up , forced = . true .) if ( comp_dn ) then call DQMC_ApplyUpdate ( Hub % G_dn , forced = . true .) end if end do #   ifdef _QMC_MPI send_cnt ( 1 ) = accept_cnt send_cnt ( 2 ) = reject_cnt call mpi_allreduce ( send_cnt , recv_cnt , 2 , MPI_INT , MPI_SUM , MPI_COMM_WORLD , m ) accept_cnt = recv_cnt ( 1 ) reject_cnt = recv_cnt ( 2 ) #   endif ! update accept and reject counts Hub % naccept = Hub % naccept + accept_cnt Hub % nreject = Hub % nreject + reject_cnt !===========================! ! Step 4: Adjust parameters ! !===========================! if ( Hub % naccept + Hub % nreject > DQMC_CHECK_ITER ) then accrat = dble ( Hub % naccept ) / dble ( Hub % naccept + Hub % nreject ) if ( accrat > DQMC_ACC_UP . or . accrat < DQMC_ACC_LO ) then Hub % gamma = Hub % gamma + ( accrat - HALF ) Hub % gamma = dmax1 ( ZERO , Hub % gamma ) Hub % gamma = dmin1 ( ONE , Hub % gamma ) Hub % naccept = int ( DQMC_ADJUST * accrat ) Hub % nreject = int ( DQMC_ADJUST * ( ONE - accrat )) endif endif !Update nwrap. Stop doing it if measurements are performed !every nwrap to ensure bins contains same number of measurements. if ( nmeas0 <= 0 ) then call DQMC_UpdateWraps ( Hub % G_up ) if ( comp_dn ) then call DQMC_UpdateWraps ( Hub % G_dn ) call DQMC_SyncWraps ( Hub % G_up , Hub % G_dn ) end if endif end subroutine DQMC_Hub_Sweep !---------------------------------------------------------------------! subroutine DQMC_Hub_Sweep2 ( Hub , numTry ) ! ! Purpose ! ======= !   This subroutine performs the global moves of DQMC sweep, in which !   all the Hub(i) on some selected sites are flipped for all slice. ! !      1. Try the new configuration. !      2. Compute the probability of this new configuration. ! !             p =  r/(1+gamma*r)    if r < 1 !             p =  r/(gamma+r)      if r >=1 ! !         where r is the ratio of determinants of Green's function !         of spin up and spin down. !      3. If p > ran, a uniform random number in [0,1], then change !         the configuration and update the Green's function. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model integer , intent ( in ) :: numTry ! Number of Try ! ... Local Variables ... real ( wp ) :: ranList ( numTry ), rat , ratexp , ranSlice ( 1 ) integer :: i , j , n , L , accept , tmp , nSite , tslice real ( wp ) :: det_up , det_dn , new_up , new_dn real ( wp ) :: copy_sgn_up , copy_sgn_dn integer , pointer :: map (:) integer :: siteList ( Hub % n ), site ( numTry ) integer :: hs_sum ! sum over HS fields at site, for U<0 ! ... Executable ... n = Hub % n L = Hub % L accept = 0 if ( numTry <= 0 ) return Map => Hub % S % Map call ran0 ( 1 , ranSlice , Hub % seed ) tslice = ceiling ( ranSlice ( 1 ) * L ) ! Compute the Green's matrix and the sign Hub % G_up % ilb = - 1 call DQMC_GetG ( tslice , Hub % G_up , Hub % SB_up ) det_up = Hub % G_up % det if ( Hub % comp_dn ) then Hub % G_dn % ilb = - 1 call DQMC_GetG ( tslice , Hub % G_dn , Hub % SB_dn ) det_dn = Hub % G_dn % det elseif ( Hub % neg_u ) then det_dn = det_up Hub % G_dn % sgn = Hub % G_up % sgn else ! Note that here we have .not.neg_u and not.comp_dn. ! This implies that S%P is defined, i.e. S%checklist(STRUCT_PHASE) = 'T'. ! So we can safely call DQMC_Gfun_CopyUp() which uses particle-hole symmetry. call DQMC_Gfun_CopyUp ( Hub % G_dn , Hub % G_up , Hub % S % P ) det_dn = Hub % G_dn % det end if ! get random numbers call ran0 ( numTry , ranList , Hub % seed ) nsite = Hub % n_End - Hub % n_start + 1 siteList ( 1 : nSite ) = Hub % n_Start + ( / ( i , i = 0 , nSite - 1 ) / ) ! generate sites do i = 1 , numtry tmp = int ( ranList ( i ) * nSite ) + 1 site ( i ) = siteList ( tmp ) ! compress the list do j = tmp + 1 , nSite siteList ( j - 1 ) = siteList ( j ) end do nSite = nSite - 1 end do call ran0 ( numTry , ranList , Hub % seed ) ! Global move do i = 1 , numTry ! Flip its HS field for all the slices do j = 1 , L tmp = - Hub % HSF ( site ( i ), j ) Hub % HSF ( site ( i ), j ) = tmp #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , j ) #endif Hub % V_up ( site ( i ), j ) = Hub % explook ( tmp , map ( site ( i ))) if (. not . Hub % neg_u ) then #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , j ) #endif Hub % V_dn ( site ( i ), j ) = Hub % explook ( - tmp , map ( site ( i ))) end if end do ! Store the value of G first Hub % G_up % tmp = Hub % G_up % G if ( Hub % comp_dn ) then Hub % G_dn % tmp = Hub % G_dn % G end if copy_sgn_up = Hub % G_up % sgn copy_sgn_dn = Hub % G_dn % sgn ! Compute G with new configuration Hub % G_up % ilb = - 1 call DQMC_GetG ( tslice , Hub % G_up , Hub % SB_up ) new_up = Hub % G_up % det if ( Hub % comp_dn ) then Hub % G_dn % ilb = - 1 call DQMC_GetG ( tslice , Hub % G_dn , Hub % SB_dn ) new_dn = Hub % G_dn % det elseif ( Hub % neg_u ) then Hub % G_dn % sgn = Hub % G_up % sgn new_dn = new_up else ! Note that here we have (.not.neg_u) and (.not.comp_dn). ! This implies that S%P is defined, i.e. S%checklist(STRUCT_PHASE) = 'T'. ! So we can safely call DQMC_Gfun_CopyUp() which uses particle-hole symmetry. call DQMC_Gfun_CopyUp ( Hub % G_dn , Hub % G_up , Hub % S % P ) new_dn = Hub % G_dn % det end if ! Compute the Det ratio ! NB: the determinant computed by GetG is log(abs(det(G))) !     Here we need log(abs(Z))= -log(abs(det(G))) rat = det_up + det_dn - new_up - new_dn if ( Hub % neg_u ) then hs_sum = 0 do j = 1 , L hs_sum = hs_sum + Hub % HSF ( site ( i ), j ) end do ! extra factor for U<0: exp(2 * lambda * Sum(l, s_new(i, l))) rat = rat - 2 * Hub % explook ( 0 , map ( site ( i ))) * hs_sum end if if ( rat > ZERO ) then ratexp = ONE else ratexp = exp ( rat ) end if ! Compare the ratio to a random number if ( ratexp >= ranList ( i )) then ! accept det_up = new_up det_dn = new_dn accept = accept + 1 else ! reject ! recover the old values Hub % G_up % G = Hub % G_up % tmp if ( Hub % comp_dn ) then Hub % G_dn % G = Hub % G_dn % tmp end if Hub % G_up % sgn = copy_sgn_up Hub % G_dn % sgn = copy_sgn_dn do j = 1 , L tmp = - Hub % HSF ( site ( i ), j ) Hub % HSF ( site ( i ), j ) = tmp #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , j ) #endif Hub % V_up ( site ( i ), j ) = Hub % explook ( tmp , map ( site ( i ))) if (. not . Hub % neg_u ) then #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , j ) #endif Hub % V_dn ( site ( i ), j ) = Hub % explook ( - tmp , map ( site ( i ))) end if end do end if end do !Update determinant value Hub % G_up % det = det_up if ( Hub % comp_dn ) then Hub % G_dn % det = det_dn endif ! update G's counter Hub % G_up % wps = Hub % G_up % nWrap Hub % G_dn % wps = Hub % G_dn % nWrap ! update accept and reject counts Hub % nAcceptGlobal = Hub % nAcceptGlobal + accept Hub % nRejectGlobal = Hub % nRejectGlobal + ( numTry - accept ) end subroutine DQMC_Hub_Sweep2 !---------------------------------------------------------------------! ! sweep for continuous HSF ! --------------------------------------------------------------------! subroutine DQMC_Hub_Sweep_Cont ( Hub , nMeas0 ) ! ! Purpose ! ======= !   This subroutine performs the DQMC sweep, which is consisted of !   four steps. (See [1] for more details.) ! !      1. Swap the slice of G and recompute G if necessary. !      2. Metropolis Algorithm !      3. Update the model and perform physical measurement. !      4. Adjust parameters. ! !   The first three steps are within a big loop, which run !   through each time slice of G. The major part is the second !   step, which is explained below. ! !      1. Try the new configuration by single spin-flip sampling !         at site j at time slice i. !      2. Compute the probability of this new configuration. ! !             p =  r/(1+gamma*r)    if r < 1 !             p =  r/(gamma+r)      if r >=1 ! !         where r is the ratio of determinants of Green's function !         of spin up and spin down. !      3. If p > ran, a uniform random number in [0,1], then change !         the configuration and update the Green's function. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ), target :: Hub ! Hubbard model integer , intent ( in ) :: nMeas0 ! Duration of measurement ! ... paremeters ... integer , parameter :: DQMC_CHECK_ITER = 10000 integer , parameter :: DQMC_ADJUST = 100 real ( wp ), parameter :: DQMC_ACC_UP = 0.52_wp real ( wp ), parameter :: DQMC_ACC_LO = 0.48_wp ! ... local scalar ... integer :: i , j , k , n , L ! Loop iterator integer :: cnt ! Counter for measurement integer :: accept , reject ! Counter for accept in Met-alg real ( wp ) :: accrat real ( wp ) :: alpha_up , alpha_dn ! Change of configuration real ( wp ) :: p , randn ! Probability of changing real ( wp ) :: r_up , r_dn , r ! Ratio of determinant real ( wp ) :: gjj_up , gjj_dn ! (j,j) element of G_up or G_dn ! To speed up the computation real ( wp ), pointer :: G_up (:,:) real ( wp ), pointer :: G_dn (:,:) real ( wp ), pointer :: U_up (:,:) real ( wp ), pointer :: U_dn (:,:) real ( wp ), pointer :: W_up (:,:) real ( wp ), pointer :: W_dn (:,:) real ( wp ), pointer :: V_up (:,:) real ( wp ), pointer :: V_dn (:,:) integer , pointer :: blksz_up integer , pointer :: blksz_dn real ( wp ), pointer :: sgn_up real ( wp ), pointer :: sgn_dn real ( wp ), pointer :: ranlist (:) real ( wp ), pointer :: CHSF (:,:) real ( wp ), pointer :: lambda (:) integer , pointer :: map (:) real ( wp ) :: gamma , edx , delta1 , dx , dE , dPE , dKE logical :: comp_dn , neg_u ! ... Executable ... !=====================! ! Step 0: Setup alias ! !=====================! G_up => Hub % G_up % G U_up => Hub % G_up % U W_up => Hub % G_up % W V_up => Hub % G_up % V blksz_up => Hub % G_up % blksz sgn_up => Hub % G_up % sgn G_dn => Hub % G_dn % G U_dn => Hub % G_dn % U W_dn => Hub % G_dn % W V_dn => Hub % G_dn % V blksz_dn => Hub % G_dn % blksz sgn_dn => Hub % G_dn % sgn ranlist => Hub % WS % R7 CHSF => Hub % CHSF map => Hub % S % map lambda => Hub % lambda comp_dn = Hub % comp_dn neg_u = Hub % neg_u gamma = Hub % gamma n = Hub % n cnt = nMeas0 L = Hub % L delta1 = Hub % delta1 ! This is a reminder: ! comp_dn = .false. if !   1) U <= 0 !   2) U > 0 and mu = 0 and bipartitle lattice !   3) Holstein model ! Loop over time slices do i = 1 , L !==============================! ! Step 1: Swap the slice of G  ! !==============================! call DQMC_GetG ( i , Hub % G_up , Hub % SB_up ) if ( comp_dn ) then call DQMC_GetG ( i , Hub % G_dn , Hub % SB_dn ) else sgn_dn = sgn_up end if !==============================! ! Step 2: Metropolis Algorithm ! !==============================! accept = 0 reject = 0 call ran0 ( 2 * n , ranlist , Hub % seed ) ! Loop over lattice sites do j = Hub % n_start , Hub % n_end ! propose a new move dx = delta1 * ( ranlist ( j + n ) - HALF ) ! Hubbard model mode if ( SimType . eq . Hubbard_model ) then ! Remember positive and negative U use different HS transfoamtaions if ( neg_u ) then alpha_up = exp ( lambda ( map ( j )) * dx ) - ONE alpha_dn = alpha_up else alpha_up = exp ( lambda ( map ( j )) * dx ) - ONE alpha_dn = exp ( - lambda ( map ( j )) * dx ) - ONE !alpha_dn = ONE/edx - ONE end if ! Compute the ratio of new and old partition functions gjj_up = DQMC_Gfun_Getjj ( n , j , blksz_up , G_up , U_up , W_up ) r_up = ONE + ( ONE - gjj_up ) * alpha_up ! Need to compute r_dn explicitly if not on the half-filled bipartite lattices if ( comp_dn ) then gjj_dn = DQMC_Gfun_Getjj ( n , j , blksz_dn , G_dn , U_dn , W_dn ) r_dn = ONE + ( ONE - gjj_dn ) * alpha_dn ! Spin up and down ratio are identical for negative U else if ( neg_u ) then r_dn = r_up ! For positive U and on half-filled bipartite lattices, r_dn can be computed from gjj_up else r_dn = ONE + gjj_up * alpha_dn end if ! dE = [(x+dx)&#94;2-x&#94;2]/2 = x*dx + dx*dx/2 dE = CHSF ( j , i ) * dx + 0.5_wp * dx * dx ! Holstein model else if ( SimType . eq . Holstein_model ) then alpha_up = exp ( lambda ( map ( j )) * dx ) - ONE gjj_up = DQMC_Gfun_Getjj ( n , j , blksz_up , G_up , U_up , W_up ) r_up = ONE + ( ONE - gjj_up ) * alpha_up alpha_dn = alpha_up r_dn = r_up ! phonon potential energy difference dPE = 2.0_wp * CHSF ( j , i ) * dx + dx * dx ! phonon kinetic energy difference if ( i . eq . 1 ) then !dKE = 2.0_wp*( 2.0_wp*CHSF(j,i)*dx + dx*dx - dx*( CHSF(j, L)   + CHSF(j,i+1) ) ) dKE = 2.0_wp * ( dPE - dx * ( CHSF ( j , L ) + CHSF ( j , i + 1 ) ) ) elseif ( i . eq . L ) then !dKE = 2.0_wp*( 2.0_wp*CHSF(j,i)*dx + dx*dx - dx*( CHSF(j, i-1) + CHSF(j,1)   ) ) dKE = 2.0_wp * ( dPE - dx * ( CHSF ( j , i - 1 ) + CHSF ( j , 1 ) ) ) else !dKE = 2.0_wp*( 2.0_wp*CHSF(j,i)*dx + dx*dx - dx*( CHSF(j, i-1) + CHSF(j,i+1) ) ) dKE = 2.0_wp * ( dPE - dx * ( CHSF ( j , i - 1 ) + CHSF ( j , i + 1 ) ) ) end if dE = dKE * norm_phonon ( 1 ) + dPE * norm_phonon ( 2 ) end if r = abs ( r_up * r_dn ) * exp ( - dE ) ! Compute the probability if ( r <= ONE ) then p = r / ( ONE + gamma * r ) else p = r / ( gamma + r ) end if randn = ranlist ( j ) ! Accept if ( p > randn ) then accept = accept + 1 if ( r_up < ZERO ) sgn_up = - sgn_up if ( r_dn < ZERO ) sgn_dn = - sgn_dn CHSF ( j , i ) = CHSF ( j , i ) + dx ! Update G_up call DQMC_UpdateG ( j , alpha_up / r_up , Hub % G_up ) #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , i ) #endif V_up ( j , i ) = V_up ( j , i ) * ( alpha_up + ONE ) Hub % G_up % nModify = i Hub % G_up % det = Hub % G_up % det - log ( abs ( r_up )) ! Update G_dn when it is necessary if ( comp_dn ) then call DQMC_UpdateG ( j , alpha_dn / r_dn , Hub % G_dn ) Hub % G_dn % det = Hub % G_dn % det - log ( abs ( r_dn )) end if if (. not . neg_u ) then #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , i ) #endif V_dn ( j , i ) = V_dn ( j , i ) * ( alpha_dn + ONE ) Hub % G_dn % det = Hub % G_dn % det - log ( abs ( r_dn )) end if Hub % G_dn % nModify = i else ! If reject, advance the counter then move on. reject = reject + 1 end if end do !============================! ! Step 3: Update and Measure ! !============================! ! update G_up/G_dn if there are some updates not applied. call DQMC_ApplyUpdate ( Hub % G_up , forced = . true .) if ( comp_dn ) then call DQMC_ApplyUpdate ( Hub % G_dn , forced = . true .) end if ! update accept and reject counts Hub % naccept = Hub % naccept + accept Hub % nreject = Hub % nreject + reject !cnt = cnt - 1 !if (cnt == 0) then !   ! construct G_dn for mu = 0 !   if (.not.Hub%neg_u .and. .not.Hub%comp_dn) then !      do k = 1,n !         do j = 1,n !            G_dn(k,j) = -Hub%S%P(k)*Hub%S%P(j)*G_up(j,k) !         end do !         G_dn(k,k) = G_dn(k,k) + ONE !      end do !   end if !   ! Basic measurement !   !call DQMC_Phy0_Meas(Hub%n, Hub%P0, G_up, G_dn, & !   !     Hub%U, Hub%mu_up, Hub%mu_dn, Hub%t_up, Hub%t_dn, sgn_up, sgn_dn, Hub%S) !   !if (Hub%meas2) then !   !   ! Pair measurement !   !   r = sgn_up*sgn_dn !   !   call DQMC_Phy2_Meas(n, Hub%P2%M1, Hub%P2%M2, & !   !        Hub%P2, Hub%S%B, G_up, G_dn, r) !   ! !   !end if !   ! Reset the counter !   cnt = nMeas0 !end if end do !===========================! ! Step 4: Adjust parameters ! !===========================! if ( Hub % naccept + Hub % nreject > DQMC_CHECK_ITER ) then accrat = float ( Hub % naccept ) / float ( Hub % naccept + Hub % nreject ) if ( accrat > DQMC_ACC_UP . or . accrat < DQMC_ACC_LO ) then Hub % gamma = Hub % gamma + ( accrat - HALF ) Hub % gamma = dmax1 ( ZERO , Hub % gamma ) Hub % gamma = dmin1 ( ONE , Hub % gamma ) Hub % naccept = int ( DQMC_ADJUST * accrat ) Hub % nreject = int ( DQMC_ADJUST * ( ONE - accrat )) endif endif call DQMC_UpdateWraps ( Hub % G_up ) if ( comp_dn ) then call DQMC_UpdateWraps ( Hub % G_dn ) end if end subroutine DQMC_Hub_Sweep_Cont !---------------------------------------------------------------------! subroutine DQMC_Hub_Sweep2_Cont ( Hub , numTry ) ! ! Purpose ! ======= !   This subroutine performs the global moves of DQMC sweep, in which !   all the Hub(i) on some selected sites are flipped for all slice. ! !      1. Try the new configuration. !      2. Compute the probability of this new configuration. ! !             p =  r/(1+gamma*r)    if r < 1 !             p =  r/(gamma+r)      if r >=1 ! !         where r is the ratio of determinants of Green's function !         of spin up and spin down. !      3. If p > ran, a uniform random number in [0,1], then change !         the configuration and update the Green's function. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model integer , intent ( in ) :: numTry ! Number of Try ! ... Local Variables ... integer , pointer :: map (:) real ( wp ), pointer :: CHSF (:,:) integer :: i , j , k , n , L , si , sj , tmp , nSite , accept , reject integer :: siteList ( Hub % n ) integer :: slice ( numTry ), site ( numTry ) real ( wp ) :: ranList ( 2 * numTry ), rat , ratexp real ( wp ) :: det_up , det_dn , new_up , new_dn real ( wp ) :: copy_sgn_up , copy_sgn_dn , delta2 , dx real ( wp ) :: G_dn_tmp ( Hub % n , Hub % n ) real ( wp ) :: E_old , E_new logical :: compute_dn , neg_u ! ... Executable ... if ( numTry <= 0 ) return compute_dn = Hub % comp_dn . or . . not . Hub % neg_u neg_u = Hub % neg_u n = Hub % n L = Hub % L accept = 0 reject = 0 delta2 = Hub % delta2 map => Hub % S % map CHSF => Hub % CHSF ! Compute the Green's matrix and the sign #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( Hub % G_up % cpp_data , L , Hub % G_up % sgn , & Hub % G_up % G , Hub % V_up , Hub % SB_up % B % B , & Hub % SB_up % nOrth , det_up ) #else call DQMC_ComputeG ( L , n , Hub % G_up % sgn , Hub % G_up % G , Hub % V_up , & Hub % SB_up , Hub % G_up % pvt , . true ., det_up , HUb % G_up % sxx ) #endif if ( compute_dn ) then #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( Hub % G_dn % cpp_data , L , Hub % G_dn % sgn , & Hub % G_dn % G , Hub % V_dn , Hub % SB_dn % B % B , & Hub % SB_dn % nOrth , det_dn ) #else call DQMC_ComputeG ( L , n , Hub % G_dn % sgn , Hub % G_dn % G , Hub % V_dn , & Hub % SB_dn , Hub % G_dn % pvt , . true ., det_dn , Hub % G_dn % sxx ) #endif else det_dn = det_up Hub % G_dn % sgn = Hub % G_up % sgn end if ! get random numbers call ran0 ( 2 * numTry , ranList , Hub % seed ) nsite = Hub % n_End - Hub % n_start + 1 siteList ( 1 : nSite ) = Hub % n_Start + ( / ( i , i = 0 , nSite - 1 ) / ) ! generate sites do i = 1 , numtry tmp = int ( ranList ( i ) * nSite ) + 1 site ( i ) = siteList ( tmp ) ! compress the list do j = tmp + 1 , nSite siteList ( j - 1 ) = siteList ( j ) end do nSite = nSite - 1 end do ! generate slice do i = 1 , numtry tmp = int ( ranList ( i + numTry ) * L ) + 1 slice ( i ) = tmp end do call ran0 ( numTry , ranList , Hub % seed ) ! Global move do i = 1 , numTry si = site ( i ) !sj = slice(i) if ( SimType . eq . Hubbard_model ) then E_old = 0.0_wp E_new = 0.0_wp do j = 1 , L !CHSF (si,sj) = CHSF(site(i),sj) + dx !CHSF (si,sj) = CHSF(si,sj) + dx dx = delta2 * ( ranlist ( i ) - 0.5d0 ) ! compute the old Gaussian exponent E_old = E_old - 0.5_wp * CHSF ( si , j ) * CHSF ( si , j ) ! update fields at all time slices at site index si CHSF ( si , j ) = CHSF ( si , j ) + dx ! compute the new Gaussian exponent E_new = E_new - 0.5_wp * CHSF ( si , j ) * CHSF ( si , j ) #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , sj ) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , sj ) #endif !Hub%V_up(si,sj) = exp(Hub%lambda(Hub%S%map(sj))*CHSF(si,sj)) !Hub%V_dn(si,sj) = exp(-Hub%lambda(Hub%S%map(sj))*CHSF(si,sj)) Hub % V_up ( si , j ) = exp ( Hub % lambda ( Hub % S % map ( si )) * CHSF ( si , j )) if ( neg_u ) then Hub % V_dn ( si , j ) = Hub % V_up ( si , j ) else Hub % V_dn ( si , j ) = exp ( - Hub % lambda ( Hub % S % map ( si )) * CHSF ( si , j )) end if end do else if ( SimType . eq . Holstein_model ) then E_old = 0.0_wp E_new = 0.0_wp !subroutine PHONON_ACTION(L, norm, x, Sb) call Phonon_Action ( L , norm_phonon , CHSF ( si ,:), E_old ) dx = delta2 * ( ranlist ( i ) - 0.5d0 ) do j = 1 , L ! update fields at all time slices at site index si CHSF ( si , j ) = CHSF ( si , j ) + dx #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , sj ) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , sj ) #endif Hub % V_up ( si , j ) = exp ( Hub % lambda ( Hub % S % map ( si )) * CHSF ( si , j )) if ( neg_u ) then Hub % V_dn ( si , j ) = Hub % V_up ( si , j ) else Hub % V_dn ( si , j ) = exp ( - Hub % lambda ( Hub % S % map ( si )) * CHSF ( si , j )) end if end do call Phonon_Action ( L , norm_phonon , CHSF ( si ,:), E_new ) end if ! Store the value of G first Hub % G_up % tmp = Hub % G_up % G if ( compute_dn ) then G_dn_tmp = Hub % G_dn % G end if copy_sgn_up = Hub % G_up % sgn copy_sgn_dn = Hub % G_dn % sgn ! Compute G with new configuration #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( Hub % G_up % cpp_data , L , n , & Hub % G_up % sgn , Hub % G_up % G , Hub % V_up , Hub % SB_up % B % B , & Hub % SB_up % L , Hub % SB_up % nOrth , new_up ) #else call DQMC_ComputeG ( L , n , Hub % G_up % sgn , Hub % G_up % G , Hub % V_up , & Hub % SB_up , Hub % G_up % pvt , . true ., new_up , Hub % G_up % sxx ) #endif if ( compute_dn ) then #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( Hub % G_up % cpp_data , L , n , & Hub % G_dn % sgn , Hub % G_dn % G , Hub % V_dn , Hub % SB_dn % B % B , & Hub % SB_dn % L , Hub % SB_dn % nOrth , new_dn ) #else call DQMC_ComputeG ( L , n , Hub % G_dn % sgn , Hub % G_dn % G , Hub % V_dn , & Hub % SB_dn , Hub % G_dn % pvt , . true ., new_dn , Hub % G_up % sxx ) #endif else new_dn = new_up Hub % G_dn % sgn = Hub % G_up % sgn end if ! Compute the Det ratio ! NB: the determinant computed by GetG is log(abs(det(G))) !     Here we need log(abs(Z))= -log(abs(det(G))) rat = det_up + det_dn - new_up - new_dn ratexp = exp ( rat ) ratexp = ratexp * exp ( E_new - E_old ) ! Compare the ratio to a random number ! add random number if ( ratexp >= ranList ( i )) then ! accept det_up = new_up det_dn = new_dn accept = accept + 1 ! update G's counter !Hub%G_up%wps = Hub%G_up%nWrap !Hub%G_dn%wps = Hub%G_dn%nWrap else ! reject ! recover the old values Hub % G_up % G = Hub % G_up % tmp if ( compute_dn ) then Hub % G_dn % G = G_dn_tmp end if Hub % G_up % sgn = copy_sgn_up Hub % G_dn % sgn = copy_sgn_dn reject = reject + 1 !sj = slice(i) do j = 1 , L CHSF ( si , j ) = CHSF ( si , j ) - dx #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , sj ) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , sj ) #endif !Hub%V_up(si,sj) = exp(Hub%lambda(Hub%S%map(sj))*CHSF(si,sj)) !Hub%V_dn(si,sj) = exp(-Hub%lambda(Hub%S%map(sj))*CHSF(si,sj)) Hub % V_up ( si , j ) = exp ( Hub % lambda ( Hub % S % map ( si )) * CHSF ( si , j )) if ( neg_u ) then Hub % V_dn ( si , j ) = Hub % V_up ( si , j ) else Hub % V_dn ( si , j ) = exp ( - Hub % lambda ( Hub % S % map ( si )) * CHSF ( si , j )) end if end do end if end do !Update determinant value Hub % G_up % det = det_up if ( Hub % comp_dn ) then Hub % G_dn % det = det_dn endif ! update G's counter Hub % G_up % wps = Hub % G_up % nWrap Hub % G_dn % wps = Hub % G_dn % nWrap ! update accept and reject counts !Hub%naccept = Hub%naccept + accept !Hub%nreject = Hub%nreject + (numTry-accept) Hub % nAcceptGlobal = Hub % nAcceptGlobal + accept Hub % nRejectGlobal = Hub % nRejectGlobal + ( numTry - accept ) do k = 1 , L write ( * , '(A,f6.2,1x,f6.2,1x,f6.2,1x,f6.2)' ) 'Sweep2' , CHSF ( 1 , k ), CHSF ( 2 , k ), CHSF ( 3 , k ), CHSF ( 4 , k ) end do contains subroutine PHONON_ACTION ( L , norm , x , Sb ) implicit none integer , intent ( in ) :: L real ( wp ), intent ( in ) :: norm ( 2 ) real ( wp ), intent ( in ) :: x ( L ) real ( wp ), intent ( inout ) :: Sb integer :: iL real ( wp ) :: Ptmp , Ktmp Ptmp = 0.0_wp Ktmp = 0.0_wp do iL = 1 , L - 1 Ptmp = Ptmp - x ( iL ) * x ( iL ) Ktmp = Ktmp - ( x ( iL ) - x ( iL + 1 ) ) * ( x ( iL ) - x ( iL + 1 ) ) end do Ptmp = Ptmp - x ( L ) * x ( L ) Ktmp = Ktmp - ( x ( L ) - x ( 1 ) ) * ( x ( L ) - X ( 1 ) ) Sb = Ktmp * norm ( 1 ) + Ptmp * norm ( 2 ) return end subroutine PHONON_ACTION end subroutine DQMC_Hub_Sweep2_Cont !---------------------------------------------------------------------! subroutine DQMC_Hol_Sweep3_Cont ( Hub , numTry ) ! ! Purpose ! ======= !   This subroutine performs the global moves of DQMC sweep, in which !   all the Hub(i) on some selected sites are flipped for all slice. ! !      1. Try the new configuration. !      2. Compute the probability of this new configuration. ! !             p =  r/(1+gamma*r)    if r < 1 !             p =  r/(gamma+r)      if r >=1 ! !         where r is the ratio of determinants of Green's function !         of spin up and spin down. !      3. If p > ran, a uniform random number in [0,1], then change !         the configuration and update the Green's function. ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model integer , intent ( in ) :: numTry ! Number of Try ! ... Local Variables ... integer , pointer :: map (:) real ( wp ), pointer :: CHSF (:,:) integer :: i , j , k , n , L , si , sj , tmp , nSite , accept , reject integer :: siteList ( Hub % n ) integer :: slice ( numTry ), site ( numTry ) real ( wp ) :: ranList ( 2 * numTry ), rat , ratexp real ( wp ) :: det_up , det_dn , new_up , new_dn real ( wp ) :: copy_sgn_up , copy_sgn_dn , delta2 , dx real ( wp ) :: G_dn_tmp ( Hub % n , Hub % n ) real ( wp ) :: E_old , E_new logical :: compute_dn , neg_u ! ... Executable ... if ( numTry <= 0 ) return compute_dn = Hub % comp_dn . or . . not . Hub % neg_u neg_u = Hub % neg_u n = Hub % n L = Hub % L accept = 0 reject = 0 delta2 = Hub % delta2 map => Hub % S % map CHSF => Hub % CHSF ! Compute the Green's matrix and the sign #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( Hub % G_up % cpp_data , L , Hub % G_up % sgn , & Hub % G_up % G , Hub % V_up , Hub % SB_up % B % B , & Hub % SB_up % nOrth , det_up ) #else call DQMC_ComputeG ( L , n , Hub % G_up % sgn , Hub % G_up % G , Hub % V_up , & Hub % SB_up , Hub % G_up % pvt , . true ., det_up , HUb % G_up % sxx ) #endif if ( compute_dn ) then #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( Hub % G_dn % cpp_data , L , Hub % G_dn % sgn , & Hub % G_dn % G , Hub % V_dn , Hub % SB_dn % B % B , & Hub % SB_dn % nOrth , det_dn ) #else call DQMC_ComputeG ( L , n , Hub % G_dn % sgn , Hub % G_dn % G , Hub % V_dn , & Hub % SB_dn , Hub % G_dn % pvt , . true ., det_dn , Hub % G_dn % sxx ) #endif else det_dn = det_up Hub % G_dn % sgn = Hub % G_up % sgn end if ! get random numbers call ran0 ( 2 * numTry , ranList , Hub % seed ) nsite = Hub % n_End - Hub % n_start + 1 siteList ( 1 : nSite ) = Hub % n_Start + ( / ( i , i = 0 , nSite - 1 ) / ) ! generate sites do i = 1 , numtry tmp = int ( ranList ( i ) * nSite ) + 1 site ( i ) = siteList ( tmp ) ! compress the list do j = tmp + 1 , nSite siteList ( j - 1 ) = siteList ( j ) end do nSite = nSite - 1 end do ! generate slice do i = 1 , numtry tmp = int ( ranList ( i + numTry ) * L ) + 1 slice ( i ) = tmp end do call ran0 ( numTry , ranList , Hub % seed ) ! Global move do i = 1 , numTry si = site ( i ) !sj = slice(i) if ( SimType . eq . Hubbard_model ) then write ( * , * ) ' No Sweep3 for Hubbard model.' else if ( SimType . eq . Holstein_model ) then E_old = 0.0_wp E_new = 0.0_wp !subroutine PHONON_ACTION(L, norm, x, Sb) call Phonon_Action ( L , norm_phonon , CHSF ( si ,:), E_old ) dx = 2.0d0 * Hub % lambda ( map ( si )) / (( Hub % omega ) ** 2 ) / Hub % dtau do j = 1 , L ! update fields at all time slices at site index si CHSF ( si , j ) = - CHSF ( si , j ) + dx #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , sj ) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , sj ) #endif Hub % V_up ( si , j ) = exp ( Hub % lambda ( map ( si )) * CHSF ( si , j )) if ( neg_u ) then Hub % V_dn ( si , j ) = Hub % V_up ( si , j ) else Hub % V_dn ( si , j ) = exp ( - Hub % lambda ( Hub % S % map ( si )) * CHSF ( si , j )) end if end do call Phonon_Action ( L , norm_phonon , CHSF ( si ,:), E_new ) end if ! Store the value of G first Hub % G_up % tmp = Hub % G_up % G if ( compute_dn ) then G_dn_tmp = Hub % G_dn % G end if copy_sgn_up = Hub % G_up % sgn copy_sgn_dn = Hub % G_dn % sgn ! Compute G with new configuration #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( Hub % G_up % cpp_data , L , n , & Hub % G_up % sgn , Hub % G_up % G , Hub % V_up , Hub % SB_up % B % B , & Hub % SB_up % L , Hub % SB_up % nOrth , new_up ) #else call DQMC_ComputeG ( L , n , Hub % G_up % sgn , Hub % G_up % G , Hub % V_up , & Hub % SB_up , Hub % G_up % pvt , . true ., new_up , Hub % G_up % sxx ) #endif if ( compute_dn ) then #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( Hub % G_up % cpp_data , L , n , & Hub % G_dn % sgn , Hub % G_dn % G , Hub % V_dn , Hub % SB_dn % B % B , & Hub % SB_dn % L , Hub % SB_dn % nOrth , new_dn ) #else call DQMC_ComputeG ( L , n , Hub % G_dn % sgn , Hub % G_dn % G , Hub % V_dn , & Hub % SB_dn , Hub % G_dn % pvt , . true ., new_dn , Hub % G_up % sxx ) #endif else new_dn = new_up Hub % G_dn % sgn = Hub % G_up % sgn end if ! Compute the Det ratio ! NB: the determinant computed by GetG is log(abs(det(G))) !     Here we need log(abs(Z))= -log(abs(det(G))) rat = det_up + det_dn - new_up - new_dn !       if (rat > ZERO) then !          ratexp = ONE !       else ratexp = exp ( rat ) !       end if ratexp = ratexp * exp ( E_new - E_old ) ! Compare the ratio to a random number ! add random number if ( ratexp >= ranList ( i )) then ! accept det_up = new_up det_dn = new_dn accept = accept + 1 ! update G's counter !Hub%G_up%wps = Hub%G_up%nWrap !Hub%G_dn%wps = Hub%G_dn%nWrap else ! reject ! recover the old values Hub % G_up % G = Hub % G_up % tmp if ( compute_dn ) then Hub % G_dn % G = G_dn_tmp end if Hub % G_up % sgn = copy_sgn_up Hub % G_dn % sgn = copy_sgn_dn reject = reject + 1 !sj = slice(i) do j = 1 , L !             dx = 2.0d0*Hub%lambda(Hub%S%map(si))/(Hub%omega**2)/Hub%dtau CHSF ( si , j ) = - CHSF ( si , j ) + dx #if defined(DQMC_ASQRD) call cpp_gfun_invalid_cache ( Hub % G_up % cpp_data , sj ) call cpp_gfun_invalid_cache ( Hub % G_dn % cpp_data , sj ) #endif !Hub%V_up(si,sj) = exp(Hub%lambda(Hub%S%map(sj))*CHSF(si,sj)) !Hub%V_dn(si,sj) = exp(-Hub%lambda(Hub%S%map(sj))*CHSF(si,sj)) Hub % V_up ( si , j ) = exp ( Hub % lambda ( map ( si )) * CHSF ( si , j )) if ( neg_u ) then Hub % V_dn ( si , j ) = Hub % V_up ( si , j ) else Hub % V_dn ( si , j ) = exp ( - Hub % lambda ( Hub % S % map ( si )) * CHSF ( si , j )) end if end do end if end do !Update determinant value Hub % G_up % det = det_up if ( Hub % comp_dn ) then Hub % G_dn % det = det_dn endif ! update G's counter Hub % G_up % wps = Hub % G_up % nWrap Hub % G_dn % wps = Hub % G_dn % nWrap ! update accept and reject counts !Hub%naccept = Hub%naccept + accept !Hub%nreject = Hub%nreject + (numTry-accept) Hub % nAcceptGlobal2 = Hub % nAcceptGlobal2 + accept Hub % nRejectGlobal2 = Hub % nRejectGlobal2 + ( numTry - accept ) do k = 1 , L write ( * , '(A,f6.2,1x,f6.2,1x,f6.2,1x,f6.2)' ) 'Sweep3' , CHSF ( 1 , k ), CHSF ( 2 , k ), CHSF ( 3 , k ), CHSF ( 4 , k ) end do contains subroutine PHONON_ACTION ( L , norm , x , Sb ) implicit none integer , intent ( in ) :: L real ( wp ), intent ( in ) :: norm ( 2 ) real ( wp ), intent ( in ) :: x ( L ) real ( wp ), intent ( inout ) :: Sb integer :: iL real ( wp ) :: Ptmp , Ktmp Ptmp = 0.0_wp Ktmp = 0.0_wp do iL = 1 , L - 1 Ptmp = Ptmp - x ( iL ) * x ( iL ) Ktmp = Ktmp - ( x ( iL ) - x ( iL + 1 ) ) * ( x ( iL ) - x ( iL + 1 ) ) end do Ptmp = Ptmp - x ( L ) * x ( L ) Ktmp = Ktmp - ( x ( L ) - x ( 1 ) ) * ( x ( L ) - x ( 1 ) ) Sb = Ktmp * norm ( 1 ) + Ptmp * norm ( 2 ) return end subroutine PHONON_ACTION end subroutine DQMC_Hol_Sweep3_Cont !---------------------------------------------------------------------! subroutine DQMC_Hub_Run ( Hub , Info ) ! ! Purpose ! ======= !   This subroutine is the main subroutine for DQMC. !   There are four major wroks ! !      1. Compute Green function. !      2. Perform warmup sweep. !      3. Perform actual sweep. !      4. Analyze the measurement. (see DQMC_Phy0) ! ! Arguments ! ========= ! !   Info == 1: Print runtime information !   Info == 0: Silent mode ! type ( Hubbard ), intent ( inout ) :: Hub ! Hubbard model ! ... local scalar ... integer :: i , j , nIter , nBin , Info ! ... Executable ... ! Warmup sweep do i = 1 , Hub % nWarm if ( Info == 1 . and . mod ( i , 10 ) == 0 ) write ( * , '(A,i6,1x,i3)' ) ' Warmup Sweep, nwrap  : ' , i , Hub % G_up % nwrap ! The second parameter means no measurement should be made. call DQMC_Hub_Sweep ( Hub , NO_MEAS0 ) call DQMC_Hub_Sweep2 ( Hub , Hub % nTry ) end do ! We divide all the measurement into nBin, ! each having nPass/nBin pass. nBin = Hub % P0 % nBin nIter = Hub % nPass / nBin do i = 1 , nBin do j = 1 , nIter call DQMC_Hub_Sweep ( Hub , Hub % nMeas ) call DQMC_Hub_Sweep2 ( Hub , Hub % nTry ) end do ! Accumulate results for each bin if ( Info == 1 ) write ( * , '(a,2i6)' ) ' Measurement Sweep, bin, iter : ' , i , j call DQMC_Phy0_Avg ( Hub % P0 ) if ( Hub % meas2 ) then if ( Hub % P2 % diagonalize ) then call DQMC_Phy2_Avg ( Hub % P2 , Hub % S ) else call DQMC_Phy2_Avg ( Hub % P2 , Hub % S % W ) endif end if end do ! Get average result call DQMC_Phy0_GetErr ( Hub % P0 ) if ( Hub % meas2 ) then call DQMC_Phy2_GetErr ( Hub % P2 ) end if end subroutine DQMC_Hub_Run !--------------------------------------------------------------------! subroutine DQMC_Hub_FullMeas ( Hub , nnb , A_up , A_dn , sgn_up , sgn_dn ) !type(Hubbard), target, intent(inout) :: Hub type ( Hubbard ), intent ( inout ) :: Hub integer , intent ( in ) :: nnb real ( wp ), intent ( in ) :: A_up ( nnb , nnb ) real ( wp ), intent ( in ) :: A_dn ( nnb , nnb ) real ( wp ), intent ( in ) :: sgn_up real ( wp ), intent ( in ) :: sgn_dn integer :: it , i , j , nb ! Extra space for dtau&#94;2-correct estimate type ( G_fun ), target :: G_up_local , G_dn_local real ( wp ), pointer :: G_up (:,:) real ( wp ), pointer :: G_dn (:,:) !Duplicate the Green's function call DQMC_Gfun_Duplicate ( G_up_local , Hub % G_up ) if (. not . Hub % neg_u . or . Hub % comp_dn ) then call DQMC_Gfun_Duplicate ( G_dn_local , Hub % G_dn ) else call DQMC_Gfun_clone ( G_dn_local , G_up_local ) endif G_up => G_up_local % G G_dn => G_dn_local % G !write(*,*) \"Hub%S%checklist(PHASE)=\",Hub%S%checklist(STRUCT_PHASE) nb = nnb / Hub % n !Perform static measurement on all stored time slices do it = 0 , nb - 1 !Load the diagonal of Aup/Adn in G_up/G_dn i = it * Hub % n + 1 j = i + Hub % n - 1 G_up = A_up ( i : j , i : j ) ! Modified in order to take into account U < 0 model on non-bipartite lattices. ! Before the modification, the code calls DQMC_Gfun_CopyUp() which assumes bipartite lattice. ! This causes segmentation fault on, for example, the triagular lattice which lacks particle-hole ! symmetry. As a result, S%P is not defined. We fix it by separating U < 0 model from the rest ! of the if-else statements, and calling DQMC_Gfun_clone(). if ( Hub % comp_dn ) then ! Get G_dn directly when : !     1) U > 0, mu_up .neq. 0, or mu_dn .neq. 0. !     2) U > 0, mu_up = mu_dn = 0, but \"PHASE\" S%P is not defined. E.g. non-bipartite lattice or S%P is simply lacking. !     3) U > 0, mu_up = mu_dn = 0, but t_up .neq. t_dn. !     4) U < 0, but mu_up .neq. mu_dn, or t_up .neq. t_dn. !     5) U = 0, but mu_up .neq. mu_dn, or t_up .neq. t_dn. G_dn = A_dn ( i : j , i : j ) else if ( Hub % neg_u ) then ! G_dn and G_up are identical when : !     1) U < 0, mu_up = mu_dn, and t_up = t_dn !     2) U = 0, mu_up = mu_dn, and t_up = t_dn call DQMC_Gfun_Clone ( G_dn_local , G_up_local ) else ! Note that here we are left with the last condition: (.not.neg_u) and (.not.comp_dn). ! This implies that S%P is defined, i.e. S%checklist(STRUCT_PHASE) = 'T'. ! So we can safely call DQMC_Gfun_CopyUp() which assumes particle-hole symmetry. ! Use particle-hole symmetry to get G_dn when : !     1) U > 0, at half-filling, t_up = t_dn, and \"PHASE\" S%P is defined. call DQMC_Gfun_CopyUp ( G_dn_local , G_up_local , Hub % S % P ) endif call DQMC_GetG_2nd_order ( G_up_local , Hub % B_up ) if ( Hub % comp_dn . or . . not . Hub % neg_u ) then call DQMC_GetG_2nd_order ( G_dn_local , Hub % B_dn ) endif call DQMC_Phy0_Meas ( Hub % n , Hub % P0 , G_up_local % GS , G_dn_local % GS , Hub % U , & Hub % mu_up , Hub % mu_dn , Hub % t_up , Hub % t_dn , sgn_up , sgn_dn , Hub % S ) if ( SimType . eq . Holstein_model ) then call DQMC_Phy0_Meas_Holstein ( Hub % n , Hub % L , Hub % P0 , G_up_local % GS , G_dn_local % GS , & Hub % U , sgn_up , sgn_dn , Hub % S , Hub % CHSF , norm_phonon , Hub % dtau ) end if if ( Hub % meas2 ) then ! Pair measurement call DQMC_Phy2_Meas ( Hub % n , Hub % P2 % M1 , Hub % P2 % M2 , Hub % P2 , Hub % S % B , & G_up_local % GS , G_dn_local % GS , sgn_up * sgn_dn ) end if enddo call DQMC_Gfun_Free ( G_up_local ) call DQMC_Gfun_Free ( G_dn_local ) end subroutine !-------------------------------------------------------------------! subroutine DQMC_Hub_Meas ( Hub , slice ) !type(Hubbard), target, intent(inout) :: Hub type ( Hubbard ), intent ( inout ) :: Hub integer , intent ( inout ) :: slice type ( G_fun ), target :: G_up_local , G_dn_local real ( wp ), pointer :: G_up (:,:) real ( wp ), pointer :: G_dn (:,:) real ( wp ), pointer :: sgn_up real ( wp ), pointer :: sgn_dn real ( wp ) :: randn ( 1 ) ! Warning: if slice = 0, DQMC_Hub_Meas() would return meaningless results. if ( slice <= 0 . or . slice > Hub % L ) then write ( * , * ) \" In subroutine DQMC_Hub_Meas(Hub, slice), the argument 'slice' is out of bound.\" write ( * , * ) \" It will now be reset randomly.\" call ran0 ( 1 , randn , Hub % seed ) slice = ceiling ( randn ( 1 ) * Hub % L ) write ( * , * ) \" New time slice index is\" , slice end if !Duplicate the Green's function call DQMC_Gfun_Duplicate ( G_up_local , Hub % G_up ) if (. not . Hub % neg_u . or . Hub % comp_dn ) then call DQMC_Gfun_Duplicate ( G_dn_local , Hub % G_dn ) else call DQMC_Gfun_clone ( G_dn_local , G_up_local ) endif G_up => G_up_local % G G_dn => G_dn_local % G sgn_up => G_up_local % sgn sgn_dn => G_dn_local % sgn !Recompute G from scratch G_up_local % ilb = - 1 call DQMC_GetG ( slice , G_up_local , Hub % SB_up ) if ( Hub % comp_dn ) then G_dn_local % ilb = - 1 call DQMC_GetG ( slice , G_dn_local , Hub % SB_dn ) elseif ( Hub % neg_u ) then sgn_dn = sgn_up else ! Note that here we have (.not.neg_u) and (.not.comp_dn). ! This implies that S%P is defined, i.e. S%checklist(STRUCT_PHASE) = 'T'. ! So we can safely call DQMC_Gfun_CopyUp() which uses particle-hole symmetry. call DQMC_Gfun_CopyUp ( G_dn_local , G_up_local , Hub % S % P ) endif !Get G correct to 2nd order call DQMC_GetG_2nd_order ( G_up_local , Hub % B_up ) if ( Hub % comp_dn . or . . not . Hub % neg_u ) then call DQMC_GetG_2nd_order ( G_dn_local , Hub % B_dn ) endif ! Basic measurement call DQMC_Phy0_Meas ( Hub % n , Hub % P0 , G_up_local % GS , G_dn_local % GS , Hub % U , & Hub % mu_up , Hub % mu_dn , Hub % t_up , Hub % t_dn , sgn_up , sgn_dn , Hub % S ) if ( SimType . eq . Holstein_model ) then call DQMC_Phy0_Meas_Holstein ( Hub % n , Hub % L , Hub % P0 , G_up_local % GS , G_dn_local % GS , & Hub % U , sgn_up , sgn_dn , Hub % S , Hub % CHSF , norm_phonon , Hub % dtau ) end if if ( Hub % meas2 ) then ! Pair measurement call DQMC_Phy2_Meas ( Hub % n , Hub % P2 % M1 , Hub % P2 % M2 , Hub % P2 , Hub % S % B , & G_up_local % GS , G_dn_local % GS , sgn_up * sgn_dn ) end if call DQMC_Gfun_Free ( G_up_local ) call DQMC_Gfun_Free ( G_dn_local ) end subroutine DQMC_Hub_Meas !-------------------------------------------------------------------! subroutine DQMC_Hub_Init_Vmat ( Hub ) ! ! Purpose ! ======= !    The element of V(i) is either exp(nu) or exp(-nu) !    where nu = acosh(exp(U*dtau/2)). (see reference [1].) !    The values of exp(nu) and exp(-nu) are stored in a lookup !    table explook.  The decision of wheather V(i,j) is exp(nu) !    or exp(-nu) is given by the list hub, which is a list !    or random +1 and -1. Matrix V for spin up and down have !    opposite selection decision. ! ! ! Arguments ! ========= ! type ( Hubbard ), intent ( inout ) :: Hub ! ... Local variables ... integer :: i , j real ( wp ) :: temp , temp2 ! ... Executable ... if (. not . associated ( Hub % V_up )) then allocate ( Hub % V_up ( Hub % n , Hub % L )) endif ! This fix is required to make test program in /EXAMPLE/test work. ! Without the fix, the array size of Hub%V_up and Hub%V_dn would be 1 rather then n * L. ! This causes segmentation fault when running the test program. if ( size ( Hub % V_up ) /= Hub % n * Hub % L ) then allocate ( Hub % V_up ( Hub % n , Hub % L )) end if ! discrete fields if ( Hub % HSFtype . eq . HSF_DISC ) then do i = 1 , Hub % L do j = 1 , Hub % n Hub % V_up ( j , i ) = Hub % explook ( Hub % HSF ( j , i ), Hub % S % map ( j )) end do end do if ( Hub % neg_u ) then if (. not . associated ( Hub % V_dn )) then Hub % V_dn => Hub % V_up endif else if (. not . associated ( Hub % V_dn )) then allocate ( Hub % V_dn ( Hub % n , Hub % L )) endif ! This fix is required to make test program in /EXAMPLE/test work. ! Without the fix, the array size of Hub%V_up and Hub%V_dn would be 1 rather then n * L. ! This causes segmentation fault when running the test program. if ( size ( Hub % V_dn ) /= Hub % n * Hub % L ) then allocate ( Hub % V_dn ( Hub % n , Hub % L )) end if do i = 1 , Hub % L do j = 1 , Hub % n Hub % V_dn ( j , i ) = Hub % explook ( - Hub % HSF ( j , i ), Hub % S % map ( j )) end do end do end if ! continuous fields else if ( Hub % HSFtype . eq . HSF_CONT ) then if ( SimType . eq . Hubbard_model ) then if ( Hub % neg_u ) then do i = 1 , Hub % L do j = 1 , Hub % n temp = Hub % lambda ( Hub % S % map ( j )) * Hub % CHSF ( j , i ) temp2 = Hub % lambda ( Hub % S % map ( j )) * Hub % lambda ( Hub % S % map ( j )) Hub % V_up ( j , i ) = exp ( temp ) ! + temp2) end do end do if (. not . associated ( Hub % V_dn )) Hub % V_dn => Hub % V_up else if (. not . associated ( Hub % V_dn )) allocate ( Hub % V_dn ( Hub % n , Hub % L )) ! The following is required to make test program in /EXAMPLE/test work. ! Without the fix, the array size of Hub%V_up and Hub%V_dn would be 1 rather then n * L. ! This causes segmentation fault when running the test program. if ( size ( Hub % V_dn ) /= Hub % n * Hub % L ) allocate ( Hub % V_dn ( Hub % n , Hub % L )) do i = 1 , Hub % L do j = 1 , Hub % n temp = Hub % lambda ( Hub % S % map ( j )) * Hub % CHSF ( j , i ) Hub % V_up ( j , i ) = exp ( temp ) Hub % V_dn ( j , i ) = exp ( - temp ) end do end do end if else if ( SimType . eq . Holstein_model ) then do i = 1 , Hub % L do j = 1 , Hub % n temp = Hub % lambda ( Hub % S % map ( j )) * Hub % CHSF ( j , i ) Hub % V_up ( j , i ) = exp ( temp ) end do end do if (. not . associated ( Hub % V_dn )) Hub % V_dn => Hub % V_up end if end if end subroutine DQMC_Hub_Init_Vmat !-------------------------------------------------------------------! end module DQMC_Hubbard","tags":"","loc":"sourcefile/dqmc_holstein.f90.html"},{"title":"dqmc_checkerboard.F90 – Quest","text":"This file depends on sourcefile~~dqmc_checkerboard.f90~~EfferentGraph sourcefile~dqmc_checkerboard.f90 dqmc_checkerboard.F90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_checkerboard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_checkerboard.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_checkerboard.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_CheckerBoard #include \"dqmc_include.h\" use DQMC_UTIL use DQMC_WSPACE !  use BLAS_MOD !  use LAPACK_MOD implicit none ! ! This module defines the type and subroutines for propagator B. ! B is defined by the checkerboard method. See [1] ! ! For a 2-dimensional model ! ! B = exp(K) = exp(K_{4})exp(K_{3})exp(K_{2})exp(K_{1}) !            = B_4B_3B_2B_1 ! !    [1] W. Hanke and Yu.V. Kopaev, \"Stable Numerical Simulation !        of Models of Interating Electrons in Condensed-Matter Physics.\" !        Chapter 4. Elsevier Science Pub. ! !  Data Type !  ========= ! type matB integer :: n ! dim of B integer :: m ! number of neighbors of lattice integer , pointer :: A (:,:) ! Adjacency info real ( wp ), pointer :: sinht (:) ! sinh(t), cosh(t) real ( wp ), pointer :: cosht (:) ! sinh(t), cosh(t) real ( wp ), pointer :: exptaumu (:) ! parameters for checkerboard method real ( wp ), pointer :: work (:) ! parameters for checkerboard method character ( 12 ) :: name logical :: exactb !unused in ckb end type matB contains !-------------------------------------------------------------------------! subroutine DQMC_B_Init ( n , B , WS , Adj , ckb , t , mu , dtau ) ! ! Purpose ! ======= !    This subroutine initiliazes the data type of Green function. ! ! Pre-assumption ! ============== !    This module only used for one band Hubbard's model. ! ! Arguments ! ========= ! use DQMC_STRUCT integer , intent ( in ) :: n ! Number of sites type ( MatB ), intent ( out ) :: B ! MatB type ( CCS ), intent ( in ) :: adj ! adjacent info type ( CCS ), intent ( in ) :: ckb real ( wp ), intent ( in ) :: t ( * ) ! model parameter real ( wp ), intent ( in ) :: mu ( n ), dtau type ( WSpace ), intent ( in ), target :: WS ! shared working space ! ... local variables    ... integer :: h , k , i , j , nt , nckb integer :: ckbmat ( n , n ) integer :: hopmat ( n , n ) real ( wp ), pointer :: dum (:,:) ! ... Executable ... ! So that the compiler does not warn for WS being unused dum => WS % R1 if ( sum (( ckb % row - adj % row ) ** 2 ) + sum (( ckb % cstart - adj % cstart ) ** 2 ) > 0 ) then write ( * , * ) 'ckb and adj do not conform. Stop.' stop endif B % n = n B % m = ckb % nnz / 2 B % name = \"Checkerboard\" nckb = maxval ( ckb % A ) nt = maxval ( Adj % A ) allocate ( B % cosht ( nt )) allocate ( B % sinht ( nt )) allocate ( B % A ( 3 , B % m )) allocate ( B % exptaumu ( n )) if ( nt . gt . 0 ) then B % sinht ( 1 : nt ) = sinh ( dtau * 0.5 * t ( 1 : nt )) B % cosht ( 1 : nt ) = cosh ( dtau * 0.5 * t ( 1 : nt )) endif call dqmc_ccs_fill ( n , ckbmat , ckb ) call dqmc_ccs_fill ( n , hopmat , Adj ) h = 0 do k = 1 , nckb do j = 2 , n do i = 1 , j - 1 if ( ckbmat ( i , j ) . eq . k ) then h = h + 1 B % A ( 1 , h ) = i B % A ( 2 , h ) = j B % A ( 3 , h ) = hopmat ( i , j ) endif enddo enddo enddo do i = 1 , n B % exptaumu ( i ) = exp ( dtau * mu ( i )) enddo allocate ( B % work ( n )) end subroutine DQMC_B_Init !-------------------------------------------------------------------------! subroutine DQMC_B_Free ( B ) ! ! Purpose ! ======= !    This subroutine frees memory of B. ! ! Arguments ! ========= ! type ( MatB ), intent ( inout ) :: B ! MatB ! ... Executable ... deallocate ( B % A , B % work ) end subroutine DQMC_B_Free !----------------------------------------------------------------------! subroutine DQMC_MultB_Left ( n , M , B , V_i , C ) ! ! Purpose ! ======= !    This subroutine uses checkerboard method to multiply B from !    leftside. ! !      B_i = V_i*B ! ! Pre-assumption ! ============== !    1. Matrix M, B and C are square with the same order n. !    2. Vector V_i is of length n. !    3. Flag lr is either 'l' or 'r'. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M type ( MatB ), intent ( inout ) :: B ! real ( wp ), intent ( in ) :: V_i ( n ) ! real ( wp ), intent ( inout ), target :: M ( n , n ) ! real ( wp ), intent ( inout ), target :: C ( n , n ) ! ! ... Local variables ... integer :: i , j , k , h real ( wp ) :: a ! ... executable ... call DQMC_Trans ( n , C , M ) do k = B % m , 1 , - 1 i = B % A ( 1 , k ) j = B % A ( 2 , k ) h = B % A ( 3 , k ) a = B % sinht ( h ) / B % cosht ( h ) call daxpy ( n , a , C (:, j ), 1 , C (:, i ), 1 ) a = B % cosht ( h ) * B % sinht ( h ) call daxpy ( n , a , C (:, i ), 1 , C (:, j ), 1 ) a = B % cosht ( h ) call dscal ( n , a , C (:, i ), 1 ) a = 1.d0 / B % cosht ( h ) call dscal ( n , a , C (:, j ), 1 ) enddo do k = 1 , B % m i = B % A ( 1 , k ) j = B % A ( 2 , k ) h = B % A ( 3 , k ) a = B % sinht ( h ) / B % cosht ( h ) call daxpy ( n , a , C (:, j ), 1 , C (:, i ), 1 ) a = B % cosht ( h ) * B % sinht ( h ) call daxpy ( n , a , C (:, i ), 1 , C (:, j ), 1 ) a = B % cosht ( h ) call dscal ( n , a , C (:, i ), 1 ) a = 1.d0 / B % cosht ( h ) call dscal ( n , a , C (:, j ), 1 ) enddo ! Combin V_i with the coefficient of B B % work ( 1 : n ) = B % exptaumu ( 1 : n ) * V_i ( 1 : n ) call DQMC_ScaleCol ( n , C , B % work ) call DQMC_Trans ( n , M , C ) end subroutine DQMC_MultB_Left !----------------------------------------------------------------------! subroutine DQMC_MultB_Right ( n , M , B , V_i , C ) ! ! Purpose ! ======= !    This subroutine uses checkerboard method to multiply B from !    righthand side. ! !      B_i = V_i*B ! ! Pre-assumption ! ============== !    1. Matrix M, B and C are square with the same order n. !    2. Vector V_i is of length n. !    3. Flag lr is either 'l' or 'r'. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M type ( MatB ), intent ( inout ) :: B ! real ( wp ), intent ( in ) :: V_i ( n ) ! real ( wp ), intent ( inout ), target :: M ( n , n ) ! real ( wp ), intent ( inout ), target :: C ( n , n ) ! ! ... Local variables ... integer :: i , j , k , h real ( wp ) :: a ! ... executable ... ! Combin V_i with the coefficient of B B % work ( 1 : n ) = B % exptaumu ( 1 : n ) * V_i ( 1 : n ) call DQMC_ScaleCol ( n , M , B % work ) do k = 1 , B % m i = B % A ( 1 , k ) j = B % A ( 2 , k ) h = B % A ( 3 , k ) a = B % sinht ( h ) / B % cosht ( h ) call daxpy ( n , a , M (:, j ), 1 , M (:, i ), 1 ) a = B % cosht ( h ) * B % sinht ( h ) call daxpy ( n , a , M (:, i ), 1 , M (:, j ), 1 ) a = B % cosht ( h ) call dscal ( n , a , M (:, i ), 1 ) a = 1.d0 / B % cosht ( h ) call dscal ( n , a , M (:, j ), 1 ) enddo do k = B % m , 1 , - 1 i = B % A ( 1 , k ) j = B % A ( 2 , k ) h = B % A ( 3 , k ) a = B % sinht ( h ) / B % cosht ( h ) call daxpy ( n , a , M (:, j ), 1 , M (:, i ), 1 ) a = B % cosht ( h ) * B % sinht ( h ) call daxpy ( n , a , M (:, i ), 1 , M (:, j ), 1 ) a = B % cosht ( h ) call dscal ( n , a , M (:, i ), 1 ) a = 1.d0 / B % cosht ( h ) call dscal ( n , a , M (:, j ), 1 ) enddo end subroutine DQMC_MultB_Right !--------------------------------------------------------------------------! subroutine DQMC_MultBi_Left ( n , M , B , V_i , C ) ! ! Purpose ! ======= !    This subroutine uses checkerboard method to multiply inv(B) from !    leftside. ! ! Pre-assumption ! ============== !    1. Matrix M, B and C are square with the same order n. !    2. Vector V_i is of length n. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M type ( MatB ), intent ( inout ) :: B ! real ( wp ), intent ( in ) :: V_i ( n ) ! real ( wp ), intent ( inout ), target :: M ( n , n ) ! real ( wp ), intent ( inout ), target :: C ( n , n ) ! ! ... Local variables ... integer :: i , j , k , h real ( wp ) :: a ! ... executable ... call DQMC_Trans ( n , C , M ) B % work ( 1 : n ) = 1.d0 / ( B % exptaumu ( 1 : n ) * V_i ( 1 : n )) call DQMC_ScaleCol ( n , C , B % work ) do k = 1 , B % m i = B % A ( 1 , k ) j = B % A ( 2 , k ) h = B % A ( 3 , k ) a = - B % sinht ( h ) / B % cosht ( h ) call daxpy ( n , a , C (:, j ), 1 , C (:, i ), 1 ) a = - B % cosht ( h ) * B % sinht ( h ) call daxpy ( n , a , C (:, i ), 1 , C (:, j ), 1 ) a = B % cosht ( h ) call dscal ( n , a , C (:, i ), 1 ) a = 1.d0 / B % cosht ( h ) call dscal ( n , a , C (:, j ), 1 ) enddo do k = B % m , 1 , - 1 i = B % A ( 1 , k ) j = B % A ( 2 , k ) h = B % A ( 3 , k ) a = - B % sinht ( h ) / B % cosht ( h ) call daxpy ( n , a , C (:, j ), 1 , C (:, i ), 1 ) a = - B % cosht ( h ) * B % sinht ( h ) call daxpy ( n , a , C (:, i ), 1 , C (:, j ), 1 ) a = B % cosht ( h ) call dscal ( n , a , C (:, i ), 1 ) a = 1.d0 / B % cosht ( h ) call dscal ( n , a , C (:, j ), 1 ) enddo ! Combin V_i with the coefficient of B call DQMC_Trans ( n , M , C ) end subroutine DQMC_MultBi_Left !--------------------------------------------------------------------------! subroutine DQMC_MultBi_Right ( n , M , B , V_i , C ) ! ! Purpose ! ======= !    This subroutine uses checkerboard method to multiply inv(B) from !    right hand side. ! ! Pre-assumption ! ============== !    1. Matrix M, B and C are square with the same order n. !    2. Vector V_i is of length n. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M type ( MatB ), intent ( inout ) :: B ! real ( wp ), intent ( in ) :: V_i ( n ) ! real ( wp ), intent ( inout ), target :: M ( n , n ) ! real ( wp ), intent ( inout ), target :: C ( n , n ) ! ! ... Local variables ... integer :: i , j , k , h real ( wp ) :: a ! ... executable ... do k = B % m , 1 , - 1 i = B % A ( 1 , k ) j = B % A ( 2 , k ) h = B % A ( 3 , k ) a = - B % sinht ( h ) / B % cosht ( h ) call daxpy ( n , a , M (:, j ), 1 , M (:, i ), 1 ) a = - B % cosht ( h ) * B % sinht ( h ) call daxpy ( n , a , M (:, i ), 1 , M (:, j ), 1 ) a = B % cosht ( h ) call dscal ( n , a , M (:, i ), 1 ) a = 1.d0 / B % cosht ( h ) call dscal ( n , a , M (:, j ), 1 ) enddo do k = 1 , B % m i = B % A ( 1 , k ) j = B % A ( 2 , k ) h = B % A ( 3 , k ) a = - B % sinht ( h ) / B % cosht ( h ) call daxpy ( n , a , M (:, j ), 1 , M (:, i ), 1 ) a = - B % cosht ( h ) * B % sinht ( h ) call daxpy ( n , a , M (:, i ), 1 , M (:, j ), 1 ) a = B % cosht ( h ) call dscal ( n , a , M (:, i ), 1 ) a = 1.d0 / B % cosht ( h ) call dscal ( n , a , M (:, j ), 1 ) enddo B % work ( 1 : n ) = 1.d0 / ( B % exptaumu ( 1 : n ) * V_i ( 1 : n )) call DQMC_ScaleCol ( n , M , B % work ) end subroutine DQMC_MultBi_Right !----------------------------------------------------------------------! subroutine DQMC_MultrtB0_Left ( n , M , B , C ) ! ! Purpose ! ======= !    This subroutine mulitplies matrix M by the matrix sqrt(B0) from !    leftside. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M real ( wp ), intent ( inout ) :: M ( n , n ) ! type ( MatB ), intent ( in ) :: B ! real ( wp ), intent ( inout ) :: C ( n , n ) ! working space integer :: i ! Dummy executable to avoid warning C = M i = B % n end subroutine DQMC_MultrtB0_Left !----------------------------------------------------------------------! subroutine DQMC_MultrtB0i_Right ( n , M , B , C ) ! ! Purpose ! ======= !    This subroutine mulitplies matrix M by the matrix sqrt(B0_i) from !    rightside. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M real ( wp ), intent ( inout ) :: M ( n , n ) ! type ( MatB ), intent ( in ) :: B ! real ( wp ), intent ( inout ) :: C ( n , n ) ! working space integer :: i ! Dummy executable to avoid warning C = M i = B % n end subroutine DQMC_MultrtB0i_Right !-------------------------------------------------------------------------! subroutine DQMC_GetB ( n , M , B , V_i , C ) ! ! Purpose ! ======= !    This subroutine returns M = V_iB ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M real ( wp ), intent ( inout ) :: M ( n , n ) ! type ( MatB ), intent ( inout ) :: B ! real ( wp ), intent ( in ) :: V_i ( n ) ! real ( wp ), intent ( inout ) :: C ( n , n ) ! ! ... Executable ... call DQMC_Eye ( n , M ) call DQMC_MultB_Left ( n , M , B , V_i , C ) end subroutine DQMC_GetB !-----------------------------------------------------------------------! subroutine DQMC_GetBi ( n , M , B , V_i , C ) ! ! Purpose ! ======= !    This subroutine returns M = inv(B)inv(V_i) ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! The order of matrix M real ( wp ), intent ( inout ) :: M ( n , n ) ! type ( MatB ), intent ( inout ) :: B ! MatB real ( wp ), intent ( in ) :: V_i ( n ) ! real ( wp ), intent ( inout ) :: C ( n , n ) ! ! ... Executable ... call DQMC_Eye ( n , M ) call DQMC_MultBi_Left ( n , M , B , V_i , C ) end subroutine DQMC_GetBi !-----------------------------------------------------------------------! end module DQMC_CheckerBoard","tags":"","loc":"sourcefile/dqmc_checkerboard.f90.html"},{"title":"dqmc_mpi.F90 – Quest","text":"Files dependent on this one sourcefile~~dqmc_mpi.f90~~AfferentGraph sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_mpi.f90 sourcefile~ggeom.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_mpi.f90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_mpi.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_MPI implicit none # ifdef _QMC_MPI #   include \"mpif.h\" # else integer :: MPI_COMM_WORLD # endif type MPI_SIMOR integer :: level ! level of parallelization integer :: rank ! global rank integer :: size ! global size integer :: aggr_rank integer :: meas_rank integer :: gfun_rank integer :: aggr_size integer :: meas_size integer :: gfun_size integer :: aggr_root integer :: meas_root integer :: gfun_root integer :: aggr_comm ! communicator for aggregation integer :: meas_comm ! communicator for measurements integer :: gfun_comm ! communicator for Green's fun end type MPI_SIMOR integer , parameter :: CHANNEL_AGGR = 1 integer , parameter :: CHANNEL_MEAS = 2 integer , parameter :: CHANNEL_GFUN = 3 integer , parameter :: PLEVEL_1 = 1 integer , parameter :: PLEVEL_2 = 2 integer , parameter :: PLEVEL_3 = 3 integer , parameter :: PLEVEL_4 = 4 type ( MPI_SIMOR ) :: qmc_sim contains subroutine DQMC_MPI_Init ( sim , level ) ! ! Purpose ! ======= !   This subroutine initializes MPI procedure. ! ! Argument ! ======== type ( MPI_SIMOR ) :: sim integer , intent ( in ) :: level ! ... Local variables ... #   ifdef _QMC_MPI integer :: ierr , rc #   endif ! ... Executable ... #   ifdef _QMC_MPI call MPI_INIT ( ierr ) if ( ierr . ne . MPI_SUCCESS ) then print * , 'Error starting MPI program. Terminating.' call MPI_ABORT ( MPI_COMM_WORLD , rc , ierr ) end if #   endif sim % level = level if ( level . eq . 1 ) then ! Get MPI parameters #   ifdef _QMC_MPI call MPI_COMM_RANK ( MPI_COMM_WORLD , sim % rank , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , sim % size , ierr ) #   else sim % rank = 0 sim % size = 1 #   endif sim % aggr_rank = sim % rank sim % meas_rank = sim % rank sim % gfun_rank = sim % rank sim % aggr_size = sim % size sim % meas_size = sim % size sim % gfun_size = sim % size sim % aggr_root = 0 sim % meas_root = 0 sim % gfun_root = 0 sim % aggr_comm = MPI_COMM_WORLD sim % meas_comm = MPI_COMM_WORLD sim % gfun_comm = MPI_COMM_WORLD end if end subroutine DQMC_MPI_Init ! ========================================================= subroutine DQMC_MPI_Final ( sim ) ! ! Purpose ! ======= !   This subroutine finalizes MPI procedure. ! ! Argument ! ======== type ( MPI_SIMOR ) :: sim #   ifdef _QMC_MPI ! ... Local variables ... integer :: ierr , rc ! ... Executable ... call MPI_FINALIZE ( ierr ) if ( ierr . ne . MPI_SUCCESS ) then print * , 'Error in finalize MPI program. Terminating.' call MPI_ABORT ( sim % aggr_comm , rc , ierr ) end if #   endif sim % level = 0 end subroutine DQMC_MPI_Final ! ========================================================= function DQMC_MPI_Is_Root ( sim , channel ) result ( isRoot ) ! ! Purpose ! ======= !   This subroutine finalizes MPI procedure. ! ! Argument ! ======== type ( MPI_SIMOR ) :: sim integer , intent ( in ) :: channel logical :: isRoot ! ... Executable ... select case ( channel ) case ( CHANNEL_AGGR ) isRoot = ( sim % aggr_rank . eq . sim % aggr_root ) end select end function DQMC_MPI_Is_Root end module DQMC_MPI","tags":"","loc":"sourcefile/dqmc_mpi.f90.html"},{"title":"dqmc_geom_param.F90 – Quest","text":"Files dependent on this one sourcefile~~dqmc_geom_param.f90~~AfferentGraph sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_kbonds.f90 dqmc_kbonds.F90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_GEOM_PARAM implicit none integer , parameter :: rdim = 3 real * 8 , parameter :: toll = 1.d-6 , pi = acos ( - 1.d0 ) complex * 16 , parameter :: im = ( 0.d0 , 1.d0 ) integer , parameter :: N_Fields = 10 integer , parameter :: NDIM_F = 1 integer , parameter :: PRIM_F = 2 integer , parameter :: SUPER_F = 3 integer , parameter :: ORB_F = 4 integer , parameter :: HAMILT_F = 5 integer , parameter :: SYMM_F = 6 integer , parameter :: PHASE_F = 7 integer , parameter :: BONDS_F = 8 integer , parameter :: PAIRS_F = 9 integer , parameter :: DILUT_F = 10 character * 10 , parameter :: INPUT_FIELDS ( N_Fields ) = ( / & '  #NDIM   ' , & '  #PRIM   ' , & '  #SUPER  ' , & '   #ORB   ' , & ' #HAMILT  ' , & '  #SYMM   ' , & '  #PHASE  ' , & '  #BONDS  ' , & '   #PAIR  ' , & '  #DILUT  ' / ) integer :: inpunit !Assigned in Geom_Fill logical :: Found_Field ( N_fields ) !Assigned in analyze_input save contains !---------------------------------------------- ! Determines which Fields are specified !---------------------------------------------- subroutine analyze_input integer :: i , ios logical :: stop_exe character ( len = 100 ) :: str do i = 1 , N_Fields rewind ( inpunit ) Found_Field ( i ) = . false . do read ( inpunit , '(A)' , iostat = ios ) str if ( ios /= 0 ) exit if ( index ( str , adjustl ( INPUT_FIELDS ( i ))) > 0 ) Found_Field ( i ) = . true . enddo enddo stop_exe = . false . do i = NDIM_F , HAMILT_F if (. not . Found_Field ( i )) then write ( * , '(A)' ) INPUT_FIELDS ( i ), ' is compulsory in input' stop_exe = . true . endif enddo if ( Found_Field ( PAIRS_F ). and .. not . Found_Field ( BONDS_F )) then write ( * , '(A)' ) '#PAIR requires #BONDS to be specified in input' stop_exe = . true . endif if ( stop_exe ) stop end subroutine analyze_input end module DQMC_GEOM_PARAM","tags":"","loc":"sourcefile/dqmc_geom_param.f90.html"},{"title":"dqmc_seqb.F90 – Quest","text":"This file depends on sourcefile~~dqmc_seqb.f90~~EfferentGraph sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_seqb.f90~~AfferentGraph sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_SEQB #include \"dqmc_include.h\" #ifdef DQMC_CKB use DQMC_CheckerBoard #else use DQMC_MATB #endif use DQMC_UTIL use DQMC_WSPACE implicit none ! ! This module implements multiplication of a sequent B. ! ! Data Types ! ========== ! !  UDT decomposition ! type SeqB integer :: n integer :: L integer :: nOrth ! B matrix type ( MatB ), pointer :: B ! For UDT decomposition real ( wp ), pointer :: U (:,:) real ( wp ), pointer :: D (:) real ( wp ), pointer :: T (:,:) ! Working space real ( wp ), pointer :: W1 (:,:) real ( wp ), pointer :: W2 (:,:) real ( wp ), pointer :: W3 (:,:) real ( wp ), pointer :: rw (:) real ( wp ), pointer :: tau (:) integer , pointer :: piv (:) integer , pointer :: lw (:) end type SeqB contains !----------------------------------------------------------------------! subroutine DQMC_SeqB_Init ( n , L , nOrth , B , SB , WS ) ! ! Purpose ! ======= ! This subroutine initializes the intermediate results ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! order of matrix integer , intent ( in ) :: L ! time slice integer , intent ( in ) :: nOrth ! number of safe multiplication type ( MatB ), intent ( in ), target :: B ! Data structure of B matrix type ( SeqB ), intent ( inout ) :: SB ! intermediate results type ( WSpace ), intent ( in ), target :: WS ! intermediate results ! ... Executable ... SB % n = n SB % L = L SB % nOrth = nOrth ! B matrix SB % B => B ! working spaces SB % U => WS % R1 SB % T => WS % R2 SB % W1 => WS % R3 SB % W2 => WS % R4 SB % D => WS % R5 SB % tau => WS % R6 SB % rw => WS % R7 SB % W3 => WS % R8 SB % piv => WS % I1 SB % lw => WS % lw end subroutine DQMC_SeqB_Init !----------------------------------------------------------------------! subroutine DQMC_SeqB_Init2 ( n , L , nOrth , B , SB , U , D , T , WS ) ! ! Purpose ! ======= ! This subroutine initializes the intermediate results ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! order of matrix integer , intent ( in ) :: L ! time slice integer , intent ( in ) :: nOrth ! number of safe multiplication real ( wp ), intent ( in ), target :: U (:,:) ! real ( wp ), intent ( in ), target :: D (:) ! real ( wp ), intent ( in ), target :: T (:,:) ! type ( MatB ), intent ( in ), target :: B ! Data structure of B matrix type ( SeqB ), intent ( inout ) :: SB ! intermediate results type ( WSpace ), intent ( in ), target :: WS ! intermediate results ! ... Executable ... SB % n = n SB % L = L SB % nOrth = nOrth ! B matrix SB % B => B ! working spaces SB % U => U SB % D => D SB % T => T SB % W1 => WS % R3 SB % W2 => WS % R4 SB % rw => WS % R7 SB % tau => WS % R6 SB % piv => WS % I1 SB % lw => WS % lw end subroutine DQMC_SeqB_Init2 !----------------------------------------------------------------------! subroutine DQMC_SeqB_Free ( SB ) ! ! Purpose ! ======= !    This subroutine frees dynamically allocated memory of SB. ! ! Arguments ! ========= ! type ( SeqB ), intent ( inout ) :: SB ! intermediate results SB % n = 0 end subroutine DQMC_SeqB_Free !----------------------------------------------------------------------! subroutine DQMC_SeqB_Update ( SB ) ! ! This subroutine initializes the intermediate results ! type ( SeqB ), intent ( inout ) :: SB ! Data structure of B matrix SB % n = 0 end subroutine DQMC_SeqB_Update !----------------------------------------------------------------------! subroutine DQMC_UDTD ( n , U , D , T , W1 , W2 , rw , tau , piv , lwork ) ! ! Purpose ! ======= !    This subroutine computes (updates) UDT decomposition, ! !       A = UDT ! !    where U is orthonormal, D is diagonal, and T is normalized !    is some way. ! !    In input, U is not orthonormal. Therefore, ! !    1. QR-decomposition with pivoting on U ! !          [U, R, P] = QRP(U*D) ! !    2. Normalize R by its diagonal elements and set them to D. ! !          R = D*R ! !    3. Apply P to T,  W = P*T. ! !    4. Multiply R to W to get the new T, T = R*W = R*P*T. ! ! ! Arguments ! ========= ! integer , intent ( in ) :: n real ( wp ), intent ( inout ) :: U ( n , n ) real ( wp ), intent ( inout ) :: D ( n ) real ( wp ), intent ( inout ) :: T ( n , n ) real ( wp ), intent ( inout ) :: W1 ( n , n ) ! R-factor in QR factor real ( wp ), intent ( inout ) :: W2 ( n , n ) ! working array in pivoting real ( wp ), intent ( inout ) :: rw (:) ! working array in QR factor real ( wp ), intent ( inout ) :: tau ( n ) ! working array in QR factor integer , intent ( inout ) :: piv (:) ! pivoting array in QRD integer , intent ( in ) :: lwork (:) ! working array in QR ! ... Local variables ... integer :: info , i ! ... Executable ... !! Compute U = U*D call DQMC_ScaleCol ( n , U , D ) !! Initial parameters for dgeqp3 piv = 0 info = 0 !! QR factorization with column pivoting call lapack_dgeqp3 ( n , n , U , n , piv , tau , rw , lwork ( LA_GEQRF ), info ) if ( info . ne . 0 ) then call DQMC_Error ( \"Error: dgeqp3 in dqmc_UDTD.\" , info ) end if !! dgegp3 returns R-factor on the upper triangle of G. !! The lower triangle of G stores \"reflectors\", !! which is used to reconstruct the Q-factor. !! Move R-factor to R, and normalize it by diagonal elements. ! W1 = U call blas_dcopy ( n * n , U , 1 , W1 , 1 ) do i = 1 , n !! make T upper triangular. W1 ( i , 1 : i - 1 ) = ZERO !! D = diag(T). D ( i ) = W1 ( i , i ) if ( D ( i ) . eq . ZERO ) then call DQMC_Error ( \"Error: R-factor is singular: dqmc_UDTD.\" , i ) else !! Normalize R's row by its diagonal. R = inv(D)*R call blas_dscal ( n - i + 1 , ONE / D ( i ), W1 ( i , i ), n ) endif end do !! Compute V = P*V. (W is used as an temporary variable.) do i = 1 , n W2 ( i , 1 : n ) = T ( piv ( i ), 1 : n ) end do !! Compute V = R*W = R*P*V call blas_dtrmm ( 'L' , 'U' , 'N' , 'U' , n , n , ONE , W1 , n , W2 , n ) ! T = W2 call blas_dcopy ( n * n , W2 , 1 , T , 1 ) ! Generate Q-factor call lapack_dorgqr ( n , n , n , U , n , tau , rw , lwork ( LA_ORGQR ), info ) end subroutine DQMC_UDTD !----------------------------------------------------------------------! subroutine DQMC_SeqMultB ( il , ir , SB , V ) ! ! Purpose ! ======= !    This subroutine computes A = B_{il}B_{il-1}...B_{ir} !    and returns A's UDT decomposition. ! !    ir is the index of right most B, adn il is the index for the !    left most B. ! ! Arguments ! ========= ! integer , intent ( in ) :: il , ir ! start/end slice type ( SeqB ), intent ( inout ) :: SB ! SeqB real ( wp ), intent ( in ) :: V ( SB % n , SB % L ) ! ... local scalars    ... integer :: i , si , interval ! iterator integer :: n , L ! alias real ( wp ), pointer :: U (:,:) real ( wp ), pointer :: T (:,:) real ( wp ), pointer :: D (:) real ( wp ), pointer :: W1 (:,:) real ( wp ), pointer :: W2 (:,:) real ( wp ), pointer :: tau (:) real ( wp ), pointer :: rw (:) integer , pointer :: piv (:) integer , pointer :: lw (:) ! ... Executable ... U => SB % U D => SB % D T => SB % T W1 => SB % W1 W2 => SB % W2 tau => SB % tau n = SB % n L = SB % L rw => SB % rw lw => SB % lw piv => SB % piv !! Initially, Q = B_{i} = V_i*B ! computing the interval between i1 and i2 if ( il . ge . ir ) then interval = il - ir + 1 else interval = il + L - ir + 1 end if si = ir if ( si . gt . L ) si = si - L ! Let U be B_{i1} call DQMC_GetB ( n , U , SB % B , V (:, si ), SB % W1 ) !! T = I, T will be the R-factor of the QDR factorization call DQMC_Eye ( n , T ) D = ONE ! Loop over the rest B_i do i = 1 , interval - 1 !! Compute the index of B_{i} si = si + 1 if ( si . gt . L ) si = 1 !! The UDT decomposition is performed at every nOrth step, and !! at the last step. In other steps, we just multiply B_i to !! the Q-factor if ( mod ( i , SB % nOrth ) . eq . 0 ) then ! UDV decomposition call DQMC_UDTD ( n , U , D , T , W1 , W2 , rw , tau , piv , lw ) end if !! multiply B_i to the Q-factor call DQMC_MultB_Left ( n , U , SB % B , V (:, si ), SB % W1 ) end do ! before leave, make the decomposition form call DQMC_UDTD ( n , U , D , T , W1 , W2 , rw , tau , piv , lw ) end subroutine DQMC_SeqMultB !----------------------------------------------------------------------! subroutine DQMC_SeqMultBi ( il , ir , SB , V ) ! ! Purpose ! ======= !    This subroutine computes A = inv(B_{il}B_{il-1}...B_{ir}) !    and returns A's UDT decomposition. ! ! Pre-assumption ! ============== !   ir is the index of right most B, adn il is the index for the !   left most B. Both i1, i2 are in [1,..L]. ! ! Arguments ! ========= ! integer , intent ( in ) :: il , ir ! start/end slice type ( SeqB ), intent ( inout ) :: SB ! MatB real ( wp ), intent ( in ) :: V ( SB % n , SB % L ) ! ... local scalars    ... integer :: i , si , interval ! iterator integer :: n , L ! alias real ( wp ), pointer :: U (:,:) real ( wp ), pointer :: T (:,:) real ( wp ), pointer :: D (:) real ( wp ), pointer :: W1 (:,:) real ( wp ), pointer :: W2 (:,:) real ( wp ), pointer :: tau (:) real ( wp ), pointer :: rw (:) integer , pointer :: piv (:) integer , pointer :: lw (:) ! ... Executable ... U => SB % U D => SB % D T => SB % T W1 => SB % W1 W2 => SB % W2 tau => SB % tau n = SB % n L = SB % L rw => SB % rw lw => SB % lw piv => SB % piv ! computing the interval between i1 and i2 if ( il . ge . ir ) then interval = il - ir + 1 else interval = il + L - ir + 1 end if si = il if ( si . gt . L ) si = si - L ! Let U be B_{i2}&#94;{-1} call DQMC_GetBi ( n , U , SB % B , V (:, si ), SB % W1 ) !! R = I, R will be the R-factor of the QDR factorization call DQMC_Eye ( n , T ) D = ONE ! Loop over the rest B_i do i = 1 , interval - 1 si = si - 1 if ( si . le . 0 ) si = L !! The UDT decomposition is performed at every nOrth step, and !! at the last step. In other steps, we just multiply B_i to !! the Q-factor if ( mod ( i , SB % nOrth ) . eq . 0 ) then ! UDV decomposition call DQMC_UDTD ( n , U , D , T , W1 , W2 , rw , tau , piv , lw ) end if !! multiply B_i to the Q-factor call DQMC_MultBi_Left ( n , U , SB % B , V (:, si ), SB % W1 ) end do ! before leave, make the decomposition form call DQMC_UDTD ( n , U , D , T , W1 , W2 , rw , tau , piv , lw ) end subroutine DQMC_SeqMultBi !----------------------------------------------------------------------! end module DQMC_SEQB","tags":"","loc":"sourcefile/dqmc_seqb.f90.html"},{"title":"dqmc_gtau.F90 – Quest","text":"This file depends on sourcefile~~dqmc_gtau.f90~~EfferentGraph sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_gtau.f90~~AfferentGraph sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_GTAU #include \"dqmc_include.h\" use DQMC_UTIL use DQMC_WSPACE #ifdef DQMC_CKB use DQMC_CheckerBoard #else use DQMC_MATB #endif use DQMC_SEQB use DQMC_GFUN implicit none ! ! This module is designed for the computation of time dependent ! measurement (TDM), which requires the unequal time Green's ! function Gup_tau (Gdn_tau). ! Mathematically, Gup_tau(Gdn_tau) is the inverse of the following ! matrix. ! !                  [  I                   B_L] !                  [-B_1   I                 ] !              M = [     -B_2  I             ] !                  [          ...   ...      ] !                  [             -B_{L-1}  I ] ! ! ! The current implementation only considers to return the ith row ! of Gup_tau (Gdn_tau). Let Gup_ij be the (i,j) block matrix of ! Gup_tau. ! !     Gup_ii = inv(I+B_iB_{i-1}...B_1B_L...B_{i+1}) !     Gup_ij = -Gup_ii(B_iB_{i-1}...B_1B_L...B_{j+1})  for j = i...L !     Gup_ij =  Gup_ii(B_iB_{i-1}...B_1B_L...B_{j+1})  for j = 1...i-1 ! ! The corresponding Gdn_ij has the same structure. ! ! [1] Z. Bai, W.Chen, R. Scalettar, I. Yamazaki, \"Lecture Notes !     on Advances of Numerical Methods for Hubbard Quantum Monte !     Carlo Simulation.\" ! type Gtau integer :: n ! number of sites integer :: L ! number of imag-times integer :: nb ! number of imag-times in A_up, A_dn integer :: nnb ! size of A_up, A_dn integer :: it_up ! time indices for upt0, up0t, dnt0 and dn0t integer :: i0_up ! time indices for upt0, up0t, dnt0 and dn0t integer :: it_dn ! time indices for upt0, up0t, dnt0 and dn0t integer :: i0_dn ! time indices for upt0, up0t, dnt0 and dn0t integer :: north ! Number of imag-times integer :: which ! part of gtau to compute integer :: sfc ! safe count ! Green's functions real ( wp ), pointer :: upt0 (:,:) ! Gup(t,0) real ( wp ), pointer :: up0t (:,:) ! Gup(0,t) real ( wp ), pointer :: dnt0 (:,:) ! Gdn(t,0) real ( wp ), pointer :: dn0t (:,:) ! Gdn(0,t) real ( wp ), pointer :: up00 (:,:) ! Gup(0,0) real ( wp ), pointer :: uptt (:,:) ! Gup(t,t) real ( wp ), pointer :: dn00 (:,:) ! Gdn(0,0) real ( wp ), pointer :: dntt (:,:) ! Gdn(t,t) ! Full Green's functions (nb imag-times. Not L!) real ( wp ), pointer :: A_up (:,:) real ( wp ), pointer :: A_dn (:,:) ! Indices of imag-times stored in the A's integer , pointer :: itau_up (:) integer , pointer :: itau_dn (:) ! Pointers to B matrices (no fields) type ( MatB ), pointer :: B_up type ( MatB ), pointer :: B_dn ! Pointers to B matrices with fields real ( wp ), pointer :: V_up (:,:) real ( wp ), pointer :: V_dn (:,:) ! Pointers to phase real ( wp ), pointer :: P (:) ! Control variables for dn computation logical :: comp_dn logical :: neg_u ! Signs real ( wp ), pointer :: sgnup real ( wp ), pointer :: sgndn ! Workspace variables integer :: lw integer , pointer :: IW (:) real ( wp ), pointer :: W1 (:) real ( wp ), pointer :: W2 (:,:) real ( wp ), pointer :: W3 (:,:) ! Workspace for g0 computation logical :: g0_stored = . false . real ( wp ), pointer :: e0up (:) real ( wp ), pointer :: e0dn (:) real ( wp ), pointer :: U0up (:,:) real ( wp ), pointer :: U0dn (:,:) end type Gtau integer , parameter :: TAU_T0 = 0 ! Column integer , parameter :: TAU_BOTH = 1 ! column and row integer , parameter :: TAU_0T = 2 ! ROW integer , parameter :: TAU_UP = 1 ! Spin up integer , parameter :: TAU_DN = - 1 ! Spin down integer , parameter :: TPLUS = 1 ! Spin up integer , parameter :: TMINUS = 2 ! Spin down integer , parameter :: ZPLUS = 3 ! Spin up integer , parameter :: ZMINUS = 4 ! Spin down contains ! Subroutines ! ================================================================== subroutine DQMC_Gtau_Init ( Hub , tau ) use DQMC_HUBBARD ! ! Purpose ! ======= !    This subroutine initializes tau. ! ! Arguments ! ========= ! type ( Gtau ), intent ( inout ) :: tau type ( Hubbard ), target , intent ( in ) :: Hub integer :: n , nnb , info real ( wp ) :: query ( 1 ) ! ... Executable ... tau % it_up = 0 tau % i0_up = 0 tau % it_dn = 0 tau % i0_dn = 0 ! Copy variable from Hub tau % n = Hub % n tau % L = Hub % L tau % north = Hub % SB_up % north tau % nb = Hub % L / tau % north tau % comp_dn = Hub % comp_dn tau % neg_u = Hub % neg_u if ( mod ( tau % L , tau % north ) /= 0 ) & call dqmc_error ( \"L must be an exact multiple of north. Stop.\" , 1 ) tau % which = TAU_BOTH ! Allocate space for measurement tau % nnb = tau % n * tau % nb n = tau % n nnb = tau % nnb allocate ( tau % upt0 ( n , n )) allocate ( tau % up0t ( n , n )) allocate ( tau % up00 ( n , n )) allocate ( tau % uptt ( n , n )) allocate ( tau % A_up ( nnb , nnb )) if ( tau % comp_dn . or . . not . tau % neg_u ) then allocate ( tau % dnt0 ( n , n )) allocate ( tau % dn0t ( n , n )) allocate ( tau % dn00 ( n , n )) allocate ( tau % dntt ( n , n )) allocate ( tau % A_dn ( nnb , nnb )) else tau % dnt0 => tau % upt0 tau % dn0t => tau % up0t tau % dn00 => tau % up00 tau % dntt => tau % uptt tau % A_dn => tau % A_up endif ! sgn and itaus are identical when .not.comp_dn allocate ( tau % sgnup ) allocate ( tau % itau_up ( tau % nb )) if ( tau % comp_dn ) then allocate ( tau % sgndn ) allocate ( tau % itau_dn ( tau % nb )) else tau % sgndn => tau % sgnup tau % itau_dn => tau % itau_up endif tau % B_up => Hub % B_up tau % B_dn => Hub % B_dn tau % V_up => Hub % V_up tau % V_dn => Hub % V_dn tau % P => Hub % S % P ! Create working space allocate ( tau % IW ( nnb )) call lapack_dgetri ( nnb , tau % A_up , nnb , tau % IW , query , - 1 , info ) tau % lw = nint ( query ( 1 )) allocate ( tau % W1 ( tau % lw )) allocate ( tau % W2 ( n , n )) allocate ( tau % W3 ( n , n )) tau % g0_stored = . false . end subroutine DQMC_Gtau_Init !--------------------------------------------------------------------! subroutine DQMC_Gtau_Free ( tau ) ! ! Purpose ! ======= !    This subroutine frees TDM. ! ! Arguments ! ========= ! type ( Gtau ), intent ( inout ) :: tau ! TDM to be initialized ! ... Executable ... deallocate ( tau % A_up ) deallocate ( tau % upt0 , tau % up0t ) deallocate ( tau % up00 , tau % uptt ) deallocate ( tau % itau_up ) deallocate ( tau % sgnup ) if ( associated ( tau % A_dn )) then deallocate ( tau % A_dn ) deallocate ( tau % dnt0 , tau % dn0t ) deallocate ( tau % dn00 , tau % dntt ) endif if ( associated ( tau % sgndn )) then deallocate ( tau % itau_dn ) deallocate ( tau % sgndn ) endif deallocate ( tau % W1 , tau % IW ) if ( tau % g0_stored ) then deallocate ( tau % e0up ) deallocate ( tau % e0dn ) deallocate ( tau % U0up ) deallocate ( tau % U0dn ) endif end subroutine DQMC_Gtau_Free !--------------------------------------------------------------------! subroutine DQMC_Gtau_LoadA ( tau , spin , slice , sgn ) ! ! This solves the gtau explicitly by Lapack. ! type ( gtau ), target , intent ( inout ) :: tau integer , intent ( in ) :: spin integer , intent ( in ) :: slice real ( wp ), intent ( out ) :: sgn ! ... Local var ... real ( wp ), pointer :: A (:,:) real ( wp ), pointer :: V (:,:) type ( MatB ), pointer :: B real ( wp ), pointer :: s integer , pointer :: t (:) real ( wp ), pointer :: gtau1 (:,:) real ( wp ), pointer :: gtau2 (:,:) integer :: i , j , k , h , isl , jsl integer :: n , nb , nnb , nor , L integer :: info ! ... Executable ... n = tau % n nb = tau % nb nnb = tau % nnb nor = tau % north L = tau % L isl = mod ( slice - 1 , nor ) + 1 if ( spin == TAU_UP . or . tau % comp_dn ) then call dqmc_gtau_setAlias ( spin , tau , A = A , V = V , B = B , sgn = s , itau = t ) ! making A A = ZERO do i = 1 , nnb A ( i , i ) = ONE end do ! Compute B products: !    i=0  B_{isl}BB...B_{isl-north+1} !    i=1  B_{isl+north}BB...B_{isl+1} !    i=2  B_{isl+2*north}BB...B_{isl+north+1} !    .... do i = 0 , nb - 1 ! Pointers to sub-diagonal blocks (except when i=0) jsl = mod ( isl + i * nor - 1 , L ) + 1 t ( i + 1 ) = jsl call DQMC_GetB ( n , tau % W3 , B , V (:, jsl ), tau % W2 ) do j = 2 , nor k = mod ( jsl - j + L , L ) + 1 call DQMC_MultB_Right ( n , tau % W3 , B , V (:, k ), tau % W2 ) enddo ! Subdiagonal blocks need negative sign if ( i > 0 ) tau % W3 = - tau % W3 j = mod ( i + nb - 1 , nb ) A ( i * n + 1 :( i + 1 ) * n , j * n + 1 :( j + 1 ) * n ) = tau % W3 end do ! Inversion call lapack_dgetrf ( nnb , nnb , A , nnb , tau % IW , info ) s = ONE do i = 1 , nnb if ( tau % IW ( i ) /= i ) s = - s if ( A ( i , i ) < ZERO ) s = - s enddo call lapack_dgetri ( nnb , A , nnb , tau % IW , tau % W1 , tau % lw , info ) elseif (. not . tau % neg_u ) then ! Use p-h symmetry to fill A_dn s => tau % sgndn do i = 0 , nb - 1 do j = 0 , nb - 1 gtau1 => tau % A_up ( i * n + 1 : ( i + 1 ) * n , j * n + 1 :( j + 1 ) * n ) gtau2 => tau % A_dn ( j * n + 1 : ( j + 1 ) * n , i * n + 1 :( i + 1 ) * n ) do h = 1 , n do k = 1 , n gtau2 ( h , k ) = - tau % P ( k ) * tau % P ( h ) * gtau1 ( k , h ) enddo enddo enddo enddo ! Equal time, equal site entries need correction do i = 1 , nnb tau % A_dn ( i , i ) = tau % A_dn ( i , i ) + ONE enddo else ! Negative U case with identical non-interacting parts s => tau % sgndn endif sgn = s end subroutine DQMC_Gtau_LoadA !--------------------------------------------------------------------! subroutine DQMC_Gtau_CopyUp ( tau ) ! ! Load content of A in upt0, up0t, dnt0 and dn0t. ! Equal time upt0=G_up(t+,t), up0t=G_up(t,t+) ! type ( Gtau ), intent ( inout ) :: tau integer :: h , k real ( wp ) :: PP do h = 1 , tau % n do k = 1 , tau % n PP = - tau % P ( k ) * tau % P ( h ) tau % dnt0 ( h , k ) = PP * tau % up0t ( k , h ) tau % dn0t ( h , k ) = PP * tau % upt0 ( k , h ) tau % dn00 ( h , k ) = PP * tau % up00 ( k , h ) tau % dntt ( h , k ) = PP * tau % uptt ( k , h ) enddo tau % dn00 ( h , h ) = ONE + tau % dn00 ( h , h ) tau % dntt ( h , h ) = ONE + tau % dntt ( h , h ) enddo tau % it_dn = tau % it_up tau % i0_dn = tau % i0_up end subroutine DQMC_Gtau_CopyUp !--------------------------------------------------------------------! subroutine DQMC_Gtau_DumpA ( tau , spin , it , i0 ) ! ! Load content of A in upt0, up0t, dnt0 and dn0t. ! Equal time upt0=G_up(t+,t), up0t=G_up(t,t+) ! type ( Gtau ), intent ( inout ) :: tau integer , intent ( in ) :: it , i0 , spin integer :: n , i , j0 , jt integer , pointer :: itptr integer , pointer :: i0ptr integer , pointer :: t (:) real ( wp ), pointer :: gt0 (:,:) real ( wp ), pointer :: g0t (:,:) real ( wp ), pointer :: g00 (:,:) real ( wp ), pointer :: gtt (:,:) real ( wp ), pointer :: A (:,:) n = tau % n call dqmc_gtau_setAlias ( spin , tau , A = A , gt0 = gt0 , g0t = g0t , g00 = g00 , gtt = gtt , it = itptr , i0 = i0ptr , itau = t ) ! Save current slice in tau itptr = t ( it ) i0ptr = t ( i0 ) ! Fill gt0 and g0t jt = ( it - 1 ) * n j0 = ( i0 - 1 ) * n gt0 = A ( jt + 1 : jt + n , j0 + 1 : j0 + n ) g0t = A ( j0 + 1 : j0 + n , jt + 1 : jt + n ) if ( i0 == it ) then do i = 1 , n g0t ( i , i ) = g0t ( i , i ) - ONE enddo endif g00 = A ( j0 + 1 : j0 + n , j0 + 1 : j0 + n ) gtt = A ( jt + 1 : jt + n , jt + 1 : jt + n ) end subroutine DQMC_Gtau_DumpA !--------------------------------------------------------------------! subroutine DQMC_MakeGtau ( tau , it , i0 ) ! ! Purpose ! ======= !    This subroutine generates Gtau. ! ! Arguments ! ========= ! type ( Gtau ), intent ( inout ) :: tau integer , intent ( in ) :: it , i0 ! ... local scalar integer :: n , idx , dt , d0 , L ! ... executable ... ! !  meaning of indices !     ii: the ii-th block row or column !     ib: the block offset ! !     id: ! initialization n = tau % n L = tau % L ! Find increment d0 = i0 - tau % i0_up if ( abs ( d0 ) > L / 2 ) d0 = d0 - sign ( L , d0 ) dt = it - tau % it_up if ( abs ( dt ) > L / 2 ) dt = dt - sign ( L , dt ) if ( abs ( dt ) + abs ( d0 ) == 1 ) then ! reduce safe count tau % sfc = tau % sfc - 1 ! Map the increment in a direction of motion if ( dt == 1 ) then idx = TPLUS elseif ( dt == - 1 ) then idx = TMINUS elseif ( d0 == 1 ) then idx = ZPLUS elseif ( d0 == - 1 ) then idx = ZMINUS endif else ! recompute if cannot use update tau % sfc = 0 end if ! compute Gtau if ( tau % sfc /= 0 ) then ! Update Gtau call DQMC_change_gtau_time ( tau , idx , TAU_UP ) call DQMC_change_gtau_time ( tau , idx , TAU_DN ) else ! Recompute Gtau from scratch call DQMC_GetGtau ( it , i0 , TAU_UP , tau % upt0 , tau % up0t , tau % upt0 , tau % up0t , tau ) call DQMC_GetGtau ( it , i0 , TAU_DN , tau % dnt0 , tau % dn0t , tau % dnt0 , tau % dn0t , tau ) !tau%sfc = tau%nWrap end if end subroutine DQMC_MakeGtau !-----------------------------------------------------! subroutine DQMC_GetGtau ( it , i0 , spin , gt0 , g0t , g00 , gtt , tau ) ! ! Derived from DQMC_GetGtau with a few bug fixes from Simone ! ! Purpose ! ======= ! !    This subroutine computes the (i,j) submatrix of Gtau if which !    equals to'R'ow or 'B'oth. and computes the (j,i) submatrix of !    Gtau if which equals to 'C'olumn or 'B'oth ! ! Mathematically, Gtau(Gdn_tau) is the inverse of ! !                  [  I                   B_1] !                  [-B_2   I                 ] !              M = [     -B_3  I             ] !                  [          ...   ...      ] !                  [             -B_{L}    I ] ! ! ! The (i,j) submatrix of Gtau is given as ! !     G_ii =    inv(I+B_iB_{i-1}...B_1B_L...B_{i+1}) !     gt0 = -Gtau_ii(B_iB_{i-1}...B_1B_L...B_{j+1})  for j = i+1...L !     gt0 =  Gtau_ii(B_iB_{i-1}...B_{j+1})           for j = 1...i-1 ! ! In general, we can write gt0 as ! !         gt0 = (+/-) inv(I+A_1A_2)A_1 !              = (+/-) inv(inv(A_1)+A_2) ! where ! !          A_1 = B_{i}...B_{j+1} and !          A_2 = B_{j}...B_{i+1} ! ! The following procedure compute gt0 in a stable way ! ! 1. Perform UDT decomposition on inv(A_1) and A_2 ! !       inv(A_1) = U_1D_1T_1 !           A_2  = U_2D_2T_2 ! !    See the DQMC_UDTD in DQMC_B.F90 for detail of UDT decomposition. ! ! 2. Decompose D_1 = barD_1*hatD_1 !              D_2 = barD_2*hatD_2 !    where !           barD_1(i,i) = max(1, D_1(i,i)) and !           hatD_1(i,i) = min(1, D_1(i,i)) ! ! 3. Compute ! !    C = hatD_2*T_2*inv(T_1)*inv(barD_1)+inv(barD_2)*inv(U_2)*U_1*hatD_1 ! ! 4. Assemble G as ! !    G = inv(T_1)*inv(barD_1)*inv(C)*inv(barD_2)*inv(U_2) !      = inv(T_1)*inv(D_2T_2inv(T_1)+inv(U_2)U_1D_1)*inv(U_2) !      = inv(U_1D_1T_1+U_2D_2T_2) !      = inv(inv(A_1)+A_2) !      = inv(I+A_1A_2)A_1 !      = inv(I+B_{i}...B_1*B_l...B_{i-1})B_i...B_{j+1} ! ! Matrix g0t has very similar structure with gt0. ! !     G_jj =    inv(I+B_jB_{j-1}...B_1B_L...B_{j+1}) !     g0t = -Gtau_jj(B_jB_{j-1}...B_1B_L...B_{i+1})  for i = j+1...L !     g0t =  Gtau_jj(B_jB_{j-1}...B_{i+1})           for i = 1...j-1 ! ! For a fixed i and j, ! !         g0t = (+/-) inv(I+A_2A_1)A_2 !              = (+/-) inv(inv(A_2)+A_1) ! ! where A_1 and A_2 are as defined before. ! Therefore, ! !         g0t = inv(inv(U_1D_1T_1)+inv(U_2D_2T_2)) !              = inv(inv(T_1)inv(D_1)inv(U_1)+inv(T_2)inv(D_2)inv(U_2)) !              = U_2*inv(inv(D_1)inv(U_1)U_2+T_1*inv(T_2)*inv(D_2))*T_1 ! ! The same trick of bar and hat is also applied to inv(D_1) and inv(D_2). ! !         g0t = U_2*inv(barD_2)*inv(...)*inv(barD_1)*T_1 ! ! where (...) = hatD_1*inv(U_1)U_2*inv(barD_2)+ !               inv(barD_1)T_1*inv(T_2)hatD_2 ! ! NOTE: the hatD_1, barD_1, hatD_2, and barD_2 here are different from !       the previous ones. ! ! See working notes for more detail. ! ! Arguments ! ========= ! integer , intent ( in ) :: it , i0 ! block indices integer , intent ( in ) :: spin real ( wp ), intent ( inout ) :: gt0 (:,:) ! submatrix of Gtau real ( wp ), intent ( inout ) :: g0t (:,:) ! submatrix of Gtau real ( wp ), intent ( inout ) :: g00 (:,:) ! submatrix of Gtau real ( wp ), intent ( inout ) :: gtt (:,:) ! submatrix of Gtau type ( Gtau ), intent ( inout ), target :: tau ! ... local scalars    ... integer :: info ! parameters for lapack's sub integer :: i ! iterator integer :: n integer :: which real ( wp ), pointer :: U1 (:,:) ! real ( wp ), pointer :: D1 (:) ! real ( wp ), pointer :: T1 (:,:) ! real ( wp ), pointer :: U2 (:,:) ! real ( wp ), pointer :: D2 (:) ! real ( wp ), pointer :: T2 (:,:) ! real ( wp ), pointer :: W1 (:,:) ! working space real ( wp ), pointer :: W2 (:,:) ! real ( wp ), pointer :: rw (:) ! working space real ( wp ), pointer :: V (:,:) ! HSF integer , pointer :: lw (:) ! integer , pointer :: pvt1 (:) ! integer , pointer :: pvt2 (:) ! real ( wp ), pointer :: bar1i (:) ! real ( wp ), pointer :: bar2i (:) ! real ( wp ), pointer :: hat1 (:) ! real ( wp ), pointer :: hat2 (:) ! type ( SeqB ), pointer :: SB1 type ( SeqB ), pointer :: SB2 ! ... Executable ... write ( * , * ) \"Need to implement g00 and gtt in GetGtau before using it\" g00 = 0 gtt = 0 stop ! STEP 0. Initialization n = tau % n !bar1i => tau%v1 !bar2i => tau%v2 !hat1  => tau%v3 !hat2  => tau%v4 !if(spin == TAU_UP) then !   SB1 => tau%SB1_up !   SB2 => tau%SB2_up !   V   => tau%V_up !else !   SB1 => tau%SB1_dn !   SB2 => tau%SB2_dn !   V   => tau%V_dn !endif !U1 => SB1%U !D1 => SB1%D !T1 => SB1%T !U2 => SB2%U !D2 => SB2%D !T2 => SB2%T !W1 => SB1%W1 !W2 => SB1%W2 !rw => SB1%rw !lw => SB1%lw !pvt1 => SB1%piv !pvt2 => SB2%piv info = 0 if ( it < 1 . or . it > tau % L . or . i0 < 1 . or . i0 > tau % L ) then write ( * , '(A)' ) \"GetGtau can only work with indices in [1,L]. Stop.\" stop endif ! STEP 1. Cmpute UDT decomposition of !         inv(A_1) = inv(B_{i}...B_{j+1}) !         and A_2  = B_j...B_{i+1}. ! ========================================== ! W1, W2, rw, lwork, tau, pvt1 can be reused. call DQMC_SeqMultB ( i0 , it + 1 , SB1 , V ) if ( it /= i0 ) then call DQMC_SeqMultBi ( it , i0 + 1 , SB2 , V ) which = tau % which else D2 = ONE call DQMC_Eye ( n , U2 ) call DQMC_Eye ( n , T2 ) which = TAU_T0 endif if ( which == TAU_T0 . or . which == TAU_BOTH ) then ! ! STEP 2.  D_1 = inv(barD_1)*hatD_1 !          D_2 = inv(barD_2)*hatD_2 ! ================================== do i = 1 , n bar1i ( i ) = ONE / max ( ONE , abs ( D1 ( i ))) hat1 ( i ) = D1 ( i ) * bar1i ( i ) bar2i ( i ) = ONE / max ( ONE , abs ( D2 ( i ))) hat2 ( i ) = D2 ( i ) * bar2i ( i ) end do ! ! STEP 3. Compute C = hatD_2*T_2*inv(T_1)*inv(barD_1)+ !                     inv(barD_2)*inv(U_2)*U_1*hatD_1 ! ======================================================= !! Compute  T_2*inv(T_1) ! copy T_1 to W_2, because we may need T_1 later call blas_dcopy ( n * n , T1 (:, 1 ), 1 , W2 (:, 1 ), 1 ) ! W_1 = T_2' call DQMC_trans ( n , W1 , T2 ) ! W_1 = inv(W_2')*W_1 = inv(T_1')*T_2' call lapack_dgetrf ( n , n , W2 , n , pvt1 , info ) call lapack_dgetrs ( 'T' , n , n , W2 , n , pvt1 , W1 , n , info ) if ( info /= 0 ) then call DQMC_Error ( \"Error: dgetrs(1) in dqmc_getgtau.\" , info ) end if ! T_2 = transpose(W_1) = transpose(inv(T_1')*T_2') = T_2*inv(T_1) call DQMC_trans ( n , T2 , W1 ) if ( tau % which == TAU_T0 ) then ! if only Row is computed, then T1 is not reference, reuse it call blas_dcopy ( n * n , gt0 (:, 1 ), 1 , T1 (:, 1 ), 1 ) end if ! U_1 = gt0 = U_2'*U_1 ! ** gt0 here is used as a temp variable call blas_dgemm ( 'T' , 'N' , n , n , n , ONE , U2 , n , U1 , n , ZERO , gt0 , n ) call blas_dcopy ( n * n , gt0 , 1 , U1 , 1 ) !! *** We need to keep T2 and U1 for later use. ! compute U_1 = barD_2*U_2'*U_1*hatD_1 call DQMC_ScaleRow ( n , gt0 , bar2i ) call DQMC_ScaleCol ( n , gt0 , hat1 ) ! compute W_1 = hatD_2*T_2*inv(T_1)*barD_1 call blas_dcopy ( n * n , T2 (:, 1 ), 1 , W1 (:, 1 ), 1 ) call DQMC_ScaleRow ( n , W1 , hat2 ) call DQMC_ScaleCol ( n , W1 , bar1i ) ! W_1 = W_1 + gt0 (This is called \"C\" where STEP 3 is defined) call blas_daxpy ( n * n , ONE , gt0 , 1 , W1 , 1 ) ! ! STEP 4. Compute inv(T_1)*inv(barD_1)*inv(C)*inv(barD_2)*inv(U_2) ! ================================================================= ! Let gt0 = inv(barD_2) * inv(U2) call DQMC_trans ( n , gt0 , U2 ) call DQMC_ScaleRow ( n , gt0 , bar2i ) ! Straight inversion of \"C\" using LU (dgesv calls dgetrf). ! To be modified using the safer alternative of a further ! UDT decomposition followed by inversion? ! gt0 = inv(W_1)*inv(barD_2)*inv(U_2) call lapack_dgesv ( n , n , W1 , n , pvt2 , gt0 , n , info ) if ( info /= 0 ) then call DQMC_Error ( \"Error: dgesv(2) in dqmc_getgtau.\" , info ) end if ! gt0 = inv(barD_1)*gt0 = inv(barD_1)*inv(W_1)*inv(barD_2)*inv(U_2) call DQMC_ScaleRow ( n , gt0 , bar1i ) ! gt0 = inv(T_1)*gt0 !      = inv(T_1)*inv(barD_1)*inv(C)*inv(barD_2)*inv(U_2) call lapack_dgetrs ( 'N' , n , n , W2 , n , pvt1 , gt0 , n , info ) if ( info /= 0 ) then call DQMC_Error ( \"Error: dgetrs(1) in dqmc_getgtau.\" , info ) end if end if ! ! Compute g0t, repeat step 2, 3, 4 for Gji ! ========================================== if ( which == TAU_0T . or . which == TAU_BOTH ) then ! ! STEP 5.  inv(D_1) = barD_1*hatD_1 !          inv(D_2) = barD_2*hatD_2 ! ====================================== ! do i = 1 , n if ( D1 ( i ) == ZERO ) then call DQMC_Error ( \"Error: in dqmc_getgtau, D1(i)=0.0, i=\" , i ) end if D1 ( i ) = ONE / D1 ( i ) bar1i ( i ) = ONE / max ( ONE , D1 ( i )) hat1 ( i ) = D1 ( i ) * bar1i ( i ) if ( D2 ( i ) == ZERO ) then call DQMC_Error ( \"Error: in dqmc_getgtau, D2(i)=0.0, i=\" , i ) end if D2 ( i ) = ONE / D2 ( i ) bar2i ( i ) = ONE / max ( ONE , D2 ( i )) hat2 ( i ) = D2 ( i ) * bar2i ( i ) end do ! ! STEP 6. Compute g0t = hatD_1*inv(U_1)U_2*inv(barD_2)+ !                        inv(barD_1)T_1*inv(T_2)hatD_2 ! ======================================================= if ( tau % which == TAU_BOTH ) then ! Previously, T_2 = T_2*inv(T_1) !             U_1 = inv(U_2)*U_1 ! Therefore, we only need to invert them. ! first, compute inv(barD_1)T_1*inv(T_2)hatD_2 call lapack_dgetrf ( n , n , T2 , n , pvt1 , info ) if ( info /= 0 ) then call DQMC_Error ( \"Error: dgetrf(1) in dqmc_getgtau.\" , info ) end if call lapack_dgetri ( n , T2 , n , pvt1 , rw , lw ( LA_GETRI ), info ) ! W1 = U1' = inv(inv(U_2)*U_1) = inv(U_1)*U_2 call DQMC_Trans ( n , W1 , U1 ) else ! No previous computed results. Compute them from scratch. ! ! (1) Compute T_1*inv(T_2) !     Let W_1 = T_1' call DQMC_trans ( n , W1 , T1 ) !     W_1 = inv(T_2')*W_1 = inv(T_2')*T_1' call lapack_dgetrf ( n , n , T2 , n , pvt1 , info ) call lapack_dgetrs ( 'T' , n , n , T2 , n , pvt1 , W1 , n , info ) if ( info /= 0 ) then call DQMC_Error ( \"Error: dgetrs(1) in dqmc_getgtau.\" , info ) end if !     T_2 = W_1' = (inv(T_2')*T_1')' = T_1*inv(T_2) call DQMC_trans ( n , T2 , W1 ) ! (2) Compute W_1 = U_2'*U_1 call blas_dgemm ( 'T' , 'N' , n , n , n , ONE , U1 , n , U2 , n , ZERO , W1 , n ) end if ! Compute inv(barD_1)T_1*inv(T_2)hatD_2 call DQMC_ScaleRow ( n , T2 , bar1i ) call DQMC_ScaleCol ( n , T2 , hat2 ) ! Compute hatD_1*inv(U_1)U_2*inv(barD_2) call DQMC_ScaleRow ( n , W1 , hat1 ) call DQMC_ScaleCol ( n , W1 , bar2i ) ! W1 = W1 + T2 call blas_daxpy ( n * n , ONE , T2 , 1 , W1 , 1 ) ! ! STEP 7. Compute U_2*inv(barD_2)*inv(...)*inv(barD_1)*T_1 ! ========================================================= ! call DQMC_ScaleRow ( n , T1 , bar1i ) call lapack_dgesv ( n , n , W1 , n , pvt1 , T1 , n , info ) if ( info /= 0 ) then call DQMC_Error ( \"Error: dgesv(3) in dqmc_getgtau.\" , info ) end if ! inv(barD_2)*inv(...)*inv(barD_1)*T_1 call DQMC_ScaleRow ( n , T1 , bar2i ) ! copy the previous result call blas_dcopy ( n * n , gt0 (:, 1 ), 1 , W2 (:, 1 ), 1 ) ! multiply -U2, the sign is negative call blas_dgemm ( 'N' , 'N' , n , n , n , - ONE , U2 , n , T1 , n , ZERO , g0t , n ) end if if ( it == i0 . and . tau % which > TAU_T0 ) then g0t = gt0 endif if ( i0 > it ) then if ( tau % which < TAU_0T ) gt0 = - gt0 if ( tau % which > TAU_T0 ) g0t = - g0t endif if ( spin == TAU_UP ) then tau % it_up = it tau % i0_up = i0 else tau % it_dn = it tau % i0_dn = i0 endif end subroutine DQMC_GetGtau !--------------------------------------------------------------------! subroutine DQMC_change_gtau_time ( tau , idir , spin ) ! ! Purpose ! ======= ! This subroutine computes a new Gtau which is adjacent ! to the one stored in tau using the recursion relations. ! idir specifies which one of the adjacent four G has to be ! computed. ! ! tau contains (or may contain) two blocks : ! G(i,j) and G(j,i) where i and j are time indices. tau%ii ! and tau%ib are assumed to contain the indices i and j ! (Note that somewhere else tau%ib contains the displacement ! from tau%ii instead). The variable tau%which says whether ! G(i,j) and/or G(j,i) are stored. ! ! This routine applies the following transformation: !   if (idir == TPLUS [1]) G(i,j)=>G(i+1,j) and/or G(j,i)=>G(j,i+1) !   if (idir == TMINUS[2]) G(i,j)=>G(i-1,j) and/or G(j,i)=>G(j,i-1) !   if (idir == ZPLUS [3]) G(i,j)=>G(i,j+1) and/or G(j,i)=>G(j+1,i) !   if (idir == ZMINUS[4]) G(i,j)=>G(i,j-1) and/or G(j,i)=>G(j-1,i) ! keeping correctly track of the case where i==j (either ! initially or after the transformation). ! i and j are always kept between 1 and L. ! ! Arguments ! ========= ! type ( Gtau ), intent ( inout ) :: tau integer , intent ( in ) :: idir integer , intent ( in ) :: spin ! ... local ... integer :: i , j , id , n , L ! ... aliases ... type ( matB ), pointer :: B real ( wp ), pointer :: gt0 (:,:) real ( wp ), pointer :: g0t (:,:) real ( wp ), pointer :: g00 (:,:) real ( wp ), pointer :: gtt (:,:) real ( wp ), pointer :: W (:,:) real ( wp ), pointer :: V (:,:) integer , pointer :: it integer , pointer :: i0 n = tau % n L = tau % L W => tau % W2 call dqmc_gtau_setAlias ( spin , tau , B = B , V = V , gt0 = gt0 , g0t = g0t , g00 = g00 , gtt = gtt , it = it , i0 = i0 ) if ( tau % which <= TAU_BOTH ) then select case ( idir ) case ( TPLUS ) ! G(i,j)=> G(i+1,j) i = it + 1 if ( i > L ) i = 1 !Multiply by B_{ii+1} call DQMC_MultB_Left ( n , gt0 , B , V (:, i ), W ) !Time wrapped through beta. Need to change sign. if ( i == 1 ) then gt0 = - gt0 endif !Final G is equal time. Handle G(i,j) properly. if ( i0 == i ) then do id = 1 , n gt0 ( id , id ) = 1.d0 + gt0 ( id , id ) enddo endif case ( TMINUS ) ! G(i,j)=> G(i-1,j) i = it !Initial G is equal time. Handle G(i,j) properly. if ( i0 == it ) then do id = 1 , n gt0 ( id , id ) = - 1.d0 + gt0 ( id , id ) enddo endif call DQMC_MultBi_Left ( n , gt0 , B , V (:, i ), W ) !Time wrapped through zero. Need to change sign. if ( i == 1 ) then gt0 = - gt0 i = L else i = i - 1 endif case ( ZPLUS ) !G(i,j)=> G(i,j+1) j = i0 + 1 if ( j > L ) j = 1 ! Initial G is equal time. if ( i0 == it ) then do id = 1 , n gt0 ( id , id ) = - 1.d0 + gt0 ( id , id ) enddo endif call DQMC_MultBi_Right ( n , gt0 , B , V (:, j ), W ) !Time wrapped through beta. Need to change sign. if ( j == 1 ) then gt0 = - gt0 endif case ( ZMINUS ) !G(i,j)=> G(i,j-1) j = i0 call DQMC_MultB_Right ( n , gt0 , B , V (:, j ), W ) !Time wrapped through zero. Need to change sign. if ( j == 1 ) then gt0 = - gt0 j = L else j = j - 1 endif !Final G is equal time. Treat G(i,j) properly. if ( it == j ) then do id = 1 , n gt0 ( id , id ) = 1.d0 + gt0 ( id , id ) enddo endif end select endif if ( tau % which >= TAU_BOTH ) then select case ( idir ) case ( TPLUS ) ! G(j,i)=>G(j,i+1) i = it + 1 if ( i > L ) i = 1 !Multiply by B_{i+1} and its inverse call DQMC_MultBi_Right ( n , g0t , B , V (:, i ), W ) !Time wrapped through beta. Need to change sign. if ( i == 1 ) then g0t = - g0t endif ! Update equal time G at t call DQMC_MultB_Left ( n , gtt , B , V (:, i ), W ) call DQMC_MultBi_Right ( n , gtt , B , V (:, i ), W ) !Final G is equal time. Handle G(j,i) properly. if ( i0 == i ) then do id = 1 , n g0t ( id , id ) = - 1.d0 + g0t ( id , id ) enddo endif case ( TMINUS ) ! G(j,i)=>G(j,i-1) i = it !Initial G is equal time. Handle G(j,i) properly. if ( i0 == i ) then do id = 1 , n g0t ( id , id ) = 1.d0 + g0t ( id , id ) enddo endif call DQMC_MultB_Right ( n , g0t , B , V (:, i ), W ) ! Update equal time G at t call DQMC_MultBi_Left ( n , gtt , B , V (:, i ), W ) call DQMC_MultB_Right ( n , gtt , B , V (:, i ), W ) !Time wrapped through zero. Need to change sign. if ( i == 1 ) then g0t = - g0t i = L else i = i - 1 endif ! Update gtt case ( ZPLUS ) !G(j,i)=>G(j+1,i) j = i0 + 1 if ( j > L ) j = 1 !Initial G is equal time. Handle G(j,i) properly. if ( it == i0 ) then do id = 1 , n g0t ( id , id ) = 1.d0 + g0t ( id , id ) enddo endif call DQMC_MultB_Left ( n , g0t , B , V (:, j ), W ) ! Update equal time G at 0 call DQMC_MultB_Left ( n , g00 , B , V (:, j ), W ) call DQMC_MultBi_Right ( n , g00 , B , V (:, j ), W ) !Time wrapped through beta. Need to change sign. if ( j == 1 ) then g0t = - g0t endif case ( ZMINUS ) ! G(j,i)=>G(j-1,i) j = i0 call DQMC_MultBi_Left ( n , g0t , B , V (:, j ), W ) ! Update equal time G at 0 call DQMC_MultBi_Left ( n , g00 , B , V (:, j ), W ) call DQMC_MultB_Right ( n , g00 , B , V (:, j ), W ) !Time wrapped through zero. Need to change sign. if ( j == 1 ) then g0t = - g0t j = L else j = j - 1 endif if ( it == j ) then do id = 1 , n g0t ( id , id ) = - 1.d0 + g0t ( id , id ) enddo endif end select endif !Update block index select case ( idir ) case ( 1 , 2 ) it = i case ( 3 , 4 ) i0 = j end select end subroutine DQMC_change_gtau_time !---------------------------------------------------------------------! subroutine DQMC_Gtau_SetAlias ( spin , tau , A , B , V , gt0 , g0t , g00 , gtt , it , i0 , itau , sgn ) integer , intent ( in ) :: spin type ( gtau ), target , intent ( in ) :: tau type ( MatB ), pointer , optional :: B integer , pointer , optional :: itau (:) real ( wp ), pointer , optional :: A (:,:) real ( wp ), pointer , optional :: V (:,:) real ( wp ), pointer , optional :: gt0 (:,:) real ( wp ), pointer , optional :: g0t (:,:) real ( wp ), pointer , optional :: g00 (:,:) real ( wp ), pointer , optional :: gtt (:,:) integer , pointer , optional :: it integer , pointer , optional :: i0 real ( wp ), pointer , optional :: sgn select case ( spin ) case ( TAU_UP ) if ( present ( A )) A => tau % A_up if ( present ( B )) B => tau % B_up if ( present ( V )) V => tau % V_up if ( present ( gt0 )) gt0 => tau % upt0 if ( present ( g0t )) g0t => tau % up0t if ( present ( gtt )) gtt => tau % uptt if ( present ( g00 )) g00 => tau % up00 if ( present ( it )) it => tau % it_up if ( present ( i0 )) i0 => tau % i0_up if ( present ( sgn )) sgn => tau % sgnup if ( present ( itau )) itau => tau % itau_up case ( TAU_DN ) if ( present ( A )) A => tau % A_dn if ( present ( B )) B => tau % B_dn if ( present ( V )) V => tau % V_dn if ( present ( gt0 )) gt0 => tau % dnt0 if ( present ( g0t )) g0t => tau % dn0t if ( present ( gtt )) gtt => tau % dntt if ( present ( g00 )) g00 => tau % dn00 if ( present ( it )) it => tau % it_dn if ( present ( i0 )) i0 => tau % i0_dn if ( present ( sgn )) sgn => tau % sgndn if ( present ( itau )) itau => tau % itau_dn end select end subroutine DQMC_Gtau_SetAlias !--------------------------------------------------------------------! subroutine DQMC_Gtau_GetG0 ( n , tau , spin , slice , g0tau ) integer , intent ( in ) :: n type ( gtau ), intent ( inout ) :: tau integer , intent ( in ) :: spin integer , intent ( in ) :: slice real ( wp ), intent ( out ) :: g0tau ( n , n ) integer :: L , lw , info real ( wp ) :: alpha , beta real ( wp ) :: g ( n ) real ( wp ), allocatable :: work (:) ! ! This solves the gtau explicitly by Lapack. ! ! ... Executable ... alpha = 1.0_wp beta = 1.0_wp g0tau = 0.0_wp L = tau % L if (. not . tau % g0_stored ) then call dsyev ( 'V' , 'L' , n , tau % W2 , n , tau % W1 , tau % W1 , - 1 , info ) lw = nint ( tau % W1 ( 1 )) allocate ( work ( lw )) allocate ( tau % e0up ( n )) allocate ( tau % e0dn ( n )) allocate ( tau % U0up ( n , n )) allocate ( tau % U0dn ( n , n )) tau % W1 = 1.0_wp call DQMC_GetB ( n , tau % U0up , tau % B_up , tau % W1 , tau % W2 ) call DQMC_GetB ( n , tau % U0dn , tau % B_dn , tau % W1 , tau % W2 ) call dsyev ( 'V' , 'L' , n , tau % U0up , n , tau % e0up , work , lw , info ) call dsyev ( 'V' , 'L' , n , tau % U0dn , n , tau % e0dn , work , lw , info ) tau % g0_stored = . true . endif if ( spin == TAU_UP . or . spin == 0 ) then g = tau % e0up ** slice / ( 1.0_wp + tau % e0up ** L ) call dcopy ( n * n , tau % U0up (:, 1 ), 1 , tau % W2 (:, 1 ), 1 ) call dqmc_scaleCol ( n , tau % W2 , g ) call dgemm ( 'N' , 'C' , n , n , n , alpha , tau % W2 , n , tau % U0up , n , beta , g0tau , n ) endif if ( spin == TAU_DN . or . spin == 0 ) then g = tau % e0dn ** slice / ( 1.0_wp + tau % e0dn ** L ) call dcopy ( n * n , tau % U0dn (:, 1 ), 1 , tau % W2 (:, 1 ), 1 ) call dqmc_scaleCol ( n , tau % W2 , g ) call dgemm ( 'N' , 'C' , n , n , n , alpha , tau % W2 , n , tau % U0dn , n , beta , g0tau , n ) endif if ( spin == 0 ) g0tau = g0tau / 2 end subroutine DQMC_Gtau_GetG0 !--------------------------------------------------------------------! end module DQMC_GTAU","tags":"","loc":"sourcefile/dqmc_gtau.f90.html"},{"title":"dqmc_bonds.F90 – Quest","text":"This file depends on sourcefile~~dqmc_bonds.f90~~EfferentGraph sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_bonds.f90~~AfferentGraph sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_kbonds.f90 dqmc_kbonds.F90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_BONDS use DQMC_geom_param use DQMC_LATT implicit none type :: bonds_t integer :: ntotbond !number of bonds read from input, possibly augmented by symmetry integer , pointer :: bond_label (:) !label of bond (ntotbond) integer , pointer :: bond_origin (:) !primitive cell site from which bond originates (ntotbond) integer , pointer :: bond_target (:) real ( wp ), pointer :: xxbond (:,:) !bond vector cartesian coordinates (rdim,ntotbond) integer :: nclass_b !number of inequivalent bond pairs integer , pointer :: myclass_b (:,:) !class for pair of bonds (ntotbond,ntotbond) integer , pointer :: class_size_b (:) !number of equivalent pairs of bond in each class (nclass_b) logical :: initialized logical :: analyzed end type type :: pairing integer :: nwave !number of waves to analyze integer :: nbond !number of bonds necessary to describe  waves integer , pointer :: nbondv (:) !number of bonds in each cell (0:ncell-1)(constant if no-dilution) integer , pointer :: bond_origin (:,:) !origin of bond in a given cell (nbond, 0:ncell-1) integer , pointer :: bond_end (:,:) !end of bond originating from cell (nbond, 0:ncell-1) integer , pointer :: bond_map (:) !mapping to the bonds in bonds_t (nbond) integer , pointer :: pair_map (:) !inverse of bond_map: Given a bond returns its label in pairing. !If 0 bond does not enter pairing integer , pointer :: bond_number (:,:) !label of bonds starting from each cell (nbond,0:ncell-1)(needed when diluted) real ( wp ), pointer :: bond_wgt (:,:) !coefficient forming the wave (nwave, nbond) character * 20 , pointer :: wave_label (:) !label of wave: s-wave, d-wave etc... (nwave) integer , pointer :: myclass_p (:,:) integer :: nclass_p integer , pointer :: class_size_p (:) logical :: initialized end type contains !------------------------------------------------------! subroutine free_bonds ( bonds ) type ( bonds_t ), intent ( out ) :: bonds if ( associated ( bonds % xxbond )) deallocate ( bonds % xxbond ) if ( associated ( bonds % myclass_b )) deallocate ( bonds % myclass_b ) if ( associated ( bonds % bond_label )) deallocate ( bonds % bond_label ) if ( associated ( bonds % bond_origin )) deallocate ( bonds % bond_origin ) if ( associated ( bonds % bond_target )) deallocate ( bonds % bond_target ) if ( associated ( bonds % class_size_b )) deallocate ( bonds % class_size_b ) end subroutine free_bonds !------------------------------------------------------! subroutine free_pairs ( pairs ) type ( pairing ), intent ( out ) :: pairs if ( associated ( pairs % nbondv )) deallocate ( pairs % nbondv ) if ( associated ( pairs % bond_end )) deallocate ( pairs % bond_end ) if ( associated ( pairs % bond_map )) deallocate ( pairs % bond_map ) if ( associated ( pairs % pair_map )) deallocate ( pairs % pair_map ) if ( associated ( pairs % bond_wgt )) deallocate ( pairs % bond_wgt ) if ( associated ( pairs % myclass_p )) deallocate ( pairs % myclass_p ) if ( associated ( pairs % wave_label )) deallocate ( pairs % wave_label ) if ( associated ( pairs % bond_origin )) deallocate ( pairs % bond_origin ) if ( associated ( pairs % bond_number )) deallocate ( pairs % bond_number ) if ( associated ( pairs % class_size_p )) deallocate ( pairs % class_size_p ) end subroutine free_pairs !------------------------------------------------------------------------------------- ! This subroutine defines 1)bond_label(ibond): the label of the ibond-th ! bond. This label is just the number of the record corresponding to that bond. ! Bonds between sites A and B (A/=B) have two labels: irec for A->B and -irec for ! B->A. 2)bond_origin(ibond): the site where the ibond-th bond originates. ! xxbond(1:3,ibond) are the cartesian coordinate describing the bond. When ! bond_label(jbond)=-bond_label(ibond) => xxbond(1:3,jbond)=-xxbond(1:3,ibond) !------------------------------------------------------------------------------------- subroutine read_bonds ( Bonds , SOP ) type ( bonds_t ) :: Bonds integer , intent ( in ) :: SOP integer :: nrecord , iat , jat , ibond , irec , ios , i , ntotbond integer , pointer :: bond_label (:) integer , pointer :: bond_origin (:) integer , pointer :: bond_target (:) real ( wp ) :: delta ( rdim ) real ( wp ), pointer :: xxbond (:,:) character * 100 string logical ldum ntotbond = 0 nrecord = 0 Bonds % initialized = . false . if ( move_to_record ( INPUT_FIELDS ( BONDS_F ), inpunit )) then !Count the bonds do read ( inpunit , '(A)' ) string read ( string , * , iostat = ios ) iat , jat ,( delta ( i ), i = 1 , rdim ) if ( ios . ne . 0 ) exit nrecord = nrecord + 1 ntotbond = ntotbond + 1 !Add the bond the goes in the opposite direction to the list if (. not .( iat == jat . and . sum ( delta ** 2 ) < 1.d-10 )) ntotbond = ntotbond + 1 enddo allocate ( bond_origin ( ntotbond ), bond_target ( ntotbond ), bond_label ( ntotbond ), xxbond ( rdim , ntotbond )) !rewind to the beginning of BONDS field ldum = move_to_record ( INPUT_FIELDS ( BONDS_F ), inpunit ) ibond = 0 !Read again and store bond information do irec = 1 , nrecord read ( inpunit , '(A)' ) string read ( string , * ) iat , jat ,( delta ( i ), i = 1 , rdim ) ibond = ibond + 1 xxbond (:, ibond ) = delta (:) bond_label ( ibond ) = irec bond_origin ( ibond ) = iat bond_target ( ibond ) = jat if ( iat == jat . and . sum ( delta ** 2 ) < 1.d-10 ) cycle !Store info for \"opposite\" bond ibond = ibond + 1 xxbond (:, ibond ) =- delta (:) bond_label ( ibond ) =- irec bond_origin ( ibond ) = jat bond_target ( ibond ) = iat enddo !Print out write ( SOP , * ) 'Bonds (from input)' do ibond = 1 , ntotbond write ( SOP , '(3i4,3f12.7)' ) ibond , bond_label ( ibond ), bond_origin ( ibond ), xxbond ( 1 : rdim , ibond ) enddo !Save info in Bonds Bonds % ntotbond = ntotbond Bonds % bond_label => bond_label Bonds % bond_origin => bond_origin Bonds % bond_target => bond_target Bonds % xxbond => xxbond Bonds % initialized = . true . Found_Field ( BONDS_F ) = . true . endif end subroutine read_bonds !------------------------------------------------------------------------------------------ ! Construct all bonds i.e. pairs of atoms that enter pairing susceptibility. ! Each bond is characterized by pair_bond_origin(ibond,icell) which specify the ! site on cell icell where the ibond-th bond begins and pair_bond_end(ibond,icell) that ! specify the site on which it ends. Reads and store the names (wave_label) and ! coeffiecients (pair_bond_wgt) with which the pairing susceptibility have to be ! combined to obtain pair state with a given angular momentum. !------------------------------------------------------------------------------------------ subroutine construct_pairs ( Bonds , Pairs , lattice , SOP ) type ( bonds_t ) :: Bonds type ( pairing ) :: Pairs type ( lattice_t ) :: lattice integer , intent ( in ) :: SOP integer :: ios , idum , ibond , iwave , iat , jat , icell , isite , jbond , nwave , npairbond , natom , nsites , ncell integer , allocatable :: pair_bond_label (:) integer , pointer :: pair_bond_origin (:,:) integer , pointer :: pair_bond_end (:,:) integer , pointer :: pair_bond_map (:) integer , pointer :: npairbondv (:) integer , pointer :: pair_bond_number (:,:) real ( wp ) :: rdum real ( wp ), pointer :: pair_bond_wgt (:,:) character * 100 string character * 10 :: label character * 20 , pointer :: wave_label (:) logical :: ldum , donullify natom = lattice % natom nsites = lattice % nsites ncell = lattice % ncell npairbond = 0 if (. not . Bonds % initialized ) stop 'Need to initialize Bonds before calling make_pairs' allocate ( Pairs % pair_map ( Bonds % ntotbond )) if ( move_to_record ( INPUT_FIELDS ( PAIRS_F ), inpunit )) then read ( inpunit , '(A)' ) string !count how many bonds are used to define pairing function do if ( npairbond > Bonds % ntotbond ) stop 'Too many bonds in #PAIRING.' npairbond = npairbond + 1 read ( string , * , iostat = ios )( idum , ibond = 1 , npairbond ) if ( ios /= 0 ) exit enddo npairbond = npairbond - 1 !Count \"waves\" nwave = 0 do read ( inpunit , * , iostat = ios ) label ,( rdum , ibond = 1 , npairbond ) if ( ios /= 0 ) exit nwave = nwave + 1 enddo allocate ( wave_label ( nwave ), pair_bond_wgt ( nwave , npairbond ), pair_bond_map ( npairbond ), pair_bond_label ( npairbond )) !rewind to beginning of #PAIR field ldum = move_to_record ( '#PAIR' , inpunit ) !Read and store the bonds defining the pairs read ( inpunit , * )( pair_bond_label ( ibond ), ibond = 1 , npairbond ) !Construct the mapping from pairs to bond (bond_map) and viceversa (pair_map) Pairs % pair_map (:) = 0 do ibond = 1 , npairbond do jbond = 1 , Bonds % ntotbond if ( pair_bond_label ( ibond ) == Bonds % bond_label ( jbond )) then pair_bond_map ( ibond ) = jbond Pairs % pair_map ( jbond ) = ibond exit endif enddo if ( jbond > Bonds % ntotbond ) stop 'One or more labels in #PAIRING are wrong' enddo do iwave = 1 , nwave read ( inpunit , * ) wave_label ( iwave ),( pair_bond_wgt ( iwave , ibond ), ibond = 1 , npairbond ) rdum = sqrt ( sum ( pair_bond_wgt ( iwave , 1 : npairbond ) ** 2 )) pair_bond_wgt ( iwave , 1 : npairbond ) = pair_bond_wgt ( iwave , 1 : npairbond ) / rdum enddo !Print write ( SOP , '(1x,A)' ) 'Wave coefficients' write ( SOP , '(11x,20(5x,i2,3x))' )( pair_bond_map ( ibond ), ibond = 1 , npairbond ) do iwave = 1 , nwave write ( SOP , '(1x,A10,20f10.5)' ) wave_label ( iwave ),( pair_bond_wgt ( iwave , ibond ), ibond = 1 , npairbond ) enddo write ( SOP , '(76(''=''))' ) deallocate ( pair_bond_label ) donullify = . false . else !The field #PAIR was not specified: Use as many waves as bonds npairbond = Bonds % ntotbond nwave = npairbond allocate ( wave_label ( nwave ), pair_bond_map ( npairbond )) !label is temporarily given by an integer do iwave = 1 , nwave write ( wave_label ( iwave ), '(i2)' ) iwave enddo !mapping is trivial do ibond = 1 , npairbond pair_bond_map ( ibond ) = ibond Pairs % pair_map ( ibond ) = ibond enddo donullify = . true . endif !Define origin and target of all bonds in simulation cell. allocate ( pair_bond_origin ( npairbond , 0 : ncell - 1 ), pair_bond_end ( npairbond , 0 : ncell - 1 ), npairbondv ( 0 : ncell - 1 ), & & pair_bond_number ( npairbond , 0 : ncell - 1 )) !store how many bonds are associated with a given cell npairbondv ( 0 : ncell - 1 ) = npairbond !needed when system is site-diluted !loop over all sites do isite = 0 , nsites - 1 !find atom type and cell where isite is contained iat = mod ( isite , natom ) icell = isite / natom do ibond = 1 , npairbond jbond = pair_bond_map ( ibond ) !Check which bonds originate from that site if ( Bonds % bond_origin ( jbond ) == iat ) then !Save isite as the site in cell \"icell\" from where \"ibond\" originates pair_bond_origin ( ibond , icell ) = isite jat = Bonds % bond_target ( jbond ) !Save the site where ibond from icell is pointing pair_bond_end ( ibond , icell ) = hoptowho ( isite , Bonds % xxbond ( 1 : rdim , jbond ), jat , lattice ) pair_bond_number ( ibond , icell ) = ibond !needed when system is site-diluted endif enddo enddo !Fill members of Pairs Pairs % nwave = nwave Pairs % nbond = npairbond Pairs % nbondv => npairbondv Pairs % bond_map => pair_bond_map Pairs % bond_number => pair_bond_number Pairs % bond_end => pair_bond_end Pairs % bond_origin => pair_bond_origin Pairs % wave_label => wave_label if ( donullify ) then nullify ( Pairs % bond_wgt ) else Pairs % bond_wgt => pair_bond_wgt endif end subroutine construct_pairs end module DQMC_BONDS","tags":"","loc":"sourcefile/dqmc_bonds.f90.html"},{"title":"dqmc_2dperl.F90 – Quest","text":"This file depends on sourcefile~~dqmc_2dperl.f90~~EfferentGraph sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_2dperl.f90~~AfferentGraph sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_2DPERL use DQMC_UTIL use DQMC_CFG use DQMC_STRUCT use DQMC_HUBBARD ! Chia-Chen: 09/06/2011 ! added in order to access the number of processors use DQMC_MPI implicit none ! ! This module defines subroutines to initialize the data structure of ! a two-dimensional periodic rectangular lattice (2DPerl). ! !  Subroutine List !  =============== !    DQMC_Read2PERL : read in data for 2D rectangular !                                    lattice. !    DQMC_2DREC(nx, ny, S) : construct data for a 2D rectangular lattice. ! integer , parameter :: IMP_TRIANGLE = 1 integer , parameter :: IMP_RECTANGLE = 2 contains !---------------------------------------------------------------------! subroutine DQMC_Comp_2DPerl ! ! Purpose ! ======= !    This subroutine reads in data for a 2D rectangular lattice, !    and the calls DQMC_2DREC to construct the lattice structure. !    Basically, the only parameters needed are Nx and Ny, which !    the size of the lattice along the x-cord and the y-cord. ! ! Arguments ! ========= ! integer :: OPT ! Input/output handle ! ... Local scalar ... type ( config ) :: cfg type ( Hubbard ) :: Hub ! Hubbard model integer :: nx , ny integer :: i , j , k , nBin , nIter , slice real ( wp ) :: randn ( 1 ) character ( len = 60 ) :: ofile ! ... Executable ... ! Read in run parameters from input file call DQMC_Read_Config ( cfg ) ! Initialize the geometry call CFG_Get ( cfg , \"nx\" , nx ) call CFG_Get ( cfg , \"ny\" , ny ) call DQMC_Init_2DPerl ( nx , ny , Hub % S , IMP_TRIANGLE ) ! Fetch additional parameters call CFG_Get ( cfg , \"ofile\" , ofile ) ! output file name ! Initialize the Hubbard data structure call DQMC_Hub_Config ( Hub , cfg ) ! Execution MC loop ! Warmup sweep do i = 1 , Hub % nWarm if ( mod ( i , 10 ) == 0 ) write ( * , '(A,i6,1x,i3)' ) ' Warmup Sweep, nwrap  : ' , i , Hub % G_up % nwrap ! The second parameter means no measurement should be made. call DQMC_Hub_Sweep ( Hub , NO_MEAS0 ) call DQMC_Hub_Sweep2 ( Hub , Hub % nTry ) end do ! Measurement sweeps. Note that we divide up nPass measurement sweeps into nBins, ! each having nPass/nBin sweeps. This is to reduce autocorrelation between measurements. nBin = Hub % P0 % nBin nIter = Hub % nPass / Hub % tausk / nBin if ( nIter > 0 ) then do i = 1 , nBin do j = 1 , nIter do k = 1 , Hub % tausk call DQMC_Hub_Sweep ( Hub , NO_MEAS0 ) call DQMC_Hub_Sweep2 ( Hub , Hub % nTry ) enddo ! Fetch a random imaginary time slice for measurement call ran0 ( 1 , randn , Hub % seed ) slice = ceiling ( randn ( 1 ) * Hub % L ) write ( * , '(a,3i6)' ) ' Measurement Sweep, bin, iter, slice : ' , i , j , slice call DQMC_Hub_Meas ( Hub , slice ) end do ! Accumulate results for each bin call DQMC_Phy0_Avg ( Hub % P0 ) if ( Hub % meas2 ) then if ( Hub % P2 % diagonalize ) then call DQMC_Phy2_Avg ( Hub % P2 , Hub % S ) else call DQMC_Phy2_Avg ( Hub % P2 , Hub % S % W ) endif end if end do else write ( * , * ) \" Error : The number of measurement sweeps npass/(nbin*tausk) in each bin is less than zero!\" write ( * , * ) \"         Reset 'npass', 'nbin', and 'tausk' in the input and start over\" stop endif !Compute average and error call DQMC_Phy0_GetErr ( Hub % P0 ) if ( Hub % meas2 ) then call DQMC_Phy2_GetErr ( Hub % P2 ) end if ! Prepare output file call DQMC_open_file ( adjustl ( trim ( ofile )) // '.out' , 'unknown' , OPT ) ! Print computed results call DQMC_Hub_Print ( Hub , OPT ) write ( * , * ) 'Done Printing' ! Clean up the used storage call DQMC_Hub_Free ( Hub ) call DQMC_Config_Free ( cfg ) end subroutine DQMC_Comp_2DPerl !---------------------------------------------------------------------! subroutine DQMC_Init_2DPerl ( nx , ny , S , IMP ) ! ! Purpose ! ======= !    This subroutine constuctures data structure for a 2D !    periodic rectangular lattice. ! ! Details ! ======= !    For a Nx*Ny 2D rectangular lattice. ! !    1. The sites are numbered from 1, which is the site on the !       south-west corner. The numbering is row major, which means !       it increases along x direction first (left to right) and !       then y-direction (bottom up). ! !    2. Adjacency (T) has exact 4 elements per site: left !       right, up and down. Since the adjacency is cyclic, !       the code has had spacial treat for boundary sites. !       *** The way it computed here is not satisfied the !           'checkboard' order. should change it later. ! !    3. The number of unique distance is computed as follows. !       Let long = max(Nx, Ny) and short = min(Nx, Ny). !       The distinct distance sites form a trapezoid !       The bottom is (long/2+1), the top is ((long-short)/2+1) !       and the height is (short/2+1). Therefore, ! !           nClass = (short/2+1)*(long-short/2+2)/2 ! !    4. The phase (P) is computed in the rules that !       (a) adjacent sites have opposite phase. !       (b) site 1 is phased +. ! ! Arguments ! ========= ! integer , intent ( in ) :: nx , ny ! dimension of the lattice type ( Struct ), intent ( inout ) :: S ! Struct integer , intent ( in ) :: IMP ! ... local vars ... integer :: n ! Order of matrix T and D integer :: i , j , jx , jy ! Loop iterator integer :: up , dn , lt , rt ! adj and neighbor integer :: ne , nw , se , sw ! integer :: idx ! integer :: tmp ( nx * ny , nx * ny ) real ( wp ), pointer :: cord (:,:) ! ... parameters ... integer , parameter :: NADJ = 4 ! Number of adjacencies integer , parameter :: NNBR = 9 ! Number of neighbors real ( wp ), parameter :: TWOPI = 6.283185307179586 ! ... Executable ... n = nx * ny S % nSite = n write ( S % name , '(A,I3,A,I3,A,I5)' ) & \"2D Periodic Lattice; Nx=\" , & nx , \"; Ny=\" , ny , \"; total sites=\" , S % nSite ! Compute all distinct sites S % nWave = 9 ! memory allocation allocate ( S % P ( n )) allocate ( S % W ( NNBR , S % nWave )) allocate ( S % dim ( 2 )) allocate ( S % map ( n )) S % dim ( 1 ) = nx S % dim ( 2 ) = ny S % Map = 1 S % nGroup = 1 allocate ( S % gf_phase ( n , n )) S % gf_phase = 1 ! Build adjacent matrix for checkerboard method S % n_t = 1 tmp = 0 do j = 1 , ny do i = 1 , nx idx = ( j - 1 ) * nx + i ! up link up = idx + nx if ( up . gt . n ) then up = up - n end if ! down link dn = idx - nx if ( dn . le . 0 ) then dn = dn + n end if ! left link if ( i . eq . 1 ) then lt = idx + nx - 1 else lt = idx - 1 end if ! right link if ( i . eq . nx ) then rt = idx - nx + 1 else rt = idx + 1 end if tmp ( idx , up ) = 1 tmp ( idx , dn ) = 1 tmp ( idx , lt ) = 1 tmp ( idx , rt ) = 1 end do end do call DQMC_CCS_Compress ( n , n * NADJ , tmp , S % T ) ! Build neighboring matrix !        +---+---+---+ !        | 7 | 4 | 1 | !        +---+---+---+ !        | 8 | 5 | 2 | !        +---+---+---+ !        | 9 | 6 | 3 | !        +---+---+---+ ! S % n_b = 9 tmp = 0 do j = 1 , ny do i = 1 , nx idx = ( j - 1 ) * nx + i ! up link up = idx + nx if ( up . gt . n ) then up = up - n end if ! down link dn = idx - nx if ( dn . le . 0 ) then dn = dn + n end if ! left link if ( i . eq . 1 ) then lt = idx + nx - 1 else lt = idx - 1 end if ! right link if ( i . eq . nx ) then rt = idx - nx + 1 else rt = idx + 1 end if ! northeast link = up's right if ( i . eq . nx ) then ne = up + 1 - nx else ne = up + 1 end if ! northwest link = up's left if ( i . eq . 1 ) then nw = up - 1 + nx else nw = up - 1 end if ! southeast link = down's right if ( i . eq . nx ) then se = dn + 1 - nx else se = dn + 1 end if ! southwest link = down's left if ( i . eq . 1 ) then sw = dn - 1 + nx else sw = dn - 1 end if ! fill tmp ( idx , ne ) = 1 tmp ( idx , rt ) = 2 tmp ( idx , se ) = 3 tmp ( idx , up ) = 4 tmp ( idx , idx ) = 5 tmp ( idx , dn ) = 6 tmp ( idx , nw ) = 7 tmp ( idx , lt ) = 8 tmp ( idx , sw ) = 9 end do end do call DQMC_CCS_Compress ( n , n * NNBR , tmp , S % B ) ! build up the distance matrix. if ( IMP . eq . IMP_TRIANGLE ) then call DQMC_2DPerl_DC_Imp1 ( n , nx , ny , S , cord ) else call DQMC_2DPerl_DC_Imp2 ( n , nx , ny , S , cord ) end if ! Initialize phase matrix S % P ( 1 : nx : 2 ) = - 1 S % P ( 2 : nx : 2 ) = 1 do i = 2 , ny , 2 S % P (( i - 1 ) * nx + 1 : i * nx ) = - S % P ( 1 : nx ) end do do i = 3 , ny , 2 S % P (( i - 1 ) * nx + 1 : i * nx ) = S % P ( 1 : nx ) end do ! Make wave matrix S % W (:, 1 ) = ( / ZERO , ZERO , ZERO , ZERO , ONE , ZERO , ZERO , ZERO , ZERO / ) S % W (:, 2 ) = ( / ZERO , HALF , ZERO , HALF , ZERO , HALF , ZERO , HALF , ZERO / ) S % W (:, 3 ) = ( / ZERO , - HALF , ZERO , HALF , ZERO , HALF , ZERO , - HALF , ZERO / ) S % W (:, 4 ) = ( / HALF , ZERO , HALF , ZERO , ZERO , ZERO , HALF , ZERO , HALF / ) S % W (:, 5 ) = ( /- HALF , ZERO , HALF , ZERO , ZERO , ZERO , HALF , ZERO , - HALF / ) S % W (:, 6 ) = ( / ZERO , ZERO , ZERO , - HALF , ZERO , HALF , ZERO , ZERO , ZERO / ) S % W (:, 7 ) = ( / ZERO , - HALF , ZERO , ZERO , ZERO , ZERO , ZERO , HALF , ZERO / ) S % W (:, 8 ) = ( /- HALF , ZERO , ZERO , ZERO , ZERO , ZERO , ZERO , ZERO , HALF / ) S % W (:, 9 ) = ( / ZERO , ZERO , - HALF , ZERO , ZERO , ZERO , HALF , ZERO , ZERO / ) ! label for each wave function allocate ( S % wlabel ( 9 )) write ( S % wlabel ( 1 ), \"(a20)\" ) \"  S-Wave : \" write ( S % wlabel ( 2 ), \"(a20)\" ) \" SX-Wave : \" write ( S % wlabel ( 3 ), \"(a20)\" ) \"  D-Wave : \" write ( S % wlabel ( 4 ), \"(a20)\" ) \"SXX-Wave : \" write ( S % wlabel ( 5 ), \"(a20)\" ) \"DXX-Wave : \" write ( S % wlabel ( 6 ), \"(a20)\" ) \" PX-Wave : \" write ( S % wlabel ( 7 ), \"(a20)\" ) \" PY-Wave : \" write ( S % wlabel ( 8 ), \"(a20)\" ) \"PXY-Wave : \" write ( S % wlabel ( 9 ), \"(a20)\" ) \"PYX-Wave : \" ! Fourier Transformation allocate ( S % FT ( S % nClass , S % nClass )) S % FT = ZERO do i = 1 , S % nClass do jx = 0 , nx - 1 do jy = 0 , ny - 1 j = S % D ( jy * nx + jx + 1 , 1 ) S % FT ( i , j ) = S % FT ( i , j ) + & cos ( TWOPI * ( cord ( i , 1 ) * jx / nx + cord ( i , 2 ) * jy / ny )) end do end do end do ! enable the flag S % checklist = . true . deallocate ( cord ) end subroutine DQMC_INIT_2DPERL !---------------------------------------------------------------------! subroutine DQMC_2DPerl_DC_Imp1 ( n , nx , ny , S , cord ) ! ! Purpose ! ======= !    This subroutine implements distance classification, which !    use compact stragety ! ! Arguments ! ========= ! integer , intent ( in ) :: n , nx , ny ! dimension of the lattice type ( Struct ), intent ( inout ) :: S ! Struct real ( wp ), pointer :: cord (:,:) ! ... local vars ... integer :: L ( nx * ny , nx * ny ) ! distance table integer :: long , short ! Used in computing nClass integer :: i , j , ix , iy , jx , jy , dx , dy , idx ! site i to i is a special case, do not compute it long = max ( nx , ny ) short = min ( nx , ny ) S % nClass = ( short / 2 + 1 ) * ( long - short / 2 + 2 ) / 2 allocate ( S % D ( n , n )) allocate ( S % F ( S % nClass )) allocate ( S % clabel ( S % nClass )) allocate ( cord ( S % nClass , 2 )) S % D = 0 S % F = 0 S % F ( 1 ) = n write ( S % clabel ( 1 ), FMT_POINT ) 0 , 0 !! using lookup table (maybe hashing table ) L = 0 idx = 1 ! the first one is a special one do i = 1 , n !! compute the index of i ix = mod ( i - 1 , nx ) + 1 iy = ( i - 1 ) / nx + 1 !! initial the index of j do j = i + 1 , n !! compute the index of j jx = mod ( j - 1 , nx ) + 1 jy = ( j - 1 ) / nx + 1 !! compute the distance dx = abs ( ix - jx ) dx = min ( dx , nx - dx ) dy = abs ( iy - jy ) dy = min ( dy , ny - dy ) long = max ( dx , dy ) + 1 short = min ( dx , dy ) + 1 ! not found if ( L ( long , short ) . eq . 0 ) then idx = idx + 1 L ( long , short ) = idx S % D ( i , j ) = idx write ( S % clabel ( idx ), FMT_POINT ) long - 1 , short - 1 cord ( idx , 1 ) = long - 1 cord ( idx , 2 ) = short - 1 else ! found S % D ( i , j ) = L ( long , short ) end if ! matrix D is symmetric S % D ( j , i ) = S % D ( i , j ) ! increase count by 2 S % F ( S % D ( i , j )) = S % F ( S % D ( i , j )) + 2 end do ! site i to i S % D ( i , i ) = 1 end do end subroutine DQMC_2DPERL_DC_IMP1 !---------------------------------------------------------------------! subroutine DQMC_2DPerl_DC_Imp2 ( n , nx , ny , S , cord ) ! ! Purpose ! ======= !    In this implementation of distance classication, the classes !    are in a rectangular form. ! ! Arguments ! ========= ! integer , intent ( in ) :: n , nx , ny ! dimension of the lattice type ( Struct ), intent ( inout ) :: S ! Struct real ( wp ), pointer :: cord (:,:) ! ... parameters ... real ( wp ), parameter :: TWOPI = 6.283185307179586 ! ... local vars ... integer :: L ( n , n ) ! distance table integer :: i , j ! loop iterators integer :: ix , iy , jx , jy , dx , dy , idx ! indices ! site i to i is a special case, do not compute it S % nClass = ( nx / 2 + 1 ) * ( ny / 2 + 1 ) allocate ( S % D ( n , n )) allocate ( S % F ( S % nClass )) allocate ( S % clabel ( S % nClass )) allocate ( cord ( S % nClass , 2 )) S % D = 0 S % F = 0 S % F ( 1 ) = n write ( S % clabel ( 1 ), FMT_POINT ) 0 , 0 !! using lookup table (maybe hashing table ) L = 0 idx = 1 ! the first one is a special one cord ( 1 , 1 ) = ZERO cord ( 1 , 2 ) = ZERO do i = 1 , n !! compute the index of i ix = mod ( i - 1 , nx ) + 1 iy = ( i - 1 ) / nx + 1 !! initial the index of j do j = i + 1 , n !! compute the index of j jx = mod ( j - 1 , nx ) + 1 jy = ( j - 1 ) / nx + 1 !! compute the distance dx = abs ( ix - jx ) dx = min ( dx , nx - dx ) + 1 dy = abs ( iy - jy ) dy = min ( dy , ny - dy ) + 1 ! not found if ( L ( dx , dy ) . eq . 0 ) then ! Creat a new node idx = idx + 1 L ( dx , dy ) = idx S % D ( i , j ) = idx write ( S % clabel ( idx ), FMT_POINT ) dx - 1 , dy - 1 ! Build a new row of COS table cord ( idx , 1 ) = dx - 1 cord ( idx , 2 ) = dy - 1 else ! found S % D ( i , j ) = L ( dx , dy ) end if ! matrix D is symmetric S % D ( j , i ) = S % D ( i , j ) ! increase count by 2 S % F ( S % D ( i , j )) = S % F ( S % D ( i , j )) + 2 end do ! site i to i S % D ( i , i ) = 1 end do end subroutine DQMC_2DPERL_DC_IMP2 end module DQMC_2DPERL","tags":"","loc":"sourcefile/dqmc_2dperl.f90.html"},{"title":"dqmc_phy0.F90 – Quest","text":"This file depends on sourcefile~~dqmc_phy0.f90~~EfferentGraph sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_phy0.f90~~AfferentGraph sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_phy0.f90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_Phy0 #include \"dqmc_include.h\" use DQMC_UTIL use DQMC_WSPACE use DQMC_STRUCT implicit none ! ! This module contains data structure and subroutines for some ! physics measurement on Hubbard's model, including ! !     1.  Up spin occupancy !     2.  Down spin occupancy !     3.  Potential energy !     4.  Kinetic energy !     5.  Total engery !     6.  Density !     7.  XX ferromagnetic structure factor !     8.  ZZ ferromagnetic structure factor !     9.  XX antiferromagnetic structure factor !    10.  ZZ antiferromagnetic structure factor !    11.  RMS XX AF SF !    12.  RMS ZZ AF SF !    13.  Average sign !    14.  Average up sign !    15.  Average down sign !    16.  Equal time Green's function !    17.  Density-density correlation fn: (up-up) !    18.  Density-density correlation fn: (up-dn) !    19.  XX Spin correlation function !    20.  ZZ Spin correlation function ! ! Measurement 1-15 are scalars. 16-20 are lists of length ! nClass, which are the number of distinct autocorrelation terms. ! (see DQMC_STRUCT for more details about nClass.) ! ! List of subroutines ! =================== !    1. DQMC_Phy0_Init(P0, nClass, nBin, nHist) !    2. DQMC_Phy0_Normalize(P0, u) !    3. DQMC_Phy0_Print(P0, S, OPT) !    4. DQMC_Phy0_GetErr(P0) !    5. DQMC_Phy0_Dump(P0, idx, opt) !    6. DQMC_PHY0_Hist(n, nBin, over, under, H, list, GetIndex) !    7. DQMC_Meas0(n, P0, G_up, G_dn, mu, t, sgnup, sgndn, S, up, dn) ! !    *** Most subroutines are for internal use only. User program !        should not need any of them. ! ! Data Structure and Parameters ! ============================= !    The data type Phy0 is consisted of two parts: the measurements !    and the histograms. ! !    The measurements are put into bins and then analysized in the end. !    To make data manipulation easy, all scalar variables are put into !    an array S and identified by the indeces, which are defined by the !    parameters below. Each column of S represents a bin. !    List variables, like Green's function, are put into separated !    arrays, in which each column is also for one bin. ! !    There are two special bins, averge and error, which are used to !    store the final averaged result and error. Their indeces are !    specified by 'avg' and 'err' respectively. ! !    The histogram part consists of three histograms, each having !    nHist+2 bins. They are histogram for up occupancy (Nup), !    down occupancy (Ndn), and Nup*Ndn. The additional two bins !    are for data exceeds the range, whose indeces are specified !    by 'over' and 'under' respectively. ! ! Array integer , parameter :: narrays = 9 ! Index of the array varaiables integer , parameter :: IMEAS = 0 integer , parameter :: IGFUN = 1 integer , parameter :: IGFUP = 2 integer , parameter :: IGFDN = 3 integer , parameter :: ISPXX = 4 integer , parameter :: ISPZZ = 5 integer , parameter :: IAVSP = 6 integer , parameter :: IDEN0 = 7 integer , parameter :: IDEN1 = 8 integer , parameter :: IPAIR = 9 ! Parameter for the index of scalar variables (IMEAS) integer , parameter :: P0_NUP = 1 integer , parameter :: P0_NDN = 2 integer , parameter :: P0_NUD = 3 integer , parameter :: P0_KE = 4 integer , parameter :: P0_ENERGY = 5 integer , parameter :: P0_DENSITY = 6 integer , parameter :: P0_CHIT = 7 integer , parameter :: P0_CV = 8 integer , parameter :: P0_SFERRO = 9 integer , parameter :: P0_SFER2 = 10 integer , parameter :: P0_SAF = 15 integer , parameter :: P0_SAFSQ = 16 integer , parameter :: P0_SAF2 = 17 integer , parameter :: P0_SAF2SQ = 18 integer , parameter :: P0_potential_energy = 11 integer , parameter :: P0_hopping_energy = 12 integer , parameter :: P0_double_occupancy = 13 integer , parameter :: P0_magnetization_squared = 14 integer , parameter :: P0_N_NO_SAF = 14 integer , parameter :: P0_N = 18 integer , parameter :: P0_SGN = 1 integer , parameter :: P0_SGNUP = 2 integer , parameter :: P0_SGNDN = 3 ! Name of scalar variables character ( len =* ), parameter :: P0_STR ( P0_N ) = ( / & \"          Up spin occupancy : \" , & \"        Down spin occupancy : \" , & \"             <U*N_up*N_dn>  : \" , & \"             Kinetic energy : \" , & \"               Total energy : \" , & \"                    Density : \" , & \"                Chi_thermal : \" , & \"              Specific heat : \" , & \"  XX Ferro structure factor : \" , & \"  ZZ Ferro structure factor : \" , & \"           Potential energy : \" , & \"             Hopping energy : \" , & \"           Double occupancy : \" , & \"      Magnetization squared : \" , & \"     XX AF structure factor : \" , & \"  Root Mean Square of XX AF : \" , & \"     ZZ AF structure factor : \" , & \"  Root Mean Square of ZZ AF : \" / ) character ( len =* ), parameter :: P0_SIGN_STR ( 3 ) = ( / & \"                   Avg sign : \" , & \"                Avg up sign : \" , & \"                Avg dn sign : \" / ) type Phy0 ! Measurement part integer :: nClass ! Number of distinct ! autocorrelction terms integer :: nBin ! Number of terms integer :: nMeas ! Number of measurements integer :: avg , err ! Index for average and error ! bins. integer :: cnt ! Number of measurement for ! current bin integer :: idx ! current bin index integer :: n ! number of sites real ( wp ) :: beta ! Inverse Temperature ! Scalar array real ( wp ), pointer :: meas (:, :) ! Scalar varaibles real ( wp ), pointer :: sign (:, :) ! Scalar varaibles ! Indices integer :: IARR ( 0 : narrays + 1 ) integer :: IARRFT ( 1 : narrays + 1 ) integer :: IARREV ( 1 : narrays + 1 ) real ( wp ), pointer :: AllProp (:, :) ! Vector of all properties real ( wp ), pointer :: AllPropFT (:, :) ! Matrix of FT real ( wp ), pointer :: AllPropEigVal (:, :) ! Vector of Fourier transforms complex * 16 , pointer :: AllPropEigVec (:, :, :, :) ! Vector with the normal modes !Pointers to AllProp real ( wp ), pointer :: G_fun (:, :) ! Green's function real ( wp ), pointer :: Gf_up (:, :) ! Green's function real ( wp ), pointer :: Gf_dn (:, :) ! Green's function real ( wp ), pointer :: SpinXX (:, :) ! XX Spin correlation function real ( wp ), pointer :: SpinZZ (:, :) ! ZZ Spin correlation function real ( wp ), pointer :: AveSpin (:, :) ! Ave Spin correlation function real ( wp ), pointer :: Den0 (:, :) ! Density-density correlation real ( wp ), pointer :: Den1 (:, :) ! up-up (0) and up-dn (1) real ( wp ), pointer :: Pair (:, :) ! on-site pairing ! working space real ( wp ), pointer :: up (:) real ( wp ), pointer :: dn (:) logical :: compSAF logical :: init logical :: initFT end type Phy0 contains ! Subroutines ! ================================================================== subroutine DQMC_Phy0_Init ( P0 , S , beta , nBin , WS ) ! ! Purpose ! ======= !    This subroutine initializes Phy0. ! !  Pre-assumption ! ============== !    nClass, nBin and nHist are positive integers. ! ! Arguments ! ========= ! type ( Phy0 ), intent ( inout ) :: P0 ! Phy0 to be initialized type ( Struct ), intent ( in ) :: S integer , intent ( in ) :: nBin ! No of bins real ( wp ), intent ( in ) :: beta type ( WSpace ), intent ( in ), target :: WS ! ... Local vars ... integer :: i , n ! ... Executable ... P0 % nClass = S % nClass P0 % nBin = nBin P0 % n = S % nsite P0 % beta = beta P0 % avg = nBin + 1 P0 % err = nBin + 2 P0 % cnt = 0 P0 % idx = 1 P0 % compSAF = S % checklist ( STRUCT_PHASE ) ! count total number of data if ( P0 % compSAF ) then P0 % nMeas = P0_N else p0 % nMeas = P0_N_NO_SAF end if ! Allocate storages for sign and properties n = P0 % nmeas + P0 % nClass * narrays allocate ( P0 % sign ( 3 , P0 % err )) allocate ( P0 % AllProp ( n , P0 % err )) !Pointers to beginning of each array P0 % IARR ( IMEAS ) = 1 do i = 1 , narrays + 1 P0 % IARR ( i ) = P0 % nmeas + 1 + ( i - 1 ) * P0 % nClass enddo P0 % meas => P0 % AllProp ( P0 % IARR ( IMEAS ): P0 % IARR ( IMEAS + 1 ) - 1 , :) P0 % G_fun => P0 % AllProp ( P0 % IARR ( IGFUN ): P0 % IARR ( IGFUN + 1 ) - 1 , :) P0 % Gf_up => P0 % AllProp ( P0 % IARR ( IGFUP ): P0 % IARR ( IGFUP + 1 ) - 1 , :) P0 % Gf_dn => P0 % AllProp ( P0 % IARR ( IGFDN ): P0 % IARR ( IGFDN + 1 ) - 1 , :) P0 % SpinXX => P0 % AllProp ( P0 % IARR ( ISPXX ): P0 % IARR ( ISPXX + 1 ) - 1 , :) P0 % SpinZZ => P0 % AllProp ( P0 % IARR ( ISPZZ ): P0 % IARR ( ISPZZ + 1 ) - 1 , :) P0 % AveSpin => P0 % AllProp ( P0 % IARR ( IAVSP ): P0 % IARR ( IAVSP + 1 ) - 1 , :) P0 % Den0 => P0 % AllProp ( P0 % IARR ( IDEN0 ): P0 % IARR ( IDEN0 + 1 ) - 1 , :) P0 % Den1 => P0 % AllProp ( P0 % IARR ( IDEN1 ): P0 % IARR ( IDEN1 + 1 ) - 1 , :) P0 % Pair => P0 % AllProp ( P0 % IARR ( IPAIR ): P0 % IARR ( IPAIR + 1 ) - 1 , :) !allocate(P0%meas(P0%nMeas, nBin+2)) !allocate(P0%sign(3, nBin+2)) !allocate(P0%G_fun  (nClass, nBin+2)) !allocate(P0%Gf_up  (nClass, nBin+2)) !allocate(P0%Gf_dn  (nClass, nBin+2)) !allocate(P0%SpinXX (nClass, nBin+2)) !allocate(P0%SpinZZ (nClass, nBin+2)) !allocate(P0%AveSpin(nClass, nBin+2)) !allocate(P0%Den0   (nClass, nBin+2)) !allocate(P0%Den1   (nClass, nBin+2)) !allocate(P0%Pair   (nClass, nBin+2)) ! Initialize P0 % meas = ZERO P0 % sign = ZERO P0 % G_fun = ZERO P0 % Gf_up = ZERO P0 % Gf_dn = ZERO P0 % SpinXX = ZERO P0 % SpinZZ = ZERO P0 % AveSpin = ZERO P0 % Den0 = ZERO P0 % Den1 = ZERO P0 % Pair = ZERO P0 % up => WS % R5 P0 % dn => WS % R6 P0 % init = . true . ! 10/26/2012 ! The following pointers will be allocated in DQMC_GetFT(): ! !     AllPropFT(:,:)           ! Matrix of FT !     AllPropEigVal(:,:)       ! Vector of Fourier transforms !     AllPropEigVec(:,:,:,:)   ! Vector with the normal modes ! ! However, dqmc_2dperl.F90 does not calculate momentum space observables, the status of the ! three pointer arrays become associated, but never allocated. This is why in /EXAMPLE/test, ! test.F90 generates the error message at the end of the simulation: ! !    pointer being freed was not allocated ! ! This happens only in /EXAMPLE/test/test.F90, not in /EXAMPLE/geom/ggeom.F90. To fix this, ! I added a flag that checks whether these arrays are allocated. The default value is .false. ! It will be changed to .true. once DQMC_GetFT() is called. P0 % initFT = . false . end subroutine DQMC_Phy0_Init !--------------------------------------------------------------------! subroutine DQMC_Phy0_Free ( P0 ) ! ! Purpose ! ======= !    This subroutine frees Phy0. ! ! Arguments ! ========= ! type ( Phy0 ), intent ( inout ) :: P0 ! Phy0 to be freed ! ... Executable ... if ( P0 % init ) then nullify ( P0 % meas ) nullify ( P0 % G_fun , P0 % Gf_up , P0 % Gf_dn ) nullify ( P0 % SpinXX , P0 % SpinZZ , P0 % AveSpin ) nullify ( P0 % Den0 , P0 % Den1 ) nullify ( P0 % Pair ) deallocate ( P0 % AllProp , P0 % sign ) ! P0%initFT = .true. if DQMC_GetFT() was called if ( P0 % initFT ) then deallocate ( P0 % AllPropEigVal ) deallocate ( P0 % AllPropEigVec ) endif end if end subroutine DQMC_Phy0_Free !--------------------------------------------------------------------! subroutine DQMC_Phy0_Avg ( P0 ) ! ! Purpose ! ======= !    This subroutine averges the data with a bin. !    It also computes some measurements from others, such as !    density and energy. ! !  Pre-assumption ! ============== !    idx is in the range of (1,nClass). ! ! Arguments ! ========= ! type ( Phy0 ), intent ( inout ) :: P0 ! Phy0 ! ... local scalar ... real ( wp ) :: factor integer :: idx , n ! ... Executable ... idx = P0 % idx ! compute the normalization factor = 1/cnt if ( P0 % cnt == 0 ) then call DQMC_Error ( \"Phy0 normalize: cnt = 0\" , 0 ) end if factor = ONE / P0 % cnt ! average P0 % meas (:, idx ) = P0 % meas (:, idx ) * factor P0 % sign (:, idx ) = P0 % sign (:, idx ) * factor if ( P0 % compSAF ) then ! The sqaure terms P0 % meas ( P0_SAFSQ , idx ) = sqrt ( abs ( P0 % meas ( P0_SAFSQ , idx ))) P0 % meas ( P0_SAF2SQ , idx ) = sqrt ( abs ( P0 % meas ( P0_SAF2SQ , idx ))) end if ! This list terms n = P0 % nClass call blas_dscal ( n , factor , P0 % G_fun ( 1 : n , idx ), 1 ) call blas_dscal ( n , factor , P0 % Gf_up ( 1 : n , idx ), 1 ) call blas_dscal ( n , factor , P0 % Gf_dn ( 1 : n , idx ), 1 ) call blas_dscal ( n , factor , P0 % SpinXX ( 1 : n , idx ), 1 ) call blas_dscal ( n , factor , P0 % SpinZZ ( 1 : n , idx ), 1 ) call blas_dscal ( n , factor , P0 % Den0 ( 1 : n , idx ), 1 ) call blas_dscal ( n , factor , P0 % Den1 ( 1 : n , idx ), 1 ) call blas_dscal ( n , factor , P0 % Pair ( 1 : n , idx ), 1 ) ! Change bin P0 % idx = P0 % idx + 1 ! reset the counter p0 % cnt = 0 end subroutine DQMC_Phy0_Avg !--------------------------------------------------------------------! subroutine DQMC_Phy0_Print ( P0 , S , OPT ) use dqmc_mpi ! ! Purpose ! ======= !    This subroutine prints out the average and errors !    of measurements. Structure S will give labels for !    each autocorrelation terms. ! !  Pre-assumption ! =============== !    OPT is a file handle !    DQMC_Phy0_GetErr was called. ! ! Arguments ! ========= ! type ( Phy0 ), intent ( in ) :: P0 ! Phy0 type ( Struct ), intent ( in ) :: S ! Underline lattice structure integer , intent ( in ) :: OPT ! Output file handle ! ... Local scalar ... integer :: nClass , avg , err ! ... Executable ... if ( qmc_sim % rank /= 0 ) return nClass = P0 % nClass avg = P0 % avg err = P0 % err ! Scalar terms call DQMC_Print_RealArray ( 0 , 3 , \"Sign of equal time measurements:\" , & P0_SIGN_STR , P0 % sign (:, avg : avg ), P0 % sign (:, err : err ), OPT ) call DQMC_Print_RealArray ( 0 , P0 % nmeas , \"Equal time measurements:\" , & P0_STR , P0 % meas (:, avg : avg ), P0 % meas (:, err : err ), OPT ) ! Function terms call DQMC_Print_RealArray ( 0 , nClass , \"Mean Equal time Green's function:\" , & S % clabel , P0 % G_fun (:, avg : avg ), P0 % G_fun (:, err : err ), OPT ) call DQMC_Print_RealArray ( 0 , nClass , \"Up Equal time Green's function:\" , & S % clabel , P0 % Gf_up (:, avg : avg ), P0 % Gf_up (:, err : err ), OPT ) call DQMC_Print_RealArray ( 0 , nClass , \"Down Equal time Green's function:\" , & S % clabel , P0 % Gf_dn (:, avg : avg ), P0 % Gf_dn (:, err : err ), OPT ) call DQMC_Print_RealArray ( 0 , nClass , & \"Density-density correlation fn: (up-up)\" , & S % clabel , P0 % Den0 (:, avg : avg ), P0 % Den0 (:, err : err ), OPT ) call DQMC_Print_RealArray ( 0 , nClass , & \"Density-density correlation fn: (up-dn)\" , & S % clabel , P0 % Den1 (:, avg : avg ), P0 % Den1 (:, err : err ), OPT ) call DQMC_Print_RealArray ( 0 , nClass , \"XX Spin correlation function:\" , & S % clabel , P0 % SpinXX (:, avg : avg ), P0 % SpinXX (:, err : err ), OPT ) call DQMC_Print_RealArray ( 0 , nClass , \"ZZ Spin correlation function:\" , & S % clabel , P0 % SpinZZ (:, avg : avg ), P0 % SpinZZ (:, err : err ), OPT ) call DQMC_Print_RealArray ( 0 , nClass , \"Average Spin correlation function:\" , & S % clabel , P0 % AveSpin (:, avg : avg ), P0 % AveSpin (:, err : err ), OPT ) call DQMC_Print_RealArray ( 0 , nClass , \"Pairing correlation function:\" , & S % clabel , P0 % Pair (:, avg : avg ), P0 % Pair (:, err : err ), OPT ) end subroutine DQMC_Phy0_Print !--------------------------------------------------------------------! subroutine DQMC_Phy0_GetErr ( P0 ) use dqmc_mpi ! ! Purpose ! ======= !    This subroutine computes the average and errors !    of measurements. ! ! Argument ! ======== ! type ( Phy0 ), intent ( inout ) :: P0 ! ... Local Scalar ... integer :: i , n integer :: avg , err , mpi_err integer :: nproc ! ... Local Array real ( wp ) :: sum_sgn , sgn ( P0 % nBin ), y ( P0 % nBin ), data ( P0 % nBin ) ! ... Executable ... n = P0 % nBin avg = P0 % avg err = P0 % err nproc = qmc_sim % size if ( nproc == 1 ) then ! Average sign, sign up, sign down do i = P0_SGNUP , P0_SGNDN data = P0 % sign ( i , 1 : n ) call DQMC_JackKnife ( n , P0 % sign ( i , avg ), P0 % sign ( i , err ), data , & y , sgn , sum_sgn ) end do data = P0 % sign ( P0_SGN , 1 : n ) call DQMC_JackKnife ( n , P0 % sign ( P0_SGN , avg ), P0 % sign ( P0_SGN , err ), data , & y , sgn , sum_sgn ) ! Average other single terms do i = 1 , P0 % nMeas data = P0 % meas ( i , 1 : n ) call DQMC_SignJackKnife ( n , P0 % meas ( i , avg ), P0 % meas ( i , err ), data , & y , sgn , sum_sgn ) end do ! Average Green function do i = 1 , P0 % nClass data = P0 % G_fun ( i , 1 : n ) call DQMC_SignJackKnife ( n , P0 % G_fun ( i , avg ), P0 % G_fun ( i , err ), & data , y , sgn , sum_sgn ) end do ! Up Green function do i = 1 , P0 % nClass data = P0 % Gf_up ( i , 1 : n ) call DQMC_SignJackKnife ( n , P0 % Gf_up ( i , avg ), P0 % Gf_up ( i , err ), & data , y , sgn , sum_sgn ) end do ! Down Green function do i = 1 , P0 % nClass data = P0 % Gf_dn ( i , 1 : n ) call DQMC_SignJackKnife ( n , P0 % Gf_dn ( i , avg ), P0 % Gf_dn ( i , err ), & data , y , sgn , sum_sgn ) end do ! Average correlated Density do i = 1 , P0 % nClass data = P0 % Den0 ( i , 1 : n ) call DQMC_SignJackKnife ( n , P0 % Den0 ( i , avg ), P0 % Den0 ( i , err ), & data , y , sgn , sum_sgn ) end do do i = 1 , P0 % nClass data = P0 % Den1 ( i , 1 : n ) call DQMC_SignJackKnife ( n , P0 % Den1 ( i , avg ), P0 % Den1 ( i , err ), & data , y , sgn , sum_sgn ) end do ! Average spin do i = 1 , P0 % nClass data = P0 % SpinXX ( i , 1 : n ) call DQMC_SignJackKnife ( n , P0 % SpinXX ( i , avg ), P0 % SpinXX ( i , err ), & data , y , sgn , sum_sgn ) end do do i = 1 , P0 % nClass data = P0 % SpinZZ ( i , 1 : n ) call DQMC_SignJackKnife ( n , P0 % SpinZZ ( i , avg ), P0 % SpinZZ ( i , err ), & data , y , sgn , sum_sgn ) end do do i = 1 , P0 % nClass P0 % AveSpin ( i , 1 : n ) = ( P0 % SpinZZ ( i , 1 : n ) + 2.d0 * P0 % SpinXX ( i , 1 : n ) ) / 3.d0 data = P0 % AveSpin ( i , 1 : n ) call DQMC_SignJackKnife ( n , P0 % AveSpin ( i , avg ), P0 % AveSpin ( i , err ), & data , y , sgn , sum_sgn ) end do ! Pairing do i = 1 , P0 % nClass data = P0 % Pair ( i , 1 : n ) call DQMC_SignJackKnife ( n , P0 % Pair ( i , avg ), P0 % Pair ( i , err ), & data , y , sgn , sum_sgn ) end do ! Store Jackknife in bins do i = 1 , n P0 % sign (:, i ) = ( n * P0 % sign (:, avg ) - P0 % sign (:, i )) / dble ( n - 1 ) P0 % AllProp (:, i ) = ( sum_sgn * P0 % AllProp (:, avg ) - P0 % AllProp (:, i )) / dble ( n - 1 ) P0 % AllProp (:, i ) = P0 % AllProp (:, i ) / P0 % sign ( P0_SGN , i ) enddo ! Deal with error and expectation values of cv and chi_thermal properly P0 % meas ( P0_CHIT , 1 : avg ) = P0 % meas ( P0_CHIT , 1 : avg ) - P0 % n * P0 % beta ** 2 * P0 % meas ( P0_ENERGY , 1 : avg ) & * P0 % meas ( P0_DENSITY , 1 : avg ) P0 % meas ( P0_CV , 1 : avg ) = P0 % meas ( P0_CV , 1 : avg ) - P0 % n * ( P0 % beta * P0 % meas ( P0_ENERGY , 1 : avg )) ** 2 P0 % meas ( P0_CV , err ) = sqrt (( n - 1 ) * sum (( P0 % meas ( P0_CV , 1 : n ) - P0 % meas ( P0_CV , avg )) ** 2 )) P0 % meas ( P0_CHIT , err ) = sqrt (( n - 1 ) * sum (( P0 % meas ( P0_CHIT , 1 : n ) - P0 % meas ( P0_CHIT , avg )) ** 2 )) else mpi_err = 0 #      ifdef _QMC_MPI n = size ( P0 % AllProp , 1 ) !Set bin to 1 and fill the average spin P0 % AveSpin (:, 1 ) = ( P0 % SpinZZ (:, 1 ) + 2.d0 * P0 % SpinXX (:, 1 ) ) / 3.d0 !Average sign call mpi_allreduce ( P0 % sign (:, 1 ), P0 % sign (:, avg ), 3 , mpi_double , & mpi_sum , mpi_comm_world , mpi_err ) !Average properties call mpi_allreduce ( P0 % AllProp (:, 1 ), P0 % AllProp (:, avg ), n , mpi_double , & mpi_sum , mpi_comm_world , mpi_err ) !Compute average over n-1 processors P0 % AllProp (:, 1 ) = ( P0 % AllProp (:, avg ) - P0 % AllProp (:, 1 )) / dble ( nproc - 1 ) P0 % sign (:, 1 ) = ( P0 % sign (:, avg ) - P0 % sign (:, 1 )) / dble ( nproc - 1 ) !Store average amongst all processors P0 % AllProp (:, avg ) = P0 % AllProp (:, avg ) / P0 % sign ( P0_SGN , avg ) P0 % sign (:, avg ) = P0 % sign (:, avg ) / dble ( nproc ) !Store jackknife in the processor bin P0 % AllProp (:, 1 ) = P0 % AllProp (:, 1 ) / P0 % sign ( P0_SGN , 1 ) !Compute proper chi_thermal and C_v P0 % meas ( P0_CHIT , 1 : avg ) = P0 % meas ( P0_CHIT , 1 : avg ) - P0 % n * P0 % beta ** 2 * P0 % meas ( P0_ENERGY , 1 : avg ) & * P0 % meas ( P0_DENSITY , 1 : avg ) P0 % meas ( P0_CV , 1 : avg ) = P0 % meas ( P0_CV , 1 : avg ) - P0 % n * ( P0 % beta * P0 % meas ( P0_ENERGY , 1 : avg )) ** 2 !Compute error call mpi_allreduce ( P0 % AllProp (:, 1 ) ** 2 , P0 % AllProp (:, err ), n , mpi_double , & mpi_sum , mpi_comm_world , mpi_err ) P0 % AllProp (:, err ) = P0 % AllProp (:, err ) / dble ( nproc ) - P0 % AllProp (:, avg ) ** 2 P0 % AllProp (:, err ) = sqrt ( P0 % AllProp (:, err ) * dble ( nproc - 1 )) !Compute error for sign call mpi_allreduce ( P0 % sign (:, 1 ) ** 2 , P0 % sign (:, err ), 3 , mpi_double , & mpi_sum , mpi_comm_world , mpi_err ) P0 % sign (:, err ) = P0 % sign (:, err ) / dble ( nproc ) - P0 % sign (:, avg ) ** 2 P0 % sign (:, err ) = sqrt ( P0 % sign (:, err ) * dble ( nproc - 1 )) P0 % meas ( P0_CHIT , avg ) = P0 % meas ( P0_CHIT , avg ) - P0 % n * P0 % beta ** 2 * P0 % meas ( P0_ENERGY , avg ) & * P0 % meas ( P0_DENSITY , avg ) P0 % meas ( P0_CV , avg ) = P0 % meas ( P0_CV , avg ) - P0 % n * ( P0 % beta * P0 % meas ( P0_ENERGY , avg )) ** 2 #      endif endif end subroutine DQMC_Phy0_GetErr !--------------------------------------------------------------------! subroutine DQMC_Phy0_Meas ( n , P0 , G_up , G_dn , U , mu_up , mu_dn , t_up , t_dn , sgnup , sgndn , S ) ! ! Purpose ! ======= !    This subroutine performs some physics measurement on !    Hubbard model. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! Number of sites type ( Phy0 ), intent ( inout ) :: P0 ! Phy0 real ( wp ), intent ( in ) :: G_up ( n , n ) ! Green's function real ( wp ), intent ( in ) :: G_dn ( n , n ) ! for spin up and down real ( wp ), intent ( in ) :: sgnup , sgndn ! Sgn for det(G_up) det(G_dn) real ( wp ), intent ( in ) :: mu_up ( n ), mu_dn ( n ) ! Chemical and Kinetic para real ( wp ), intent ( in ) :: t_up (:), t_dn (:) ! Chemical and Kinetic para real ( wp ), intent ( in ) :: U (:) ! Chemical and Kinetic para type ( Struct ), intent ( in ) :: S ! Underline structure target :: S ! ... local scalar ... integer :: i , j , k , ph ! Loop iterator integer :: tmp , idx , m ! Helper variables real ( wp ) :: sgn real ( wp ) :: var1 , var2 , var3 integer , pointer :: start (:) integer , pointer :: r (:) integer , pointer :: A (:) ! Auxiliary variable for chi_thermal and C_v real ( wp ) :: Cbar , Nbar , Tbar , un real ( wp ) :: h_up ( n , n ), h_dn ( n , n ) real ( wp ) :: A_up ( n , n ), A_dn ( n , n ) ! ... executable ... idx = P0 % idx tmp = P0 % avg ! initialization ! Here we use avg bin as a temp variable P0 % meas (:, tmp ) = ZERO P0 % G_fun (:, tmp ) = ZERO P0 % Gf_up (:, tmp ) = ZERO P0 % Gf_dn (:, tmp ) = ZERO P0 % Den0 (:, tmp ) = ZERO P0 % Den1 (:, tmp ) = ZERO P0 % SpinXX (:, tmp ) = ZERO P0 % SpinZZ (:, tmp ) = ZERO P0 % Pair (:, tmp ) = ZERO ! Compute the site density for spin up and spin down do i = 1 , n !======================================================! ! The density of electrons of spin up(dn) on site i    ! ! is 1-G_up(i,i) (1-G_dn(i,i)).                        ! ! nup (ndn) is the sum of all spin up (down) electrons.! !======================================================! P0 % up ( i ) = ONE - G_up ( i , i ) P0 % dn ( i ) = ONE - G_dn ( i , i ) P0 % meas ( P0_NUD , tmp ) = P0 % meas ( P0_NUD , tmp ) + & P0 % up ( i ) * P0 % dn ( i ) * U ( S % Map ( i )) !======================================================! ! Double occupancy P0%up(i) * P0%dn(i) !======================================================! P0 % meas ( P0_double_occupancy , tmp ) = P0 % meas ( P0_double_occupancy , tmp ) + & P0 % up ( i ) * P0 % dn ( i ) !=====================================================================! ! Potential energy (P0%up(i)-0.5d0) * (P0%dn(i)-0.5d0) * U(S%Map(i)) !=====================================================================! P0 % meas ( P0_potential_energy , tmp ) = P0 % meas ( P0_potential_energy , tmp ) + & ( P0 % up ( i ) - 0.5d0 ) * ( P0 % dn ( i ) - 0.5d0 ) * U ( S % Map ( i )) end do P0 % meas ( P0_NUP , tmp ) = sum ( P0 % up ) P0 % meas ( P0_NDN , tmp ) = sum ( P0 % dn ) !=================================================================! ! Kinetic energy = tt*sum_{ij\\sigma}(G_{ij\\sigma}+G_{ji\\sigma}) - ! - \\sum_{i\\sigma} \\mu_{i\\sigma} (n_{i\\sigma} + U_i / 2)! ! where site i and site j are neighbors   ! !=================================================================! ! Hopping energy = tt*sum_{ij\\sigma}(G_{ij\\sigma}+G_{ji\\sigma}) ! set alias start => S % T % cstart r => S % T % row A => S % T % A ! loop all adj sites do i = 1 , n ! for each column do j = start ( i ), start ( i + 1 ) - 1 ! for each nonzero elements P0 % meas ( P0_KE , tmp ) = P0 % meas ( P0_KE , tmp ) + & t_up ( A ( j )) * G_up ( r ( j ), i ) + & t_dn ( A ( j )) * G_dn ( r ( j ), i ) P0 % meas ( P0_hopping_energy , tmp ) = P0 % meas ( P0_hopping_energy , tmp ) + & t_up ( A ( j )) * G_up ( r ( j ), i ) + & t_dn ( A ( j )) * G_dn ( r ( j ), i ) end do P0 % meas ( P0_KE , tmp ) = P0 % meas ( P0_KE , tmp ) - & ( mu_up ( S % Map ( i )) + 0.5d0 * U ( S % map ( i ))) * P0 % up ( i ) - & ( mu_dn ( S % Map ( i )) + 0.5d0 * U ( S % map ( i ))) * P0 % dn ( i ) end do !=================================================================! ! Total occupancy = nup + ndn !=================================================================! P0 % meas ( P0_DENSITY , tmp ) = P0 % meas ( P0_NUP , tmp ) + & P0 % meas ( P0_NDN , tmp ) !=================================================================! ! Magnetisation squared = 1/4 (rho - 2 double_occupancy) !=================================================================! P0 % meas ( P0_magnetization_squared , tmp ) = 0.25d0 * ( P0 % meas ( P0_density , tmp ) - & 2 * P0 % meas ( P0_double_occupancy , tmp )) !=================================================================! ! Total energy = hopping energy + potential energy - ! - sum_{i \\sigma} (\\mu_{up i \\sigma} n_{dn i \\sigma}) !=================================================================! P0 % meas ( P0_ENERGY , tmp ) = P0 % meas ( P0_hopping_energy , tmp ) + & P0 % meas ( P0_potential_energy , tmp ) do i = 1 , n P0 % meas ( P0_ENERGY , tmp ) = P0 % meas ( P0_ENERGY , tmp ) - & ( mu_up ( S % Map ( i )) * P0 % up ( i ) + mu_dn ( S % Map ( i )) * P0 % dn ( i )) enddo !=========================================! ! Chi_thermal !=========================================! ! Fill h_up, h_dn with hopping matrix elements h_up = ZERO h_dn = ZERO do i = 1 , n do j = start ( i ), start ( i + 1 ) - 1 h_up ( r ( j ), i ) = - t_up ( A ( j )) h_dn ( r ( j ), i ) = - t_dn ( A ( j )) end do h_up ( i , i ) = h_up ( i , i ) - mu_up ( S % Map ( i )) - 0.5d0 * U ( S % Map ( i )) h_dn ( i , i ) = h_dn ( i , i ) - mu_dn ( S % Map ( i )) - 0.5d0 * U ( S % Map ( i )) end do ! Gfun * t ! Fill h_up, h_dn call blas_dgemm ( 'N' , 'N' , n , n , n , ONE , G_up , n , h_up , n , ZERO , A_up , n ) call blas_dgemm ( 'N' , 'N' , n , n , n , ONE , G_dn , n , h_dn , n , ZERO , A_dn , n ) ! Total number of particles Nbar = sum ( P0 % up ) + sum ( P0 % dn ) Tbar = 0.d0 do i = 1 , n Tbar = Tbar + h_up ( i , i ) + h_dn ( i , i ) enddo Cbar = 0.d0 do i = 1 , n Cbar = Cbar + A_up ( i , i ) + A_dn ( i , i ) enddo !< N T > P0 % meas ( P0_CHIT , tmp ) = ( Tbar - Cbar ) * Nbar do j = 1 , n do k = 1 , n P0 % meas ( P0_CHIT , tmp ) = P0 % meas ( P0_CHIT , tmp ) - G_up ( j , k ) * A_up ( k , j ) - G_dn ( j , k ) * A_dn ( k , j ) enddo enddo P0 % meas ( P0_CHIT , tmp ) = P0 % meas ( P0_CHIT , tmp ) + Cbar !< N U > P0 % meas ( P0_CHIT , tmp ) = P0 % meas ( P0_CHIT , tmp ) + Nbar * P0 % meas ( P0_NUD , tmp ) do i = 1 , n un = ONE do k = 1 , n un = un - G_up ( i , k ) * G_up ( k , i ) enddo P0 % meas ( P0_CHIT , tmp ) = P0 % meas ( P0_CHIT , tmp ) + un * P0 % dn ( i ) * U ( S % Map ( i )) un = ONE do k = 1 , n un = un - G_dn ( i , k ) * G_dn ( k , i ) enddo P0 % meas ( P0_CHIT , tmp ) = P0 % meas ( P0_CHIT , tmp ) + un * P0 % up ( i ) * U ( S % Map ( i )) enddo P0 % meas ( P0_CHIT , tmp ) = P0 % meas ( P0_CHIT , tmp ) - TWO * P0 % meas ( P0_NUD , tmp ) !Scale by inverse temperature P0 % meas ( P0_CHIT , tmp ) = P0 % beta * P0 % beta * P0 % meas ( P0_CHIT , tmp ) !=========================================! ! Specific heat !=========================================! !< T T > P0 % meas ( P0_CV , tmp ) = ( Tbar - Cbar ) ** 2 do i = 1 , n do j = 1 , n P0 % meas ( P0_CV , tmp ) = P0 % meas ( P0_CV , tmp ) + ( h_up ( i , j ) - A_up ( i , j )) * A_up ( j , i ) & + ( h_dn ( i , j ) - A_dn ( i , j )) * A_dn ( j , i ) enddo enddo !< T U > P0 % meas ( P0_CV , tmp ) = P0 % meas ( P0_CV , tmp ) + ( Tbar - Cbar ) * P0 % meas ( P0_NUD , tmp ) do i = 1 , n !un = U(S%map(i)) * P0%up(i) un = ZERO do j = 1 , n !P0%meas(P0_CV,tmp) = P0%meas(P0_CV,tmp) + un * G_dn(j,i) * (h_dn(i,j) - A_dn(i,j)) un = un + G_dn ( j , i ) * ( h_dn ( i , j ) - A_dn ( i , j )) enddo P0 % meas ( P0_CV , tmp ) = P0 % meas ( P0_CV , tmp ) + un * U ( S % map ( i )) * P0 % up ( i ) !un = U(S%map(i)) * P0%dn(i) un = ZERO do j = 1 , n !P0%meas(P0_CV,tmp) = P0%meas(P0_CV,tmp) + un * G_up(j,i) * (h_up(i,j) - A_up(i,j)) un = un + G_up ( j , i ) * ( h_up ( i , j ) - A_up ( i , j )) enddo P0 % meas ( P0_CV , tmp ) = P0 % meas ( P0_CV , tmp ) + un * U ( S % map ( i )) * P0 % dn ( i ) enddo !< U T > P0 % meas ( P0_CV , tmp ) = P0 % meas ( P0_CV , tmp ) + ( Tbar - Cbar ) * P0 % meas ( P0_NUD , tmp ) do i = 1 , n P0 % meas ( P0_CV , tmp ) = P0 % meas ( P0_CV , tmp ) + U ( S % map ( i )) * P0 % up ( i ) * A_dn ( i , i ) !un = U(S%map(i)) * P0%up(i) un = ZERO do j = 1 , n !P0%meas(P0_CV,tmp) = P0%meas(P0_CV,tmp) - un * A_dn(i,j) * G_dn(j,i) un = un + A_dn ( i , j ) * G_dn ( j , i ) enddo P0 % meas ( P0_CV , tmp ) = P0 % meas ( P0_CV , tmp ) - un * U ( S % map ( i )) * P0 % up ( i ) P0 % meas ( P0_CV , tmp ) = P0 % meas ( P0_CV , tmp ) + U ( S % map ( i )) * P0 % dn ( i ) * A_up ( i , i ) !un = U(S%map(i)) * P0%dn(i) un = ZERO do j = 1 , n !P0%meas(P0_CV,tmp) = P0%meas(P0_CV,tmp) - un * A_up(i,j) * G_up(j,i) un = un + A_up ( i , j ) * G_up ( j , i ) enddo P0 % meas ( P0_CV , tmp ) = P0 % meas ( P0_CV , tmp ) - un * U ( S % map ( i )) * P0 % dn ( i ) enddo !< U U > ! Redefine A_up and A_dn do j = 1 , n do i = 1 , n un = sqrt ( U ( S % Map ( i )) * U ( S % Map ( j ))) A_up ( i , j ) = un * ( P0 % up ( i ) * P0 % up ( j ) - G_up ( i , j ) * G_up ( j , i )) A_dn ( i , j ) = un * ( P0 % dn ( i ) * P0 % dn ( j ) - G_dn ( i , j ) * G_dn ( j , i )) enddo A_up ( j , j ) = P0 % up ( j ) * U ( S % Map ( j )) A_dn ( j , j ) = P0 % dn ( j ) * U ( S % Map ( j )) enddo ! Compute UU contribution to Cv do j = 1 , n do i = 1 , n P0 % meas ( P0_CV , tmp ) = P0 % meas ( P0_CV , tmp ) + A_up ( i , j ) * A_dn ( i , j ) enddo enddo ! Scale by inverse T P0 % meas ( P0_CV , tmp ) = P0 % beta * P0 % beta * P0 % meas ( P0_CV , tmp ) !=====================! ! Autocorelation term.! !=====================! if ( P0 % compSAF ) then P0 % meas ( P0_SAF , tmp ) = TWO * n - P0 % meas ( P0_NUP , tmp ) - & P0 % meas ( P0_NDN , tmp ) P0 % meas ( P0_SAF2 , tmp ) = P0 % meas ( P0_SAF , tmp ) end if do i = 1 , n do j = 1 , n var1 = G_up ( i , j ) * G_up ( j , i ) + G_dn ( i , j ) * G_dn ( j , i ) var2 = - TWO * G_up ( i , j ) * G_dn ( j , i ) var3 = G_up ( i , i ) * G_up ( j , j ) + G_dn ( i , i ) * G_dn ( j , j ) - & TWO * G_up ( i , i ) * G_dn ( j , j ) - var1 ! k is the index k = S % D ( i , j ) ph = S % gf_phase ( i , j ) P0 % G_fun ( k , tmp ) = P0 % G_fun ( k , tmp ) + ph * ( G_up ( i , j ) + G_dn ( i , j )) P0 % Gf_up ( k , tmp ) = P0 % Gf_up ( k , tmp ) + ph * G_up ( i , j ) P0 % Gf_dn ( k , tmp ) = P0 % Gf_dn ( k , tmp ) + ph * G_dn ( i , j ) P0 % Den0 ( k , tmp ) = P0 % Den0 ( k , tmp ) + & P0 % up ( i ) * P0 % up ( j ) + P0 % dn ( i ) * P0 % dn ( j ) - var1 P0 % Den1 ( k , tmp ) = P0 % Den1 ( k , tmp ) + P0 % up ( i ) * P0 % dn ( j ) P0 % SpinXX ( k , tmp ) = P0 % SpinXX ( k , tmp ) + var2 P0 % SpinZZ ( k , tmp ) = P0 % SpinZZ ( k , tmp ) + var3 P0 % Pair ( k , tmp ) = P0 % Pair ( k , tmp ) + G_up ( i , j ) * G_dn ( i , j ) if ( P0 % compSAF ) then var1 = S % P ( i ) * S % P ( j ) P0 % meas ( P0_SAF , tmp ) = P0 % meas ( P0_SAF , tmp ) + var1 * var2 P0 % meas ( P0_SAF2 , tmp ) = P0 % meas ( P0_SAF2 , tmp ) + var1 * var3 end if end do ! special case for (i,i) k = S % D ( i , i ) var1 = G_up ( i , i ) + G_dn ( i , i ) P0 % Den0 ( k , tmp ) = P0 % Den0 ( k , tmp ) + var1 P0 % SpinXX ( k , tmp ) = P0 % SpinXX ( k , tmp ) + var1 P0 % SpinZZ ( k , tmp ) = P0 % SpinZZ ( k , tmp ) + var1 end do P0 % meas ( P0_SFERRO , tmp ) = sum ( P0 % SpinXX (:, tmp )) P0 % meas ( P0_SFER2 , tmp ) = sum ( P0 % SpinZZ (:, tmp )) ! Average P0 % meas (:, tmp ) = P0 % meas (:, tmp ) / n do i = 1 , P0 % nClass P0 % G_fun ( i , tmp ) = P0 % G_fun ( i , tmp ) / S % F ( i ) * HALF P0 % Gf_up ( i , tmp ) = P0 % Gf_up ( i , tmp ) / S % F ( i ) P0 % Gf_dn ( i , tmp ) = P0 % Gf_dn ( i , tmp ) / S % F ( i ) P0 % SpinXX ( i , tmp ) = P0 % SpinXX ( i , tmp ) / S % F ( i ) P0 % SpinZZ ( i , tmp ) = P0 % SpinZZ ( i , tmp ) / S % F ( i ) P0 % Den0 ( i , tmp ) = P0 % Den0 ( i , tmp ) / S % F ( i ) * HALF P0 % Den1 ( i , tmp ) = P0 % Den1 ( i , tmp ) / S % F ( i ) P0 % Pair ( i , tmp ) = P0 % Pair ( i , tmp ) / S % F ( i ) * HALF end do if ( P0 % compSAF ) then P0 % meas ( P0_SAFSQ , tmp ) = P0 % meas ( P0_SAF , tmp ) * P0 % meas ( P0_SAF , tmp ) P0 % meas ( P0_SAF2SQ , tmp ) = P0 % meas ( P0_SAF2 , tmp ) * P0 % meas ( P0_SAF2 , tmp ) end if ! Accumulate result to P0(:, idx) sgn = sgnup * sgndn P0 % meas (:, idx ) = P0 % meas (:, idx ) + P0 % meas (:, tmp ) * sgn m = P0 % nClass call blas_daxpy ( m , sgn , P0 % G_fun ( 1 : m , tmp ), 1 , P0 % G_fun ( 1 : m , idx ), 1 ) call blas_daxpy ( m , sgn , P0 % Gf_up ( 1 : m , tmp ), 1 , P0 % Gf_up ( 1 : m , idx ), 1 ) call blas_daxpy ( m , sgn , P0 % Gf_dn ( 1 : m , tmp ), 1 , P0 % Gf_dn ( 1 : m , idx ), 1 ) call blas_daxpy ( m , sgn , P0 % SpinXX ( 1 : m , tmp ), 1 , P0 % SpinXX ( 1 : m , idx ), 1 ) call blas_daxpy ( m , sgn , P0 % SpinZZ ( 1 : m , tmp ), 1 , P0 % SpinZZ ( 1 : m , idx ), 1 ) call blas_daxpy ( m , sgn , P0 % Den0 ( 1 : m , tmp ), 1 , P0 % Den0 ( 1 : m , idx ), 1 ) call blas_daxpy ( m , sgn , P0 % Den1 ( 1 : m , tmp ), 1 , P0 % Den1 ( 1 : m , idx ), 1 ) call blas_daxpy ( m , sgn , P0 % Pair ( 1 : m , tmp ), 1 , P0 % Pair ( 1 : m , idx ), 1 ) P0 % sign ( P0_SGN , idx ) = P0 % sign ( P0_SGN , idx ) + sgn P0 % sign ( P0_SGNUP , idx ) = P0 % sign ( P0_SGNUP , idx ) + sgnup P0 % sign ( P0_SGNDN , idx ) = P0 % sign ( P0_SGNDN , idx ) + sgndn P0 % cnt = P0 % cnt + 1 end subroutine DQMC_Phy0_Meas !--------------------------------------------------------------------! subroutine DQMC_Phy0_GetFT ( P0 , class , phase , ft_wgt_t , ft_wgt_g , nkt , nkg , na , nt ) ! ! Purpose ! ======= !    This subroutine computes the FT of the correlation functions !    stored in phy0. It fills the bins transforming the jackknived !    values of the real space correlation functions. The error is !    estimated using the standard jackknife formula. ! ! Comments ! ======== !    LAPACK could have been used in, at least, two places but this !    routine is not critical (only called at the end) so that !    having explicit matrix multiplication improves readability !    without degrading performance. ! ! Arguments ! ========= integer , intent ( in ) :: na !number of site in primitive cell integer , intent ( in ) :: nt !number of translations integer , intent ( in ) :: nkt , nkg !number of k-points integer , intent ( in ) :: class ( na * nt , na * nt ) !classes of pairs of sites integer , intent ( in ) :: phase ( na * nt , na * nt ) !classes of pairs of sites complex * 16 , intent ( in ), target :: ft_wgt_t ( nt , nkt ) !fourier weights : exp(ikr) complex * 16 , intent ( in ), target :: ft_wgt_g ( nt , nkg ) !fourier weights : exp(ikr) type ( Phy0 ), intent ( inout ) :: P0 !container ! ... Local variables ... real ( wp ) :: rwork ( 3 * na ), phcurr real ( wp ), pointer :: curr (:) real ( wp ), pointer :: currft (:) integer :: ph ( na * nt , na * nt ) integer :: nak , ip , ibin , nBin integer :: avg , err , ia , ja , ik , i , j , it , nk , jt complex * 16 :: work ( 2 * na ), U ( na , na ), W ( na , na ) complex * 16 , pointer :: ft_wgt (:,:) complex * 16 , parameter :: ZEROZ = ( 0.d0 , 0.d0 ), ONEZ = ( 1.d0 , 0.d0 ) nBin = P0 % nBin avg = P0 % avg err = P0 % err nk = max ( nkt , nkg ) nak = na * nk !Initialize pointers to Fourier transform do ip = 1 , narrays + 1 P0 % IARREV ( ip ) = ( ip - 1 ) * nak + 1 P0 % IARRFT ( ip ) = ( ip - 1 ) * nak * ( na + 1 ) / 2 + 1 enddo !Allocate storage for Fourier transform allocate ( P0 % AllPropFT ( nak * ( na + 1 ) * narrays / 2 , P0 % err )) allocate ( P0 % AllPropEigVal ( nak * narrays , P0 % err )) allocate ( P0 % AllPropEigVec ( na , na , nk , narrays )) P0 % initFT = . true . !Loop over properties to Fourier transform do ip = 1 , narrays !select k-grid with twist or not (only gfun's require twist) select case ( ip ) case ( IGFUN , IGFUP , IGFDN ) nk = nkt ft_wgt => ft_wgt_t ph = phase case default nk = nkg ft_wgt => ft_wgt_g ph = nint ( ONE ) end select !Fourier transform each bin and average do ibin = P0 % avg , 1 , - 1 !Pointer to property \"ip\" in bin \"ibin\" curr => P0 % AllProp ( P0 % IARR ( ip ): P0 % IARR ( ip + 1 ) - 1 , ibin ) !Loop over inequvalent k-points do ik = 1 , nk U = 0.d0 !Compute Fourier transform matrix at \"ik\" for (ja,ia) do ia = 1 , na do ja = ia , na !sum over translations do it = 1 , nt do jt = 1 , nt !Find atom which is the translation of \"ja\" by \"it\" i = ( it - 1 ) * na + ia j = ( jt - 1 ) * na + ja !Use class that corresponds to the (i,j) pair phcurr = ph ( i , j ) * curr ( class ( i , j )) U ( ja , ia ) = U ( ja , ia ) + phcurr * ft_wgt ( it , ik ) * dconjg ( ft_wgt ( jt , ik )) enddo enddo enddo enddo !Pointer to Fourier transform of \"ip\" at \"ik\" in \"ibin\" i = P0 % IARRFT ( ip ) + ( ik - 1 ) * na * ( na + 1 ) / 2 do ia = 1 , na do ja = ia , na P0 % AllPropFT ( i , ibin ) = U ( ja , ia ) i = i + 1 enddo enddo currft => P0 % AllPropEigVal ( P0 % IARREV ( ip ) + ( ik - 1 ) * na : P0 % IARREV ( ip ) + ik * na - 1 , ibin ) !Diagonalize Fourier transform matrix. Store eigenvalues in AllPropEigVal. if ( ibin == P0 % avg ) then call zheev ( 'V' , 'L' , na , U , na , currft , work , 2 * na , rwork , it ) !Store eigenvectors as well for the average P0 % AllPropEigVec (:,:, ik , ip ) = U else call zheev ( 'N' , 'L' , na , U , na , currft , work , 2 * na , rwork , it ) call zgemm ( 'N' , 'N' , na , na , na , ONEZ , U , na , P0 % AllPropEigVec (:,:, ik , ip ), na , ZEROZ , W , na ) call zgemm ( 'T' , 'N' , na , na , na , ONEZ , P0 % AllPropEigVec (:,:, ik , ip ), na , W , na , ZEROZ , U , na ) do i = 1 , na currft ( i ) = dreal ( U ( i , i )) enddo endif enddo ! Loop over k-points enddo ! Loop over bins enddo ! Loop over properties end subroutine DQMC_Phy0_GetFT !--------------------------------------------------------------------! subroutine DQMC_Phy0_GetErrFT ( P0 ) use dqmc_mpi ! ! Purpose ! ======= !    This subroutine computes the error the Fourier Transform of all properties. ! !  Pre-assumption ! =============== !    DQMC_Phy0_GetFT was called. ! ! Arguments ! ========= ! type ( Phy0 ), intent ( inout ) :: P0 !container integer :: err , avg , n , m , nbin , i , nproc nbin = P0 % nbin err = P0 % err avg = P0 % avg nproc = qmc_sim % size n = size ( P0 % AllPropEigVal , 1 ) m = size ( P0 % AllPropFT , 1 ) if ( nproc > 1 ) then !Compute errorbars avgraging over processors #      ifdef _QMC_MPI call mpi_allreduce ( P0 % AllPropEigVal (:, 1 ) ** 2 , P0 % AllPropEigVal (:, err ), n , mpi_double , & mpi_sum , mpi_comm_world , i ) call mpi_allreduce ( P0 % AllPropFT (:, 1 ) ** 2 , P0 % AllPropFT (:, err ), m , mpi_double , & mpi_sum , mpi_comm_world , i ) #      endif P0 % AllPropEigVal (:, err ) = P0 % AllPropEigVal (:, err ) / dble ( nproc ) - P0 % AllPropEigVal (:, avg ) ** 2 P0 % AllPropEigVal (:, err ) = sqrt ( P0 % AllPropEigVal (:, err ) * dble ( nproc - 1 )) P0 % AllPropFT (:, err ) = P0 % AllPropFT (:, err ) / dble ( nproc ) - P0 % AllPropFT (:, avg ) ** 2 P0 % AllPropFT (:, err ) = sqrt ( P0 % AllPropFT (:, err ) * dble ( nproc - 1 )) else !Compute errorbars using bins do i = 1 , n P0 % AllPropEigVal ( i , err ) = sqrt (( nbin - 1 ) * sum (( P0 % AllPropEigVal ( i , avg ) - P0 % AllPropEigVal ( i , 1 : nbin )) ** 2 ) / nbin ) enddo do i = 1 , m P0 % AllPropFT ( i , err ) = sqrt (( nbin - 1 ) * sum (( P0 % AllPropFT ( i , avg ) - P0 % AllPropFT ( i , 1 : nbin )) ** 2 ) / nbin ) enddo endif end  subroutine DQMC_Phy0_GetErrFT !--------------------------------------------------------------------! subroutine DQMC_Phy0_PrintFT ( P0 , na , nkt , nkg , OPT ) use dqmc_mpi ! ! Purpose ! ======= !    This subroutine prints out the Fourier transform. !    Labels need to be produced separately. ! !  Pre-assumption ! =============== !    OPT is a file handle !    DQMC_Phy0_GetErrFT was called. ! ! Arguments ! ========= ! type ( Phy0 ), intent ( in ) :: P0 ! Phy0 integer , intent ( in ) :: OPT ! Output file handle integer , intent ( in ) :: na ! number of sites in unit cell integer , intent ( in ) :: nkt , nkg ! number of non-equivalent k-points ! ... Local varaiables ... integer :: i , ia , ja , ii , avg , err , nakt , nakg real ( wp ), pointer :: FTptr (:,:) complex * 16 , pointer :: Nmptr (:,:,:) character ( len = 30 ), pointer :: clabel (:) if ( qmc_sim % rank /= 0 ) return avg = P0 % avg err = P0 % err nakt = na * nkt nakg = na * nkg allocate ( clabel ( max ( nakt , nakg ) * ( na + 1 ) / 2 )) ! ... Executable ... ii = 0 do i = 1 , nkt do ia = 0 , na - 1 do ja = ia , na - 1 ii = ii + 1 if ( ia + ja == 0 ) then write ( clabel ( ii ), '(3(i5))' ) i , ja , ia else write ( clabel ( ii ), '(5x,2(i5))' ) ja , ia endif enddo enddo enddo FTptr => P0 % AllPropFT ( P0 % IARRFT ( IGFUN ): P0 % IARRFT ( IGFUN + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakt * ( na + 1 ) / 2 , \"FT of Ave Equal t Green's function:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropFT ( P0 % IARRFT ( IGFUP ): P0 % IARRFT ( IGFUP + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakt * ( na + 1 ) / 2 , \"FT of Up Equal t Green's function:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropFT ( P0 % IARRFT ( IGFDN ): P0 % IARRFT ( IGFDN + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakt * ( na + 1 ) / 2 , \"FT of Dn Equal t Green's function:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) ii = 0 do i = 1 , nkg do ia = 0 , na - 1 do ja = ia , na - 1 ii = ii + 1 if ( ia + ja == 0 ) then write ( clabel ( ii ), '(3(i5))' ) i , ja , ia else write ( clabel ( ii ), '(5x,2(i5))' ) ja , ia endif enddo enddo enddo FTptr => P0 % AllPropFT ( P0 % IARRFT ( IDEN0 ): P0 % IARRFT ( IDEN0 + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakg * ( na + 1 ) / 2 , \"FT of Density-density correlation fn: (up-up)\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropFT ( P0 % IARRFT ( IDEN1 ): P0 % IARRFT ( IDEN1 + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakg * ( na + 1 ) / 2 , \"FT of Density-density correlation fn: (up-dn)\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropFT ( P0 % IARRFT ( ISPXX ): P0 % IARRFT ( ISPXX + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakg * ( na + 1 ) / 2 , \"FT of XX spin correlation fn:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropFT ( P0 % IARRFT ( ISPZZ ): P0 % IARRFT ( ISPZZ + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakg * ( na + 1 ) / 2 , \"FT of ZZ spin correlation fn:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropFT ( P0 % IARRFT ( IAVSP ): P0 % IARRFT ( IAVSP + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakg * ( na + 1 ) / 2 , \"FT of Average spin correlation fn:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropFT ( P0 % IARRFT ( IPAIR ): P0 % IARRFT ( IPAIR + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakg * ( na + 1 ) / 2 , \"FT of Pairing correlation fn:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) if ( na > 1 ) then ii = 0 do i = 1 , nkt do ia = 1 , na ii = ii + 1 if ( ia == 1 ) then write ( clabel ( ii ), '(2(i5))' ) i , ia else write ( clabel ( ii ), '(5x,i5)' ) ia endif enddo enddo FTptr => P0 % AllPropEigVal ( P0 % IARREV ( IGFUN ): P0 % IARREV ( IGFUN + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakt , \"Eigenvalues of Ave Equal t Green's function:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropEigVal ( P0 % IARREV ( IGFUP ): P0 % IARREV ( IGFUP + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakt , \"Eigenvalues of Up Equal t Green's function:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropEigVal ( P0 % IARREV ( IGFDN ): P0 % IARREV ( IGFDN + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakt , \"Eigenvalues of Dn Equal t Green's function:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) ii = 0 do i = 1 , nkg do ia = 1 , na ii = ii + 1 if ( ia == 1 ) then write ( clabel ( ii ), '(2(i5))' ) i , ia else write ( clabel ( ii ), '(5x,i5)' ) ia endif enddo enddo FTptr => P0 % AllPropEigVal ( P0 % IARREV ( IDEN0 ): P0 % IARREV ( IDEN0 + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakg , \"Eigenvalues of Density-density correlation fn: (up-up)\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropEigVal ( P0 % IARREV ( IDEN1 ): P0 % IARREV ( IDEN1 + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakg , \"Eigenvalues of Density-density correlation fn: (up-dn)\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropEigVal ( P0 % IARREV ( ISPXX ): P0 % IARREV ( ISPXX + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakg , \"Eigenvalues of XX spin correlation fn:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropEigVal ( P0 % IARREV ( ISPZZ ): P0 % IARREV ( ISPZZ + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakg , \"Eigenvalues of ZZ spin correlation fn:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropEigVal ( P0 % IARREV ( IAVSP ): P0 % IARREV ( IAVSP + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakg , \"Eigenvalues of Average spin correlation fn:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) FTptr => P0 % AllPropEigVal ( P0 % IARREV ( IPAIR ): P0 % IARREV ( IPAIR + 1 ) - 1 ,:) call DQMC_Print_RealArray ( 0 , nakg , \"Eigenvalues of Pairing correlation fn:\" , & clabel , FTptr (:, avg : avg ), FTptr (:, err : err ), OPT ) Nmptr => P0 % AllPropEigVec (:,:,:, IGFUN ) call DQMC_Print_EigenMode ( na , nkt , \"Eigenmodes of Ave Equal t Green's function (Natural orbitals):\" , & Nmptr , OPT ) Nmptr => P0 % AllPropEigVec (:,:,:, IGFUP ) call DQMC_Print_EigenMode ( na , nkt , \"Eigenmodes of Up Equal t Green's function (Natural orbitals):\" , & Nmptr , OPT ) Nmptr => P0 % AllPropEigVec (:,:,:, IGFDN ) call DQMC_Print_EigenMode ( na , nkt , \"Eigenmodes of Down Equal t Green's function (Natural orbitals):\" , & Nmptr , OPT ) Nmptr => P0 % AllPropEigVec (:,:,:, IDEN0 ) call DQMC_Print_EigenMode ( na , nkg , \"Eigenmodes of Density-density correlation fn: (up-up)\" , & Nmptr , OPT ) Nmptr => P0 % AllPropEigVec (:,:,:, IDEN1 ) call DQMC_Print_EigenMode ( na , nkg , \"Eigenmodes of Density-density correlation fn: (up-dn)\" , & Nmptr , OPT ) Nmptr => P0 % AllPropEigVec (:,:,:, ISPXX ) call DQMC_Print_EigenMode ( na , nkg , \"Eigenmodes of XX-Spin correlation fn: \" , & Nmptr , OPT ) Nmptr => P0 % AllPropEigVec (:,:,:, ISPZZ ) call DQMC_Print_EigenMode ( na , nkg , \"Eigenmodes of ZZ-Spin correlation fn: \" , & Nmptr , OPT ) Nmptr => P0 % AllPropEigVec (:,:,:, IAVSP ) call DQMC_Print_EigenMode ( na , nkg , \"Eigenmodes of Average Spin correlation fn: \" , & Nmptr , OPT ) Nmptr => P0 % AllPropEigVec (:,:,:, IPAIR ) call DQMC_Print_EigenMode ( na , nkg , \"Eigenmodes of Pairing correlation fn: \" , & Nmptr , OPT ) endif deallocate ( clabel ) end subroutine DQMC_Phy0_PrintFT end module DQMC_Phy0","tags":"","loc":"sourcefile/dqmc_phy0.f90.html"},{"title":"dqmc_gfun.F90 – Quest","text":"This file depends on sourcefile~~dqmc_gfun.f90~~EfferentGraph sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_gfun.f90~~AfferentGraph sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_GFun #include \"dqmc_include.h\" use DQMC_UTIL use DQMC_WSPACE #ifdef DQMC_CKB use DQMC_CheckerBoard #else use DQMC_MATB #endif use DQMC_SEQB implicit none ! ! This module defines the data type and subroutines for ! constructiong and manipulating the Green's function. ! The Green's function in Hubbard's model is defined as ! !     G = inv((I+B_{i-1}...B_1*B_l...B_{i})), ! ! where B_{i} = V_{i}*B.  Matrix V_{i} is diagonal and B is ! defined as exp(-t*K), where K is an adjacent matrix for ! underline lattice. ! !     G = inv((I+inv(B_{i-1}...B_1*B_l...B_{i}))), ! ! For more details, see the working note. ! ! [1] Z. Bai, W.Chen, R. Scalettar, I. Yamazaki, \"Lecture Notes !     on Advances of Numerical Methods for Hubbard Quantum Monte !     Carlo Simulation.\" ! !  Subroutine List !  =============== !    DQMC_GFun_Init(n, l, GF) : initialize the data type. !    DQMC_GetV(G_up, G_dn, explook, hub) : construct matrix V !    DQMC_GetG(sl, G, R, Q, T, rw, D, !              tau, piv1, piv2, lwork, nOrth) : construct matrix G ! !  Data Type !  ========= ! type G_fun integer :: n ! Number of sites in Hubbard's model integer :: L ! Number of slice real ( wp ) :: sgn ! Sign of det(G) real ( wp ), pointer :: G (:,:) ! Matrix of Green's function logical :: owns_G ! does this G_fun own its G's storage? real ( wp ), pointer :: V (:,:) ! Matrix info of V(1)...V(l) integer :: ilb ! index of left most B real ( wp ) :: det ! working space, in addition to SB's integer , pointer :: pvt (:) real ( wp ), pointer :: tmp (:,:) ! data pointer for the C++ module #if defined(DQMC_ASQRD) integer * 8 :: cpp_data #endif ! For numerical stab integer :: nWrap , wps , lastwr , maxwrap , fixwrap real ( wp ) :: difflim , errrate integer :: redo , noredo ! Block size of delayed update integer :: nBlk integer :: blkSz real ( wp ), pointer :: U (:,:) real ( wp ), pointer :: W (:,:) integer :: nModify real ( wp ), pointer :: GS (:,:) real ( wp ), pointer :: WS (:,:) logical :: sxx end type G_fun logical , parameter :: GMAT_UP = . true . logical , parameter :: GMAT_DN = . false . #ifdef DQMC_PROFILE #define PROF_BEGIN if (gfun_profile) call get_time(gfun_t1) #define PROF_END(c, t) if (gfun_profile) call gfun_end(c, t) real ( wp ) :: GetG_time = 0 , ComputeG_time = 0 , Getjj_time = 0 real ( wp ) :: UpdateG_time = 0 , ApplyUpdate_time = 0 double precision :: gfun_t1 , gfun_t2 logical :: gfun_profile = . false . integer :: GetG_count = 0 , ComputeG_count = 0 , Getjj_count = 0 integer :: UpdateG_count = 0 , ApplyUpdate_count = 0 contains subroutine gfun_end ( c , t ) integer :: c real ( wp ) :: t call get_time ( gfun_t2 ) c = c + 1 t = t + gfun_t2 - gfun_t1 end subroutine gfun_end subroutine gfun_print () write ( * , * ) \"GetG          \" , GetG_count , GetG_time write ( * , * ) \"ComputeG      \" , ComputeG_count , ComputeG_time write ( * , * ) \"Getjj         \" , Getjj_count , Getjj_time write ( * , * ) \"UpdateG       \" , UpdateG_count , UpdateG_time write ( * , * ) \"ApplyUpdate   \" , ApplyUpdate_count , ApplyUpdate_time end subroutine gfun_print #else #define PROF_BEGIN #define PROF_END(c, t) contains #endif !-------------------------------------------------------------------------! subroutine DQMC_GFun_Init ( n , L , G , V , WS , nWrap , difflim , errrate , up , ssxx , fixw ) ! ! Purpose ! ======= !    This subroutine initiliazes the data type of Green function. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! Number of sites integer , intent ( in ) :: L ! Number of slice type ( G_fun ), intent ( inout ) :: G ! Green's function real ( wp ), intent ( in ), target :: V ( n , L ) ! V matrix type ( Wspace ), intent ( in ), target :: WS ! working space real ( wp ), intent ( in ) :: difflim ! limit of mat diff real ( wp ), intent ( in ) :: errrate ! toleratble error integer , intent ( in ) :: nwrap ! safe wrap number logical , intent ( in ) :: up ! for G_up or G_dn integer , intent ( in ) :: ssxx integer , intent ( in ) :: fixw ! ... LAPACK subroutine integer :: ILAENV ! ... Local variables ... integer :: nb ! ... Executable ... G % n = n G % L = L G % sgn = ONE G % pvt => WS % I2 G % V => V G % ilb = - L - 1 G % difflim = difflim G % nWrap = nWrap G % fixwrap = fixw G % maxWrap = 3 * nWrap G % wps = 1 G % errrate = errrate G % redo = 0 G % noRedo = 1 G % lastwr = 0 G % blkSz = 0 G % nModify = 0 G % det = 0 nb = ILAENV ( 1 , \"DGETRI\" , \" \" , n , - 1 , - 1 , - 1 ) G % nblk = min ( nb , n ) allocate ( G % G ( n , n ), G % tmp ( n , n )) G % owns_G = . true . G % sgn = ONE ! U and W are used when updating G during the sweep over sites ! while Gs and WS are used before measuring. Hence, there should ! be no conflict in having them pointing to the same location. if ( up ) then G % U => WS % R1 G % W => WS % R2 G % GS => WS % R1 G % WS => WS % R2 else G % U => WS % R3 G % W => WS % R4 G % GS => WS % R3 G % WS => WS % R4 end if G % sxx = ssxx . gt . 0 ! C++ module initialization #if defined(DQMC_ASQRD) call cpp_gfun_init ( G % cpp_data , n , L , nWrap , fixw ) #endif end subroutine DQMC_GFun_Init !-------------------------------------------------------------------------! subroutine DQMC_GFun_Init_original ( n , L , G , V , WS , nWrap , difflim , errrate , up , ssxx , fixw ) ! ! Purpose ! ======= !    This subroutine initiliazes the data type of Green function. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! Number of sites integer , intent ( in ) :: L ! Number of slice type ( G_fun ), intent ( inout ) :: G ! Green's function real ( wp ), intent ( in ), target :: V ( n , L ) ! V matrix type ( Wspace ), intent ( in ), target :: WS ! working space real ( wp ), intent ( in ) :: difflim ! limit of mat diff real ( wp ), intent ( in ) :: errrate ! toleratble error integer , intent ( in ) :: nwrap ! safe wrap number logical , intent ( in ) :: up ! for G_up or G_dn integer , intent ( in ) :: ssxx integer , intent ( in ) :: fixw ! ... LAPACK subroutine integer :: ILAENV ! ... Local variables ... integer :: nb ! ... Executable ... G % n = n G % L = L G % sgn = ONE G % pvt => WS % I2 G % V => V G % ilb = - L - 1 G % difflim = difflim G % nWrap = nWrap G % fixwrap = fixw G % wps = nWrap G % errrate = errrate G % redo = 0 G % noRedo = 1 G % lastwr = 0 G % blkSz = 0 G % nModify = 0 G % det = 0 nb = ILAENV ( 1 , \"DGETRI\" , \" \" , n , - 1 , - 1 , - 1 ) G % nblk = min ( nb , n ) allocate ( G % G ( n , n ), G % tmp ( n , n )) G % sgn = ONE ! U and W are used when updating G during the sweep over sites ! while Gs and WS are used before measuring. Hence, there should ! be no conflict in having them pointing to the same location. if ( up ) then G % U => WS % R1 G % W => WS % R2 G % GS => WS % R1 G % WS => WS % R2 else G % U => WS % R3 G % W => WS % R4 G % GS => WS % R3 G % WS => WS % R4 end if G % sxx = ssxx . gt . 0 end subroutine DQMC_GFun_Init_original !-------------------------------------------------------------------------! subroutine DQMC_GFun_Clone ( G1 , G2 ) ! ! Purpose ! ======= !    G1 = G2 ! ! Arguments ! ========= ! type ( G_fun ), intent ( inout ) :: G1 ! Green's function type ( G_fun ), intent ( in ) :: G2 ! Green's function ! ... Executable ... G1 % n = G2 % n G1 % L = G2 % L G1 % det = G2 % det G1 % sgn = G2 % sgn G1 % G => G2 % G G1 % owns_G = . false . G1 % V => G2 % V G1 % GS => G2 % GS G1 % sxx = G2 % sxx #if defined(DQMC_ASQRD) G1 % cpp_data = G2 % cpp_data #endif end subroutine DQMC_GFun_Clone !-------------------------------------------------------------------------! subroutine DQMC_GFun_Duplicate ( G1 , G2 ) ! ! Purpose ! ======= !    G1 = G2 ! ! Arguments ! ========= ! type ( G_fun ), intent ( inout ) :: G1 ! Green's function type ( G_fun ), intent ( in ) :: G2 ! Green's function ! ... Executable ... G1 % n = G2 % n G1 % L = G2 % L G1 % sgn = G2 % sgn G1 % pvt => G2 % pvt G1 % V => G2 % V G1 % ilb = G2 % ilb G1 % difflim = G2 % difflim G1 % nWrap = G2 % nWrap G1 % wps = G2 % wps G1 % errrate = G2 % errrate G1 % redo = G2 % redo G1 % noRedo = G2 % noRedo G1 % lastwr = G2 % lastwr G1 % blkSz = G2 % blkSz G1 % nModify = G2 % nModify G1 % det = G2 % det G1 % nblk = G2 % nblk allocate ( G1 % G ( G2 % n , G2 % n ), G1 % tmp ( G2 % n , G2 % n )) G1 % owns_G = . true . G1 % G = G2 % G G1 % tmp = G2 % tmp G1 % U => G2 % U G1 % W => G2 % W G1 % GS => G2 % GS G1 % WS => G2 % WS G1 % sxx = G2 % sxx #if defined(DQMC_ASQRD) call cpp_gfun_init ( G1 % cpp_data , G2 % n , G2 % L , G2 % nWrap , G2 % fixwrap ) #endif end subroutine DQMC_GFun_Duplicate !-------------------------------------------------------------------------! subroutine DQMC_GFun_CopyUp ( G1 , G2 , P ) ! ! Purpose ! ======= !    G1 = G2 ! ! Arguments ! ========= ! type ( G_fun ), intent ( inout ) :: G1 ! Green's function type ( G_fun ), intent ( in ) :: G2 ! Green's function real ( wp ), intent ( in ) :: P ( G2 % n ) integer :: i , j ! ... Executable ... G1 % ilb = G2 % ilb G1 % sgn = G2 % sgn do i = 1 , G2 % n do j = 1 , G2 % n G1 % G ( i , j ) = - P ( i ) * P ( j ) * G2 % G ( j , i ) end do G1 % G ( i , i ) = G1 % G ( i , i ) + ONE end do G1 % det = G2 % det do i = 1 , G2 % L do j = 1 , G2 % n G1 % det = G1 % det + log ( G2 % V ( j , i )) end do end do end subroutine DQMC_GFun_CopyUp !-------------------------------------------------------------------------! subroutine DQMC_Gfun_Free ( G ) ! ! Purpose ! ======= !    This subroutine frees memory of G. ! ! Arguments ! ========= ! type ( G_fun ), intent ( inout ) :: G ! Green's function ! ... Executable ... if ( G % owns_G ) then deallocate ( G % G , G % tmp ) #if defined(DQMC_ASQRD) call cpp_gfun_free ( G % cpp_data ) #endif end if end subroutine DQMC_Gfun_Free !--------------------------------------------------------------------------! subroutine DQMC_GetG ( il , G , SB ) ! ! Purpose ! ======= !    This subroutine returns ! !         G = inv((I+B_{il}...B_1*B_L...B_{il+1})), ! !    where B_{i} = V_{i}*B. Matrix V_{i} is diagonal, !    whose elements are stored in a vector V. !    It also returns the sign of det(G). ! ! Arguments ! ========= ! integer , intent ( in ) :: il ! starting slice type ( G_fun ), intent ( inout ) :: G type ( SeqB ), intent ( inout ) :: SB ! ... local scalars    ... logical :: match real ( wp ) :: diff , sgn ! ... Executable ... match = (( G % ilb . eq . G % L . and . il . eq . 1 ) . or . ( G % ilb . eq . il - 1 )) if ( match ) then ! Swap the slice of G_up PROF_BEGIN #if defined(DQMC_ASQRD) call cpp_gfun_swapg ( G % cpp_data , SB % B % B , SB % B % Bi , G % V (:, il ), G % G ) #else call DQMC_MultB_Left ( G % n , G % G , SB % B , G % V (:, il ), SB % W1 ) call DQMC_MultBi_Right ( G % n , G % G , SB % B , G % V (:, il ), SB % W1 ) #endif PROF_END ( GetG_count , GetG_time ) ! check if the swapping is safe G % wps = G % wps - 1 ! need to recompute if ( G % wps . eq . 0 ) then ! store current result ! G%tmp = G%G call blas_dcopy ( G % n * G % n , G % G , 1 , G % tmp , 1 ) ! recompute G PROF_BEGIN #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( G % cpp_data , il , sgn , G % G , G % V , SB % B % B , SB % nOrth , G % det ) #else call DQMC_ComputeG ( il , G % n , sgn , G % G , G % V , SB , G % pvt , . true ., G % det , G % sxx ) #endif PROF_END ( ComputeG_count , ComputeG_time ) ! evaluate the difference diff = DQMC_MatDiff ( G % n , G % tmp , G % G ) ! increase the statistics if ( diff . gt . G % difflim . or . abs ( sgn - G % sgn ) . gt . 1.0d-3 ) then G % redo = G % redo + 1 write ( * , '(3x,A, f12.6)' ) 'Error in updating the Green''s function :' , diff else G % noredo = G % noredo + 1 end if G % wps = G % nWrap G % sgn = sgn end if else ! cannot use swap, recompute PROF_BEGIN #if defined(DQMC_ASQRD) call cpp_gfun_computeg ( G % cpp_data , il , G % sgn , G % G , G % V , SB % B % B , SB % nOrth , G % det ) #else call DQMC_ComputeG ( il , G % n , G % sgn , G % G , G % V , SB , G % pvt , . true ., G % det , G % sxx ) #endif PROF_END ( ComputeG_count , ComputeG_time ) G % wps = G % nWrap end if G % ilb = il end subroutine DQMC_GetG !--------------------------------------------------------------------------! subroutine DQMC_GetG_2nd_order ( G , B ) ! ! Purpose ! ======= !    This subroutine computes the GF correct to dtau&#94;2. ! ! Argument ! ======== type ( G_fun ), intent ( inout ) :: G type ( matB ), intent ( in ) :: B integer :: n n = B % n G % GS = G % G ! ! Temporary fix for the inconsistency b/t equal-time ! and time-dependent tau=0 measurements. The inconsistency ! is caused by using 2nd and 1st order Trotter breakup ! when generating B matrices. ! !call DQMC_MultrtB0i_Right(n, G%GS, B, G%WS) !call DQMC_MultrtB0_Left(n, G%GS, B, G%WS) end subroutine !--------------------------------------------------------------------------! subroutine DQMC_ComputeG ( il , n , sgn , G , V , SB , pvt2 , compDet , det , sxx ) integer , intent ( in ) :: il ! starting slice integer , intent ( in ) :: n ! dim of G real ( wp ), intent ( inout ) :: sgn ! sign(det(G)) real ( wp ), intent ( in ) :: V (:,:) ! HSF real ( wp ), intent ( inout ) :: G (:,:) ! Green's function type ( SeqB ), intent ( inout ) :: SB integer , intent ( inout ) :: pvt2 (:) ! working space logical , intent ( in ) :: compDet real ( wp ), intent ( inout ) :: det ! det(G) logical , intent ( in ) :: sxx ! ... local scalars    ... integer :: info ! parameters for lapack's sub integer :: i , j ! iterator #   ifdef _SXX ! Error estimates real ( wp ) :: rcond real ( wp ) :: berr ( n ) ! Additional working space real ( wp ) :: work ( 4 * n ) integer :: iwork ( n ) !More parameters for dgesvxx integer , parameter :: nerr = 2 , maxerr = 3 real ( wp ) :: errn ( n , maxerr ), errc ( n , maxerr ) integer , parameter :: nparam = 0 , maxparam = 3 real ( wp ) :: param ( maxparam ) #   endif !Alias to SB's working space real ( wp ), pointer :: U (:,:) real ( wp ), pointer :: T (:,:) real ( wp ), pointer :: D (:) real ( wp ), pointer :: D2 (:) real ( wp ), pointer :: R (:) real ( wp ), pointer :: C (:) real ( wp ), pointer :: W1 (:,:) real ( wp ), pointer :: W2 (:,:) real ( wp ), pointer :: W3 (:,:) integer , pointer :: pvt1 (:) !real(wp) :: W3(n,n) ! ... Executable ... #ifdef DQMC_PROFILE call profile_enable () #endif U => SB % U D => SB % D T => SB % T W1 => SB % W1 W2 => SB % W2 pvt1 => SB % piv D2 => SB % tau W3 => SB % W3 C => SB % tau R => SB % rw ! ! STEP 0. Initialization ! ====================== !! Setup index for B_{i} sgn = ONE det = ZERO info = 0 ! ! STEP 1. Cmpute A = B_{il}...B_1*B_l...B_{il+1}. !         and its UDT decomposition, A = UDT ! ============================================= call DQMC_SeqMultB ( il , il + 1 , SB , V ) ! STEP 2. Compute C = inv(U)*inv(T) + D. ! ====================================== !! Compute the LU decomposition of T first. call lapack_dgetrf ( n , n , T , n , pvt1 , info ) if ( info . ne . 0 ) then T ( info , info ) = epsilon ( ONE ) call DQMC_Warning ( \"T is singular, dgetrf in dqmc_ComputeG.\" , info ) end if ! determine the sign of det(T) call DQMC_DetSgn ( n , T , pvt1 , sgn ) if ( compDet ) then call DQMC_DetLog ( n , T , det ) end if !! Solve T'W = U. W = transpose(inv(U)inv(T)) ! W1 = U call blas_dcopy ( n * n , U , 1 , W1 , 1 ) call lapack_dgetrs ( 'T' , n , n , T , n , pvt1 , W1 , n , info ) if ( info . ne . 0 ) then call DQMC_Error ( \"Error: dgetrs in dqmc_getgp.\" , info ) end if ! STEP 2.5 Here we need to decompose D = D2/D1=D1\\D2. !       if   abs(D(i,i))>1, !            D1(i,i) = 1/abs(D(i,i)) !            D2(i,i) = sign(D(i,i)) !       else !            D1(i,i) = 1 !            D2(i,i) = D(i,i) ! ====================================== !! Compute W*D1+D2 !!   = transpose(inv(U)inv(T))*D1+D2 !!   = transpose(D1*inv(U)inv(T) + D2) do i = 1 , n if ( abs ( D ( i )) . gt . ONE ) then if ( D ( i ) . gt . ZERO ) then D2 ( i ) = ONE else D2 ( i ) = - ONE end if D ( i ) = ONE / abs ( D ( i )) else D2 ( i ) = D ( i ) D ( i ) = ONE end if ! W' = W'*D1 do j = 1 , n W1 ( j , i ) = W1 ( j , i ) * D ( i ) end do ! W' = W' + D2 = W'*D1+D2 W1 ( i , i ) = W1 ( i , i ) + D2 ( i ) end do ! ! STEP 3. Compute G = inv(T)*D1*inv(C)*inv(U) ! =========================================== if ( sxx ) call blas_dcopy ( n * n , W1 , 1 , W3 , 1 ) !! Compute the LU decomposition of W1. call lapack_dgetrf ( n , n , W1 , n , pvt2 , info ) if ( info . ne . 0 ) then call DQMC_Warning ( \"matrix D+inv(U)inv(T) is singular. & & dgetrf(2) in dqmc_computeG.\" , info ) W1 ( info , info ) = epsilon ( ONE ) end if ! determine the sign of det(W) call DQMC_DetSgn ( n , W1 , pvt2 , sgn ) if ( compDet ) then call DQMC_DetLog ( n , W1 , det ) end if !! G = inv(U), which is transpose of U. call DQMC_Trans ( n , G , U ) !! G = D1*G = D1*inv(U) call DQMC_ScaleRow ( n , G , D ) call blas_dcopy ( n * n , G , 1 , U , 1 ) !! Solve W'G = inv(U), G = inv(W')*G call lapack_dgetrs ( 'T' , n , n , W1 , n , pvt2 , G , n , info ) if ( info . ne . 0 ) then call DQMC_Error ( \"Error: dgetrs(2) in dqmc_getgp.\" , info ) end if !Refine the solution if ( sxx ) then #      ifdef _SXX call lapack_dgerfsx ( 'T' , 'N' , n , n , W3 , n , W1 , N , pvt2 , R , C , & & U , n , G , n , rcond , berr , nerr , errn , errc , & & nparam , param , work , iwork , info ) #      endif endif !! Solve TG = inv(W')*inv(U), G = inv(T)inv(W')*D1*inv(U) call lapack_dgetrs ( 'N' , n , n , T , n , pvt1 , G , n , info ) if ( info . ne . 0 ) then call DQMC_Error ( \"Error: dgetrs(3) in dqmc_getgp.\" , info ) end if ! ! STEP 4. Compute the sign of det(G) ! ================================== !! Compute the LU decomposition of U first. call lapack_dgetrf ( n , n , U , n , pvt2 , info ) if ( info . ne . 0 ) then call DQMC_Error ( \"Error: dgetrf(4) in dqmc_getgp.\" , info ) end if call DQMC_DetSgn ( n , U , pvt2 , sgn ) ! det = det(D1)/(det(W)*det(T)) if ( compDet ) then det = - det do i = 1 , n det = det + log ( abs ( D ( i ))) end do end if #ifdef DQMC_PROFILE call profile_disable () #endif contains !--------------------------------------------------------! subroutine DQMC_DetSgn ( n , A , pvt , sgn ) ! ! Purpose ! ======= !    This subroutine computes sign(DET(A)) !    where A is the content after dgetrf; !    pvt is the vipoting vector. ! ! Pre-assumption ! ============== !    A contains the content of dgetrf ! ! Argument ! ======== integer , intent ( in ) :: n real ( wp ), intent ( in ) :: A ( n , n ) integer , intent ( in ) :: pvt ( n ) real ( wp ), intent ( inout ) :: sgn ! ... local scalar integer :: i !! decide the sgn of det(Q) do i = 1 , n if ( pvt ( i ). ne . i ) then sgn = - sgn end if !! ?? stable ?? if ( A ( i , i ) . lt . ZERO ) then sgn = - sgn end if end do end subroutine DQMC_DetSgn !--------------------------------------------------------! subroutine DQMC_DetLog ( n , A , det ) ! ! Purpose ! ======= !    This subroutine computes log(abs(DET(A))) !    where A is the content after dgetrf; !    pvt is the vipoting vector. ! ! Pre-assumption ! ============== !    A contains the content of dgetrf ! ! Argument ! ======== integer , intent ( in ) :: n real ( wp ), intent ( in ) :: A ( n , n ) real ( wp ), intent ( inout ) :: det ! ... local scalar integer :: i !! decide the sgn of det(Q) do i = 1 , n det = det + log ( abs ( A ( i , i ))) end do end subroutine DQMC_DetLog end subroutine DQMC_ComputeG !-----------------------------------------------------------------------! subroutine DQMC_UpdateWraps ( G ) use dqmc_mpi ! ! Purpose ! ======= !    This subroutine updates G%nWraps depends on previous !    execution results ! ! Arguments ! ========= ! type ( G_fun ), intent ( inout ) :: G ! ... paremeters ... integer , parameter :: DQMC_REDO_F = 10 integer , parameter :: DQMC_NOREDO_F = 100 real ( wp ), parameter :: DQMC_REDO_RATE = 0.20_wp ! ... local scalar ... real ( wp ) :: redorat integer :: redo , noredo #   ifdef _QMC_MPI integer :: send_cnt ( 2 ), recv_cnt ( 2 ), err #   endif if ( G % fixwrap . le . 0 ) then #      ifdef _QMC_MPI send_cnt ( 1 ) = G % redo send_cnt ( 2 ) = G % noredo call mpi_allreduce ( send_cnt , recv_cnt , 2 , MPI_INT , MPI_SUM , MPI_COMM_WORLD , err ) redo = recv_cnt ( 1 ) noredo = recv_cnt ( 2 ) #      else redo = G % redo noredo = G % noredo #      endif redorat = dble ( redo ) / dble ( redo + noredo ) !write(*,'(3x,A,i4,A,i6)') 'Total number of errors : ', redo,' out of ', noredo+redo ! ... Executable ... if ( redo . gt . DQMC_REDO_F ) then if ( redorat . gt . G % errrate ) then !write(*,'(3x,A)')'Lowering nwrap and resetting counter' G % nwrap = G % nwrap - 1 G % maxwrap = G % nwrap G % redo = 0 G % noredo = 1 !write(*,'(3x,A,i4)')'New nwrap :', G%nwrap endif endif if ( NoRedo . gt . DQMC_NOREDO_F ) then if ( redorat . lt . DQMC_REDO_RATE * G % errrate ) then if ( G % nwrap . ge . G % lastwr ) then if ( G % nwrap < G % maxwrap ) then !write(*,'(3x,A)')'Raising nwrap and resetting counter' G % nwrap = G % nwrap + 1 G % redo = 0 G % noredo = 1 G % lastwr = G % nwrap !write(*,'(3x,A,i4)')'New nwrap :', G%nwrap endif end if endif endif endif end subroutine DQMC_UpdateWraps !-----------------------------------------------------------------------! subroutine DQMC_SyncWraps ( G1 , G2 ) ! ! Purpose ! ======= !    This subroutine syncronize the value of nwrap !    after this was updated for one of the G's ! ! Arguments ! ========= ! type ( G_fun ), intent ( inout ) :: G1 , G2 if ( G1 % redo == 0 . and . G1 % noredo == 1 ) then G2 % redo = 0 G2 % noredo = 1 G2 % nwrap = G1 % nwrap G2 % maxwrap = G1 % maxwrap G2 % lastwr = G1 % lastwr elseif ( G2 % redo == 0 . and . G2 % noredo == 1 ) then G1 % redo = 0 G1 % noredo = 1 G1 % nwrap = G2 % nwrap G1 % maxwrap = G2 % maxwrap G1 % lastwr = G2 % lastwr end if end subroutine DQMC_SyncWraps !-----------------------------------------------------------------------! ! The following three subroutines are used for delayed update.          ! !-----------------------------------------------------------------------! function DQMC_Gfun_Getjj ( n , j , blksz , G , U , W ) result ( gjj ) ! ! Purpose ! ======= !    This function returns the (j,j)th element of G to gjj, !    in which ! !       G = G_1 + UV' ! !    where U,V are n*BlkSz. ! !    Therefore, ! !       gjj = G_1(j,j)+U(j,:)*V(j,:)' ! ! Arguments ! ========= ! real ( wp ) :: gjj integer , intent ( in ) :: n , j , blksz real ( wp ), intent ( in ) :: G ( n , n ) real ( wp ), intent ( in ) :: U ( n , n ) real ( wp ), intent ( in ) :: W ( n , n ) ! ... BLAS function ... real ( wp ), external :: blas_ddot ! ... Executable ... PROF_BEGIN gjj = G ( j , j ) if ( blkSz . gt . 0 ) then gjj = gjj + blas_ddot ( blkSz , U ( j , 1 ), n , W ( j , 1 ), n ) end if PROF_END ( Getjj_count , Getjj_time ) end function DQMC_Gfun_Getjj !--------------------------------------------------------------------------! subroutine DQMC_UpdateG ( j , gamma , G ) ! ! Purpose ! ======= !    This subroutine updates U, V, and D, which accumulate !    rank-1 updates of G. ! !    Matrix G has the form ! !       G_k = G_1 + UV' ! !    where U,V are n*BlkSz. ! !    The new matrix is ! !       G_{k+1} = G_{k} + gamma*xy' ! !    where ! !       x = G_1(:,j) + UV'(:,j) !       y' = G_1(j,:) - e_j' + U(j,:)V' ! !    The update of U, V, and D is as follows. ! !       U = [U x], V = [V gamma*y] ! !    If blkSz==nBlk, then apply the update ! Arguments ! ========= ! integer , intent ( in ) :: j real ( wp ), intent ( in ) :: gamma type ( g_fun ), intent ( inout ), target :: G ! ... local variables ... real ( wp ), pointer :: x (:) real ( wp ), pointer :: y (:) real ( wp ) :: xx ( G % n ) integer :: n , blksz ! ... Executable ... PROF_BEGIN n = G % n blksz = G % blkSz x => G % U ( 1 : n , blkSz + 1 ) y => G % W ( 1 : n , blkSz + 1 ) x = G % G ( 1 : n , j ) y = G % G ( j , 1 : n ) y ( j ) = y ( j ) - ONE if ( blkSz . gt . 0 ) then ! if U, V are not empty, add their effects xx = G % W ( j , 1 : n ) call blas_dgemv ( 'N' , n , blkSz , ONE , G % U , n , xx , 1 , ONE , x , 1 ) xx = G % U ( j , 1 : n ) call blas_dgemv ( 'N' , n , blkSz , ONE , G % W , n , xx , 1 , ONE , y , 1 ) end if call blas_dscal ( n , gamma , y , 1 ) G % blkSz = G % blkSz + 1 ! apply the update when necessary PROF_END ( UpdateG_count , UpdateG_time ) call DQMC_ApplyUpdate ( G , . false .) !call DQMC_ApplyUpdate(G, .true.) end subroutine DQMC_UpdateG !--------------------------------------------------------------------------! subroutine DQMC_ApplyUpdate ( G , forced ) ! ! Purpose ! ======= !    This subroutine updates G with U, V, and D. !    Matrix G has the form ! !       G_k = G_1 + UV' ! !    where U,V are n*BlkSz. ! ! Arguments ! ========= ! type ( g_fun ), intent ( inout ) :: G logical , intent ( in ) :: forced ! ... local variables ... integer :: n ! ... Executable ... if ( forced . or . G % blkSz . eq . G % nBlk ) then PROF_BEGIN n = G % n ! apply the update when necessary call blas_dgemm ( 'N' , 'T' , n , n , G % blkSz , ONE , G % U , n , G % W , n , ONE , G % G , n ) ! reset the block size G % blkSz = 0 PROF_END ( ApplyUpdate_count , ApplyUpdate_time ) end if end subroutine DQMC_ApplyUpdate !--------------------------------------------------------------------------! end module DQMC_GFun","tags":"","loc":"sourcefile/dqmc_gfun.f90.html"},{"title":"dqmc_phy2.F90 – Quest","text":"This file depends on sourcefile~~dqmc_phy2.f90~~EfferentGraph sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_phy2.f90~~AfferentGraph sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_Phy2 #include \"dqmc_include.h\" use DQMC_UTIL use DQMC_STRUCT use DQMC_WSPACE use DQMC_BONDS use DQMC_SYMM implicit none ! ! This module contains data structure and subroutines for ! pair measurement. ! ! List of subroutines ! =================== !    1. DQMC_Phy2_Init(P2, nBin, nb) !    2. DQMC_Phy2_Avg(P2, W, T, ldt) !    3. DQMC_Phy2_Print(P2, OPT) !    4. DQMC_Phy2_GetErr(P2) !    5. DQMC_Phy2_Meas(n, P2, G_up, G_dn, sgn, S) ! ! Data Structure and Parameters ! ============================= !    The data type Phy2 performs pair measurement. For each paired sites, !    it computes the convolution of their correlation and their neighbors' !    correlation. (CHECK) The results are accumulated into bins and then !    transformed by the 'wave' function. ! type Phy2 ! Measurement of pair integer :: nb ! Number of bonds integer :: nWave ! Number of wave functions integer :: nBin ! Number of bins integer :: idx ! current bin index integer :: cnt ! Number of measurement for integer :: ncell ! current bin integer :: avg , err ! Index for average and error ! bins. real ( wp ), pointer :: sgn (:) ! sign real ( wp ), pointer :: M1 (:,:) ! pair measurement real ( wp ), pointer :: M2 (:,:) ! accumulated pair measurement real ( wp ), pointer :: M3 (:,:) ! averaged pair measurement real ( wp ), pointer :: M4 (:,:) ! averaged pair measurement when waves are not specified real ( wp ), pointer :: M5 (:,:) ! averaged pair measurement connected ! working space real ( wp ), pointer :: T (:,:) integer :: ldt integer :: nData logical :: compute logical :: connected logical :: diagonalize = . false . end type Phy2 interface DQMC_Phy2_avg module procedure DQMC_Phy2_Avg_Wave , DQMC_Phy2_Avg_Symm end interface interface DQMC_Phy2_GetIrrep module procedure DQMC_Phy2_GetIrrep_Connected , DQMC_Phy2_GetIrrep_Full end interface contains ! Subroutines ! ================================================================== subroutine DQMC_Phy2_Init ( P2 , nBin , S , WS , meas ) ! ! Purpose ! ======= !    This subroutine initializes Phy2. ! ! Arguments ! ========= ! type ( Phy2 ), intent ( inout ) :: P2 ! Phy2 to be initialized integer , intent ( in ) :: nBin ! No of bin type ( Struct ), intent ( in ) :: S type ( Wspace ), intent ( in ), target :: WS ! working space logical , intent ( out ) :: meas ! ... Local Vars ... integer :: nb , nWave real ( wp ), pointer :: dum (:,:) ! ... Executable ... P2 % compute = S % checklist ( STRUCT_BOND ) meas = P2 % compute if ( P2 % compute ) then nWave = S % nWave nb = S % n_b P2 % nBin = nBin P2 % nb = nb P2 % nwave = nWave P2 % ncell = S % ncell ! Allocate storages !! Allocate two additional bins for storing !! average value and error allocate ( P2 % M1 ( nb , nb )) allocate ( P2 % M2 ( nb , nb )) allocate ( P2 % sgn ( nBin + 2 )) if ( S % checklist ( STRUCT_WAVE )) then allocate ( P2 % M3 ( nWave , nBin + 2 )) nullify ( P2 % M4 , P2 % M5 ) else allocate ( P2 % M3 ( S % nClass_b , nBin + 2 )) allocate ( P2 % M4 ( nWave , nbin + 2 )) allocate ( P2 % M5 ( nWave , nbin + 2 )) P2 % diagonalize = . true . endif ! Initialize P2 % M2 = ZERO P2 % sgn = ZERO P2 % avg = nBin + 1 P2 % err = nBin + 2 P2 % cnt = 0 P2 % idx = 1 dum => WS % R4 !P2%ldt     = size(WS%R4, 1) allocate ( P2 % T ( nb , nWave )) P2 % ldt = nb P2 % nData = nWave + 1 else P2 % nData = 0 end if end subroutine DQMC_Phy2_Init !--------------------------------------------------------------------! subroutine DQMC_Phy2_Free ( P2 ) ! ! Purpose ! ======= !    This subroutine frees Phy2. ! ! Arguments ! ========= ! type ( Phy2 ), intent ( inout ) :: P2 ! Phy0 to be initialized ! ... Executable ... if ( P2 % compute ) then deallocate ( P2 % sgn , P2 % M1 , P2 % M2 , P2 % M3 , P2 % T ) if ( associated ( P2 % M4 )) deallocate ( P2 % M4 ) if ( associated ( P2 % M5 )) deallocate ( P2 % M5 ) end if end subroutine DQMC_Phy2_Free !--------------------------------------------------------------------! subroutine DQMC_Phy2_Meas ( n , M1 , M2 , P2 , Bond , G_up , G_dn , sgn ) ! ! Purpose ! ======= !    This subroutine performs physics measurement on !    the neighbors of pairs of sites ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! Number of sites real ( wp ), intent ( inout ) :: M1 (:, :) ! temp variables real ( wp ), intent ( inout ) :: M2 (:, :) ! type ( Phy2 ), intent ( inout ) :: P2 ! Phy2 type ( CCS ), intent ( in ) :: Bond real ( wp ), intent ( in ) :: G_up ( n , n ) ! Green's function real ( wp ), intent ( in ) :: G_dn ( n , n ) ! for spin up and down real ( wp ), intent ( in ) :: sgn ! Sgnup*sgndn ! ... local scalar ... integer :: nb real ( wp ) :: factor if ( P2 % compute ) then ! Compute the pair measurement call DQMC_Phy2_Pair ( n , M1 , G_up , G_dn , Bond ) ! Averaging and accumulation factor = sgn / P2 % ncell nb = P2 % nb call blas_daxpy ( nb * nb , factor , M1 , 1 , M2 , 1 ) P2 % sgn ( P2 % idx ) = P2 % sgn ( P2 % idx ) + sgn !write(*,*) 'Phy2_Meas',P2%ncell ! increase counter p2 % cnt = P2 % cnt + 1 end if end subroutine DQMC_Phy2_Meas !--------------------------------------------------------------------! subroutine DQMC_Phy2_Pair ( n , M , up , dn , Bond ) ! ! Purpose ! ======= !    This subroutine computes pair measurements. !    For each pair (i,j), compute the effect of !    all their neighbor pairs. ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! Number of sites real ( wp ), intent ( inout ) :: M (:, :) ! pair measurement ! (P_dd') real ( wp ), intent ( in ) :: up (:,:) ! Green's function real ( wp ), intent ( in ) :: dn (:,:) ! for spin up and down type ( CCS ), intent ( in ) :: Bond ! bond info ! ... local variables ... integer :: i , j , inbr , jnbr , ni , nj , nci , ncj integer , pointer :: start (:) integer , pointer :: r (:) integer , pointer :: A (:) ! ... Executable ... ! alias start => Bond % cstart r => Bond % row A => Bond % A ! clean up M = ZERO do i = 1 , n do inbr = start ( i ), start ( i + 1 ) - 1 ni = r ( inbr ) ! bond of site i nci = A ( inbr ) ! bond class of (i,ri) do j = 1 , n do jnbr = start ( j ), start ( j + 1 ) - 1 nj = r ( jnbr ) ! bond of site j ncj = A ( jnbr ) ! bond class of (j,rj) M ( ncj , nci ) = M ( ncj , nci ) + up ( nj , ni ) * dn ( j , i ) end do end do end do end do end subroutine DQMC_Phy2_Pair !--------------------------------------------------------------------! subroutine DQMC_Phy2_Avg_Wave ( P2 , W ) ! ! Purpose ! ======= !    This subroutine averges the pair measurements. !    which is stored in P2%M2. ! ! Arguments ! ========= ! type ( Phy2 ), intent ( inout ) :: P2 ! phy2 real ( wp ), intent ( in ) :: W ( P2 % nb , P2 % nwave ) ! wave ! ... local scalar ... real ( wp ) :: factor ! ... Executable ... if ( P2 % compute ) then factor = ONE / P2 % cnt ! CC !write(*,*) 'Avg_Wave', P2%M2(:,:) call DQMC_Wave_Avg ( P2 % nb , P2 % nWave , W , P2 % T , P2 % M2 , & P2 % M3 ( 1 : P2 % nWave , P2 % idx ), factor , P2 % ldt ) P2 % sgn ( P2 % idx ) = P2 % sgn ( P2 % idx ) * factor ! Reset counter and change bins P2 % idx = P2 % idx + 1 P2 % cnt = 0 P2 % M2 = ZERO end if end subroutine DQMC_Phy2_Avg_Wave !--------------------------------------------------------------------! subroutine DQMC_Phy2_Avg_Symm ( P2 , S ) ! ! Purpose ! ======= !    This subroutine averges the pair measurements. !    which is stored in P2%M2. ! ! Arguments ! ========= ! type ( Phy2 ), intent ( inout ) :: P2 ! phy2 type ( struct ), intent ( in ) :: S ! ... local scalar ... real ( wp ) :: factor ! ... Executable ... if ( P2 % compute ) then factor = ONE / P2 % cnt call DQMC_Pair_Symm ( P2 % M2 , P2 % M3 ( 1 : S % nclass_b , P2 % idx ), & S % class_b , S % size_b , S % n_b , S % nclass_b , factor ) P2 % sgn ( P2 % idx ) = P2 % sgn ( P2 % idx ) * factor ! Reset counter and change bins P2 % idx = P2 % idx + 1 P2 % cnt = 0 P2 % M2 = ZERO end if end subroutine DQMC_Phy2_Avg_Symm !--------------------------------------------------------------------! subroutine DQMC_Wave_Avg ( nb , nWave , W , T , I , O , factor , ldt ) ! ! Purpose ! ======= !    This subroutine computes the waves from input data. ! !    The averaging process runs as follows. !    1. Let T = I*W !    2. Compute O(i) = W(:,i)'*T(:,i) !    3. Averaging O  = O*factor ! ! Arguments ! ========= ! integer , intent ( in ) :: nB ! number of bonds integer , intent ( in ) :: nWave ! number of waves real ( wp ), intent ( in ) :: W ( nb , nWave ) ! wave matrix real ( wp ), intent ( in ) :: T ( ldt , nWave ) ! temp matrix real ( wp ), intent ( in ) :: I ( nb , nb ) ! input matrix real ( wp ), intent ( inout ) :: O (:) ! output matrix real ( wp ), intent ( in ) :: factor integer , intent ( in ) :: ldt ! ... Local Variables ... integer :: j ! ... BLAS function ... real ( wp ), external :: blas_ddot ! ... Executable .... call blas_dgemm ( 'N' , 'N' , nb , nWave , nb , factor , I , nb , W , nb , & ZERO , T , ldt ) do j = 1 , nWave O ( j ) = blas_ddot ( nb , W ( 1 : nb , j ), 1 , T ( 1 : nb , j ), 1 ) end do end subroutine DQMC_Wave_Avg !--------------------------------------------------------------------! subroutine DQMC_Pair_Symm ( M2 , M3 , class_b , size_b , n , nclass , factor ) ! ! Purpose ! ======= !    This subroutine symmetrizes the pairing matrix. ! ! Arguments ! ========= ! integer , intent ( in ) :: n , nclass integer , intent ( in ) :: size_b ( nclass ) integer , intent ( in ) :: class_b ( n , n ) real ( wp ), intent ( in ) :: M2 ( n , n ) real ( wp ), intent ( in ) :: factor real ( wp ), intent ( out ) :: M3 ( nclass ) ! ... Local Variables ... integer :: i , j , ij ! ... Executable ... !Symmetrize M3 = 0.d0 do i = 1 , n do j = 1 , n ij = class_b ( i , j ) M3 ( ij ) = M3 ( ij ) + M2 ( i , j ) enddo enddo !Normalize M3 = factor * M3 / size_b end subroutine !--------------------------------------------------------------------! subroutine DQMC_Phy2_GetErr ( P2 ) use dqmc_mpi ! ! Purpose ! ======= !    This subroutine computes the average and errors !    of measurements. After this routine is called !    bins are modified to contain data from the !    jack-knived distribution. ! ! Argument ! ======== type ( Phy2 ), intent ( inout ) :: P2 ! ... Local Scalar ... integer :: i integer :: n , avg , err , m integer :: nproc ! ... Local Array real ( wp ) :: sgn ( P2 % nBin ) , sum_sgn , y ( P2 % nBin ), data ( P2 % nBin ) ! ... Executable ... if ( P2 % compute ) then n = P2 % nBin avg = P2 % avg err = P2 % err m = size ( P2 % M3 , 1 ) nproc = qmc_sim % size if ( nproc == 1 ) then ! Averge the other terms data = P2 % sgn ( 1 : n ) call DQMC_JackKnife ( n , P2 % sgn ( avg ), P2 % sgn ( err ), data , y , sgn , sum_sgn ) do i = 1 , m data = P2 % M3 ( i , 1 : n ) call DQMC_SignJackKnife ( n , P2 % M3 ( i , avg ), P2 % M3 ( i , err ), & data , y , sgn , sum_sgn ) end do !Store Jackknife in bins P2 % sgn ( 1 : n ) = sgn ( 1 : n ) / dble ( n - 1 ) do i = 1 , m P2 % M3 ( i , 1 : n ) = ( sum_sgn * P2 % M3 ( i , avg ) - P2 % M3 ( i , 1 : n )) / dble ( n - 1 ) enddo else #         ifdef _QMC_MPI !Sum sign call mpi_allreduce ( P2 % sgn ( 1 ), P2 % sgn ( avg ), 1 , mpi_double , & mpi_sum , mpi_comm_world , n ) !Sum properties call mpi_allreduce ( P2 % M3 (:, 1 ), P2 % M3 (:, avg ), m , mpi_double , & mpi_sum , mpi_comm_world , n ) !Compute averages over n-1 processors P2 % M3 (:, 1 ) = ( P2 % M3 (:, avg ) - P2 % M3 (:, 1 )) / dble ( nproc - 1 ) P2 % sgn ( 1 ) = ( P2 % sgn ( avg ) - P2 % sgn ( 1 )) / dble ( nproc - 1 ) !Store physical average amongst all processors P2 % M3 (:, avg ) = P2 % M3 (:, avg ) / P2 % sgn ( avg ) !Store jackknife in the processor bin P2 % M3 (:, 1 ) = P2 % M3 (:, 1 ) / P2 % sgn ( 1 ) !Compute error call mpi_allreduce ( P2 % M3 (:, 1 ) ** 2 , P2 % M3 (:, err ), m , mpi_double , & mpi_sum , mpi_comm_world , n ) P2 % M3 (:, err ) = P2 % M3 (:, err ) / dble ( nproc ) - P2 % M3 (:, avg ) ** 2 P2 % M3 (:, err ) = sqrt ( P2 % M3 (:, err ) * dble ( nproc - 1 )) #         endif endif end if end subroutine DQMC_Phy2_GetErr !--------------------------------------------------------------------! subroutine DQMC_Phy2_GetIrrep_Full ( P2 , S ) ! !  Interfaced by DQMC_Phy2_GetIrrep ! type ( Phy2 ), intent ( inout ) :: P2 type ( Struct ), intent ( inout ) :: S ! ... Local variables ... integer :: i , j , ij , nb real ( wp ) :: work ( 3 * P2 % nb ), tmp ( P2 % nWave ) ! ... Executable ... nb = P2 % nb !make sure S%W is allocated if ( associated ( S % W )) deallocate ( S % W ) allocate ( S % W ( nb , nb )) !Load Full pairing matrix do i = 1 , nb do j = 1 , nb ij = S % class_b ( i , j ) S % W ( i , j ) = P2 % M3 ( ij , P2 % avg ) enddo enddo !Compute waves as those diagonalizing the pairing matrix call lapack_dsyev ( 'V' , 'U' , nb , S % W , nb , tmp , work , 3 * nb , i ) P2 % connected = . false . end subroutine DQMC_Phy2_GetIrrep_Full !--------------------------------------------------------------------! subroutine DQMC_Phy2_GetIrrep_Connected ( P2 , G_fun , S ) ! !  Interfaced by DQMC_Phy2_GetIrrep ! type ( phy2 ), intent ( inout ) :: P2 type ( Struct ), intent ( inout ) :: S real ( wp ), intent ( in ) :: G_fun ( S % nclass ) integer :: i , j , ij , n , nb real ( wp ) :: up ( S % nSite , S % nSite ), dn ( S % nSite , S % nSite ) real ( wp ) :: work ( 3 * P2 % nb ) real ( wp ) :: tmp ( P2 % nWave ) ! ... Executable ... n = S % nSite nb = P2 % nb !Load disconnected pairing matrix in M1. do i = 1 , n do j = 1 , n up ( i , j ) = S % gf_phase ( i , j ) * G_fun ( S % D ( i , j )) enddo enddo dn = up call DQMC_Phy2_Pair ( n , P2 % M1 , up , dn , S % B ) !make sure S%W is allocated properly if ( associated ( S % W )) deallocate ( S % W ) allocate ( S % W ( nb , nb )) !Expand pairing matrix to all bond pairs do i = 1 , nb do j = 1 , nb ij = S % class_b ( i , j ) S % W ( i , j ) = P2 % M3 ( ij , P2 % avg ) enddo enddo !Compute connected Pairing function S % W = S % W - P2 % M1 !Compute waves as those diagonalizing the pairing matrix call lapack_dsyev ( 'V' , 'U' , nb , S % W , nb , tmp , work , 3 * n , i ) P2 % connected = . true . end subroutine DQMC_Phy2_GetIrrep_Connected !--------------------------------------------------------------------! subroutine DQMC_Phy2_GetErrIrrep ( P2 , G_fun , S ) use dqmc_mpi type ( struct ), intent ( in ) :: S type ( phy2 ), intent ( inout ) :: P2 real ( wp ), intent ( in ) :: G_fun ( S % nClass , P2 % err ) ! ... Local Variables ... integer :: avg , err , nbin , ibin , i , j , k , n , nproc real ( wp ) :: factor , up ( S % nSite , S % nSite ), dn ( S % nSite , S % nSite ) real ( wp ), pointer :: MX (:,:) ! ... Executable ... nBin = P2 % nBin avg = P2 % avg err = P2 % err nproc = qmc_sim % size factor = 1.d0 p2 % M4 (:, err ) = 0.d0 p2 % M5 (:, err ) = 0.d0 n = S % nSite !Fill bins with wave amplitudes using S%W from diagonalization do ibin = 1 , avg !Create JK bin for Full pairing matrix (M2) do i = 1 , P2 % nb do j = 1 , P2 % nb k = S % class_b ( i , j ) P2 % M2 ( i , j ) = P2 % M3 ( k , ibin ) enddo enddo !Compute waves amplitute for bin \"ibin\". Full pairing function. call DQMC_Wave_Avg ( P2 % nb , P2 % nWave , S % W , P2 % T , P2 % M2 , P2 % M4 ( 1 : P2 % nWave , ibin ), factor , P2 % ldt ) !create JK bin for G do i = 1 , n do j = 1 , n k = S % D ( i , j ) up ( i , j ) = S % gf_phase ( i , j ) * G_fun ( k , ibin ) enddo enddo dn = up !Construct JK bin for G*G call DQMC_Phy2_Pair ( n , P2 % M1 , up , dn , S % B ) P2 % M1 = P2 % M1 / n !Construct connected function P2 % M1 = P2 % M2 - P2 % M1 !Compute waves amplitute for bin \"ibin\": Connected pairing function. call DQMC_Wave_Avg ( P2 % nb , P2 % nWave , S % W , P2 % T , P2 % M1 , P2 % M5 ( 1 : P2 % nWave , ibin ), factor , P2 % ldt ) enddo if ( nproc > 1 ) then MX => P2 % M4 do i = 1 , 2 j = size ( MX , 1 ) !Compute errorbars averaging over processors. #            ifdef _QMC_MPI call mpi_allreduce ( MX (:, 1 ) ** 2 , MX (:, err ), j , mpi_double , & mpi_sum , mpi_comm_world , k ) #            endif MX (:, err ) = MX (:, err ) / dble ( nproc ) - MX (:, avg ) ** 2 MX (:, err ) = sqrt ( MX (:, err ) * dble ( nproc - 1 )) MX => P2 % M5 enddo else !Compute errors do i = 1 , P2 % nWave !Full Pairing matrix P2 % M4 ( i , err ) = sqrt (( nBin - 1 ) * sum (( P2 % M4 ( i , 1 : nBin ) - P2 % M4 ( i , avg )) ** 2 ) / nBin ) !Connected Pairing matrix P2 % M5 ( i , err ) = sqrt (( nBin - 1 ) * sum (( P2 % M5 ( i , 1 : nBin ) - P2 % M5 ( i , avg )) ** 2 ) / nBin ) enddo endif end subroutine DQMC_Phy2_GetErrIrrep !--------------------------------------------------------------------! subroutine DQMC_Phy2_Print ( P2 , wlabel , OPT ) use dqmc_mpi ! ! Purpose ! ======= !    This subroutine prints out the average and errors !    of pair measurements. The first three terms only. ! !  Pre-assumption ! =============== !    OPT is a file handle !    DQMC_Phy2_GetErr was called. !    nWave >= 3 ! ! Arguments ! ========= ! type ( Phy2 ), intent ( in ) :: P2 ! Phy2 character ( * ), intent ( in ) :: wlabel (:) integer , intent ( in ) :: OPT ! Output file handle ! ... Local var integer :: avg , err ! ... Executable ... if ( qmc_sim % rank . ne . 0 ) return if ( P2 % compute ) then avg = P2 % avg err = P2 % err call DQMC_Print_RealArray ( 0 , P2 % nWave , \"Pair-field correlation function - accumulated:\" , & wlabel , P2 % M3 (:, avg : avg ), P2 % M3 (:, err : err ), OPT ) end if end subroutine DQMC_Phy2_Print !--------------------------------------------------------------------! subroutine DQMC_phy2_WaveSymm ( S , P2 , Symm ) ! INPUT ! W(nb,ns)     :  wave matrix to be analyzed ! nw           :  number of wave (number of rows of W) ! nb           :  number of bonds (number of column of W) ! wa(nw)       :  wave amplitude (expectation value out of QMC) ! maps(nb,ns)  :  returns how bonds are mapped under symm operations ! ns           :  number of symmetry operations ! OUTPUT ! wrepr(nw)  : irreducible representation of the wave ! wclass(nw) : group of the wave (a group is defined as the set of waves !              belonging to equivalent irreps) ! wlabel     : label of the wave (contains character of representation) ! nirrep     : number of irreducible representations ! nwclass    : number of inequivalent irreducible representations type ( struct ), intent ( inout ) :: S type ( phy2 ), intent ( inout ) :: P2 type ( Symm_operations ), intent ( in ) :: Symm real ( wp ), pointer :: W (:,:) real ( wp ), pointer :: wa (:) integer , pointer :: maps (:,:) integer :: iw , ir , jr , is , ib , jw , nirrep , nw , nb , ns integer :: reprlabel ( S % nwave ), rdim ( S % nwave ) real ( wp ) :: newWave ( S % n_b ), WaveSymm ( S % nwave , S % nwave , Symm % nsymm ), irrepChar ( S % nwave , Symm % nsymm ) logical :: irrep ( S % nwave ) W => S % W maps => Symm % map_symm_p if ( P2 % connected ) then wa => P2 % M5 (:, P2 % avg ) else wa => P2 % M4 (:, P2 % avg ) endif nw = S % nwave nb = S % n_b ns = Symm % nsymm if (. not . associated ( S % wrepr )) allocate ( S % wrepr ( nw )) S % wrepr = 0 nirrep = 0 rdim = 0 !Check degeneracy of eigenvalues to find the dimension of the representation do iw = 1 , nw if ( S % wrepr ( iw ) == 0 ) then nirrep = nirrep + 1 S % wrepr ( iw ) = nirrep rdim ( nirrep ) = 1 do jw = iw + 1 , nw if ( S % wrepr ( jw ) == 0. and . abs ( wa ( iw ) - wa ( jw )) < 1.d-6 ) then S % wrepr ( jw ) = nirrep rdim ( nirrep ) = rdim ( nirrep ) + 1 endif enddo endif enddo !Look at how waves transform under the action of symmetry WaveSymm = 0.d0 do is = 1 , ns do iw = 1 , nw !Apply symmetry \"is\" to wave \"iw\" do ib = 1 , nb newWave ( ib ) = W ( maps ( ib , is ), iw ) enddo !Dot-product between all waves (jw) and wave \"iw\" after transformation by \"is\" !WaveSymm(iw,jw,is)=0 means \"iw\", transformed by \"is\", has no component on \"jw\" do jw = 1 , nw WaveSymm ( iw , jw , is ) = sum ( W (:, jw ) * newWave (:)) enddo enddo enddo !Check whether dimension of representation is compatible with non-zero !elements in WaveSymm irrep = . true . do ir = 1 , nirrep do is = 1 , ns !Compare all pairs of waves that do not belong to the same irrep. !If WaveSymm is larger than 0 for any symmetry then what we found was not !an irrep. Accidental degeneracy. do jw = 1 , nw if ( S % wrepr ( jw ) == ir ) then do iw = 1 , nw if ( S % wrepr ( jw ) /= ir . and . abs ( WaveSymm ( jw , iw , is )) > 1.d-10 ) irrep ( ir ) = . false . enddo endif enddo enddo enddo !Compute character of each irreducible representation irrepChar = 0.d0 do ir = 1 , nirrep if ( irrep ( ir )) then do is = 1 , ns do iw = 1 , nw if ( S % wrepr ( iw ) == ir ) irrepChar ( ir , is ) = irrepChar ( ir , is ) + WaveSymm ( iw , iw , is ) enddo enddo endif enddo !Find which representations are equivalent (have the same character table) if (. not . associated ( S % wclass )) allocate ( S % wclass ( nirrep )) S % nwclass = 0 reprlabel = 0 do ir = 1 , nirrep if ( irrep ( ir )) then do jr = 1 , ir - 1 if ( irrep ( jr )) then if ( sum (( irrepChar ( ir , 1 : ns ) - irrepChar ( jr , 1 : ns )) ** 2 ) < 1.d-6 ) exit endif enddo if ( jr == ir ) then S % nwclass = S % nwclass + 1 S % wclass ( ir ) = S % nwclass else S % wclass ( ir ) = S % wclass ( jr ) endif endif enddo !Assign to each wave a group (which is made by equivalent representations) do iw = 1 , nw jr = S % wrepr ( iw ) write ( S % wlabel ( iw ), '(10(i3))' ) rdim ( jr ),( nint ( irrepChar ( jr , is )), is = 1 , ns ) enddo S % nirrep = nirrep end subroutine !--------------------------------------------------------------! subroutine dqmc_phy2_PrintSymm ( S , P2 , OPT ) use dqmc_mpi type ( struct ), intent ( inout ) :: S type ( phy2 ), intent ( inout ) :: P2 integer , intent ( in ) :: OPT integer :: iw , jw , ir , jr , ifw , avg , err , n real ( wp ) :: Trace3 ( P2 % err ), Trace4 ( P2 % err ) if ( qmc_sim % rank . ne . 0 ) return !aliases err = P2 % err avg = P2 % avg n = P2 % nbin !Print Waves if those were found by diagonalization write ( OPT , '(A)' ) \" Waves coefficients (Bonds label columns and are defined above)\" write ( OPT , '(3x,100(3x,i2,2x))' )( iw , iw = 1 , S % n_b ) do iw = 1 , S % nWave write ( OPT , '(i2,1x,20(1x,f6.3))' ) iw ,( S % W ( ir , iw ), ir = 1 , S % n_b ) enddo write ( OPT , '(A)' ) write ( OPT , \"(76('='))\" ) !Print wave amplitude ordered by symmetry write ( OPT , '(A)' ) \" Pair measurement: \" !Loop over groups ... do ir = 1 , S % nwclass Trace3 = 0.d0 ; Trace4 = 0.d0 write ( OPT , '(A, i2)' ) ' Irreducible representation' , ir !Find a wave that represents this group ... do jw = 1 , S % nwave if ( S % wclass ( S % wrepr ( jw )) == ir ) then !Set the format and write the header write ( OPT , '(A,A)' ) '  Dimension and characters :' , S % wlabel ( jw ) write ( OPT , '(23x,A4,23x,A9)' ) 'Full' , 'Connected' exit endif enddo ! ... and print the equivalent irreps belonging to group \"ir\" Trace3 = 0.d0 ; Trace4 = 0.d0 do jr = 1 , S % nirrep if ( S % wclass ( jr ) == ir ) then do iw = 1 , S % nwave if ( S % wrepr ( iw ) == jr ) then Trace3 ( 1 : avg ) = Trace3 ( 1 : avg ) + P2 % M4 ( iw , 1 : avg ) Trace4 ( 1 : avg ) = Trace4 ( 1 : avg ) + P2 % M5 ( iw , 1 : avg ) write ( OPT , '(2x,i2)' , advance = 'no' ) iw ifw = iw endif enddo write ( OPT , \"(' :',f10.6,' +-',f10.6,6x,f10.6,' +-',f10.6)\" ) P2 % M4 ( ifw , avg ), P2 % M4 ( ifw , err ), P2 % M5 ( ifw , avg ), P2 % M5 ( ifw , err ) endif enddo !Also compute and print the Trace +- err Trace3 ( err ) = sqrt ( sum (( Trace3 ( 1 : n ) - Trace3 ( avg )) ** 2 ) * dble ( n - 1 ) / n ) Trace4 ( err ) = sqrt ( sum (( Trace4 ( 1 : n ) - Trace4 ( avg )) ** 2 ) * dble ( n - 1 ) / n ) write ( OPT , 100 ) 'Trace' , Trace3 ( avg ), Trace3 ( err ), Trace4 ( avg ), Trace4 ( err ) write ( OPT , * ) enddo write ( OPT , \"(76('='))\" ) 100 format ( 3 x , A5 , 3 x , \" :\" , f10 . 6 , ' +-' , f10 . 6 , 6 x , f10 . 6 , ' +-' , f10 . 6 ) end subroutine DQMC_phy2_PrintSymm !-----------------------------------------------------------------------! end module DQMC_Phy2","tags":"","loc":"sourcefile/dqmc_phy2.f90.html"},{"title":"dqmc_wspace.F90 – Quest","text":"This file depends on sourcefile~~dqmc_wspace.f90~~EfferentGraph sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_wspace.f90~~AfferentGraph sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_checkerboard.f90 dqmc_checkerboard.F90 sourcefile~dqmc_checkerboard.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_phy0.f90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_WSpace use DQMC_UTIL implicit none ! ! This module is used for memory mangement. ! ! Data Type ! ========= ! type WSpace integer :: lw ( 5 ) real ( wp ), pointer :: R1 (:,:) real ( wp ), pointer :: R2 (:,:) real ( wp ), pointer :: R3 (:,:) real ( wp ), pointer :: R4 (:,:) real ( wp ), pointer :: R5 (:) real ( wp ), pointer :: R6 (:) real ( wp ), pointer :: R7 (:) real ( wp ), pointer :: R8 (:,:) integer , pointer :: I1 (:) integer , pointer :: I2 (:) end type WSpace ! ! Parameters ! ========== ! integer , parameter :: LA_SYEV = 1 ! Index of LAPACK subroutines. integer , parameter :: LA_GEQRF = 2 ! This is used to specify integer , parameter :: LA_ORGQR = 3 ! the size of working space. integer , parameter :: LA_ORMQR = 4 ! integer , parameter :: LA_GETRI = 5 ! contains !---------------------------------------------------------------------! subroutine DQMC_WSpace_Allocate ( n , mx_nbr , WS ) ! ! Purpose ! ======= !    This subrotine allocates memory for MPool ! ! Arguments ! ========= ! integer , intent ( in ) :: n , mx_nbr ! type ( WSpace ), intent ( inout ) :: WS ! working space ! ... Local scalar ... integer :: nb , info ! ... Executable .... info = 0 ! Initialize working space allocate ( WS % R1 ( n , n )) allocate ( WS % R2 ( n , n )) allocate ( WS % R3 ( n , n )) nb = max ( n , mx_nbr ) !allocate(WS%R4(nb,nb)) allocate ( WS % R4 ( n , n )) allocate ( WS % R5 ( n )) allocate ( WS % R6 ( n )) allocate ( WS % I1 ( n )) allocate ( WS % I2 ( n )) ! Get optimal block size for working space ! Part of codes are copied from LAPACK call lapack_dsyev ( 'V' , 'L' , n , WS % R1 , n , WS % R2 , WS % R3 , - 1 , info ) WS % lw ( LA_SYEV ) = int ( WS % R3 ( 1 , 1 )) call lapack_dgeqp3 ( n , n , WS % R1 , n , WS % I1 , WS % R5 , WS % R3 , - 1 , info ) WS % lw ( LA_GEQRF ) = int ( WS % R3 ( 1 , 1 )) call lapack_dorgqr ( n , n , n , WS % R1 , n , WS % R5 , WS % R3 , - 1 , info ) WS % lw ( LA_ORGQR ) = int ( WS % R3 ( 1 , 1 )) call lapack_dormqr ( 'R' , 'N' , n , n , n , WS % R1 , n , WS % R5 , WS % R2 , n , WS % R3 , - 1 , info ) WS % lw ( LA_ORMQR ) = int ( WS % R3 ( 1 , 1 )) call lapack_dgetri ( n , WS % R1 , n , WS % I1 , WS % R3 , - 1 , info ) WS % lw ( LA_GETRI ) = int ( WS % R3 ( 1 , 1 )) nb = maxval ( WS % lw ) allocate ( WS % R7 ( nb )) allocate ( WS % R8 ( n , n )) end subroutine DQMC_WSpace_Allocate !---------------------------------------------------------------------! subroutine DQMC_WSpace_Free ( WS ) ! ! Purpose ! ======= !    This subrotine frees working space ! ! Arguments ! ========= ! type ( WSpace ), intent ( inout ) :: WS ! working space ! ... Executable .... deallocate ( WS % R1 , WS % R2 , WS % R3 , WS % R4 , WS % R5 , WS % R6 , WS % R7 , WS % R8 ) deallocate ( WS % I1 , WS % I2 ) end subroutine DQMC_WSpace_Free end module DQMC_Wspace","tags":"","loc":"sourcefile/dqmc_wspace.f90.html"},{"title":"dqmc_geom.F90 – Quest","text":"This file depends on sourcefile~~dqmc_geom.f90~~EfferentGraph sourcefile~dqmc_geom.f90 dqmc_geom.F90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_geom.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_Geom use DQMC_Struct implicit none ! ! This module defines subroutines to read geometry definition from files. contains !---------------------------------------------------------------------! subroutine QUEST_GG_Init ( S , prefix ) ! ! Purpose ! ======= !    This subroutine reads in geometry data. ! ! Arguments ! ========= ! character ( * ), intent ( in ) :: prefix ! input file name type ( Struct ), intent ( inout ) :: S ! Struct ! ... Local Variable ... integer :: n , fh , fh2 logical :: valid ! ... Executable ... S % checklist = . false . S % nSite = 0 fh = 45 ! neighbor table inquire ( FILE = trim ( prefix ) // \".neigh\" , EXIST = valid ) if (. not . valid ) then print * , prefix , \".neigh does not exist. \" stop end if print * , \"Open \" , trim ( prefix ) // \".neigh\" open ( fh , FILE = trim ( prefix ) // \".neigh\" , form = 'formatted' ) call QUEST_Read_Adj ( fh , S ) close ( fh ) n = S % nSite ! class table inquire ( FILE = trim ( prefix ) // \".class\" , EXIST = valid ) if (. not . valid ) then print * , prefix , \".class does not exist.\" stop end if ! label table fh2 = - 1 inquire ( FILE = trim ( prefix ) // \".label\" , EXIST = valid ) if (. not . valid ) then print * , prefix , \".label does not exist. Use defualt labels.\" else fh2 = 44 print * , \"Open \" , trim ( prefix ) // \".label\" open ( fh2 , FILE = trim ( prefix ) // \".label\" , form = 'formatted' ) end if print * , \"Open \" , trim ( prefix ) // \".class\" open ( fh , FILE = trim ( prefix ) // \".class\" , form = 'formatted' ) call QUEST_Read_Class ( fh , fh2 , S ) close ( fh ) if ( fh2 . gt . 0 ) then close ( fh2 ) end if ! consistence check if ( n . ne . S % nSite ) then print * , \"Number of sites are inconsistent for class files.\" end if ! phase table inquire ( FILE = trim ( prefix ) // \".phase\" , EXIST = valid ) if (. not . valid ) then print * , prefix , \".phase does not exist. \" stop end if print * , \"Open \" , trim ( prefix ) // \".phase\" open ( fh , FILE = trim ( prefix ) // \".phase\" , form = 'formatted' ) call QUEST_Read_Phase ( fh , S ) close ( fh ) if ( n . ne . S % nSite ) then print * , \"Number of sites are not inconsistent for phase files.\" end if ! other part of S allocate ( S % Umap ( n )) allocate ( S % mumap ( n )) S % Umap = 1 S % muMap = 1 S % init = . true . end subroutine QUEST_GG_Init !---------------------------------------------------------------------! subroutine QUEST_Read_Adj ( IPT , S ) ! ! Purpose ! ======= !    This subroutine reads in adjacent tables. ! ! Arguments ! ========= ! integer , intent ( in ) :: IPT ! input device type ( Struct ), intent ( inout ) :: S ! Struct ! ... Local Variable ... integer :: n , n_t , max_adj , line , cnt , ios integer :: i , j , b integer , allocatable :: tbl (:,:), band_cnt (:) ! ... Executable ... ! read n, n_t, nmax read ( IPT , * ) n , n_t ! initializes data S % nSite = n S % n_t = n_t allocate ( S % BS ( n , n_t )) S % BS = 0 allocate ( tbl ( n , n )) allocate ( band_cnt ( n_t )) tbl = 0 ! read in data line = 1 do read ( unit = IPT , iostat = ios , FMT =* ) i , j , b ! end of file if ( ios . ne . 0 ) then exit end if ! validate input if ( i . le . 0. or . i . gt . n . or . j . le . 0. or . j . gt . n . or . b . le . 0. or . b . gt . n_t ) then print * , \"input data error\" , i , j , b , \" in line \" , line end if if ( tbl ( i , j ) . ne . 0 ) then print * , \"Neighbor \" , i , j , \" is redefined in line \" , line stop end if tbl ( i , j ) = b line = line + 1 end do ! symmetric check max_adj = 1 do i = 1 , n cnt = 0 do j = 1 , n if ( tbl ( i , j ) . ne . tbl ( j , i )) then print * , i , j , \"=\" , tbl ( i , j ), \" is not equal to \" , j , i , \"=\" , tbl ( j , i ) stop end if ! record band size if ( tbl ( i , j ) . gt . 0 ) then S % BS ( i , tbl ( i , j )) = S % BS ( i , tbl ( i , j )) + 1 cnt = cnt + 1 end if end do ! count the maximum number of adjacency if ( cnt . gt . max_adj ) then max_adj = cnt end if end do ! build the T table allocate ( S % T ( n , max_adj )) do i = 1 , n band_cnt = 0 cnt = 0 do j = 1 , n_t band_cnt ( j ) = cnt cnt = cnt + S % BS ( i , j ) end do do j = 1 , n if ( tbl ( i , j ) . ne . 0 ) then band_cnt ( tbl ( i , j )) = band_cnt ( tbl ( i , j )) + 1 S % T ( i , band_cnt ( tbl ( i , j ))) = j end if end do end do ! checklist S % checklist ( STRUCT_ADJ ) = . true . end subroutine QUEST_Read_Adj !---------------------------------------------------------------------! subroutine QUEST_Read_Class ( IPT , IPT2 , S ) ! ! Purpose ! ======= !    This subroutine reads in class tables. ! ! Arguments ! ========= ! integer , intent ( in ) :: IPT , IPT2 ! input device type ( Struct ), intent ( inout ) :: S ! Struct ! ... Local Variable ... integer :: i , j , c , nClass , n , line , ios , tmp ! ... Executable ... ! read n, n_t, nmax read ( unit = IPT , FMT =* ) n , nClass ! initializes data S % nSite = n S % nClass = nClass allocate ( S % D ( n , n )) allocate ( S % F ( nClass )) allocate ( S % label ( nClass )) nullify ( S % cord ) S % F = 0 S % D = 0 ! read in data line = 1 do read ( unit = IPT , iostat = ios , FMT =* ) i , j , c ! end of file if ( ios . ne . 0 ) then exit end if ! validate input if ( i . le . 0. or . i . gt . n . or . j . le . 0. or . j . gt . n . or . c . le . 0. or . c . gt . nClass ) then print * , \"input data error\" , i , j , c , \" in line \" , line end if if ( S % D ( i , j ) . ne . 0 ) then print * , \"Class \" , i , j , \" is redefined in line \" , line stop end if S % D ( i , j ) = c S % F ( c ) = S % F ( c ) + 1 line = line + 1 end do ! check class table do i = 1 , n do j = i , n if ( S % D ( i , j ) . eq . 0 ) then print * , \"Class of \" , i , j , \" is not initialized.\" stop end if end do end do do i = 1 , nClass if ( S % F ( i ) . eq . 0 ) then print * , \"Class \" , i , \" = 0.\" stop end if end do if ( IPT2 . gt . 0 ) then do i = 1 , nClass read ( IPT2 , '(a)' ) S % label ( i ) end do else do i = 1 , nClass write ( S % label ( i ), \"('class ',i5)\" ) i end do end if ! checklist S % checklist ( STRUCT_CLASS ) = . true . end subroutine QUEST_Read_Class !---------------------------------------------------------------------! subroutine QUEST_Read_Phase ( IPT , S ) ! ! Purpose ! ======= !    This subroutine reads in phase tables. ! ! Arguments ! ========= ! integer , intent ( in ) :: IPT ! input device type ( Struct ), intent ( inout ) :: S ! Struct ! ... Local Variable ... integer :: i , j , p , n , line , ios integer , allocatable :: phase (:) ! ... Executable ... ! read n, n_t, nmax read ( unit = IPT , FMT =* ) n ! initializes data S % nSite = n allocate ( S % P ( n , n )) allocate ( phase ( n )) phase = 0 line = 1 do read ( unit = IPT , iostat = ios , FMT =* ) i , p ! end of file if ( ios . ne . 0 ) then exit end if ! validate input if ( i . le . 0. or . i . gt . n . or .( p . ne . 1. and . p . ne . - 1 )) then print * , \"input data error\" , i , p , \" in line \" , line end if if ( phase ( i ) . ne . 0 ) then print * , \"phase \" , i , \" is redefined in line \" , line stop end if phase ( i ) = p line = line + 1 end do ! check class table do i = 1 , n do j = i , n S % P ( i , j ) = phase ( i ) * phase ( j ) end do end do ! checklist S % checklist ( STRUCT_PHASE ) = . true . end subroutine QUEST_Read_Phase !---------------------------------------------------------------------! end module DQMC_Geom","tags":"","loc":"sourcefile/dqmc_geom.f90.html"},{"title":"verify.F90 – Quest","text":"This file depends on sourcefile~~verify.f90~~EfferentGraph sourcefile~verify.f90 verify.F90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~verify.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~verify.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~verify.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program dqmc_verify use DQMC_2DPERL use DQMC_Hubbard use DQMC_Struct use DQMC_Phy0 ! Chia-Chen: 09/06/2011 ! MPI module is require in order to run verity in QUEST 1.0.8 ! This is because : ! 1) We need to get the correct numebr of processors !    in DQMC_Phy0_Avg() even for serial runs. ! 2) The new DQMC_Phy0_Avg() can use multiprocessors !    to calculate observable averages and errors. use DQMC_MPI implicit none !  Purpose ! ========= ! This program verifies the correctness of the QUEST code ! with two special cases on a 4x4 periodic lattice. ! !     Case 1. One site (t=0) !     Case 2  No Coulomb interaction (U=0) ! ! The computed values, like density and energy, are verified ! against theoretical values. ! !  Parameters ! ============ integer , parameter :: nx = 4 , ny = 4 , N = nx * ny real ( wp ), parameter :: t ( 4 ) = [ 0.3_wp , 0.6_wp , ONE , ZERO ] real ( wp ), parameter :: dtau = 0.125_wp real ( wp ), parameter :: U ( 6 ) = [ ONE , TWO , TWO * TWO , ZERO , - ONE , - TWO ] real ( wp ), parameter :: mu ( 3 ) = [ HALF , ZERO , - HALF ] integer , parameter :: L = 12 , HSF_IPT = - 1 , n_t = 1 integer , parameter :: nWarm = 1000 , nPass = 5000 , nTry = 0 integer , parameter :: nmeas = 12 , nBin = 10 , tausk = 10 integer , parameter :: idum = 0 , nOrth = 12 , nWrap = 12 integer , parameter :: ssxx = 0 , fixw = 0 real ( wp ), parameter :: errrate = 0.001_wp , difflim = 0.001_wp !real(wp),     parameter  :: pi = 3.141592653589793238462643_wp character ( * ), parameter :: FMT_CMP = & \"(a20,f10.6,'  |',f10.6,' +-',f10.6,'  |  ',f6.2,' :',f6.2)\" character ( * ), parameter :: FMT_CONFIG = & \"('Parameters : ',4(a,' =',f6.2,', '))\" character ( * ), parameter :: FMT_TITLE = & \"(20X,'Theoretical | Computed (avg +- error) |  |T-C| : error')\" real ( wp ) :: t_up ( 4 ), t_dn ( 4 ) real ( wp ) :: mu_up ( 3 ), mu_dn ( 3 ) ! !  Variables ! =========== type ( Hubbard ) :: Hub integer :: i , j , k real ( wp ) :: rho , energy_total , avg , err , one_site_occupancy real ( wp ) :: tmp1 , tmp2 , tmp3 , beta real ( wp ) :: lambda ( N ), X ( N ) real :: t1 , t2 character ( len = 30 ) :: name integer :: cnt ( 0 : 3 ) ! QUEST now allows spin-dependent hopping and chemical potential. t_up = t t_dn = t mu_up = mu mu_dn = mu ! !  Executable ! ============ cnt = 0 call cpu_time ( t1 ) !Count the number of processors call DQMC_MPI_Init ( qmc_sim , PLEVEL_1 ) ! Initialization call DQMC_Init_2DPerl ( nx , ny , Hub % S , IMP_TRIANGLE ) ! Case 1: t=0, run through mu = -0.5, 0.0, 0.5 and U = 1, 2, 4 ! ============================================================== write ( STDOUT , * ) write ( STDOUT , \"(a,i3,a,f6.3)\" ) \"A 4x4 periodic lattice with L =\" , L , & \", dtau=\" , dtau write ( STDOUT , * ) write ( STDOUT , * ) \"==============================\" write ( STDOUT , * ) \"| CASE 1. Single site (t=0)  |\" write ( STDOUT , * ) \"==============================\" do i = 1 , 3 do j = 1 , 6 ! Initialize the parameter of the simulation call DQMC_Hub_Init ( Hub , U ( j : j ), t_up ( 4 : 4 ), t_dn ( 4 : 4 ), mu_up ( i : i ), mu_dn ( i : i ), L , n_t , 1 , 1 , & dtau , HSF_IPT , nWarm , nPass , nMeas , nTry , nBin , tausk , idum , & nOrth , nWrap , fixw , errrate , difflim , HALF , 0 , 0 , ZERO , ZERO , ssxx , HSF_DISC ) beta = L * dtau ! Execute call DQMC_Hub_Run ( Hub , 0 ) ! Check against theoretical results write ( STDOUT , * ) write ( STDOUT , FMT_CONFIG ) \"t\" , ZERO , \"mu\" , mu_up ( i ), \"U\" , U ( j ), \"beta\" , beta write ( STDOUT , FMT_DBLINE ) write ( STDOUT , FMT_TITLE ) write ( STDOUT , FMT_SGLINE ) ! 1. One-site density ! !            2*exp((U/2+mu)*beta)+2*exp(2*mu*beta) !     rho = --------------------------------------- !            1+2*exp((U/2+mu)*beta)+exp(2*mu*beta) ! tmp1 = exp (( U ( j ) / TWO + mu ( i )) * beta ) tmp2 = exp ( TWO * mu ( i ) * beta ) tmp3 = ONE / ( ONE + TWO * tmp1 + tmp2 ) rho = TWO * ( tmp1 + tmp2 ) * tmp3 call DQMC_Phy0_GetResult ( Hub % P0 , P0_DENSITY , name , avg , err ) call Display ( \"          Density : \" , rho , avg , err ) ! 2. One-site energy ! !               U*exp(2*mu*beta) !     E = ------------------------------------- - (mu + U/2)*rho !         1+2*exp((U/2+mu)*beta)+exp(2*mu*beta) ! ! energy_total = U ( j ) * tmp2 * tmp3 - ( mu ( i ) + 0.5d0 * U ( j )) * rho + 0.25d0 * U ( j ) call DQMC_Phy0_GetResult ( Hub % P0 , P0_ENERGY , name , avg , err ) call Display ( \"          Energy : \" , energy_total , avg , err ) ! 3. One-site occupancy ! !                     exp(2*mu*beta) !    PE = -------------------------------------- !          1+2*exp((U/2+mu)*beta)+exp(2*mu*beta) ! one_site_occupancy = tmp2 * tmp3 * Hub % U ( 1 ) call DQMC_Phy0_GetResult ( Hub % P0 , P0_NUD , name , avg , err ) call Display ( \" Double occupancy : \" , one_site_occupancy , avg , err ) write ( STDOUT , FMT_DBLINE ) end do end do ! Case 2: U=0, run through mu = -0.5, 0.0, 0.5 and t = 0.3, 0.6, 1.0 ! =================================================================== ! ! We compute some terms that will be used in verification. ! write ( STDOUT , * ) write ( STDOUT , * ) \"==========================================\" write ( STDOUT , * ) \"| CASE 2. No Coulomb interaction (U=0)   |\" write ( STDOUT , * ) \"==========================================\" write ( STDOUT , * ) do i = 0 , nx - 1 do j = 0 , ny - 1 lambda ( i * nx + j + 1 ) = TWO * ( cos ( TWO * i * pi / nx ) + cos ( TWO * j * pi / ny )) end do end do ! ! In this case, we only need to run 1 measurement loop. Therefore, ! we set nWarm = 0, nPass = 2, nMeas = 1, nBin = 1 ! do i = 1 , 3 do j = 1 , 3 call DQMC_Hub_Init ( Hub , U ( 4 : 4 ), t_up ( j : j ), t_dn ( j : j ), mu_up ( i : i ), mu_dn ( i : i ), L , n_t , 1 , 1 , & dtau , HSF_IPT , nWarm , nPass , nMeas , nTry , nBin , tausk , idum , & nOrth , nWrap , fixw , errrate , difflim , HALF , 0 , 0 , ZERO , ZERO , ssxx , HSF_DISC ) beta = L * dtau call DQMC_Hub_Run ( Hub , 0 ) ! Check against theoretical results write ( STDOUT , FMT_CONFIG ) \"t\" , t ( j ), \"mu\" , mu ( i ), \"U\" , ZERO , \"beta\" , beta write ( STDOUT , FMT_DBLINE ) write ( STDOUT , FMT_TITLE ) write ( STDOUT , FMT_SGLINE ) ! 1. Density !                              1 !    rho = 1.N * sum_k ----------------- !                       1+exp(beta*x_k) ! !          x_k = -t*lambda_k - mu !     lambda_k = 2(cos(theta_kx)+cos(theta_ky)) !     theta_kx = 2kx*pi/N_x !     theta_ky = 2kx*pi/N_y !           kx = 0, 1, ... N_x-1 !           ky = 0, 1, ... N_y-1 ! rho = ZERO do k = 1 , N x ( k ) = ONE / ( ONE + exp ( beta * ( - t ( j ) * lambda ( k ) - mu ( i )))) rho = rho + TWO * x ( k ) end do rho = rho / N call DQMC_Phy0_GetResult ( Hub % P0 , P0_DENSITY , name , avg , err ) call Display ( \"          Density : \" , rho , avg , err ) ! 2. One-site energy (not including chemical energy) ! !                        -t*lambda_k !     E = 1/N * sum_k ------------------- !                      exp(beta*x_k)+1 ! one_site_occupancy = - t ( j ) * TWO * dot_product ( lambda , x ) / N - mu ( i ) * rho call DQMC_Phy0_GetResult ( Hub % P0 , P0_ENERGY , name , avg , err ) call Display ( \"          Energy : \" , one_site_occupancy , avg , err ) write ( STDOUT , FMT_DBLINE ) end do end do ! Statistics write ( STDOUT , \"(f6.2,a)\" ) dble ( cnt ( 1 )) / cnt ( 0 ) * 100 , & \"% within 1 error bar (Expected 63.2%).\" write ( STDOUT , \"(f6.2,a)\" ) dble ( cnt ( 1 ) + cnt ( 2 )) / cnt ( 0 ) * 100 , & \"% within 2 error bar (Expected 86.5%).\" call cpu_time ( t2 ) write ( STDOUT , * ) \"Running time:\" , t2 - t1 , \"(second)\" ! clean up call DQMC_Hub_Free ( hub ) contains !===============================================================! !                    Supporting subroutines                     ! !===============================================================! subroutine Display ( name , theo , avg , err ) ! ! Format the print out for each case, and make some statistics ! character ( * ), intent ( in ) :: name real ( wp ), intent ( in ) :: theo , avg , err ! Local variabel integer :: index real ( wp ) :: ratio ! Executable if ( err /= ZERO ) then ratio = abs ( theo - avg ) / err write ( STDOUT , FMT_CMP ) name , theo , avg , err , ratio , ONE index = ceiling ( ratio ) if ( index > 3 ) index = 3 else ratio = abs ( theo - avg ) write ( STDOUT , FMT_CMP ) name , theo , avg , err , ratio , ZERO if ( ratio <= 1.0D-10 ) then index = 1 else index = 3 end if end if ! cnt ( 0 ) = cnt ( 0 ) + 1 cnt ( index ) = cnt ( index ) + 1 end subroutine Display !===============================================================! !                    Supporting subroutines                     ! !===============================================================! subroutine DQMC_Phy0_GetResult ( P0 , meas , name , avg , err ) ! ! Get results of measurements ! type ( Phy0 ), intent ( in ) :: P0 integer , intent ( in ) :: meas character ( * ), intent ( inout ) :: name real ( wp ), intent ( inout ) :: avg , err name = P0_STR ( meas ) avg = P0 % meas ( meas , P0 % avg ) err = P0 % meas ( meas , P0 % err ) end subroutine DQMC_Phy0_GetResult end program dqmc_verify","tags":"","loc":"sourcefile/verify.f90.html"},{"title":"dqmc_tdm1.F90 – Quest","text":"This file depends on sourcefile~~dqmc_tdm1.f90~~EfferentGraph sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_wspace.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_tdm1.f90~~AfferentGraph sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_TDM1 #include \"dqmc_include.h\" use DQMC_UTIL use DQMC_STRUCT !  use LAPACK_MOD !  use BLAS_MOD use DQMC_GTAU implicit none ! ! This module is designed for the computation of time dependent ! measurement (TDM), which requires the unequal time Green's ! function Gtau (up and down). ! ! Two measurements are taken in this module: Green's function (G) and Chi ! (chi) function.  Both are stored in a 3 dimensional array. ! The first dimension is for space, the second is for time, and the ! last dimension is for bins. ! type tdmarray integer :: n integer :: nclass integer :: nk integer :: np integer , pointer :: D (:,:) integer , pointer :: F (:) integer , pointer :: phase (:,:) complex ( wp ), pointer :: ftk (:,:) complex ( wp ), pointer :: ftw (:,:) real ( wp ), pointer :: values (:,:,:) complex ( wp ), pointer :: valuesk (:,:,:) real ( wp ), pointer :: tlink (:,:) character ( label_len ), pointer :: clabel (:) end type tdmarray ! Index of the array varaiables integer , parameter :: NTDMARRAY = 8 integer , parameter :: IGFUN = 1 integer , parameter :: IGFUP = 2 integer , parameter :: IGFDN = 3 integer , parameter :: ISPXX = 4 integer , parameter :: ISPZZ = 5 integer , parameter :: IDENS = 6 integer , parameter :: IPAIR = 7 integer , parameter :: ICOND = 8 ! Index of the array varaiables character ( len = 12 ), parameter :: & pname ( NTDMARRAY ) = ( / & \"Gfun        \" , & \"Gfun up     \" , & \"Gfun dn     \" , & \"SxSx        \" , & \"SzSz        \" , & \"Den-Den     \" , & \"S-wave      \" , & \"Conductivity\" / ) type TDM1 integer :: L integer :: nbin integer :: avg integer :: err integer :: idx integer :: tmp integer :: cnt logical :: compute = . false . real ( wp ) :: dtau real ( wp ), pointer :: sgn (:) type ( tdmarray ), pointer :: properties (:) ! Fourier transform matrix for bosonic and fermionic fields complex ( wp ), pointer :: ftwfer (:,:) complex ( wp ), pointer :: ftwbos (:,:) end type TDM1 contains !--------------------------------------------------------------------! subroutine DQMC_TDM1_Init ( L , dtau , T1 , nBin , S , Gwrap ) use DQMC_Geom_Wrap ! ! Purpose ! ======= !    This subroutine initializes TDM1. ! ! Arguments ! ========= ! type ( TDM1 ), intent ( inout ) :: T1 ! time dependent measurement integer , intent ( in ) :: L ! No of time slice integer , intent ( in ) :: nBin ! No of Bins real ( wp ), intent ( in ) :: dtau type ( Struct ), intent ( in ) :: S type ( GeomWrap ), intent ( in ) :: Gwrap ! ... local variables ... integer :: i ! ... Executable ... T1 % L = L T1 % dtau = dtau T1 % nbin = nBin T1 % tmp = nBin + 1 T1 % avg = nBin + 1 T1 % err = nBin + 2 T1 % idx = 1 T1 % compute = . true . ! Allocate storages allocate ( T1 % sgn ( nBin + 2 )) ! initialize values T1 % sgn = ZERO call DQMC_TDM1_InitFTw ( T1 ) allocate ( T1 % properties ( NTDMARRAY )) do i = 1 , NTDMARRAY call DQMC_TDM1_InitProp ( T1 , S , Gwrap , i ) enddo end subroutine DQMC_TDM1_Init !--------------------------------------------------------------------! subroutine DQMC_TDM1_InitFTw ( T1 ) ! ! Purpose ! ======= ! Fill the matricess of fourier coefficients necessary to transform ! from imaginary time to imaginary frequency. Two matrices are ! needed: ftwbos for bosonic fields (spin, charge...) and ! ftwfer for fermionic fields (particles) ! ! Arguments ! ========= ! type ( TDM1 ), intent ( inout ) :: T1 ! TDM to be freed integer :: iw , it , L real ( wp ) :: x , pi ! ... Executable ... if (. not . T1 % compute ) return L = T1 % L pi = acos ( - 1.0_wp ) allocate ( T1 % ftwbos ( 0 : L - 1 , 0 : L - 1 )) allocate ( T1 % ftwfer ( 0 : L - 1 , 0 : L - 1 )) do iw = 0 , L - 1 do it = 0 , L - 1 x = 2 * it * iw * pi / L T1 % ftwbos ( iw , it ) = T1 % dtau * cmplx ( cos ( x ), sin ( x )) enddo enddo do iw = 0 , L - 1 do it = 0 , L - 1 x = 2 * it * ( iw + 0.5_wp ) * pi / L T1 % ftwfer ( iw , it ) = T1 % dtau * cmplx ( cos ( x ), sin ( x )) enddo enddo end subroutine DQMC_TDM1_InitFTw !--------------------------------------------------------------------! subroutine DQMC_TDM1_InitProp ( T1 , S , Gwrap , iprop ) use DQMC_Geom_Wrap ! ! Purpose ! ======= ! Initialize contents of tdmarray for iprop ! ! Arguments ! ========= type ( TDM1 ), intent ( inout ) :: T1 type ( Struct ), intent ( in ) :: S type ( GeomWrap ), intent ( in ) :: Gwrap integer , intent ( in ) :: iprop integer :: nk , np , npp , nclass select case ( iprop ) case ( IGFUN , IGFUP , IGFDN ) nk = Gwrap % RecipLattice % nclass_k nclass = S % nClass np = Gwrap % lattice % natom npp = ( np * ( np + 1 )) / 2 nullify ( T1 % properties ( iprop )% tlink ) T1 % properties ( iprop )% n = S % nSite T1 % properties ( iprop )% nclass = nclass T1 % properties ( iprop )% D => S % D T1 % properties ( iprop )% F => S % F T1 % properties ( iprop )% nk = nk T1 % properties ( iprop )% np = np T1 % properties ( iprop )% ftk => Gwrap % RecipLattice % FourierC T1 % properties ( iprop )% ftw => T1 % ftwfer T1 % properties ( iprop )% phase => S % gf_phase T1 % properties ( iprop )% clabel => S % clabel allocate ( T1 % properties ( iprop )% values ( nclass , 0 : T1 % L - 1 , T1 % err )) allocate ( T1 % properties ( iprop )% valuesk ( nk * npp , 0 : T1 % L - 1 , T1 % err )) case ( ISPXX , ISPZZ , IDENS , IPAIR ) nk = Gwrap % GammaLattice % nclass_k nclass = S % nClass np = Gwrap % lattice % natom npp = ( np * ( np + 1 )) / 2 nullify ( T1 % properties ( iprop )% tlink ) T1 % properties ( iprop )% n = S % nSite T1 % properties ( iprop )% nclass = S % nClass T1 % properties ( iprop )% D => S % D T1 % properties ( iprop )% F => S % F T1 % properties ( iprop )% nk = Gwrap % GammaLattice % nclass_k T1 % properties ( iprop )% np = np T1 % properties ( iprop )% ftk => Gwrap % GammaLattice % FourierC T1 % properties ( iprop )% ftw => T1 % ftwbos T1 % properties ( iprop )% phase => S % chi_phase T1 % properties ( iprop )% clabel => S % clabel allocate ( T1 % properties ( iprop )% values ( nclass , 0 : T1 % L - 1 , T1 % err )) allocate ( T1 % properties ( iprop )% valuesk ( nk * npp , 0 : T1 % L - 1 , T1 % err )) case ( ICOND ) nclass = 1 ! \"n\" stores the number of sites in one primitive cell T1 % properties ( iprop )% n = Gwrap % lattice % natom ! I am reusing \"nk\" to store the number of cells in the cluster. T1 % properties ( iprop )% nk = S % nSite / Gwrap % lattice % natom ! I am setting nclass to 1. nclass corresponds, in this ! routine, to the length of the array in which the property ! is stored. By setting it to 1, I am assuming that only <jx jx> ! is desired. One may want to compute the entire tensor in which ! case this number should be increased accordingly. Or one may ! want to split the conductivity in different contributions e.g. ! in a multilayer system it is interesting to look at the contribution ! that each layer gives to the conductivity. As I said, for now, ! this is set to one : only one of the diagonal component of the ! tensor is computed. T1 % properties ( iprop )% nclass = nclass ! Don't have much of a use for some of the pointer since we are ! here interested only in the k=0 component of the jj correlation. ! We can reuse such pointers to store the necessary info though. ! Here I set D to contain the list of sites making up the primitive ! links T1 % properties ( iprop )% D => Gwrap % hamilt % plink ! And store the number of primitive links in np T1 % properties ( iprop )% np = Gwrap % hamilt % nplink ! There are noareal classes so F=1. allocate ( T1 % properties ( iprop )% F ( nclass )) T1 % properties ( iprop )% F ( 1 ) = 1 ! No use for F at this point or ftk at this point nullify ( T1 % properties ( iprop )% ftk ) T1 % properties ( iprop )% ftw => T1 % ftwbos ! Not sure this is needed. Probably not since current is bosonic. T1 % properties ( iprop )% phase => S % chi_phase ! This would be needed if nclass is larger then one. I am assigning ! to it an empty string in this case. allocate ( T1 % properties ( iprop )% clabel ( nclass )) T1 % properties ( iprop )% clabel ( 1 ) = \" \" ! Since number of class is 1 allocate ( T1 % properties ( iprop )% values ( nclass , 0 : T1 % L - 1 , T1 % err )) ! We do not need FT storage nullify ( T1 % properties ( iprop )% valuesk ) ! Amazingly, I realized I had no type_real pointer in this class. ! I had to add one just to store the tlink matrix. No biggie but ! inelegant. T1 % properties ( iprop )% tlink => Gwrap % hamilt % tlink end select T1 % properties ( iprop )% values = 0.0_wp if ( associated ( T1 % properties ( iprop )% valuesk )) & T1 % properties ( iprop )% valuesk = 0.0_wp end subroutine DQMC_TDM1_InitProp !--------------------------------------------------------------------! subroutine DQMC_TDM1_Free ( T1 ) ! ! Purpose ! ======= !    This subroutine frees TDM1. ! ! Arguments ! ========= ! type ( TDM1 ), intent ( inout ) :: T1 integer :: i ! ... Executable ... if (. not . T1 % compute ) return do i = 1 , NTDMARRAY if ( associated ( T1 % properties ( i )% values )) deallocate ( T1 % properties ( i )% values ) if ( associated ( T1 % properties ( i )% valuesk )) deallocate ( T1 % properties ( i )% valuesk ) nullify ( T1 % properties ( i )% D ) nullify ( T1 % properties ( i )% F ) nullify ( T1 % properties ( i )% ftk ) nullify ( T1 % properties ( i )% ftw ) enddo deallocate ( T1 % ftwbos ) deallocate ( T1 % ftwfer ) deallocate ( T1 % properties ) end subroutine DQMC_TDM1_Free !--------------------------------------------------------------------! subroutine DQMC_TDM1_Meas ( T1 , tau ) ! ! Purpose ! ======= !    This subroutine fills the bin. It assumes that tau%A_up and, !    when necessary, tau%A_dn have been filled. ! ! Arguments ! ========= ! type ( TDM1 ), intent ( inout ) :: t1 type ( Gtau ), intent ( inout ) :: tau ! ... Local var ... integer :: i , k , m , L , cnt , dt , i0 , it , j0 , jt , dtau , iprop real ( wp ) :: sgn , factor real ( wp ), pointer :: up0t (:,:) real ( wp ), pointer :: upt0 (:,:) real ( wp ), pointer :: dn0t (:,:) real ( wp ), pointer :: dnt0 (:,:) real ( wp ), pointer :: up00 (:,:) real ( wp ), pointer :: uptt (:,:) real ( wp ), pointer :: dn00 (:,:) real ( wp ), pointer :: dntt (:,:) real ( wp ), pointer :: values (:,:,:) if (. not . T1 % compute ) return ! ... executable ... cnt = 0 L = tau % L k = mod ( tau % north , 2 ) m = ( tau % north - k ) / 2 upt0 => tau % upt0 up0t => tau % up0t dnt0 => tau % dnt0 dn0t => tau % dn0t up00 => tau % up00 uptt => tau % uptt dn00 => tau % dn00 dntt => tau % dntt blocks : do i0 = 1 , tau % nb do dtau = 0 , tau % nb - 1 it = mod ( i0 + dtau - 1 , tau % nb ) + 1 ! Stored value call DQMC_Gtau_DumpA ( tau , TAU_UP , it , i0 ) if ( tau % comp_dn . or . . not . tau % neg_u ) & call DQMC_Gtau_DumpA ( tau , TAU_DN , it , i0 ) jt = tau % it_up ; j0 = tau % i0_up call DQMC_TDM1_Compute ( T1 , upt0 , up0t , dnt0 , dn0t , up00 , uptt , dn00 , dntt , jt , j0 ) ! Decrement index tau%it. If north is even do only north/2-1 decrements. do dt = 1 , m - 1 + k call DQMC_change_gtau_time ( tau , TPLUS , TAU_UP ) if ( tau % comp_dn ) then call DQMC_change_gtau_time ( tau , TPLUS , TAU_DN ) elseif (. not . tau % neg_u ) then call DQMC_Gtau_CopyUp ( tau ) endif jt = tau % it_up ; j0 = tau % i0_up call DQMC_TDM1_Compute ( T1 , upt0 , up0t , dnt0 , dn0t , up00 , uptt , dn00 , dntt , jt , j0 ) enddo if ( m . gt . 0 ) then call DQMC_Gtau_DumpA ( tau , TAU_UP , it , i0 ) if ( tau % comp_dn . or . . not . tau % neg_u ) & call DQMC_Gtau_DumpA ( tau , TAU_DN , it , i0 ) endif ! Increment index tau%it do dt = 1 , m call DQMC_change_gtau_time ( tau , TMINUS , TAU_UP ) if ( tau % comp_dn ) then call DQMC_change_gtau_time ( tau , TMINUS , TAU_DN ) elseif (. not . tau % neg_u ) then call DQMC_Gtau_CopyUp ( tau ) endif jt = tau % it_up ; j0 = tau % i0_up call DQMC_TDM1_Compute ( T1 , upt0 , up0t , dnt0 , dn0t , up00 , uptt , dn00 , dntt , jt , j0 ) enddo enddo cnt = cnt + 1 enddo blocks if ( i0 . ne . tau % nb + 1 ) then write ( * , * ) \"Up and down time slices are mismatched. Stop\" stop endif sgn = tau % sgnup * tau % sgndn do iprop = 1 , NTDMARRAY values => T1 % properties ( iprop )% values do it = 0 , L - 1 do i = 1 , T1 % properties ( iprop )% nClass factor = sgn / ( T1 % properties ( iprop )% F ( i ) * cnt ) values ( i , it , T1 % idx ) = values ( i , it , T1 % idx ) + factor * values ( i , it , T1 % tmp ) end do end do values (:,:, T1 % tmp ) = ZERO enddo T1 % sgn ( T1 % idx ) = T1 % sgn ( T1 % idx ) + sgn T1 % cnt = T1 % cnt + 1 end subroutine DQMC_TDM1_Meas subroutine DQMC_TDM1_Meas_Para ( T1 , pT1 , tau , ptau ) ! ! Purpose ! ======= !    This subroutine fills the bin. It assumes that tau%A_up and, !    when necessary, tau%A_dn have been filled. ! ! Arguments ! ========= ! type ( TDM1 ), intent ( inout ) :: t1 type ( TDM1 ), intent ( inout ) :: pT1 (:) type ( Gtau ), intent ( inout ) :: tau type ( Gtau ), intent ( inout ) :: ptau (:) ! ... Local var ... integer :: i , k , m , n , L , cnt , dt , i0 , it , j0 , jt , iprop real ( wp ) :: sgn , factor real ( wp ), pointer :: values (:,:,:) if (. not . T1 % compute ) return ! ... executable ... cnt = 0 L = tau % L k = mod ( tau % north , 2 ) m = ( tau % north - k ) / 2 !$omp parallel private(it, i0, jt, j0) !$omp do do i = 1 , tau % nb * tau % nb it = mod ( i , tau % nb ) + 1 i0 = ( i - 1 ) / tau % nb + 1 ! Stored value call DQMC_Gtau_DumpA ( ptau ( i ), TAU_UP , it , i0 ) if ( tau % comp_dn . or . . not . tau % neg_u ) & call DQMC_Gtau_DumpA ( ptau ( i ), TAU_DN , it , i0 ) jt = ptau ( i )% it_up ; j0 = ptau ( i )% i0_up call DQMC_TDM1_Compute ( pT1 ( i ), ptau ( i )% upt0 , ptau ( i )% up0t , ptau ( i )% dnt0 , & ptau ( i )% dn0t , ptau ( i )% up00 , ptau ( i )% uptt , ptau ( i )% dn00 , ptau ( i )% dntt , jt , j0 ) ! Decrement index tau%it. If north is even do only north/2-1 decrements. do dt = 1 , m - 1 + k call DQMC_change_gtau_time ( ptau ( i ), TPLUS , TAU_UP ) if ( tau % comp_dn ) then call DQMC_change_gtau_time ( ptau ( i ), TPLUS , TAU_DN ) elseif (. not . tau % neg_u ) then call DQMC_Gtau_CopyUp ( ptau ( i )) endif jt = ptau ( i )% it_up ; j0 = ptau ( i )% i0_up call DQMC_TDM1_Compute ( pT1 ( i ), ptau ( i )% upt0 , ptau ( i )% up0t , ptau ( i )% dnt0 , & ptau ( i )% dn0t , ptau ( i )% up00 , ptau ( i )% uptt , ptau ( i )% dn00 , ptau ( i )% dntt , jt , j0 ) enddo if ( m . gt . 0 ) then call DQMC_Gtau_DumpA ( ptau ( i ), TAU_UP , it , i0 ) if ( tau % comp_dn . or . . not . tau % neg_u ) & call DQMC_Gtau_DumpA ( ptau ( i ), TAU_DN , it , i0 ) endif ! Increment index tau%it do dt = 1 , m call DQMC_change_gtau_time ( ptau ( i ), TMINUS , TAU_UP ) if ( tau % comp_dn ) then call DQMC_change_gtau_time ( ptau ( i ), TMINUS , TAU_DN ) elseif (. not . tau % neg_u ) then call DQMC_Gtau_CopyUp ( ptau ( i )) endif jt = ptau ( i )% it_up ; j0 = ptau ( i )% i0_up call DQMC_TDM1_Compute ( pT1 ( i ), ptau ( i )% upt0 , ptau ( i )% up0t , ptau ( i )% dnt0 , & ptau ( i )% dn0t , ptau ( i )% up00 , ptau ( i )% uptt , ptau ( i )% dn00 , ptau ( i )% dntt , jt , j0 ) enddo enddo !$omp end do !$omp end parallel cnt = cnt + tau % nb ! Sum up the multi-threads value do n = 1 , tau % nb * tau % nb do iprop = 1 , NTDMARRAY do i = 1 , T1 % properties ( iprop )% nclass do it = 0 , L - 1 T1 % properties ( iprop )% values ( i , it , T1 % tmp ) = T1 % properties ( iprop )% values ( i , it , T1 % tmp ) + & pT1 ( n )% properties ( iprop )% values ( i , it , T1 % tmp ) enddo enddo enddo enddo sgn = tau % sgnup * tau % sgndn do iprop = 1 , NTDMARRAY values => T1 % properties ( iprop )% values do it = 0 , L - 1 do i = 1 , T1 % properties ( iprop )% nClass factor = sgn / ( T1 % properties ( iprop )% F ( i ) * cnt ) values ( i , it , T1 % idx ) = values ( i , it , T1 % idx ) + factor * values ( i , it , T1 % tmp ) end do end do values (:,:, T1 % tmp ) = ZERO do n = 1 , tau % nb * tau % nb values => pT1 ( n )% properties ( iprop )% values values (:,:, T1 % tmp ) = ZERO enddo enddo T1 % sgn ( T1 % idx ) = T1 % sgn ( T1 % idx ) + sgn T1 % cnt = T1 % cnt + 1 end subroutine DQMC_TDM1_Meas_Para !--------------------------------------------------------------------! subroutine DQMC_TDM1_Compute ( T1 , upt0 , up0t , dnt0 , dn0t , up00 , uptt , dn00 , dntt , it , i0 ) ! ! Purpose ! ======= !    This subroutine assembles the time dependent properties !    starting from the 1-body Green's function ! ! Arguments ! ========= ! type ( TDM1 ), intent ( inout ) :: T1 real ( wp ), intent ( in ) :: up0t (:,:), upt0 (:,:) real ( wp ), intent ( in ) :: dnt0 (:,:), dn0t (:,:) real ( wp ), intent ( in ) :: up00 (:,:), uptt (:,:) real ( wp ), intent ( in ) :: dn00 (:,:), dntt (:,:) integer , intent ( in ) :: it , i0 ! ... Local scalar ... integer :: i , j , k , dt , dt1 , dt2 real ( wp ), pointer :: value1 (:) real ( wp ), pointer :: value2 (:) real ( wp ) :: factor integer :: nsite , ic , jc , l1s , l1e , l2s , l2e real ( wp ) :: tl1up2up , tl1dn2dn , tl1up2dn , tl1dn2up , dxl1 , dxl2 , dxl1l2 ! ... Executable ... if (. not . T1 % compute ) return dt = it - i0 if ( dt . gt . 0 ) then ! it > i0 dt1 = dt dt2 = T1 % L - dt factor = 0.25d0 elseif ( dt . lt . 0 ) then ! it < i0 dt1 = dt + T1 % L dt2 = - dt factor = - 0.25d0 else dt1 = 0 dt2 = 0 factor = 0.5d0 endif if ( dt . ne . 0 ) then value1 => T1 % properties ( IGFUN )% values (:, dt1 , T1 % tmp ) value2 => T1 % properties ( IGFUN )% values (:, dt2 , T1 % tmp ) do i = 1 , T1 % properties ( IGFUN )% n do j = 1 , T1 % properties ( IGFUN )% n ! k is the distance index of site i and site j k = T1 % properties ( IGFUN )% D ( i , j ) value1 ( k ) = value1 ( k ) + factor * ( upt0 ( i , j ) + dnt0 ( i , j )) value2 ( k ) = value2 ( k ) - factor * ( up0t ( i , j ) + dn0t ( i , j )) end do end do value1 => T1 % properties ( IGFUP )% values (:, dt1 , T1 % tmp ) value2 => T1 % properties ( IGFUP )% values (:, dt2 , T1 % tmp ) do i = 1 , T1 % properties ( IGFUP )% n do j = 1 , T1 % properties ( IGFUP )% n ! k is the distance index of site i and site j k = T1 % properties ( IGFUP )% D ( i , j ) value1 ( k ) = value1 ( k ) + 2 * factor * upt0 ( i , j ) value2 ( k ) = value2 ( k ) - 2 * factor * up0t ( i , j ) end do end do value1 => T1 % properties ( IGFDN )% values (:, dt1 , T1 % tmp ) value2 => T1 % properties ( IGFDN )% values (:, dt2 , T1 % tmp ) do i = 1 , T1 % properties ( IGFDN )% n do j = 1 , T1 % properties ( IGFDN )% n ! k is the distance index of site i and site j k = T1 % properties ( IGFDN )% D ( i , j ) value1 ( k ) = value1 ( k ) + 2 * factor * dnt0 ( i , j ) value2 ( k ) = value2 ( k ) - 2 * factor * dn0t ( i , j ) end do end do value1 => T1 % properties ( ISPXX )% values (:, dt1 , T1 % tmp ) value2 => T1 % properties ( ISPXX )% values (:, dt2 , T1 % tmp ) do i = 1 , T1 % properties ( ISPXX )% n do j = 1 , T1 % properties ( ISPXX )% n ! k is the distance index of site i and site j k = T1 % properties ( ISPXX )% D ( i , j ) value1 ( k ) = value1 ( k ) - ( up0t ( j , i ) * dnt0 ( i , j ) & + dn0t ( j , i ) * upt0 ( i , j )) / 2 value2 ( k ) = value2 ( k ) - ( up0t ( i , j ) * dnt0 ( j , i ) & + dn0t ( i , j ) * upt0 ( j , i )) / 2 end do end do value1 => T1 % properties ( ISPZZ )% values (:, dt1 , T1 % tmp ) value2 => T1 % properties ( ISPZZ )% values (:, dt2 , T1 % tmp ) do i = 1 , T1 % properties ( ISPZZ )% n do j = 1 , T1 % properties ( ISPZZ )% n ! k is the distance index of site i and site j k = T1 % properties ( ISPZZ )% D ( i , j ) value1 ( k ) = value1 ( k ) - ( up0t ( j , i ) * upt0 ( i , j ) & + dn0t ( j , i ) * dnt0 ( i , j ) - ( uptt ( i , i ) - dntt ( i , i )) * ( up00 ( j , j ) - dn00 ( j , j )) ) * 0.5_wp value2 ( k ) = value2 ( k ) - ( dn0t ( i , j ) * dnt0 ( j , i ) & + up0t ( i , j ) * upt0 ( j , i ) - ( uptt ( j , j ) - dntt ( j , j )) * ( up00 ( i , i ) - dn00 ( i , i )) ) * 0.5_wp end do end do value1 => T1 % properties ( IDENS )% values (:, dt1 , T1 % tmp ) value2 => T1 % properties ( IDENS )% values (:, dt2 , T1 % tmp ) do i = 1 , T1 % properties ( IDENS )% n do j = 1 , T1 % properties ( IDENS )% n ! k is the distance index of site i and site j k = T1 % properties ( IDENS )% D ( i , j ) value1 ( k ) = value1 ( k ) - ( up0t ( j , i ) * upt0 ( i , j ) & + dn0t ( j , i ) * dnt0 ( i , j ) - ( uptt ( i , i ) + dntt ( i , i )) * ( up00 ( j , j ) + dn00 ( j , j )) & - 2.0_wp * ( 1.0_wp - uptt ( i , i ) - up00 ( j , j ) ) & - 2.0_wp * ( 1.0_wp - dntt ( i , i ) - dn00 ( j , j ) ) ) * 0.5_wp value2 ( k ) = value2 ( k ) - ( dn0t ( i , j ) * dnt0 ( j , i ) & + up0t ( i , j ) * upt0 ( j , i ) - ( uptt ( j , j ) + dntt ( j , j )) * ( up00 ( i , i ) + dn00 ( i , i )) & - 2.0_wp * ( 1.0_wp - up00 ( i , i ) - uptt ( j , j ) ) & - 2.0_wp * ( 1.0_wp - dn00 ( i , i ) - dntt ( j , j ) ) ) * 0.5_wp end do end do value1 => T1 % properties ( IPAIR )% values (:, dt1 , T1 % tmp ) value2 => T1 % properties ( IPAIR )% values (:, dt2 , T1 % tmp ) do i = 1 , T1 % properties ( IPAIR )% n do j = 1 , T1 % properties ( IPAIR )% n ! k is the distance index of site i and site j k = T1 % properties ( IPAIR )% D ( i , j ) value1 ( k ) = value1 ( k ) + ( upt0 ( i , j ) * dnt0 ( i , j ) & + dn0t ( j , i ) * up0t ( j , i )) / 2 value2 ( k ) = value2 ( k ) + ( upt0 ( j , i ) * dnt0 ( j , i ) & + dn0t ( i , j ) * up0t ( i , j )) / 2 end do end do ! Uniform (q=0) current structure factor. This quantity can be used to get approximated dc conductivity. value1 => T1 % properties ( ICOND )% values (:, dt1 , T1 % tmp ) value2 => T1 % properties ( ICOND )% values (:, dt2 , T1 % tmp ) ! J-J correlation is following Simone's trick: ! n:  the number of sites in one primitive cell ! nk: the number of cells in the cluster ! D:  the list of sites making up the primitive links ! np: the number of all links, instead of primitive links ! Double Loops over all links: nsite = T1 % properties ( ICOND )% n * T1 % properties ( ICOND )% nk ! Call nk the number of unit cells, than the first nk entries of plink ! are the translation of the first primitive link. Likewise from nk+1 to 2nk ! you have all the links obtained by translation of the second link and so on do i = 0 , T1 % properties ( ICOND )% np - 1 do j = 0 , T1 % properties ( ICOND )% np - 1 ! find out if this type of link contribute to conductivity dxl1 = T1 % properties ( ICOND )% tlink ( 3 , i ) dxl2 = T1 % properties ( ICOND )% tlink ( 3 , j ) if ( abs ( dxl1 ) < 1.0E-5 . or . abs ( dxl2 ) < 1.0E-5 ) then value1 ( 1 ) = value1 ( 1 ) value2 ( 1 ) = value2 ( 1 ) else ! x-coordinate (for JxJx component of J-J tensor) difference dxl1l2 = dxl1 * dxl2 * 0.5_wp / nsite tl1up2up = T1 % properties ( ICOND )% tlink ( 1 , i ) * T1 % properties ( ICOND )% tlink ( 1 , j ) tl1dn2dn = T1 % properties ( ICOND )% tlink ( 2 , i ) * T1 % properties ( ICOND )% tlink ( 2 , j ) tl1up2dn = T1 % properties ( ICOND )% tlink ( 1 , i ) * T1 % properties ( ICOND )% tlink ( 2 , j ) tl1dn2up = T1 % properties ( ICOND )% tlink ( 2 , i ) * T1 % properties ( ICOND )% tlink ( 1 , j ) do ic = 0 , T1 % properties ( ICOND )% nk - 1 do jc = 0 , T1 % properties ( ICOND )% nk - 1 l1s = T1 % properties ( ICOND )% D ( 1 , i * T1 % properties ( ICOND )% nk + ic ) + 1 l1e = T1 % properties ( ICOND )% D ( 2 , i * T1 % properties ( ICOND )% nk + ic ) + 1 l2s = T1 % properties ( ICOND )% D ( 1 , j * T1 % properties ( ICOND )% nk + jc ) + 1 l2e = T1 % properties ( ICOND )% D ( 2 , j * T1 % properties ( ICOND )% nk + jc ) + 1 ! jx-jx for links l and l': value1 ( 1 ) = value1 ( 1 ) - dxl1l2 * tl1up2up * (( uptt ( l1e , l1s ) - uptt ( l1s , l1e )) * ( up00 ( l2e , l2s ) - up00 ( l2s , l2e )) ) & - dxl1l2 * tl1up2dn * (( uptt ( l1e , l1s ) - uptt ( l1s , l1e )) * ( dn00 ( l2e , l2s ) - dn00 ( l2s , l2e )) ) & - dxl1l2 * tl1dn2up * (( dntt ( l1e , l1s ) - dntt ( l1s , l1e )) * ( up00 ( l2e , l2s ) - up00 ( l2s , l2e )) ) & - dxl1l2 * tl1dn2dn * (( dntt ( l1e , l1s ) - dntt ( l1s , l1e )) * ( dn00 ( l2e , l2s ) - dn00 ( l2s , l2e )) ) ! cross terms value1 ( 1 ) = value1 ( 1 ) + dxl1l2 * tl1up2up * ( upt0 ( l1e , l2s ) * up0t ( l2e , l1s ) + upt0 ( l1s , l2e ) * up0t ( l2s , l1e ) & - upt0 ( l1e , l2e ) * up0t ( l2s , l1s ) - upt0 ( l1s , l2s ) * up0t ( l2e , l1e ) ) value1 ( 1 ) = value1 ( 1 ) + dxl1l2 * tl1dn2dn * ( dnt0 ( l1e , l2s ) * dn0t ( l2e , l1s ) + dnt0 ( l1s , l2e ) * dn0t ( l2s , l1e ) & - dnt0 ( l1e , l2e ) * dn0t ( l2s , l1s ) - dnt0 ( l1s , l2s ) * dn0t ( l2e , l1e ) ) ! value2: see the rules at the beginning of routine value2 ( 1 ) = value2 ( 1 ) - dxl1l2 * tl1up2up * (( up00 ( l1e , l1s ) - up00 ( l1s , l1e )) * ( uptt ( l2e , l2s ) - uptt ( l2s , l2e )) ) & - dxl1l2 * tl1up2dn * (( up00 ( l1e , l1s ) - up00 ( l1s , l1e )) * ( dntt ( l2e , l2s ) - dntt ( l2s , l2e )) ) & - dxl1l2 * tl1dn2up * (( dn00 ( l1e , l1s ) - dn00 ( l1s , l1e )) * ( uptt ( l2e , l2s ) - uptt ( l2s , l2e )) ) & - dxl1l2 * tl1dn2dn * (( dn00 ( l1e , l1s ) - dn00 ( l1s , l1e )) * ( dntt ( l2e , l2s ) - dntt ( l2s , l2e )) ) ! cross terms value2 ( 1 ) = value2 ( 1 ) + dxl1l2 * tl1up2up * ( up0t ( l1e , l2s ) * upt0 ( l2e , l1s ) + up0t ( l1s , l2e ) * upt0 ( l2s , l1e ) & - up0t ( l1e , l2e ) * upt0 ( l2s , l1s ) - up0t ( l1s , l2s ) * upt0 ( l2e , l1e ) ) value2 ( 1 ) = value2 ( 1 ) + dxl1l2 * tl1dn2dn * ( dn0t ( l1e , l2s ) * dnt0 ( l2e , l1s ) + dn0t ( l1s , l2e ) * dnt0 ( l2s , l1e ) & - dn0t ( l1e , l2e ) * dnt0 ( l2s , l1s ) - dn0t ( l1s , l2s ) * dnt0 ( l2e , l1e ) ) end do end do endif end do end do else value1 => T1 % properties ( IGFUN )% values (:, dt1 , T1 % tmp ) do i = 1 , T1 % properties ( IGFUN )% n do j = 1 , T1 % properties ( IGFUN )% n ! k is the distance index of site i and site j k = T1 % properties ( IGFUN )% D ( i , j ) value1 ( k ) = value1 ( k ) + factor * ( upt0 ( i , j ) + dnt0 ( i , j )) end do end do value1 => T1 % properties ( IGFUP )% values (:, dt1 , T1 % tmp ) do i = 1 , T1 % properties ( IGFUP )% n do j = 1 , T1 % properties ( IGFUP )% n ! k is the distance index of site i and site j k = T1 % properties ( IGFUP )% D ( i , j ) value1 ( k ) = value1 ( k ) + 2 * factor * upt0 ( i , j ) end do end do value1 => T1 % properties ( IGFDN )% values (:, dt1 , T1 % tmp ) do i = 1 , T1 % properties ( IGFDN )% n do j = 1 , T1 % properties ( IGFDN )% n ! k is the distance index of site i and site j k = T1 % properties ( IGFDN )% D ( i , j ) value1 ( k ) = value1 ( k ) + 2 * factor * dnt0 ( i , j ) end do end do value1 => T1 % properties ( ISPXX )% values (:, dt1 , T1 % tmp ) do i = 1 , T1 % properties ( ISPXX )% n do j = 1 , T1 % properties ( ISPXX )% n ! k is the distance index of site i and site j k = T1 % properties ( ISPXX )% D ( i , j ) value1 ( k ) = value1 ( k ) - up0t ( j , i ) * dnt0 ( i , j ) & - dn0t ( j , i ) * upt0 ( i , j ) end do end do value1 => T1 % properties ( ISPZZ )% values (:, dt1 , T1 % tmp ) do i = 1 , T1 % properties ( ISPZZ )% n do j = 1 , T1 % properties ( ISPZZ )% n ! k is the distance index of site i and site j k = T1 % properties ( ISPZZ )% D ( i , j ) value1 ( k ) = value1 ( k ) - ( up0t ( j , i ) * upt0 ( i , j ) & + dn0t ( j , i ) * dnt0 ( i , j ) - ( uptt ( i , i ) - dntt ( i , i )) * ( up00 ( j , j ) - dn00 ( j , j )) ) end do end do value1 => T1 % properties ( IDENS )% values (:, dt1 , T1 % tmp ) do i = 1 , T1 % properties ( IDENS )% n do j = 1 , T1 % properties ( IDENS )% n ! k is the distance index of site i and site j k = T1 % properties ( IDENS )% D ( i , j ) value1 ( k ) = value1 ( k ) - ( up0t ( j , i ) * upt0 ( i , j ) & + dn0t ( j , i ) * dnt0 ( i , j ) - ( uptt ( i , i ) + dntt ( i , i )) * ( up00 ( j , j ) + dn00 ( j , j )) & - 2.0_wp * ( 1.0_wp - uptt ( i , i ) - up00 ( j , j ) ) & - 2.0_wp * ( 1.0_wp - dntt ( i , i ) - dn00 ( j , j ) ) ) end do end do value1 => T1 % properties ( IPAIR )% values (:, dt1 , T1 % tmp ) do i = 1 , T1 % properties ( IPAIR )% n do j = 1 , T1 % properties ( IPAIR )% n ! k is the distance index of site i and site j k = T1 % properties ( IPAIR )% D ( i , j ) value1 ( k ) = value1 ( k ) + upt0 ( i , j ) * dnt0 ( i , j ) & + dn0t ( j , i ) * up0t ( j , i ) end do end do value1 => T1 % properties ( ICOND )% values (:, dt1 , T1 % tmp ) nsite = T1 % properties ( ICOND )% n * T1 % properties ( ICOND )% nk do i = 0 , T1 % properties ( ICOND )% np - 1 do j = 0 , T1 % properties ( ICOND )% np - 1 ! find out if this type of link contribute to conductivity dxl1 = T1 % properties ( ICOND )% tlink ( 3 , i ) dxl2 = T1 % properties ( ICOND )% tlink ( 3 , j ) if ( abs ( dxl1 ) < 1.0E-5 . or . abs ( dxl2 ) < 1.0E-5 ) then value1 ( 1 ) = value1 ( 1 ) else dxl1l2 = dxl1 * dxl2 / nsite tl1up2up = T1 % properties ( ICOND )% tlink ( 1 , i ) * T1 % properties ( ICOND )% tlink ( 1 , j ) tl1dn2dn = T1 % properties ( ICOND )% tlink ( 2 , i ) * T1 % properties ( ICOND )% tlink ( 2 , j ) tl1up2dn = T1 % properties ( ICOND )% tlink ( 1 , i ) * T1 % properties ( ICOND )% tlink ( 2 , j ) tl1dn2up = T1 % properties ( ICOND )% tlink ( 2 , i ) * T1 % properties ( ICOND )% tlink ( 1 , j ) do ic = 0 , T1 % properties ( ICOND )% nk - 1 do jc = 0 , T1 % properties ( ICOND )% nk - 1 l1s = T1 % properties ( ICOND )% D ( 1 , i * T1 % properties ( ICOND )% nk + ic ) + 1 l1e = T1 % properties ( ICOND )% D ( 2 , i * T1 % properties ( ICOND )% nk + ic ) + 1 l2s = T1 % properties ( ICOND )% D ( 1 , j * T1 % properties ( ICOND )% nk + jc ) + 1 l2e = T1 % properties ( ICOND )% D ( 2 , j * T1 % properties ( ICOND )% nk + jc ) + 1 ! jx-jx for links l and l': ! include x-coordinate (for JxJx component of J-J tensor) difference value1 ( 1 ) = value1 ( 1 ) - dxl1l2 * tl1up2up * (( uptt ( l1e , l1s ) - uptt ( l1s , l1e )) * ( up00 ( l2e , l2s ) - up00 ( l2s , l2e )) ) & - dxl1l2 * tl1up2dn * (( uptt ( l1e , l1s ) - uptt ( l1s , l1e )) * ( dn00 ( l2e , l2s ) - dn00 ( l2s , l2e )) ) & - dxl1l2 * tl1dn2up * (( dntt ( l1e , l1s ) - dntt ( l1s , l1e )) * ( up00 ( l2e , l2s ) - up00 ( l2s , l2e )) ) & - dxl1l2 * tl1dn2dn * (( dntt ( l1e , l1s ) - dntt ( l1s , l1e )) * ( dn00 ( l2e , l2s ) - dn00 ( l2s , l2e )) ) ! cross terms value1 ( 1 ) = value1 ( 1 ) + dxl1l2 * tl1up2up * ( upt0 ( l1e , l2s ) * up0t ( l2e , l1s ) + upt0 ( l1s , l2e ) * up0t ( l2s , l1e ) & - upt0 ( l1e , l2e ) * up0t ( l2s , l1s ) - upt0 ( l1s , l2s ) * up0t ( l2e , l1e ) ) value1 ( 1 ) = value1 ( 1 ) + dxl1l2 * tl1dn2dn * ( dnt0 ( l1e , l2s ) * dn0t ( l2e , l1s ) + dnt0 ( l1s , l2e ) * dn0t ( l2s , l1e ) & - dnt0 ( l1e , l2e ) * dn0t ( l2s , l1s ) - dnt0 ( l1s , l2s ) * dn0t ( l2e , l1e ) ) end do end do endif end do end do endif end subroutine DQMC_TDM1_Compute !--------------------------------------------------------------------! subroutine DQMC_TDM1_Avg ( T1 ) ! ! Purpose ! ======= !    This subroutine average properties in a bin and !    increment the bin count (idx). ! ! Arguments ! ========= ! type ( TDM1 ), intent ( inout ) :: T1 ! T1 ! ... local scalar ... integer :: nl , idx , i real ( wp ) :: factor ! ... Executable ... if (. not . T1 % compute ) return idx = T1 % idx factor = ONE / T1 % cnt ! Compute average on Green's function do i = 1 , NTDMARRAY nl = T1 % properties ( i )% nClass * T1 % L call dscal ( nl , factor , T1 % properties ( i )% values (:, 0 , idx ), 1 ) enddo T1 % sgn ( idx ) = T1 % sgn ( idx ) * factor T1 % cnt = 0 T1 % idx = T1 % idx + 1 end subroutine DQMC_TDM1_Avg !--------------------------------------------------------------------! subroutine DQMC_TDM1_GetErr ( T1 ) use dqmc_mpi ! ! Purpose ! ======= !    This subroutine compute the error in tdm using the jackknife ! ! Arguments ! ========= ! type ( TDM1 ), intent ( inout ) :: T1 ! T1 ! ... local scalar ... integer :: i , j , iprop integer :: nproc , n , avg , err , mpi_err real ( wp ) :: sum_sgn , sgn ( T1 % nBin ), y ( T1 % nBin ), data ( T1 % nBin ) real ( wp ) :: average , error if (. not . T1 % compute ) return ! ... Executable ... nproc = qmc_sim % size n = T1 % nbin avg = T1 % avg err = T1 % err if ( nproc . eq . 1 ) then data = T1 % sgn ( 1 : n ) call DQMC_JackKnife ( n , T1 % sgn ( avg ), T1 % sgn ( err ), data , & y , sgn , sum_sgn ) do iprop = 1 , NTDMARRAY do i = 1 , T1 % properties ( iprop )% nClass do j = 0 , T1 % L - 1 data = T1 % properties ( iprop )% values ( i , j , 1 : n ) call DQMC_SignJackKnife ( n , average , error , data , y , sgn , sum_sgn ) T1 % properties ( iprop )% values ( i , j , avg ) = average T1 % properties ( iprop )% values ( i , j , err ) = error enddo end do enddo else mpi_err = 0 #      ifdef _QMC_MPI !Average sign call mpi_allreduce ( T1 % sgn ( 1 ), T1 % sgn ( avg ), 1 , mpi_double , & mpi_sum , mpi_comm_world , mpi_err ) !Average properties do iprop = 1 , NTDMARRAY binptr => T1 % properties ( iprop )% values (:,:, 1 ) aveptr => T1 % properties ( iprop )% value (:,:, avg ) n = T1 % properties ( iprop )% nClass * T1 % L call mpi_allreduce ( binptr , aveptr , n , mpi_double , & mpi_sum , mpi_comm_world , mpi_err ) enddo !Compute average over n-1 processors do iprop = 1 , NTDMARRAY binptr => T1 % properties ( iprop )% values (:,:, 1 ) aveptr => T1 % properties ( iprop )% values (:,:, avg ) binptr = ( aveptr - binptr ) / dble ( nproc - 1 ) enddo T1 % sgn ( 1 ) = ( T1 % sgn ( avg ) - T1 % sgn ( 1 )) / dble ( nproc - 1 ) !Store average amongst all processors do iprop = 1 , NTDMARRAY aveptr => T1 % properties ( iprop )% values (:,:, avg ) aveptr = aveptr / T1 % sgn ( avg ) enddo T1 % sgn (:, avg ) = T1 % sgn (:, avg ) / dble ( nproc ) !Store jackknife in the processor bin do iprop = 1 , NTDMARRAY binptr => T1 % properties ( iprop )% values (:,:, 1 ) binptr = binptr / T1 % sgn ( 1 ) enddo !Compute error do iprop = 1 , NTDMARRAY binptr => T1 % properties ( iprop )% values (:,:, 1 ) errptr => T1 % properties ( iprop )% values (:,:, err ) n = T1 % properties ( iprop )% nClass * T1 % L call mpi_allreduce ( binptr ** 2 , errptr , n , mpi_double , & mpi_sum , mpi_comm_world , mpi_err ) errptr = errptr / dble ( nproc ) - aveptr ** 2 errptr = sqrt ( errptr * dble ( nproc - 1 )) enddo #      endif endif end subroutine DQMC_TDM1_GetErr !--------------------------------------------------------------------! subroutine DQMC_TDM1_Print ( T1 , OPT ) use dqmc_mpi ! ! Purpose ! ======= !    This subroutine prints properties to file ! ! Arguments ! ========= ! type ( TDM1 ), intent ( in ) :: T1 ! T1 integer , intent ( in ) :: OPT integer :: i , j , iprop real ( wp ) :: tmp ( T1 % L , 2 ) character ( len = 10 ) :: label ( T1 % L ) character ( len = slen ) :: title ! ... Executable ... if (. not . T1 % compute ) return if ( qmc_sim % rank . ne . 0 ) return do j = 1 , T1 % L write ( label ( j ), '(f10.5)' ) ( j - 1 ) * T1 % dtau enddo do iprop = 1 , NTDMARRAY do i = 1 , T1 % properties ( iprop )% nclass do j = 0 , T1 % L - 1 tmp ( j + 1 , 1 : 2 ) = T1 % properties ( iprop )% values ( i , j , T1 % avg : T1 % err ) enddo title = pname ( iprop ) // \" \" // trim ( adjustl ( T1 % properties ( iprop )% clabel ( i ))) call DQMC_Print_Array ( 0 , T1 % L , title , label , tmp (:, 1 : 1 ), tmp (:, 2 : 2 ), OPT ) write ( OPT , '(1x)' ) enddo enddo end subroutine DQMC_TDM1_Print !--------------------------------------------------------------------! subroutine DQMC_TDM1_GetKFT ( T1 ) type ( tdm1 ), intent ( inout ) :: T1 integer :: ip , it , n , nclass , np , nk , ibin integer , pointer :: class (:,:) complex ( wp ), pointer :: wgtftk (:,:) integer , pointer :: phase (:,:) real ( wp ), pointer :: value (:) complex ( wp ), pointer :: valuet (:) if (. not . T1 % compute ) return !Loop over properties to Fourier transform do ip = 1 , NTDMARRAY if (. not . associated ( T1 % properties ( ip )% valuesk )) cycle ! Aliases n = T1 % properties ( ip )% n nclass = T1 % properties ( ip )% nclass np = T1 % properties ( ip )% np nk = T1 % properties ( ip )% nk class => T1 % properties ( ip )% D wgtftk => T1 % properties ( ip )% ftk phase => T1 % properties ( ip )% phase !Fourier transform each bin and average do ibin = T1 % avg , 1 , - 1 ! More aliases do it = 0 , T1 % L - 1 value => T1 % properties ( ip )% values (:, it , ibin ) valuet => T1 % properties ( ip )% valuesk (:, it , ibin ) call dqmc_getFTk ( value , n , nclass , class , np , nk , wgtftk , phase , valuet ) enddo enddo ! Loop over bins enddo ! Loop over properties end subroutine DQMC_TDM1_GetKFT !--------------------------------------------------------------------! subroutine DQMC_TDM1_GetErrKFT ( T1 ) use DQMC_MPI type ( tdm1 ), intent ( inout ) :: T1 integer :: ip , it , n , nproc , i complex ( wp ), pointer :: average (:) complex ( wp ), pointer :: binval (:) complex ( wp ), pointer :: error (:) complex ( wp ), pointer :: temp (:) !Loop over properties to Fourier transform nproc = qmc_sim % size if (. not . T1 % compute ) return if ( nproc . eq . 1 ) then do ip = 1 , NTDMARRAY if (. not . associated ( T1 % properties ( ip )% valuesk )) cycle do it = 0 , T1 % L - 1 average => T1 % properties ( ip )% valuesk (:, it , T1 % avg ) error => T1 % properties ( ip )% valuesk (:, it , T1 % err ) !Fourier transform each bin and average do i = 1 , T1 % nbin binval => T1 % properties ( ip )% valuesk (:, it , i ) error = error + cmplx (( real ( average - binval )) ** 2 ,( aimag ( average - binval )) ** 2 ) enddo ! Loop over bins error = ( T1 % nbin - 1 ) * error / T1 % nbin error = cmplx ( sqrt ( real ( error )), sqrt ( aimag ( error ))) enddo enddo ! Loop over properties else do ip = 1 , NTDMARRAY if (. not . associated ( T1 % properties ( ip )% valuesk )) cycle n = T1 % properties ( ip )% nk * T1 % properties ( ip )% np allocate ( temp ( n )) do it = 0 , T1 % L - 1 average => T1 % properties ( ip )% valuesk (:, it , T1 % avg ) error => T1 % properties ( ip )% valuesk (:, it , T1 % err ) binval => T1 % properties ( ip )% valuesk (:, it , 1 ) temp = cmplx (( real ( average - binval )) ** 2 ,( aimag ( average - binval )) ** 2 ) #            ifdef _QMC_MPI call mpi_allreduce ( temp , error , n , mpi_double , mpi_sum , mpi_comm_world , i ) #            endif error = ( nproc - 1 ) * error / nproc error = cmplx ( sqrt ( real ( error )), sqrt ( aimag ( error ))) enddo deallocate ( temp ) enddo ! Loop over properties endif end subroutine DQMC_TDM1_GetErrKFT !--------------------------------------------------------------------! subroutine DQMC_TDM1_PrintKFT ( T1 , OPT ) use dqmc_mpi ! ! Purpose ! ======= !    This subroutine prints properties to file ! ! Arguments ! ========= ! type ( TDM1 ), intent ( in ) :: T1 ! T1 integer , intent ( in ) :: OPT integer :: i , j , k , ip , jp , iprop integer :: np , npp complex ( wp ) :: tmp ( T1 % L , 2 ) character ( len = 10 ) :: label ( T1 % L ) character ( len = 60 ) :: title ! ... Executable ... if (. not . T1 % compute ) return if ( qmc_sim % rank . ne . 0 ) return do j = 1 , T1 % L write ( label ( j ), '(f10.5)' ) ( j - 1 ) * T1 % dtau label ( j ) = adjustl ( label ( j )) enddo do iprop = 1 , NTDMARRAY if (. not . associated ( T1 % properties ( iprop )% valuesk )) cycle np = T1 % properties ( iprop )% np npp = ( np * ( np + 1 )) / 2 do k = 1 , T1 % properties ( iprop )% nk i = ( k - 1 ) * npp do ip = 1 , np do jp = ip , np i = i + 1 do j = 0 , T1 % L - 1 tmp ( j + 1 , 1 : 2 ) = T1 % properties ( iprop )% valuesk ( i , j , T1 % avg : T1 % err ) enddo write ( title , '(A,i3,A,i3,A,i3,A)' ) 'k=' , k , '   pair=' , ip , ',' , jp title = pname ( iprop ) // \" \" // trim ( adjustl ( title )) call DQMC_Print_Array ( 0 , T1 % L , title , label , tmp (:, 1 : 1 ), tmp (:, 2 : 2 ), OPT ) write ( OPT , '(1x)' ) enddo enddo enddo enddo end subroutine DQMC_TDM1_PrintKFT !--------------------------------------------------------------------! subroutine DQMC_TDM1_SelfEnergy ( T1 , tau , OPT ) use DQMC_MPI type ( TDM1 ), intent ( in ) :: T1 type ( gtau ), intent ( inout ) :: tau integer , intent ( in ) :: OPT real ( wp ), allocatable :: g0tau (:,:), tdmg0 (:,:) complex ( wp ), allocatable :: tdmg0k (:,:), tdmgk (:,:) complex ( wp ), allocatable :: tdmg0kw (:,:,:), tdmgkw (:,:,:) complex ( wp ), allocatable :: avgSE (:,:,:), errSE (:,:,:), binSE (:,:,:) integer :: i , j , k , h , m integer :: L , n , nclass , np , nk , npp integer , pointer :: class (:,:) integer , pointer :: ph (:,:) complex ( wp ), pointer :: ftk (:,:) complex ( wp ), pointer :: ftw (:,:) complex ( wp ) :: tmp ( T1 % L , 2 ) character ( len = 10 ) :: label ( T1 % L ) character ( len = 50 ) :: title integer , parameter :: gflist ( 3 ) = ( / IGFUN , IGFUP , IGFDN / ) integer , parameter :: splist ( 3 ) = ( / 0 , TAU_UP , TAU_DN / ) real ( wp ), parameter :: pi = 3.1415926535898 if (. not . T1 % compute ) return L = T1 % L n = T1 % properties ( IGFUN )% n nclass = T1 % properties ( IGFUN )% nclass np = T1 % properties ( IGFUN )% np nk = T1 % properties ( IGFUN )% nk class => T1 % properties ( IGFUN )% D ftk => T1 % properties ( IGFUN )% ftk ftw => T1 % properties ( IGFUN )% ftw ph => T1 % properties ( IGFUN )% phase npp = np * ( np + 1 ) / 2 do j = 1 , L write ( label ( j ), '(f10.5)' ) ( 2 * j - 1 ) * pi / ( T1 % dtau * L ) label ( j ) = adjustl ( label ( j )) enddo !non-interacting green's function allocate ( g0tau ( n , n )) allocate ( tdmg0 ( nclass , 0 : L - 1 )) allocate ( tdmg0k ( nk * npp , 0 : L - 1 )) !temporary storage allocate ( tdmgk ( npp , 0 : L - 1 )) !frequency dependent green's functions allocate ( tdmg0kw ( np , np , 0 : L - 1 )) allocate ( tdmgkw ( np , np , 0 : L - 1 )) !self energy allocate ( avgSE ( np , np , 0 : L - 1 )) allocate ( errSE ( np , np , 0 : L - 1 )) allocate ( binSE ( np , np , 0 : L - 1 )) do h = 1 , 3 ! Get G for the non-interacting system tdmg0 = 0.0_wp do m = 0 , L - 1 call dqmc_Gtau_GetG0 ( n , tau , splist ( h ), m , g0tau ) do i = 1 , n do j = 1 , n k = class ( i , j ) tdmg0 ( k , m ) = tdmg0 ( k , m ) + g0tau ( i , j ) enddo enddo enddo do k = 1 , T1 % properties ( h )% nClass tdmg0 ( k ,:) = tdmg0 ( k ,:) / T1 % properties ( IGFUN )% F ( k ) enddo ! Get G in the k-space do m = 0 , L - 1 call dqmc_getFTk ( tdmg0 (:, m ), n , nclass , class , np , nk , ftk , ph , tdmg0k (:, m )) enddo do k = 1 , nk i = ( k - 1 ) * npp + 1 j = k * npp ! Transform G0 from tau to iwn tdmgk = tdmg0k ( i : j , 0 : L - 1 ) call convert_to_iwn ( tdmgk , tdmg0kw ) call invertG ( tdmg0kw ) ! Transform G from tau to iwn for average tdmgk = T1 % properties ( gflist ( h ))% valuesk ( i : j , 0 : L - 1 , T1 % avg ) call convert_to_iwn ( tdmgk , tdmgkw ) call invertG ( tdmgkw ) !Compute average self-energy avgSE = tdmg0kw - tdmgkw errSE = ZERO do m = 0 , T1 % nbin - 1 ! Transform G from tau to iwn for bin \"m\" tdmgk = T1 % properties ( gflist ( h ))% valuesk ( i : j , 0 : L - 1 , m + 1 ) call convert_to_iwn ( tdmgk , tdmgkw ) call invertG ( tdmgkw ) ! Compute self-energy for bin binSE = tdmg0kw - tdmgkw if ( qmc_sim % size . eq . 1 ) & errSE = errSE + cmplx (( real ( binSE - avgSE )) ** 2 ,( aimag ( binSE - avgSE )) ** 2 ) enddo if ( qmc_sim % size . gt . 1 ) then m = qmc_sim % size ! Reuse tdmgkw for temporary storage tdmgkw = cmplx (( real ( binSE - avgSE )) ** 2 ,( aimag ( binSE - avgSE )) ** 2 ) #            ifdef _QMC_MPI call mpi_allreduce ( tdmgkw , errSE , n , mpi_double_complex , mpi_sum , mpi_comm_world , i ) #            endif endif errSE = cmplx ( sqrt ( real ( errSE )), sqrt ( aimag ( errSE ))) * sqrt ( dble ( m - 1 ) / m ) ! Take care of printing if ( qmc_sim % rank . eq . 0 ) then do i = 1 , np do j = 1 , np tmp ( 1 : L , 1 ) = avgSE ( i , j , 0 : L - 1 ) tmp ( 1 : L , 2 ) = errSE ( i , j , 0 : L - 1 ) write ( title , '(A,i3)' ) trim ( pname ( gflist ( h ))) // \" SelfEn k=\" , k write ( title , '(A,i3,A,i3)' ) trim ( adjustl ( title )) // '   pair=' , i , ',' , j call DQMC_Print_Array ( 0 , L , title , label , tmp (:, 1 : 1 ), tmp (:, 2 : 2 ), OPT ) write ( OPT , '(1x)' ) enddo enddo endif enddo enddo contains subroutine convert_to_iwn ( tdmgtau , tdmgw ) complex ( wp ), intent ( in ) :: tdmgtau ( npp , 0 : L - 1 ) complex ( wp ), intent ( out ) :: tdmgw ( np , np , 0 : L - 1 ) ! Local variables complex ( wp ) :: valuetl ( 0 : L - 1 ), valuewl ( 0 : L - 1 ) integer :: ipl , jpl , ijpl complex ( wp ), parameter :: unum = ( 1.0_wp , 0.0_wp ), nil = ( 0.0_wp , 0.0_wp ) ijpl = 0 do ipl = 1 , np do jpl = ipl , np ijpl = ijpl + 1 valuetl = tdmgtau ( ijpl , 0 : L - 1 ) if ( ipl . eq . jpl ) valuetl ( 0 ) = valuetl ( 0 ) - 0.5_wp call zgemv ( 'N' , L , L , unum , ftw , L , valuetl , 1 , nil , valuewl , 1 ) tdmgw ( ipl , jpl , 0 : L - 1 ) = valuewl if ( ipl . ne . jpl ) then valuetl = conjg ( tdmgtau ( ijpl , 0 : L - 1 )) call zgemv ( 'N' , L , L , unum , ftw , L , valuetl , 1 , nil , valuewl , 1 ) tdmgw ( jpl , ipl , 0 : L - 1 ) = valuewl endif enddo enddo end subroutine convert_to_iwn subroutine invertG ( tdmgw ) complex ( wp ), target , intent ( inout ) :: tdmgw ( np , np , 0 : L - 1 ) ! Local variables complex ( wp ) :: work ( np ) complex ( wp ), pointer :: gw (:,:) integer :: ipiv ( np ) integer :: iwl , info do iwl = 0 , L - 1 ! Fill matrix. Note that G is complex symmetric. Not hermitian. gw => tdmgw ( 1 : np , 1 : np , iwl ) call zgetrf ( np , np , gw , np , ipiv , info ) call zgetri ( np , gw , np , ipiv , work , np , info ) enddo end subroutine invertG end subroutine DQMC_TDM1_SelfEnergy !--------------------------------------------------------------------! end module DQMC_TDM1","tags":"","loc":"sourcefile/dqmc_tdm1.f90.html"},{"title":"dqmc_latt.F90 – Quest","text":"This file depends on sourcefile~~dqmc_latt.f90~~EfferentGraph sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~dqmc_latt.f90~~AfferentGraph sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_kbonds.f90 dqmc_kbonds.F90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_LATT use DQMC_GEOM_PARAM use DQMC_UTIL implicit none type :: lattice_t integer :: nsites !number of total sites integer :: natom !number of sites inside the primitive cell integer :: ncell !number of cells inside supercell integer :: ndim !number of extended dimensions integer :: sc ( rdim , rdim ) !fractionary components of supercell** real * 8 :: ac ( rdim , rdim ) !cartesian components of primitive cell** real * 8 :: scc ( rdim , rdim ) !cartesian components of supercell** real * 8 , pointer :: pos (:,:) !fractionary position of each site (rdim,0,nsites-1) real * 8 , pointer :: cartpos (:,:) !cartesian coordinates of each site (rdim,0,nsites-1) real * 8 , pointer :: xat (:,:) !fractional coordinate of site inside primitive cell(rdim,0:natom-1) real * 8 , pointer :: phase (:) !Phase for order parameter(0:nsites-1) real * 8 , pointer :: translation (:,:) !list of translation vectors(columns)(rdim,0:ncell-1) !** columns of these matrices are the vectors integer :: nclass !number of classes for distance integer , pointer :: myclass (:,:) !class for pair of sites (0:nsites-1, 0:nsites-1) integer , pointer :: class_size (:) !number of equivalent pairs in each class (nclass) real * 8 , pointer :: class_label (:,:) !label for pair classes integer , pointer :: gf_phase (:,:) character * 3 , pointer :: olabel (:) !label of each site in primitive cell logical :: initialized logical :: constructed logical :: analyzed end type lattice_t contains !--------------------------------------------------------------------! subroutine free_lattice ( latt ) type ( lattice_t ), intent ( inout ) :: latt if ( associated ( latt % pos )) deallocate ( latt % pos ) if ( associated ( latt % xat )) deallocate ( latt % xat ) if ( associated ( latt % phase )) deallocate ( latt % phase ) if ( associated ( latt % olabel )) deallocate ( latt % olabel ) if ( associated ( latt % cartpos )) deallocate ( latt % cartpos ) if ( associated ( latt % myclass )) deallocate ( latt % myclass ) if ( associated ( latt % gf_phase )) deallocate ( latt % gf_phase ) if ( associated ( latt % class_size )) deallocate ( latt % class_size ) if ( associated ( latt % translation )) deallocate ( latt % translation ) if ( associated ( latt % class_label )) deallocate ( latt % class_label ) end subroutine free_lattice !--------------------------------------------------------------------- ! Read and fill most of the variables that define the lattices in ! real and reciprocal space. !--------------------------------------------------------------------- subroutine init_lattice ( lattice , SOP ) integer , intent ( in ) :: SOP integer :: ndim , nsites , natom , ncell , ios , i , j real * 8 :: ainv ( rdim , rdim ) real * 8 , pointer :: ac (:,:) real * 8 , pointer :: scc (:,:) integer , pointer :: sc (:,:) character * 3 :: olab1 character * 50 :: string logical :: ldum type ( lattice_t ), target :: lattice !alias arrays sc => lattice % sc scc => lattice % scc ac => lattice % ac !Read number of dimensions ldum = move_to_record ( INPUT_FIELDS ( NDIM_F ), inpunit ) read ( inpunit , * , iostat = ios ) ndim if ( ios /= 0 ) stop ' Problem reading #NDIM field. Stop.' !read basis cell vectors(cartesian). Basis vectors are columns of ac. ldum = move_to_record ( INPUT_FIELDS ( PRIM_F ), inpunit ) ac (:,:) = 0.d0 do j = 1 , ndim read ( inpunit , * , iostat = ios )( ac ( i , j ), i = 1 , ndim ) enddo do j = ndim + 1 , rdim ac ( j , j ) = 1.d3 enddo !read(inpunit,*,iostat=ios)((ac(i,j),i=1,rdim),j=1,rdim) if ( ios /= 0 ) stop ' Problem reading #PRIM field. Stop.' !read supercell vectors in unit of the basis ones. Vectors are columns of sc. ldum = move_to_record ( INPUT_FIELDS ( SUPER_F ), inpunit ) sc (:,:) = 0 if ( ndim > 0 ) then do j = 1 , ndim read ( inpunit , * , iostat = ios )( sc ( i , j ), i = 1 , ndim ) enddo if ( ios /= 0 ) stop ' Problem reading #SUPER field. Stop.' do i = ndim + 1 , rdim sc ( i , i ) = 1 enddo endif !compute number of primitive cell inside the supercell !Use scc as temporary real*8 array scc (:,:) = dble ( sc (:,:)) ncell = nint ( abs ( get_det ( scc ))) !find cartesian component of the supercell do i = 1 , rdim do j = 1 , rdim scc ( i , j ) = sum ( ac ( i ,:) * sc (:, j )) enddo enddo !cartesian coordinates for each orbital natom = count_atom () nsites = ncell * natom ldum = move_to_record ( INPUT_FIELDS ( ORB_F ), inpunit ) allocate ( lattice % olabel ( 0 : natom - 1 ), lattice % xat ( rdim , 0 : natom - 1 )) do i = 0 , natom - 1 read ( inpunit , '(A)' ) string read ( string , * , iostat = ios ) olab1 , lattice % xat ( 1 : rdim , i ) if ( ios /= 0 ) stop ' Problem reading #ORB field. Stop.' lattice % olabel ( i ) = olab1 enddo !load values on lattice lattice % natom = natom lattice % nsites = nsites lattice % ndim = ndim lattice % ncell = ncell !convert cartesian atomic coordinates call get_inverse ( ac , ainv ) do i = 0 , natom - 1 call convert_to_fractional ( lattice % xat ( 1 : rdim , i ), ainv ) enddo lattice % initialized = . true . !write to stdout write ( SOP , * ) '================================================================' write ( SOP , * ) 'Basic real space geometry info' write ( SOP , * ) write ( SOP , * ) 'Crystal atomic basis' write ( SOP , '(i3,3f14.7)' )( j , lattice % xat ( 1 : rdim , j ), j = 0 , natom - 1 ) write ( SOP , * ) write ( SOP , * ) 'Basis cell vectors' write ( SOP , '(3f14.7)' )(( ac ( i , j ), i = 1 , rdim ), j = 1 , rdim ) write ( SOP , * ) write ( SOP , '(/,A)' ) ' Supercell vectors (fractionary unit)' write ( SOP , '(3i5)' )(( sc ( i , j ), i = 1 , rdim ), j = 1 , rdim ) write ( SOP , * ) write ( SOP , * ) 'Super-Lattice vectors (cartesian)' write ( SOP , '(3f14.7)' )(( scc ( i , j ), i = 1 , rdim ), j = 1 , rdim ) write ( SOP , * ) write ( SOP , * ) '================================================================' end subroutine init_lattice !----------------------------------------------------------------------- ! Construct the real space lattice. !----------------------------------------------------------------------- subroutine construct_lattice ( lattice , SOP ) type ( lattice_t ), intent ( inout ), target :: lattice integer , intent ( in ) :: SOP integer :: natom , nsites , iat , jat , xxmax ( rdim ), xxmin ( rdim ), ix , iy , iz , icount , j , jcount , ndim , it real * 8 , pointer :: ac (:,:) real * 8 , pointer :: pos (:,:) real * 8 , pointer :: xat (:,:) real * 8 , pointer :: cartpos (:,:) real * 8 , pointer :: translation (:,:) integer , pointer :: sc (:,:) real * 8 :: projk ( rdim ), xxat ( rdim ), xx ( rdim ), invscc ( rdim , rdim ), ainv ( rdim , rdim ), cmin , cmax if (. not . lattice % initialized ) stop 'Need to initialize lattice before construct_lattice' !Initialize local variables/pointers ndim = lattice % ndim natom = lattice % natom nsites = lattice % nsites sc => lattice % sc ac => lattice % ac xat => lattice % xat allocate ( pos ( rdim , 0 : nsites - 1 ), cartpos ( rdim , 0 : nsites - 1 ), translation ( rdim , 0 : lattice % ncell - 1 )) !find a supercell that includes the previous one and which is an \"easy\" multiple of the primitive xxmax (:) = max ( sc (:, 1 ), sc (:, 2 ), sc (:, 3 ), sc (:, 1 ) + sc (:, 2 ), sc (:, 1 ) + sc (:, 3 ), sc (:, 2 ) + sc (:, 3 ), sc (:, 1 ) + sc (:, 2 ) + sc (:, 3 ), 0 ) xxmin (:) = min ( sc (:, 1 ), sc (:, 2 ), sc (:, 3 ), sc (:, 1 ) + sc (:, 2 ), sc (:, 1 ) + sc (:, 3 ), sc (:, 2 ) + sc (:, 3 ), sc (:, 1 ) + sc (:, 2 ) + sc (:, 3 ), 0 ) !Find lattice points inside the supercell without counting the !ones on edge twice icount =- 1 call get_inverse ( lattice % scc , invscc ) do iz = xxmin ( 3 ), xxmax ( 3 ) - 1 do iy = xxmin ( 2 ), xxmax ( 2 ) - 1 do ix = xxmin ( 1 ), xxmax ( 1 ) - 1 xx ( 1 ) = dble ( ix ); xx ( 2 ) = dble ( iy ); xx ( 3 ) = dble ( iz ) !cartesian coordinates do j = 1 , rdim xxat ( j ) = sum ( xx (:) * ac ( j ,:)) enddo !Project to see if inside supercell do j = 1 , rdim projk ( j ) = sum ( xxat (:) * invscc ( j ,:)) enddo cmin = minval ( projk ); cmax = maxval ( projk ) !If inside add it to the list of translations if ( cmin >- toll . and . cmax < 1.d0 + toll ) then jcount = icount + 1 !If on edge check whether translation has already  been added if ( cmin < toll . and . cmax > 1.d0 - toll ) then !Ok, lattice point is on the edge of supercell do jcount = 0 , icount !See whether it differs by an already stored translation by a !vector belonging to the super-lattice and.... do j = 1 , rdim projk ( j ) = sum (( xxat (:) - translation (:, jcount )) * invscc ( j ,:)) enddo projk ( 1 : ndim ) = projk ( 1 : ndim ) - nint ( projk ( 1 : ndim )) !...exit the loop if it does if ( sum ( projk ( 1 : rdim ) ** 2 ) < toll ) exit enddo endif !Found new lattice point if ( jcount > icount ) then translation (:, jcount ) = xxat (:) icount = jcount endif endif enddo enddo enddo !Deal with the  orbitals in such a way that the set [0,1...natom-1] !is translated into a set of the form [natom*it,natom*it+1,....,natom*(it+1)-1] !for any arbitrary translation (\"it\" is an integer running from 0 to ncell-1) call get_inverse ( ac , ainv ) do iat = 0 , natom - 1 do j = 1 , rdim xxat ( j ) = sum ( xat (:, iat ) * ac ( j ,:)) enddo do it = 0 , lattice % ncell - 1 jat = iat + natom * it cartpos (:, jat ) = xxat (:) + translation (:, it ) do j = 1 , rdim pos ( j , jat ) = sum ( cartpos (:, jat ) * ainv ( j ,:)) enddo enddo enddo !Printing out write ( SOP , * ) 'Real space lattice' write ( SOP , * ) write ( SOP , * ) 'Number of orbitals in primitive cell: ' , natom write ( SOP , * ) 'Total number of orbitals:             ' , nsites write ( SOP , * ) 'index  label   type       X           Y         Z   ' do iat = 0 , nsites - 1 icount = mod ( iat , natom ) write ( SOP , '(i3,1x,A,1x,i3,3f14.5)' ) iat , lattice % olabel ( icount ), icount ,( cartpos ( j , iat ), j = 1 , 3 ) enddo write ( SOP , * ) '================================================================' lattice % pos => pos lattice % cartpos => cartpos lattice % translation => translation lattice % constructed = . true . !51 format(i4,5x,A3,3x,i4,5(1x,f10.5)) end subroutine !---------------------------------------------------------- !Count the number of sites in the primitive cell !---------------------------------------------------------- integer function count_atom () result ( natom ) character * 50 :: string character * 3 :: olab1 integer :: ios real * 8 :: x , y , z logical :: ldum rewind ( inpunit ) ldum = move_to_record ( INPUT_FIELDS ( ORB_F ), inpunit ) natom = 0 do read ( inpunit , '(A)' ) string read ( string , * , iostat = ios ) olab1 , x , y , z if ( ios . ne . 0 ) exit natom = natom + 1 enddo rewind ( inpunit ) end function count_atom !------------------------------------------------------------- !Given cartesian coordinates in 3D space returns coordinates !in units of primitive cell vectors. !------------------------------------------------------------- subroutine convert_to_fractional ( xat , ainv ) integer :: h real * 8 , intent ( inout ) :: xat ( rdim ) real * 8 , intent ( in ) :: ainv ( rdim , rdim ) real * 8 :: xc ( rdim ) xc (:) = xat (:) do h = 1 , 3 xat ( h ) = sum ( ainv ( h ,:) * xc (:)) enddo end subroutine convert_to_fractional !------------------------------------------------------------------------------ !Returns phase(iat). Each orbital iat has now a phase (often +1 or -1). !In input one specify a supercell (that must be contained in the !bigger supercell used in simulation) and a phase for each of the orbitals !inside it. Translational symmetry is then used to transfer the phase !to the entire system. !------------------------------------------------------------------------------ subroutine assign_phase ( lattice ) type ( lattice_t ) :: lattice integer :: pc ( rdim , rdim ), i , iat , jat , j , natom_ph , ios , ndim , nsites , natom real * 8 :: rpc ( rdim , rdim ), volume_ph , inv ( rdim , rdim ), projph ( rdim , rdim ),& & diff ( rdim ), projph2 ( rdim ), ainv ( rdim , rdim ) character * 50 :: string character * 3 :: olab1 real * 8 , allocatable :: xat_ph (:,:), tmp_phase (:) real * 8 , pointer :: phase (:) logical :: phase_assigned ( 0 : lattice % nsites - 1 ) ndim = lattice % ndim nsites = lattice % nsites natom = lattice % natom if ( move_to_record ( INPUT_FIELDS ( PHASE_F ), inpunit )) then !Read the phase cell (pc) pc (:,:) = 0 if ( ndim > 0 ) then read ( inpunit , * )(( pc ( i , j ), i = 1 , ndim ), j = 1 , ndim ) do i = ndim + 1 , rdim ; pc ( i , i ) = 1 ; enddo endif !Compute the volume of phase cell rpc ( 1 : rdim , 1 : rdim ) = dble ( pc ( 1 : rdim , 1 : rdim )) volume_ph = abs ( get_det ( rpc )) !check that the supercell is a multiple of the phase cell call get_inverse ( rpc , inv ) do i = 1 , rdim do j = 1 , rdim projph ( i , j ) = sum ( lattice % sc (:, j ) * inv ( i ,:)) enddo enddo projph (:,:) = ( projph (:,:) - nint ( projph (:,:))) ** 2 if ( sqrt ( sum ( projph )) > toll ) stop 'Supercell frustrates the phase. Stop.' !Read atom positions and their phases natom_ph = nint ( volume_ph * natom ) allocate ( phase ( 0 : nsites - 1 ), xat_ph ( rdim , 0 : natom_ph - 1 ), tmp_phase ( 0 : natom_ph - 1 )) do iat = 0 , natom_ph - 1 read ( inpunit , '(A)' ) string read ( string , * , iostat = ios ) olab1 ,( xat_ph ( i , iat ), i = 1 , rdim ), tmp_phase ( iat ) if ( ios . ne . 0 ) stop 'Problem with reading phases.' enddo !need to use inv corresponding to primitive cell call get_inverse ( lattice % ac , ainv ) do iat = 0 , natom_ph - 1 call convert_to_fractional ( xat_ph ( 1 , iat ), ainv ) enddo phase_assigned (:) = . false . !Assign the same phase to all sites equivalent by \"phase-cell\" translation do iat = 0 , natom_ph - 1 do jat = 0 , nsites - 1 if ( phase_assigned ( jat )) cycle !Determine whether site jat has the phase of iat diff (:) = xat_ph (:, iat ) - lattice % pos (:, jat ) do i = 1 , rdim projph2 ( i ) = sum ( diff (:) * inv ( i ,:)) enddo projph2 (:) = ( projph2 (:) - nint ( projph2 (:))) ** 2 if ( sqrt ( sum ( projph2 )) < toll ) then !Assign to jat the phase of iat phase ( jat ) = tmp_phase ( iat ) phase_assigned ( jat ) = . true . endif enddo enddo !Store phase lattice % phase => phase deallocate ( xat_ph , tmp_phase ) endif end subroutine assign_phase !----------------------------------------------------------------------------- ! Given site and displacement in cartesian coordinates it returns the site ! to which the particle lands onto. The numerical label of the site is ! necessary since we are not excluding the case of two orbitals sitting ! at the same site (like Wannier function). !---------------------------------------------------------------------------- integer function hoptowho ( iat , delta , jat , lattice ) type ( lattice_t ), intent ( in ) :: lattice integer , intent ( in ) :: iat , jat integer :: i , j , ndim real * 8 , intent ( in ) :: delta ( rdim ) real * 8 :: projk ( rdim ), xxat ( rdim ), invscc ( rdim , rdim ), xx ( rdim ) real * 8 , pointer :: cartpos (:,:) if (. not . lattice % constructed ) stop 'Need to construct lattice before hoptowho' cartpos => lattice % cartpos ndim = lattice % ndim call get_inverse ( lattice % scc , invscc ) !determine position after hopping xxat (:) = cartpos (:, iat ) + delta (:) !Try to determine whether xxat corresponds to a site do j = jat , lattice % nsites - 1 , lattice % natom !compute distance vector in units of the supercell vectors xx (:) = cartpos (:, j ) - xxat (:) do i = 1 , rdim projk ( i ) = sum ( xx (:) * invscc ( i ,:)) enddo projk ( 1 : ndim ) = projk ( 1 : ndim ) - nint ( projk ( 1 : ndim )) if ( sum ( projk (:) ** 2 ) < toll ) exit enddo if ( j >= lattice % nsites ) then !No site was found write ( * , * ) 'Can''t find where' , iat , ' hops.' stop else hoptowho = j endif end function subroutine assign_gf_phase ( lattice , twist ) type ( lattice_t ), intent ( inout ) :: lattice real * 8 , intent ( in ) :: twist ( 3 ) integer :: i , j , n , natom , ic , csize real * 8 :: d ( 3 ), d0 ( 3 ), rphase , iphase n = lattice % nsites natom = lattice % natom allocate ( lattice % gf_phase ( 0 : n - 1 , 0 : n - 1 )) do ic = 1 , lattice % nclass csize = 0 do j = 0 , n - 1 do i = 0 , n - 1 if ( lattice % myclass ( i , j ) /= ic ) cycle d = lattice % translation (:, j / natom ) - lattice % translation (:, i / natom ) if ( csize == 0 ) then d0 = d lattice % gf_phase ( j , i ) = 1 else rphase = cos ( sum ( twist * ( d0 - d ))) iphase = sin ( sum ( twist * ( d0 - d ))) if ( abs ( iphase ) < 1.d-6 ) then if ( abs ( rphase - nint ( rphase )) < 1.d-6 ) then lattice % gf_phase ( j , i ) = nint ( rphase ) endif else rphase = cos ( sum ( twist * ( d0 + d ))) iphase = sin ( sum ( twist * ( d0 + d ))) if ( abs ( iphase ) < 1.d-6 ) then if ( abs ( rphase - nint ( rphase )) < 1.d-6 ) then lattice % gf_phase ( j , i ) = nint ( rphase ) else stop 'problem with phase' endif endif endif endif csize = csize + 1 enddo enddo if ( csize /= lattice % class_size ( ic )) stop 'problem with classes' enddo end subroutine !type(lattice_t), intent(inout) :: lattice !real*8, intent(in) :: twist(3) !integer :: i, j, k, n, natom, ic, jt, i0, j0, iat, jat !real*8 :: R(3), delta(3) !complex*16 :: phase1, phase2 !n=lattice%nsites !natom=lattice%natom !allocate(lattice%gf_phase(0:n-1,0:n-1)) !!Loop over cell !do ic=0,lattice%ncell-1 !   !loop over translation !   do jt=0,lattice%ncell-1 !      delta(:)=lattice%translation(:,jt) !      !Find the two sites (orbital 0) connected by delta !      i0=natom*ic !      j0=hoptowho(i0,delta,0,lattice) !      !Compute the winding vector !      R=lattice%cartpos(:,j0)-lattice%cartpos(:,i0)-delta !      phase=exp(-im*sum(R*twist)) !      !Loop over all orbitals contained in the two cells !      do iat=0,natom-1 !         do jat=0,natom-1 !            i=i0+iat !            j=j0+jat !            lattice%gf_phase(j,i)=phase !         enddo !      enddo !   enddo !enddo end module DQMC_LATT","tags":"","loc":"sourcefile/dqmc_latt.f90.html"},{"title":"ggeom.F90 – Quest","text":"This file depends on sourcefile~~ggeom.f90~~EfferentGraph sourcefile~ggeom.f90 ggeom.F90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~ggeom.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~ggeom.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_mpi.f90 dqmc_mpi.F90 sourcefile~ggeom.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_omp.f90 dqmc_omp.F90 sourcefile~ggeom.f90->sourcefile~dqmc_omp.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_geom_param.f90 dqmc_geom_param.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_mpi.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_geom_param.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program dqmc_ggeom use dqmc_cfg use dqmc_geom_wrap use dqmc_hubbard use dqmc_mpi use dqmc_tdm1 use dqmc_omp implicit none integer :: t1 , t2 , rate type ( config ) :: cfg type ( Hubbard ) :: Hub type ( GeomWrap ) :: Gwrap type ( tdm1 ) :: tm type ( Gtau ) :: tau type ( tdm1 ), pointer :: ptm (:) type ( Gtau ), pointer :: ptau (:) character ( len = slen ) :: gfile logical :: tformat integer :: na , nt , nkt , nkg , i , j , k , slice , nhist , comp_tdm integer :: nBin , nIter character ( len = 60 ) :: ofile integer :: OPT !integer             :: HSF_output_file_unit integer :: symmetries_output_file_unit integer :: FLD_UNIT , TDM_UNIT real ( wp ) :: randn ( 1 ) integer :: nproc call system_clock ( t1 ) !Setup OpenMP environment call DQMC_OMP_Init ( nproc ) !Count the number of processors call DQMC_MPI_Init ( qmc_sim , PLEVEL_1 ) !Read input call DQMC_Read_Config ( cfg ) !Get output file name header call CFG_Get ( cfg , \"ofile\" , ofile ) !Get general geometry input call CFG_Get ( cfg , \"gfile\" , gfile ) !Save whether to use refinement for G used in measurements. call CFG_Get ( cfg , \"nhist\" , nhist ) !if (nhist > 0) then !   call DQMC_open_file(adjustl(trim(ofile))//'.HSF.stream','unknown', HSF_output_file_unit) !endif call DQMC_open_file ( adjustl ( trim ( ofile )) // '.geometry' , 'unknown' , symmetries_output_file_unit ) !Determines type of geometry file call DQMC_Geom_Read_Def ( Hub % S , gfile , tformat ) if (. not . tformat ) then !If free format fill gwrap call DQMC_Geom_Fill ( Gwrap , gfile , cfg , symmetries_output_file_unit ) !Transfer info in Hub%S call DQMC_Geom_Init ( Gwrap , Hub % S , cfg ) endif call DQMC_Geom_Print ( Hub % S , symmetries_output_file_unit ) ! Initialize the rest data call DQMC_Hub_Config ( Hub , cfg ) ! Perform input parameter checks if ( Hub % nTry >= Gwrap % Lattice % nSites ) then write ( * , * ) write ( * , \"('  number of lattice sites =',i5)\" ) Gwrap % Lattice % nSites write ( * , \"('  ntry =',i5)\" ) Hub % nTry write ( * , * ) \" Input 'ntry' exceeds the number of lattice sites.\" write ( * , * ) \" Please reset 'ntry' such that it is less than\" write ( * , * ) \" the number of lattice sites.\" write ( * , * ) \" Program stopped.\" stop end if ! Initialize time dependent properties if comp_tdm > 0 call CFG_Get ( cfg , \"tdm\" , comp_tdm ) if ( comp_tdm > 0 ) then call DQMC_open_file ( adjustl ( trim ( ofile )) // '.tdm.out' , 'unknown' , TDM_UNIT ) call DQMC_Gtau_Init ( Hub , tau ) call DQMC_TDM1_Init ( Hub % L , Hub % dtau , tm , Hub % P0 % nbin , Hub % S , Gwrap ) if ( nproc > 1 ) then write ( * , * ) \"Initializing multi-core working space.\" allocate ( ptau ( tau % nb * tau % nb )) do i = 1 , tau % nb * tau % nb call DQMC_Gtau_Init ( Hub , ptau ( i )) enddo do i = 1 , tau % nb * tau % nb ptau ( i )% A_up => tau % A_up ptau ( i )% A_dn => tau % A_dn ptau ( i )% itau_up => tau % itau_up ptau ( i )% itau_dn => tau % itau_dn ptau ( i )% sgnup => tau % sgnup ptau ( i )% sgndn => tau % sgndn ptau ( i )% V_up => tau % V_up ptau ( i )% V_dn => tau % V_dn ptau ( i )% B_up => tau % B_up ptau ( i )% B_dn => tau % B_dn enddo allocate ( ptm ( tau % nb * tau % nb )) do i = 1 , tau % nb * tau % nb call DQMC_TDM1_Init ( Hub % L , Hub % dtau , ptm ( i ), Hub % P0 % nbin , Hub % S , Gwrap ) enddo endif endif ! Warmup sweep do i = 1 , Hub % nWarm if ( mod ( i , 10 ) == 0 ) write ( * , '(A,i6,1x,i3)' ) ' Warmup Sweep, nwrap  : ' , i , Hub % G_up % nwrap call DQMC_Hub_Sweep ( Hub , NO_MEAS0 ) call DQMC_Hub_Sweep2 ( Hub , Hub % nTry ) end do ! We divide all the measurement into nBin, ! each having nPass/nBin pass. nBin = Hub % P0 % nBin nIter = Hub % nPass / Hub % tausk / nBin if ( nIter > 0 ) then do i = 1 , nBin do j = 1 , nIter do k = 1 , Hub % tausk call DQMC_Hub_Sweep ( Hub , NO_MEAS0 ) call DQMC_Hub_Sweep2 ( Hub , Hub % nTry ) enddo ! Fetch a random slice for measurement call ran0 ( 1 , randn , Hub % seed ) slice = ceiling ( randn ( 1 ) * Hub % L ) write ( * , '(a,3i6)' ) ' Measurement Sweep, bin, iter, slice : ' , i , j , slice if ( comp_tdm > 0 ) then ! Compute full Green's function call DQMC_Gtau_LoadA ( tau , TAU_UP , slice , Hub % G_up % sgn ) call DQMC_Gtau_LoadA ( tau , TAU_DN , slice , Hub % G_dn % sgn ) ! Measure equal-time properties call DQMC_Hub_FullMeas ( Hub , tau % nnb , tau % A_up , tau % A_dn , tau % sgnup , tau % sgndn ) ! Measure time-dependent properties if ( nproc > 1 ) then call DQMC_TDM1_Meas_Para ( tm , ptm , tau , ptau ) else call DQMC_TDM1_Meas ( tm , tau ) endif else if ( comp_tdm == 0 ) then call DQMC_Hub_Meas ( Hub , slice ) endif !Write fields !if (nhist > 0) call DQMC_Hub_Output_HSF(Hub, .false., slice, HSF_output_file_unit) end do ! Accumulate results for each bin call DQMC_Phy0_Avg ( Hub % P0 ) call DQMC_tdm1_Avg ( tm ) if ( Hub % meas2 ) then if ( Hub % P2 % diagonalize ) then call DQMC_Phy2_Avg ( Hub % P2 , Hub % S ) else call DQMC_Phy2_Avg ( Hub % P2 , Hub % S % W ) endif end if end do endif !Read configurations from file if no sweep was perfomed if ( Hub % nWarm + Hub % nPass == 0 ) then Hub % nMeas = - 1 call DQMC_count_records ( Hub % npass , FLD_UNIT ) nIter = Hub % npass / nbin do i = 1 , nBin do j = 1 , nIter / qmc_sim % aggr_size call DQMC_Hub_Input_HSF ( Hub , . false ., slice , FLD_UNIT ) call DQMC_Hub_Init_Vmat ( Hub ) if ( comp_tdm > 0 ) then ! Compute full Green's function - if fullg is on - call DQMC_Gtau_LoadA ( tau , TAU_UP , slice , Hub % G_up % sgn ) call DQMC_Gtau_LoadA ( tau , TAU_DN , slice , Hub % G_dn % sgn ) ! Measure equal-time properties. Pass gtau in case fullg was computed. call DQMC_Hub_FullMeas ( Hub , tau % nb , & tau % A_up , tau % A_dn , tau % sgnup , tau % sgndn ) ! Measure time-dependent properties. Reuses fullg when possible. call DQMC_TDM1_Meas ( tm , tau ) else if ( comp_tdm == 0 ) then call DQMC_Hub_Meas ( Hub , slice ) endif enddo call DQMC_Phy0_Avg ( Hub % P0 ) call DQMC_TDM1_Avg ( tm ) if ( Hub % meas2 ) then if ( Hub % P2 % diagonalize ) then call DQMC_Phy2_Avg ( Hub % P2 , Hub % S ) else call DQMC_Phy2_Avg ( Hub % P2 , Hub % S % W ) endif end if enddo endif !Compute average and error call DQMC_Phy0_GetErr ( Hub % P0 ) call DQMC_TDM1_GetErr ( tm ) if ( Hub % meas2 ) then call DQMC_Phy2_GetErr ( Hub % P2 ) end if ! Prepare output file call DQMC_open_file ( adjustl ( trim ( ofile )) // '.out' , 'unknown' , OPT ) ! Print computed results call DQMC_Hub_OutputParam ( Hub , OPT ) call DQMC_Phy0_Print ( Hub % P0 , Hub % S , OPT ) call DQMC_TDM1_Print ( tm , TDM_UNIT ) !Aliases for Fourier transform na = Gwrap % lattice % natom nt = Gwrap % lattice % ncell nkt = Gwrap % RecipLattice % nclass_k nkg = Gwrap % GammaLattice % nclass_k !Print info on k-points and construct clabel call DQMC_Print_HeaderFT ( Gwrap , OPT , . true .) call DQMC_Print_HeaderFT ( Gwrap , OPT , . false .) !Compute Fourier transform call DQMC_phy0_GetFT ( Hub % P0 , Hub % S % D , Hub % S % gf_phase , Gwrap % RecipLattice % FourierC , & Gwrap % GammaLattice % FourierC , nkt , nkg , na , nt ) call DQMC_Phy0_GetErrFt ( Hub % P0 ) call DQMC_Phy0_PrintFT ( Hub % P0 , na , nkt , nkg , OPT ) !Compute Fourier transform and error for TDM's call DQMC_TDM1_GetKFT ( tm ) call DQMC_TDM1_GetErrKFT ( tm ) call DQMC_TDM1_PrintKFT ( tm , TDM_UNIT ) !Compute and print the self-energy call DQMC_TDM1_SelfEnergy ( tm , tau , TDM_UNIT ) if ( Hub % P2 % compute ) then if ( Hub % P2 % diagonalize ) then !Obtain waves from diagonalization call DQMC_Phy2_GetIrrep ( Hub % P2 , Hub % S ) !Get error for waves call DQMC_Phy2_GetErrIrrep ( Hub % P2 , Hub % P0 % G_fun , Hub % S ) !Analyze symmetry of pairing modes call DQMC_Phy2_WaveSymm ( Hub % S , Hub % P2 , Gwrap % SymmOp ) !Print Pairing info call dqmc_phy2_PrintSymm ( Hub % S , Hub % P2 , OPT ) else call dqmc_phy2_print ( Hub % P2 , Hub % S % wlabel , OPT ) endif endif ! Clean up the used storage call DQMC_TDM1_Free ( tm ) call DQMC_Hub_Free ( Hub ) call DQMC_Config_Free ( cfg ) if ( nproc > 1 ) then deallocate ( ptm ) deallocate ( ptau ) endif call system_clock ( t2 , rate ) call DQMC_MPI_Final ( qmc_sim ) write ( STDOUT , * ) \"Running time:\" , ( t2 - t1 ) / REAL ( rate ), \"(second)\" close ( symmetries_output_file_unit ) end program dqmc_ggeom","tags":"","loc":"sourcefile/ggeom.f90.html"},{"title":"dqmc_util.F90 – Quest","text":"Files dependent on this one sourcefile~~dqmc_util.f90~~AfferentGraph sourcefile~dqmc_util.f90 dqmc_util.F90 sourcefile~dqmc_2dperl.f90 dqmc_2dperl.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_cfg.f90 dqmc_cfg.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hubbard.f90 dqmc_hubbard.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_struct.f90 dqmc_struct.F90 sourcefile~dqmc_2dperl.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_cfg.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_checkerboard.f90 dqmc_checkerboard.F90 sourcefile~dqmc_checkerboard.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_checkerboard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_wspace.f90 dqmc_wspace.F90 sourcefile~dqmc_checkerboard.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_gfun.f90 dqmc_gfun.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90 dqmc_matb.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90 dqmc_seqb.F90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gfun.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_gtau.f90 dqmc_gtau.F90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_hubbard.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_gtau.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_holstein.f90 dqmc_holstein.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_phy0.f90 dqmc_phy0.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_phy2.f90 dqmc_phy2.F90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_holstein.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_gfun.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy0.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_seqb.f90 sourcefile~dqmc_hubbard.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_latt.f90 dqmc_latt.F90 sourcefile~dqmc_latt.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_matb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_phy0.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_symm.f90 dqmc_symm.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_bonds.f90 dqmc_bonds.F90 sourcefile~dqmc_phy2.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_matb.f90 sourcefile~dqmc_seqb.f90->sourcefile~dqmc_wspace.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_struct.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_hamilt.f90 dqmc_hamilt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_reclatt.f90 dqmc_reclatt.F90 sourcefile~dqmc_symm.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_tdm1.f90 dqmc_tdm1.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_gtau.f90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_geom_wrap.f90 dqmc_geom_wrap.F90 sourcefile~dqmc_tdm1.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~dqmc_tdm2.f90 dqmc_tdm2.F90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_phy2.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_tdm2.f90->sourcefile~dqmc_tdm1.f90 sourcefile~dqmc_wspace.f90->sourcefile~dqmc_util.f90 sourcefile~dqmc_bonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_geom.f90 dqmc_geom.F90 sourcefile~dqmc_geom.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_struct.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_bonds.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_hamilt.f90 sourcefile~dqmc_geom_wrap.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_hamilt.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_kbonds.f90 dqmc_kbonds.F90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_latt.f90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_symm.f90 sourcefile~dqmc_kbonds.f90->sourcefile~dqmc_reclatt.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_cfg.f90 sourcefile~dqmc_reclatt.f90->sourcefile~dqmc_latt.f90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_cfg.f90 sourcefile~ggeom.f90->sourcefile~dqmc_hubbard.f90 sourcefile~ggeom.f90->sourcefile~dqmc_tdm1.f90 sourcefile~ggeom.f90->sourcefile~dqmc_geom_wrap.f90 sourcefile~test.f90 test.F90 sourcefile~test.f90->sourcefile~dqmc_2dperl.f90 sourcefile~verify.f90 verify.F90 sourcefile~verify.f90->sourcefile~dqmc_2dperl.f90 sourcefile~verify.f90->sourcefile~dqmc_hubbard.f90 sourcefile~verify.f90->sourcefile~dqmc_phy0.f90 sourcefile~verify.f90->sourcefile~dqmc_struct.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_Util !  use LAPACK_MOD !  use BLAS_MOD implicit none ! ! This module contains basic utilities used by other DQMC codes. ! It also defines basic parameters. ! ! Subroutine List ! =============== ! !    DQMC_MatDiff(A, B) : evaluates the difference of two matrices. !    DQMC_Eye(A)        : returns A as an identity matrix. !    DQMC_ScaleCol(n, A, D, inv) : compute A*D or A*inv(D) !    DQMC_ScaleRow(n, A, D, inv) : compute D*A or inv(D)*A !    Error(message, no) : print out an error message and stop the program. !    ran0(n, var, seed)     : random number generators !    ran2(idum) result(ran) : random number generators from old program. !    dumpA(A, m, n, OPT): print out the content of A ! ! Parameters ! ========== ! integer , parameter :: WP = kind ( 1.0d0 ) ! work precision real ( WP ), parameter :: ZERO = 0.0D0 ! constant 0 real ( WP ), parameter :: ONE = 1.0D0 ! constant 1 real ( WP ), parameter :: TWO = 2.0D0 ! constant 1 real ( WP ), parameter :: HALF = 0.5D0 ! constant 1 integer , parameter :: STDERR = 0 ! standard error output integer , parameter :: STDOUT = 6 ! standard output integer , parameter :: STDIN = 5 ! standardinput character ( * ), parameter :: FMT_STRINT = \"(a30, i12)\" character ( * ), parameter :: FMT_STRDBL = \"(a30, f19.6)\" character ( * ), parameter :: FMT_STR2BL = \"(a30, '(', f11.6, ',', f11.6, ')')\" character ( * ), parameter :: FMT_VALERR = \"(a30, f12.6,' +- ',f12.6)\" character ( * ), parameter :: FMT_INTPAR = \"(i3,i3)\" character ( * ), parameter :: FMT_DBLINE = \"(76('='))\" character ( * ), parameter :: FMT_SGLINE = \"(76('-'))\" character ( * ), parameter :: FMT_POINT = \"('point ; dx=', i3, ' ; dy=', i3, ' :')\" ! Preset parameters for dlarnv() call. These parameters were defined previously in lapack_mod.F90 ! which is no longer used. integer , parameter :: DLARNV_UNI_0_1 = 1 integer , parameter :: DLARNV_UNI_N1_1 = 2 integer , parameter :: DLARNV_NORMAL = 3 interface conjg module procedure conjg_real , conjg_real1 , conjg_real2 end interface conjg interface DQMC_JackKnife module procedure DQMC_JackKnife_Real , DQMC_JackKnife_Complex end interface DQMC_JackKnife interface DQMC_SignJackKnife module procedure DQMC_SignJackKnife_Real , DQMC_SignJackKnife_Complex end interface DQMC_SignJackKnife interface DQMC_Print_Array module procedure DQMC_Print_RealArray , DQMC_Print_ComplexArray end interface DQMC_Print_Array contains !--------------------------------------------------------! ! Function extension for conjg !--------------------------------------------------------| function conjg_real ( x ) result ( y ) real * 8 , target , intent ( in ) :: x real * 8 , pointer :: y y => x end function conjg_real function conjg_real1 ( x ) result ( y ) real * 8 , target , intent ( in ) :: x (:) real * 8 , pointer :: y (:) y => x end function conjg_real1 function conjg_real2 ( x ) result ( y ) real * 8 , target , intent ( in ) :: x (:,:) real * 8 , pointer :: y (:,:) y => x end function conjg_real2 !--------------------------------------------------------! ! Matrix computations !--------------------------------------------------------| function DQMC_MatDiff ( n , A , B ) result ( diff ) ! ! Purpose ! ======= !    This function computes sum(abs(A-B)). ! ! Pre-assumption ! ============== !    Matrix A and B have the same dimension. !    On return, A = A - B, and B is untouched. ! ! Arguments ! ========= integer , intent ( in ) :: n ! the order of A and B real ( WP ), intent ( in ) :: A ( n , n ) ! real ( WP ), intent ( in ) :: B ( n , n ) ! ! ! ... Return value ... ! real ( WP ) :: diff , r ! ... Blas function ... !real(WP) :: ddot ! ... Local scalar ... integer :: i ! ... Executable ... !diff = ZERO ! !do i = 1, n !   call daxpy(n, -ONE, B(1,i), 1, A(1,i), 1) !   diff = diff+ddot(n, A(1,i), 1, A(1,i), 1) !end do !diff = sqrt(diff)/n/n !diff = maxval(abs(A-B)) diff = 0.d0 do i = 1 , n r = abs ( 1.d0 - A ( i , i )) / abs ( 1.d0 - B ( i , i )) diff = max ( diff , abs ( log ( r )) ) end do end function DQMC_MatDiff !--------------------------------------------------------! function DQMC_MatNorm ( n , A ) result ( norm ) ! ! Purpose ! ======= !    This function computes sum(abs(A-B)). ! ! Pre-assumption ! ============== !    Matrix A and B have the same dimension. !    On return, A = A - B, and B is untouched. ! ! Arguments ! ========= integer , intent ( in ) :: n ! the order of A and B real ( WP ), intent ( in ) :: A ( n , n ) ! ! ! ... Return value ... ! real ( WP ) :: norm ! ... Local scalar ... integer :: i , j real ( WP ) :: maxa , temp ! ... Executable ... norm = ZERO maxa = ZERO do i = 1 , n do j = 1 , n temp = abs ( A ( i , j )) if ( temp > maxa ) then maxa = temp end if end do end do do i = 1 , n do j = 1 , n temp = abs ( A ( i , j )) / maxa norm = norm + temp * temp end do end do norm = sqrt ( norm ) * maxa end function DQMC_MatNorm !--------------------------------------------------------! subroutine DQMC_Eye ( n , A ) ! ! Purpose ! ======= !    This subroutine returns A as an identity matrix. ! ! Pre-assumption ! ============== !    Matrix A is square. ! ! Arguments ! ========= integer , intent ( in ) :: n ! The order of A real ( WP ), intent ( inout ) :: A ( n , n ) ! returned identity ! ... Local scalar ... integer :: i ! ... Executable ... A = ZERO do i = 1 , n A ( i , i ) = ONE end do end subroutine DQMC_Eye !--------------------------------------------------------! subroutine DQMC_Trans ( n , At , A ) ! ! Purpose ! ======= !    This subroutine returns the transpose of A ! ! Argument ! ======== integer , intent ( in ) :: n real ( wp ), intent ( inout ) :: At ( n , n ) real ( wp ), intent ( in ) :: A ( n , n ) ! ... local scalar !! decide the sgn of det(Q) !do i = 1, n !   At(i,1:n) = A(1:n,i) !end do At = transpose ( A ) end subroutine DQMC_Trans !--------------------------------------------------------! subroutine DQMC_ScaleCol ( n , A , D ) ! ! Purpose ! ======= !    This subroutine computes A = A*D. ! ! Pre-assumption ! ============== !    Matrix A is order n and D is of length n. ! ! Argument ! ======== integer , intent ( in ) :: n ! The order of A real ( WP ), intent ( inout ) :: A ( n , n ) ! real ( WP ), intent ( in ) :: D ( n ) ! ! ... Local scalar ... integer :: i ! ... Executable ... ! A = A*D do i = 1 , n call dscal ( n , D ( i ), A (:, i ), 1 ) end do end subroutine DQMC_ScaleCol !--------------------------------------------------------! subroutine DQMC_ScaleRow ( n , A , D ) ! ! Purpose ! ======= !    This subroutine computes A = D*A. ! ! Pre-assumption ! ============== !    Matrix A is order n and D is of length n. ! ! Argument ! ======== integer , intent ( in ) :: n ! The order of A real ( WP ), intent ( inout ) :: A ( n , n ) ! real ( WP ), intent ( in ) :: D ( n ) ! ! ... Local scalar ... integer :: i ! A = D*A do i = 1 , n call dscal ( n , D ( i ), A ( i :, 1 ), n ) end do end subroutine DQMC_ScaleRow !--------------------------------------------------------! subroutine DQMC_ScaleColInv ( n , A , D ) ! ! Purpose ! ======= !    This subroutine computes A=A*inv(D). ! ! Pre-assumption ! ============== !    Matrix A is order n and D is of length n. ! ! Argument ! ======== integer , intent ( in ) :: n ! The order of A real ( WP ), intent ( inout ) :: A ( n , n ) ! real ( WP ), intent ( in ) :: D ( n ) ! ! ... Local scalar ... real ( WP ) :: uno integer :: i ! ... Executable ... uno = ONE ! A = A*inv(D) do i = 1 , n call dscal ( n , uno / D ( i ), A (:, i ), 1 ) end do end subroutine DQMC_ScaleColInv !--------------------------------------------------------! subroutine DQMC_ScaleRowInv ( n , A , D ) ! ! Purpose ! ======= !    This subroutine computes A = inv(D)*A. ! ! Pre-assumption ! ============== !    Matrix A is order n and D is of length n. ! ! Argument ! ======== integer , intent ( in ) :: n ! The order of A real ( WP ), intent ( inout ) :: A ( n , n ) ! real ( WP ), intent ( in ) :: D ( n ) ! ! ... Local scalar ... real ( WP ) :: uno integer :: i ! ... Executable ... uno = ONE ! A = inv(D)*A do i = 1 , n call dscal ( n , uno / D ( i ), A ( i :, 1 ), n ) end do end subroutine DQMC_ScaleRowInv !--------------------------------------------------------------------! ! Statistics !--------------------------------------------------------------------! subroutine DQMC_SignJackKnife_Real ( n , avg , err , x , y , sgn , sum_sgn ) ! ! Purpose ! ======= !    This subroutine implements delete-1 JackKnife method for !    the data and sign. !    X = (x1, x2, ..., xn) be the input data. !    sgn = (sgn1, sgn2, ..., sgnn) ! !    Y = (y1, y2, ..., yn) is the Jacknife resampling of X with sign. ! !    where y_i = (sum(x)-x_i)/sgn_i !    The JackKnife variance of X with sign is defined as ! !     n-1 !    ----- sqrt(sum(y_i-avg_y)&#94;2) !      n ! !    where avg_y = sum(y)/n ! ! Arguments ! ========= integer , intent ( in ) :: n real ( wp ), intent ( out ) :: avg real ( wp ), intent ( out ) :: err real ( wp ), intent ( in ) :: x (:) real ( wp ), intent ( inout ) :: y (:) real ( wp ), intent ( in ) :: sgn (:) real ( wp ), intent ( in ) :: sum_sgn ! ... Parameter ... real ( wp ), parameter :: TOL = 1.0D-12 ! ... Local variable ... real ( wp ) :: sum_x , avg_y ! ... Executable ... ! standard division sum_x = sum ( x ) y = ( sum_x - x ( 1 : n )) / sgn ( 1 : n ) avg_y = sum ( y ) / n y = y - avg_y y = y * y err = sum ( y ) * ( n - 1 ) / n err = sqrt ( err ) ! compute average avg = sum_x / sum_sgn ! If error is small enough, then regard it as 0. if ( err . lt . TOL * abs ( avg )) then err = ZERO end if end subroutine DQMC_SignJackKnife_Real !--------------------------------------------------------------------! subroutine DQMC_SignJackKnife_Complex ( n , avg , err , x , y , sgn , sum_sgn ) ! ! Purpose ! ======= !    This subroutine implements delete-1 JackKnife method for !    the data and sign. !    X = (x1, x2, ..., xn) be the input data. !    sgn = (sgn1, sgn2, ..., sgnn) ! !    Y = (y1, y2, ..., yn) is the Jacknife resampling of X with sign. ! !    where y_i = (sum(x)-x_i)/sgn_i !    The JackKnife variance of X with sign is defined as ! !     n-1 !    ----- sqrt(sum(y_i-avg_y)&#94;2) !      n ! !    where avg_y = sum(y)/n ! ! Arguments ! ========= integer , intent ( in ) :: n complex ( wp ), intent ( out ) :: avg complex ( wp ), intent ( out ) :: err complex ( wp ), intent ( in ) :: x (:) complex ( wp ), intent ( inout ) :: y (:) complex ( wp ), intent ( in ) :: sgn (:) complex ( wp ), intent ( in ) :: sum_sgn ! ... Parameter ... real ( wp ), parameter :: TOL = 1.0D-12 ! ... Local variable ... complex ( wp ) :: sum_x , avg_y real ( wp ) :: rp , ip integer :: i ! ... Executable ... ! standard division sum_x = sum ( x ) y = ( sum_x - x ( 1 : n )) / sgn ( 1 : n ) avg_y = sum ( y ) / n y = y - avg_y do i = 1 , n rp = dble ( y ( i )) ** 2 ip = aimag ( y ( i )) ** 2 err = err + dcmplx ( rp , ip ) enddo err = ( err * ( n - 1 )) / n rp = sqrt ( dble ( err )) ip = sqrt ( aimag ( err )) err = dcmplx ( rp , ip ) ! compute average avg = sum_x / sum_sgn ! If error is small enough, then regard it as 0. if ( abs ( err ) . lt . TOL * abs ( avg )) then err = ZERO end if end subroutine DQMC_SignJackKnife_Complex !--------------------------------------------------------------------! subroutine DQMC_JackKnife_Real ( n , avg , err , x , y , sgn , sum_sgn ) ! ! Purpose ! ======= !    This subroutine implements delete-1 JackKnife method. Let !    X = (x1, x2, ..., xn) be the input data. !    Y = (y1, y2, ..., yn) is the Jacknife resampling of X. ! !    where y_i = (sum(x)-x_i)/(n-1) !    The JackKnife variance of X is defined as ! !     n-1 !    ----- sqrt(sum(y_i-avg_y)&#94;2) !      n ! !    where avg_y = sum(y)/n, which equals to avg_x ! ! Arguments ! ========= integer , intent ( in ) :: n real ( wp ), intent ( out ) :: err real ( wp ), intent ( out ) :: avg real ( wp ), intent ( in ) :: x ( n ) real ( wp ), intent ( out ) :: y ( n ) real ( wp ), intent ( out ) :: sgn ( n ) real ( wp ), intent ( out ) :: sum_sgn ! ... Parameter ... real ( wp ), parameter :: TOL = 1.0D-12 ! ... Local variable ... real ( wp ) :: sum_x ! ... Executable ... sum_x = sum ( x ) ! compute average avg = sum_x / n ! sgn and sum sgn will be used for other analysis sgn = ( sum_x - x ( 1 : n )) sum_sgn = sum_x ! compute y (Jackkife sample) y = sgn / ( n - 1 ) ! avg_y = avg_x y = y - avg y = y * y err = ( sum ( y ) * ( n - 1 )) / n err = sqrt ( err ) ! If error is small enough, then regard it as 0. if ( err . lt . TOL * abs ( avg )) then err = ZERO end if end subroutine DQMC_JackKnife_Real !--------------------------------------------------------------------! subroutine DQMC_JackKnife_Complex ( n , avg , err , x , y , sgn , sum_sgn ) ! ! Purpose ! ======= !    This subroutine implements delete-1 JackKnife method. Let !    X = (x1, x2, ..., xn) be the input data. !    Y = (y1, y2, ..., yn) is the Jacknife resampling of X. ! !    where y_i = (sum(x)-x_i)/(n-1) !    The JackKnife variance of X is defined as ! !     n-1 !    ----- sqrt(sum(y_i-avg_y)&#94;2) !      n ! !    where avg_y = sum(y)/n, which equals to avg_x ! ! Arguments ! ========= integer , intent ( in ) :: n complex ( wp ), intent ( out ) :: err complex ( wp ), intent ( out ) :: avg complex ( wp ), intent ( in ) :: x ( n ) complex ( wp ), intent ( out ) :: y ( n ) complex ( wp ), intent ( out ) :: sgn ( n ) complex ( wp ), intent ( out ) :: sum_sgn ! ... Parameter ... real ( wp ), parameter :: TOL = 1.0D-12 ! ... Local variable ... complex ( wp ) :: sum_x real ( wp ) :: rp , ip integer :: i ! ... Executable ... sum_x = sum ( x ) ! compute average avg = sum_x / n ! sgn and sum sgn will be used for other analysis sgn = ( sum_x - x ( 1 : n )) sum_sgn = sum_x ! compute y (Jackkife sample) y = sgn / ( n - 1 ) ! avg_y = avg_x y = y - avg do i = 1 , n rp = dble ( y ( i )) ** 2 ip = aimag ( y ( i )) ** 2 err = err + dcmplx ( rp , ip ) enddo err = ( err * ( n - 1 )) / n rp = sqrt ( dble ( err )) ip = sqrt ( aimag ( err )) err = dcmplx ( rp , ip ) ! If error is small enough, then regard it as 0. if ( abs ( err ) . lt . TOL * abs ( avg )) then err = ZERO end if end subroutine DQMC_JackKnife_Complex !--------------------------------------------------------------------! subroutine DQMC_GetErr ( n , err , avg , list ) ! ! Purpose ! ======= !    This subroutine computes error of the measurements. ! ! Arguments ! ========= integer , intent ( in ) :: n real ( wp ), intent ( out ) :: err real ( wp ), intent ( in ) :: avg real ( wp ), intent ( inout ) :: list ( n ) ! ... Parameter ... real ( wp ), parameter :: TOL = 1.0D-12 ! ... Local variable ... real ( wp ) :: tmp ! ... Executable ... ! compute average tmp = sum ( list ) / n ! standard division list = list - tmp list = list * list err = ( sum ( list ) * ( n - 1 )) / n err = sqrt ( err ) ! If error is small enough, then regard it as 0. if ( err . lt . TOL * abs ( avg )) then err = ZERO end if end subroutine DQMC_GetErr !-----------------------------------------------------------------! subroutine DQMC_GetErr1 ( n , data , avg , err ) ! ! Purpose ! ======= !    This subroutine computes error of the measurements. ! ! Arguments ! ========= integer , intent ( in ) :: n real ( wp ), intent ( in ) :: data ( n ) real ( wp ), intent ( out ) :: avg , err ! ... Parameter ... real ( wp ), parameter :: TOL = 1.0D-12 ! ... local vars ... integer :: i real ( wp ) :: s ! Executable avg = sum ( data ) / n s = ZERO do i = 1 , n s = s + ( data ( i ) - avg ) ** 2 end do s = s / n err = sqrt ( s ) / sqrt ( n - ONE ) if ( err . lt . TOL * abs ( avg )) then err = ZERO end if end subroutine DQMC_GetErr1 !--------------------------------------------------------! subroutine DQMC_GetErr2 ( n , sm , ssq , avg , err ) ! ! Purpose ! ======= !    This subroutine computes error of the measurements. ! ! Arguments ! ========= integer , intent ( in ) :: n real ( wp ), intent ( in ) :: sm , ssq real ( wp ), intent ( out ) :: avg , err ! ... Parameter ... real ( wp ), parameter :: TOL = 1.0D-12 ! ... local vars ... real ( wp ) :: s ! Executable avg = sm / n s = ssq / n - avg * avg err = sqrt ( s ) / sqrt ( n - ONE ) if ( err . lt . TOL * abs ( avg )) then err = ZERO end if end subroutine DQMC_GetErr2 !--------------------------------------------------------! ! Miscellanceous !--------------------------------------------------------! subroutine DQMC_Error ( message , no ) ! ! Purpose ! ======= !    This subroutine prints out an error message and !    a message number, and then stop the program. ! ! Arguments ! ========= ! character ( * ), intent ( in ) :: message ! Error message integer , intent ( in ) :: no ! Message number integer :: dum ! ... Executable ... dum = no write ( STDERR , * ) \"Error: \" , message stop end subroutine DQMC_Error !--------------------------------------------------------! subroutine DQMC_Warning ( message , no ) ! ! Purpose ! ======= !    This subroutine prints out an error message and !    a message number. ! ! Arguments ! ========= ! character ( * ), intent ( in ) :: message ! Warning message integer , intent ( in ) :: no ! Message number integer :: dum ! ... Executable ... dum = no write ( STDERR , * ) \"Warning: \" , message end subroutine DQMC_Warning !--------------------------------------------------------! #ifdef _QMC_MPI subroutine ran0 ( n , var , seed ) #   ifdef _QMC_MPI #      define SIMPLE_SPRNG #      include \"sprng_f.h\" #   endif ! ! Purpose ! ======= !    Random number generator. This subroutine uses !    SPRNG library. ! ! Arguments ! ========= ! integer , intent ( in ) :: n real ( wp ), intent ( out ) :: var ( n ) ! random number to return integer :: i integer , intent ( in ) :: seed ( 4 ) ! random seeds(not used) i = seed ( 1 ) !Avoid warning do i = 1 , n var ( i ) = sprng () enddo end subroutine ran0 #else subroutine ran0 ( n , var , seed ) ! ! Purpose ! ======= !    Random number generator. This subroutine uses !    LAPACK's random number generator dlaruv to generate !    a list of random numbers ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! length of the list real ( wp ), intent ( out ) :: var ( n ) ! random number to return integer , intent ( inout ) :: seed ( 4 ) ! random seeds ! ... local scalar ... integer , parameter :: max_len = 128 ! This max length is ! defined by dlaruv ! ... Executable ... var ( 1 : n ) = ZERO call dlarnv ( DLARNV_UNI_0_1 , seed , n , var ) end subroutine ran0 #endif !--------------------------------------------------------! subroutine ran1 ( n , var , seed ) ! ! Purpose ! ======= !    Random number generator. This subroutine uses !    LAPACK's random number generator dlaruv to generate !    a list of random numbers ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! length of the list real ( wp ), intent ( out ) :: var ( n ) ! random number to return integer , intent ( inout ) :: seed ( 4 ) ! random seeds ! ... local scalar ... integer , parameter :: max_len = 128 ! This max length is ! defined by dlaruv ! ... Executable ... var ( 1 : n ) = ZERO call dlarnv ( 2 , seed , n , var ) end subroutine ran1 !--------------------------------------------------------! integer function intran ( L , seed ) ! ! Purpose ! ======= !    Random number generator. This subroutine !    generates a random integer in [1:L] ! ! Arguments ! ========= ! integer , intent ( in ) :: L ! length of the list integer , intent ( inout ) :: seed ( 4 ) ! random seeds real ( wp ) :: var ( 1 ) ! ... Executable ... call ran0 ( 1 , var , seed ) intran = ceiling ( var ( 1 ) * L ) end function intran !--------------------------------------------------------! subroutine ranN ( n , var , seed ) ! ! Purpose ! ======= !    Random number generator. This subroutine uses !    LAPACK's random number generator dlaruv to generate !    a list of random numbers ! ! Arguments ! ========= ! integer , intent ( in ) :: n ! length of the list real ( wp ), intent ( out ) :: var ( n ) ! random number to return integer , intent ( inout ) :: seed ( 4 ) ! random seeds ! ... local scalar ... integer , parameter :: max_len = 128 ! This max length is ! defined by dlaruv ! ... Executable ... var ( 1 : n ) = ZERO call dlarnv ( 3 , seed , n , var ) end subroutine ranN !-------------------------------------------------------------! subroutine dumpA ( m , n , A , OPT ) implicit none ! ! Purpose ! ======= !    This subroutine prints the content of matrix A. !    *** for internal debugging only ! ! Arguments ! ========= ! integer , intent ( in ) :: m , n ! dimension of A real ( wp ), intent ( in ) :: A ( 1 : m , 1 : n ) ! matrix A integer , intent ( in ) :: OPT ! output device ! ... Local variables ... character ( 20 ) fmt integer i real ( wp ) :: temp ( n ) ! ... Executable ... write ( fmt , \"(A,I3,A)\" ) \"(\" , n , \"F20.15)\" do i = 1 , m temp = A ( i , 1 : n ) write ( OPT , fmt ) temp end do end subroutine dumpA !--------------------------------------------------------! subroutine DQMC_Print_RealArray ( n , m , title , label , avg , err , OPT ) ! ! Purpose ! ======= !    This subroutine prints out the content of avg +- err ! ! Arguments ! ========= integer , intent ( in ) :: OPT , n , m character ( * ), intent ( in ) :: title , label (:) real ( wp ), intent ( in ) :: avg (:,:), err (:,:) ! ... Local variable ... integer :: i , j ! ... Executable ... write ( OPT , * ) title if ( n . gt . 0 ) then do i = 1 , n write ( OPT , * ) label ( i ) do j = 1 , m write ( OPT , \"(i3,e16.8,' +-',e16.8)\" ) j - 1 , avg ( i , j ), err ( i , j ) end do end do else do j = 1 , m write ( OPT , \"(a,e16.8,' +-',e16.8)\" ) label ( j ), avg ( j , 1 ), err ( j , 1 ) end do end if !write(OPT,*) write ( OPT , FMT_DBLINE ) end subroutine DQMC_Print_RealArray !--------------------------------------------------------------------! subroutine DQMC_Print_ComplexArray ( n , m , title , label , avg , err , OPT ) ! ! Purpose ! ======= !    This subroutine prints out the content of avg +- err ! ! Arguments ! ========= integer , intent ( in ) :: OPT , n , m character ( * ), intent ( in ) :: title , label (:) complex ( wp ), intent ( in ) :: avg (:,:), err (:,:) ! ... Local variable ... integer :: i , j ! ... Executable ... write ( OPT , * ) title if ( n . gt . 0 ) then do i = 1 , n write ( OPT , * ) label ( i ) do j = 1 , m write ( OPT , \"(i3,'(',e15.8,' +-',e15.8,') & & +i (',e15.8,' +-',e15.8,')')\" )& j - 1 , dble ( avg ( i , j )), dble ( err ( i , j )), aimag ( avg ( i , j )), aimag ( err ( i , j + m )) end do end do else do j = 1 , m write ( OPT , \"(3x, A,'(',e15.8,' +-',e15.8,') & & +i (',e15.8,' +-',e15.8,')')\" ) & label ( j ), dble ( avg ( j , 1 )), dble ( err ( j , 1 )), aimag ( avg ( j , 1 )), aimag ( err ( j , 1 )) end do end if !write(OPT,*) write ( OPT , FMT_DBLINE ) end subroutine DQMC_Print_ComplexArray !--------------------------------------------------------------------! subroutine DQMC_Print_EigenMode ( n , m , title , value , OPT ) ! ! Purpose ! ======= !    This subroutine prints out the eigenmodes of correlation functions ! ! Arguments ! ========= integer , intent ( in ) :: OPT , n , m character ( * ), intent ( in ) :: title complex * 16 , intent ( in ) :: value (:,:,:) ! ... Local variable ... integer :: i , ik , ja , ia ! ... Executable ... write ( OPT , * ) title i = 0 write ( OPT , '(10x,100(13x,i2,12x))' )( ia , ia = 1 , n ) do ik = 1 , m do ja = 1 , n i = i + 1 if ( ja == 1 ) then write ( OPT , '(1x,i3,2x,i3,1x)' , advance = \"no\" ) ik , ja else write ( OPT , '(6x,i3,1x)' , advance = \"no\" ) ja endif do ia = 1 , n write ( OPT , \"(A,f10.6,' +i',f10.6,A)\" , advance = \"no\" )& \" (\" , real ( value ( ia , ja , ik )), aimag ( value ( ia , ja , ik )), \") \" end do write ( OPT , '(2(i5))' , advance = \"yes\" ) end do end do write ( OPT , FMT_DBLINE ) end subroutine DQMC_Print_EigenMode !--------------------------------------------------------------------! subroutine dqmc_getFTk ( value , n , nclass , class , na , nk , ft_wgt , phase , valuek ) real ( wp ), intent ( in ) :: value ( nclass ) integer , intent ( in ) :: n integer , intent ( in ) :: nclass integer , intent ( in ) :: class ( n , n ) integer , intent ( in ) :: phase ( n , n ) integer , intent ( in ) :: na , nk complex ( wp ), intent ( in ) :: ft_wgt ( n / na , nk ) complex ( wp ), intent ( out ) :: valuek ( nk * na * ( na + 1 ) / 2 ) integer :: ik , ia , ja , it , jt , i , j , nt , naa complex ( wp ) :: U ( na , na ), phcurr nt = n / na naa = na * ( na + 1 ) / 2 !Loop over inequvalent k-points do ik = 1 , nk U = 0.d0 !Compute Fourier transform matrix at \"ik\" for (ja,ia) do ia = 1 , na do ja = ia , na !sum over translations do it = 1 , nt do jt = 1 , nt !Find atom which is the translation of \"ja\" by \"it\" i = ( it - 1 ) * na + ia j = ( jt - 1 ) * na + ja !Use class that corresponds to the (i,j) pair phcurr = phase ( i , j ) * value ( class ( i , j )) U ( ja , ia ) = U ( ja , ia ) + phcurr * ft_wgt ( it , ik ) * dconjg ( ft_wgt ( jt , ik )) enddo enddo enddo enddo !Pointer to Fourier transform of \"ip\" at \"ik\" in \"ibin\" i = ( ik - 1 ) * naa do ia = 1 , na do ja = ia , na i = i + 1 valuek ( i ) = U ( ja , ia ) enddo enddo enddo ! Loop over k-points end subroutine DQMC_getFTk !--------------------------------------------------------------------! subroutine DQMC_IO_open ( fname , INP_UNIT , OUT_UNIT ) ! ! Purpose ! ======= !  Find a unit for input and output file ! ! Arguments ! ========= integer , intent ( out ) :: INP_UNIT , OUT_UNIT character ( len = 60 ), intent ( out ) :: fname character ( len = 60 ) :: outname !Open input file call get_command_argument ( 1 , fname ) call DQMC_open_file ( fname , 'old' , INP_UNIT ) !Open output file outname = trim ( adjustl ( fname )) // \".out\" call DQMC_open_file ( outname , 'unknown' , OUT_UNIT ) end subroutine DQMC_IO_open !--------------------------------------------------------------------! subroutine DQMC_open_file ( fname , fstatus , FILE_UNIT ) implicit none character ( len =* ), intent ( in ) :: fname , fstatus integer , intent ( out ) :: FILE_UNIT logical :: unit_is_open do FILE_UNIT = 7 , 99 inquire ( unit = FILE_UNIT , opened = unit_is_open ) if (. not . unit_is_open ) exit enddo open ( unit = FILE_UNIT , file = fname , status = fstatus ) end subroutine DQMC_open_file !--------------------------------------------------------------------! subroutine DQMC_count_records ( n , FILE_UNIT ) implicit none integer , intent ( out ) :: n integer , intent ( in ) :: FILE_UNIT character ( len = 1 ) :: c integer :: i n = 0 do read ( FILE_UNIT , '(A1)' , iostat = i ) c if ( i . ne . 0 ) exit n = n + 1 enddo rewind ( FILE_UNIT ) end subroutine DQMC_count_records !--------------------------------------------------------------------! logical function move_to_record ( string , iunit ) ! ! Purpose ! ======= !  Move to record where string is found. If not found return false. ! ! Arguments ! ========= character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: iunit ! ... Local Variables ... integer :: ios , istring character ( len = 100 ) :: line ! ... Executable ... rewind ( iunit ) do read ( iunit , '(A)' , iostat = ios ) line if ( ios . ne . 0 ) then move_to_record = . false . exit endif istring = index ( line , trim ( adjustl ( string ))) if ( istring == 0 ) cycle move_to_record = . true . exit enddo end function !--------------------------------------------------------------------! real ( wp ) function get_det ( a ) ! ! Purpose ! ======= ! Directly get determinant of 3 by 3 matrix. ! ! Arguments ! ========= real ( wp ), intent ( in ) :: a ( 3 , 3 ) ! ... Local variables ... real ( wp ) :: d ( 3 ) ! ... Executable ... d ( 1 ) = a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 3 , 1 ) * a ( 2 , 2 ) d ( 2 ) = a ( 3 , 1 ) * a ( 1 , 2 ) - a ( 1 , 1 ) * a ( 3 , 2 ) d ( 3 ) = a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 2 , 1 ) * a ( 1 , 2 ) get_det = d ( 1 ) * a ( 1 , 3 ) + d ( 2 ) * a ( 2 , 3 ) + d ( 3 ) * a ( 3 , 3 ) end function get_det !--------------------------------------------------------------------! subroutine get_inverse ( a , inv ) ! ! Purpose ! ======= !  Directly get inverse of 3 by 3 matrix. ! ! Arguments ! ========= real ( wp ), intent ( in ) :: a ( 3 , 3 ) real ( wp ), intent ( out ) :: inv ( 3 , 3 ) ! ... Local variables ... real ( wp ) :: invdet ! ... Executable ... inv ( 1 , 1 ) = a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 2 ) inv ( 1 , 2 ) = a ( 3 , 2 ) * a ( 1 , 3 ) - a ( 3 , 3 ) * a ( 1 , 2 ) inv ( 1 , 3 ) = a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 ) inv ( 2 , 1 ) = a ( 2 , 3 ) * a ( 3 , 1 ) - a ( 2 , 1 ) * a ( 3 , 3 ) inv ( 2 , 2 ) = a ( 3 , 3 ) * a ( 1 , 1 ) - a ( 3 , 1 ) * a ( 1 , 3 ) inv ( 2 , 3 ) = a ( 1 , 3 ) * a ( 2 , 1 ) - a ( 1 , 1 ) * a ( 2 , 3 ) inv ( 3 , 1 ) = a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 2 , 2 ) * a ( 3 , 1 ) inv ( 3 , 2 ) = a ( 3 , 1 ) * a ( 1 , 2 ) - a ( 3 , 2 ) * a ( 1 , 1 ) inv ( 3 , 3 ) = a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 ) invdet = 1.d0 / ( inv ( 3 , 1 ) * a ( 1 , 3 ) + inv ( 3 , 2 ) * a ( 2 , 3 ) + inv ( 3 , 3 ) * a ( 3 , 3 )) inv (:,:) = inv (:,:) * invdet end subroutine get_inverse !--------------------------------------------------------------------! end module DQMC_Util","tags":"","loc":"sourcefile/dqmc_util.f90.html"},{"title":"dqmc_omp.F90 – Quest","text":"Files dependent on this one sourcefile~~dqmc_omp.f90~~AfferentGraph sourcefile~dqmc_omp.f90 dqmc_omp.F90 sourcefile~ggeom.f90 ggeom.F90 sourcefile~ggeom.f90->sourcefile~dqmc_omp.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module DQMC_OMP implicit none contains subroutine DQMC_OMP_Init ( nproc ) ! Read in the number of OpenMP threads to execute TDM integer , intent ( inout ) :: nproc character ( len = 32 ) :: argv integer :: nprocmax , OMP_GET_NUM_PROCS , argc argc = iargc () nprocmax = OMP_GET_NUM_PROCS () call getarg ( 2 , argv ) if ( argv == '-p' ) then if ( argc == 2 ) then nproc = nprocmax call OMP_SET_NUM_THREADS ( nproc ) else call getarg ( 3 , argv ) read ( argv , '(I10)' ) nproc if ( nproc > 0 . AND . nproc . le . nprocmax ) then call OMP_SET_NUM_THREADS ( nproc ) else write ( * , \"('Invalid number of threads, must be an integer & between 1 and the max number of threads (', i2, ').')\" ) nprocmax stop endif endif else nproc = 1 endif write ( * , \"('Running the program in ', i2, ' threads.')\" ), nproc end subroutine DQMC_OMP_Init end module DQMC_OMP","tags":"","loc":"sourcefile/dqmc_omp.f90.html"},{"title":"kernel_cpu.c++ – Quest","text":"Source Code // Implementation of the different kernels in the CPU using OpenMP #include \"profile.h\" #include \"kernel_cpu.h\" void cpu_diag ( int n , double * A , double * D ) { int i ; for ( i = 0 ; i < n ; i ++ ) D [ i ] = A [ i * n + i ]; // D = diag(A) } void cpu_normcol ( int n , double * A , double * D , double * c ) { int i , j ; double dot , tmp ; PROFILE_BEGIN (); #ifdef _OPENMP #pragma omp parallel for shared(n, A, D, c) private(i, j, tmp, dot) schedule(static) #endif for ( j = 0 ; j < n ; j ++ ) { dot = 0.0 ; for ( i = 0 ; i < n ; i ++ ) { tmp = A [ j * n + i ] * D [ j ]; A [ j * n + i ] = tmp ; dot += tmp * tmp ; } c [ j ] = dot ; } PROFILE_END ( profile_normcol , 3.0 * n * n ); } void cpu_permute ( int n , int * ipiv , double * A , double * Q ) { int i , j , p ; PROFILE_BEGIN (); #ifdef _OPENMP #pragma omp parallel for shared(n, ipiv, Q, A) private(i, j, p) schedule(static) #endif for ( j = 0 ; j < n ; j ++ ) { p = ipiv [ j ]; for ( i = 0 ; i < n ; i ++ ) Q [ j * n + i ] = A [ p * n + i ]; } PROFILE_END ( profile_permute , 0.0 ); } void cpu_scalerowperm ( int n , double * D , double * Q , int * ipiv , double * T ) { int i , j , p ; PROFILE_BEGIN (); #ifdef _OPENMP #pragma omp parallel for shared(n, ipiv, T, Q, D) private(i, j, p) schedule(static) #endif for ( j = 0 ; j < n ; j ++ ) { p = ipiv [ j ]; for ( i = 0 ; i <= j ; i ++ ) T [ p * n + i ] = Q [ j * n + i ] / D [ i ]; // T = D&#94;-1*R*P for (; i < n ; i ++ ) T [ p * n + i ] = 0 ; } PROFILE_END ( profile_scalerowperm , 0.5 * n * n ); } void cpu_scalerow ( int n , double * h , double * B , double * M ) { int i , j ; PROFILE_BEGIN (); #ifdef _OPENMP #pragma omp parallel for shared(n, M, B, h) private(i, j) schedule(static) #endif for ( j = 0 ; j < n ; j ++ ) for ( i = 0 ; i < n ; i ++ ) M [ j * n + i ] = B [ j * n + i ] * h [ i ]; PROFILE_END ( profile_scalerow , n * n ); } void cpu_scalerowcol ( int n , double * h , double * G ) { int i , j ; PROFILE_BEGIN (); #ifdef _OPENMP #pragma omp parallel for shared(n, G, h) private(i, j) schedule(static) #endif for ( j = 0 ; j < n ; j ++ ) for ( i = 0 ; i < n ; i ++ ) G [ j * n + i ] = h [ i ] * G [ j * n + i ] / h [ j ]; PROFILE_END ( profile_scalerowcol , 2.0 * n * n ); } void cpu_scalerowadd ( int n , double * Db , double * U , double * D , double * T , double * G ) { int i , j ; double tmp ; PROFILE_BEGIN (); #ifdef _OPENMP #pragma omp parallel for shared(n, Db, U, D, T, G) private(i, j, tmp) schedule(static) #endif for ( j = 0 ; j < n ; j ++ ) for ( i = 0 ; i < n ; i ++ ) { tmp = U [ i * n + j ] / Db [ i ]; G [ j * n + i ] = tmp ; T [ j * n + i ] = tmp + D [ i ] * T [ j * n + i ]; } PROFILE_END ( profile_scalerowadd , 3.0 * n * n ); } void cpu_sort ( int n , double * Db , int * ipiv ) { int i , j , p , t ; double tmp , max ; PROFILE_BEGIN (); for ( j = 0 ; j < n ; j ++ ) { ipiv [ j ] = j ; } for ( j = 0 ; j < n - 1 ; j ++ ) { // find column with maximum norm max = Db [ j ]; p = j ; for ( i = j + 1 ; i < n ; i ++ ) if ( Db [ i ] > max ) { max = Db [ i ]; p = i ; } // swap columns if ( p != j ) { t = ipiv [ j ]; ipiv [ j ] = ipiv [ p ]; ipiv [ p ] = t ; tmp = Db [ j ]; Db [ j ] = Db [ p ]; Db [ p ] = tmp ; } } PROFILE_END ( profile_sort , 0 ); }","tags":"","loc":"sourcefile/kernel_cpu.c++.html"},{"title":"blaslapack.c++ – Quest","text":"Source Code #include <cstdio> #include \"blaslapack.h\" #include \"profile.h\" lapack_exception :: lapack_exception ( const char * function , int info ) { snprintf ( message , sizeof ( message ), \"LAPACK error in %s info=%i\" , function , info ); } const char * lapack_exception :: what () const throw () { return message ; } /* Actual interface to Fortran routines */ extern \"C\" { void dcopy_ ( int * n , double * dx , int * incx , double * dy , int * incy ); void daxpy_ ( int * n , double * da , double * dx , int * incx , double * dy , int * incy ); void dscal_ ( int * n , double * da , double * dx , int * incx ); double ddot_ ( int * n , double * dx , int * incx , double * dy , int * incy ); void dgemv_ ( const char * trans , int * m , int * n , double * alpha , double * a , int * lda , double * x , int * incx , double * beta , double * y , int * incy ); void dgemm_ ( const char * transa , const char * transb , int * m , int * n , int * k , double * alpha , double * a , int * lda , double * b , int * ldb , double * beta , double * c , int * ldc ); void dtrmm_ ( const char * side , const char * uplo , const char * transa , const char * diag , int * m , int * n , double * alpha , double * a , int * lda , double * b , int * ldb ); void dtrsm_ ( const char * side , const char * uplo , const char * transa , const char * diag , int * m , int * n , double * alpha , double * a , int * lda , double * b , int * ldb ); void dsyev_ ( const char * jobz , const char * uplo , int * n , double * a , int * lda , double * w , double * work , int * lwork , int * info ); void dgesv_ ( int * n , int * nrhs , double * a , int * lda , int * ipiv , double * b , int * ldb , int * info ); void dgeqp3_ ( int * m , int * n , double * a , int * lda , int * jpvt , double * tau , double * work , int * lwork , int * info ); void dorgqr_ ( int * m , int * n , int * k , double * a , int * lda , double * tau , double * work , int * lwork , int * info ); void dormqr_ ( const char * side , const char * trans , int * m , int * n , int * k , double * a , int * lda , double * tau , double * c , int * ldc , double * work , int * lwork , int * info ); void dgetrf_ ( int * m , int * n , double * a , int * lda , int * ipiv , int * info ); void dgetri_ ( int * n , double * a , int * lda , int * ipiv , double * work , int * lwork , int * info ); void dgetrs_ ( const char * trans , int * n , int * nrhs , double * a , int * lda , int * ipiv , double * b , int * ldb , int * info ); void dgejsv_ ( const char * joba , const char * jobu , const char * jobv , const char * jobr , const char * jobt , const char * jobp , int * m , int * n , double * a , int * lda , double * sva , double * u , int * ldu , double * v , int * ldv , double * work , int * lwork , int * iwork , int * info ); void dgerfsx_ ( const char * trans , const char * equed , int * n , int * nrhs , double * a , int * lda , double * af , int * ldaf , int * ipiv , double * r , double * c , double * b , int * ldb , double * x , int * ldx , double * rcond , double * berr , int * n_err_bnds , double * err_bnds_norm , double * err_bnds_comp , int * nparams , double * params , double * work , int * iwork , int * info ); void dgeqrf_ ( int * m , int * n , double * a , int * lda , double * tau , double * work , int * lwork , int * info ); void dlarft_ ( const char * direct , const char * storev , int * n , int * k , double * v , int * ldv , double * tau , double * t , int * ldt ); } #define N ((double)*n) #define N2 ((double)*n * (double)*n) #define N3 ((double)*n * (double)*n * (double)*n) #define M ((double)*m) #define M2 ((double)*m * (double)*m) #define K ((double)*k) #define K2 ((double)*k * (double)*k) #define K3 ((double)*k * (double)*k * (double)*k) /* routine stubs */ void blas_dcopy_ ( int * n , double * sx , int * incx , double * sy , int * incy ) { PROFILE_BEGIN (); dcopy_ ( n , sx , incx , sy , incy ); PROFILE_END ( profile_dcopy , 0 ); } void blas_daxpy_ ( int * n , double * sa , double * sx , int * incx , double * sy , int * incy ) { PROFILE_BEGIN (); daxpy_ ( n , sa , sx , incx , sy , incy ); PROFILE_END ( profile_daxpy , 2 * N ); } void blas_dscal_ ( int * n , double * sa , double * sx , int * incx ) { PROFILE_BEGIN (); dscal_ ( n , sa , sx , incx ); PROFILE_END ( profile_dscal , N ); } double blas_ddot_ ( int * n , double * sx , int * incx , double * sy , int * incy ) { PROFILE_BEGIN (); double dot = ddot_ ( n , sx , incx , sy , incy ); PROFILE_END ( profile_ddot , 2 * N ); return dot ; } void blas_dgemv_ ( const char * trans , int * m , int * n , double * alpha , double * a , int * lda , double * x , int * incx , double * beta , double * y , int * incy ) { PROFILE_BEGIN (); dgemv_ ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ); PROFILE_END ( profile_dgemv , 2 * M * N ); } void blas_dgemm_ ( const char * transa , const char * transb , int * m , int * n , int * k , double * alpha , double * a , int * lda , double * b , int * ldb , double * beta , double * c , int * ldc ) { PROFILE_BEGIN (); dgemm_ ( transa , transb , m , n , k , alpha , a , lda , b , ldb , beta , c , ldc ); PROFILE_END ( profile_dgemm , 2 * M * N * K ); } void blas_dtrmm_ ( const char * side , const char * uplo , const char * transa , const char * diag , int * m , int * n , double * alpha , double * a , int * lda , double * b , int * ldb ) { PROFILE_BEGIN (); dtrmm_ ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ); if ( * side == 'L' || * side == 'l' ) { PROFILE_END ( profile_dtrmm , N * M2 ); } else { PROFILE_END ( profile_dtrmm , M * N2 ); } } void blas_dtrsm_ ( const char * side , const char * uplo , const char * transa , const char * diag , int * m , int * n , double * alpha , double * a , int * lda , double * b , int * ldb ) { PROFILE_BEGIN (); dtrsm_ ( side , uplo , transa , diag , m , n , alpha , a , lda , b , ldb ); if ( * side == 'L' || * side == 'l' ) { PROFILE_END ( profile_dtrsm , N * M2 ); } else { PROFILE_END ( profile_dtrsm , M * N2 ); } } // Workaround for NERSC carver buggy MKL /* extern \"C\" { void MKL_Set_Num_Threads(int nth); int  MKL_Get_Max_Threads(void); } */ void lapack_dsyev_ ( const char * jobz , const char * uplo , int * n , double * a , int * lda , double * w , double * work , int * lwork , int * info ) { PROFILE_LWORK_BEGIN (); // int nth = MKL_Get_Max_Threads(); // MKL_Set_Num_Threads(1); dsyev_ ( jobz , uplo , n , a , lda , w , work , lwork , info ); // MKL_Set_Num_Threads(nth); PROFILE_LWORK_END ( profile_dsyev , 0 ); } void lapack_dgesv_ ( int * n , int * nrhs , double * a , int * lda , int * ipiv , double * b , int * ldb , int * info ) { PROFILE_BEGIN (); dgesv_ ( n , nrhs , a , lda , ipiv , b , ldb , info ); PROFILE_END ( profile_dgesv , N * N2 - N3 / 3 - N2 / 2 + 5 * N / 6 + ( double ) * nrhs * ( 2 * N2 - N )); } void lapack_dgeqp3_ ( int * m , int * n , double * a , int * lda , int * jpvt , double * tau , double * work , int * lwork , int * info ) { PROFILE_LWORK_BEGIN (); dgeqp3_ ( m , n , a , lda , jpvt , tau , work , lwork , info ); PROFILE_LWORK_END ( profile_dgeqp3 , 2 * M * N2 - 2 * N3 / 3 + M * N + N2 + 14 * N / 3 ); } void lapack_dorgqr_ ( int * m , int * n , int * k , double * a , int * lda , double * tau , double * work , int * lwork , int * info ) { PROFILE_LWORK_BEGIN (); dorgqr_ ( m , n , k , a , lda , tau , work , lwork , info ); PROFILE_LWORK_END ( profile_dorgqr , 4 * M * N * K - 2 * ( M + N ) * K2 + 4 * K3 / 3 + 3 * N * K - M * K - K2 - 4 * K / 3 ); } void lapack_dormqr_ ( const char * side , const char * trans , int * m , int * n , int * k , double * a , int * lda , double * tau , double * c , int * ldc , double * work , int * lwork , int * info ) { PROFILE_LWORK_BEGIN (); dormqr_ ( side , trans , m , n , k , a , lda , tau , c , ldc , work , lwork , info ); PROFILE_LWORK_END ( profile_dormqr , 4 * M * N * K - 2 * N * K2 + 3 * N * K ); } void lapack_dgetrf_ ( int * m , int * n , double * a , int * lda , int * ipiv , int * info ) { PROFILE_BEGIN (); dgetrf_ ( m , n , a , lda , ipiv , info ); PROFILE_END ( profile_dgetrf , M * N2 - N3 / 3 - N2 / 2 + 5 * N / 6 ); } void lapack_dgetri_ ( int * n , double * a , int * lda , int * ipiv , double * work , int * lwork , int * info ) { PROFILE_LWORK_BEGIN (); dgetri_ ( n , a , lda , ipiv , work , lwork , info ); PROFILE_LWORK_END ( profile_dgetri , 4 * N3 - N2 + 5 * N / 3 ); } void lapack_dgetrs_ ( const char * trans , int * n , int * nrhs , double * a , int * lda , int * ipiv , double * b , int * ldb , int * info ) { PROFILE_BEGIN (); dgetrs_ ( trans , n , nrhs , a , lda , ipiv , b , ldb , info ); PROFILE_END ( profile_dgetrs , ( double ) * nrhs * ( 2 * N2 - N )); } void lapack_dgejsv_ ( const char * joba , const char * jobu , const char * jobv , const char * jobr , const char * jobt , const char * jobp , int * m , int * n , double * a , int * lda , double * sva , double * u , int * ldu , double * v , int * ldv , double * work , int * lwork , int * iwork , int * info ) { PROFILE_LWORK_BEGIN (); dgejsv_ ( joba , jobu , jobv , jobr , jobt , jobp , m , n , a , lda , sva , u , ldu , v , ldv , work , lwork , iwork , info ); PROFILE_LWORK_END ( profile_dgejsv , 0 ); } #ifdef _SXX void lapack_dgerfsx_ ( const char * trans , const char * equed , int * n , int * nrhs , double * a , int * lda , double * af , int * ldaf , int * ipiv , double * r , double * c , double * b , int * ldb , double * x , int * ldx , double * rcond , double * berr , int * n_err_bnds , double * err_bnds_norm , double * err_bnds_comp , int * nparams , double * params , double * work , int * iwork , int * info ) { PROFILE_BEGIN (); dgerfsx_ ( trans , equed , n , nrhs , a , lda , af , ldaf , ipiv , r , c , b , ldb , x , ldx , rcond , berr , n_err_bnds , err_bnds_norm , err_bnds_comp , nparams , params , work , iwork , info ); PROFILE_END ( profile_dgerfsx , 0 ); } #endif void lapack_dgeqrf_ ( int * m , int * n , double * a , int * lda , double * tau , double * work , int * lwork , int * info ) { PROFILE_LWORK_BEGIN (); dgeqrf_ ( m , n , a , lda , tau , work , lwork , info ); PROFILE_LWORK_END ( profile_dgeqrf , 2 * M * N2 - 2 * N3 / 3 + M * N + N2 + 14 * N / 3 ); } void lapack_dlarft_ ( const char * direct , const char * storev , int * n , int * k , double * v , int * ldv , double * tau , double * t , int * ldt ) { PROFILE_BEGIN (); dlarft_ ( direct , storev , n , k , v , ldv , tau , t , ldt ); PROFILE_END ( profile_dlarft , 0 ); }","tags":"","loc":"sourcefile/blaslapack.c++.html"},{"title":"computeg.c++ – Quest","text":"Source Code #include <iostream> #include <cstdlib> #include <cstring> #include <cmath> #include <stdexcept> #include \"blaslapack.h\" #include \"profile.h\" #include \"kernel_cpu.h\" #ifdef DQMC_CUDA #include \"kernel_gpu.h\" #endif // class definition for ComputeG class gfun { public : gfun ( int n , int L , int nWrap , int fixw ); void computeg ( double * B , int nOrth , double * h , int il , double * G , double * sgn , double * det ); void stratification ( double * B , int k , double * h , int il , double * tau , double * Q , double * D , double * T ); void swapg ( double * B , double * Bi , double * h , double * G ); void invalid_cache ( int j ); void compute_M_cache ( double * B , double * h , int & il , int k , double * M , double * work ); ~ gfun (); private : // parameters from the simulation int n ; int L ; int nOrth ; int nWrap ; int fixw ; // memory allocation double * tau ; int * ipiv ; double * U ; double * D ; double * T ; double * A ; double * W ; double * Db ; int lwork ; double * work ; #ifdef DQMC_CUDA int * perm ; double * B_gpu ; double * B_fortran ; double * Bi_gpu ; double * Bi_fortran ; double * h_gpu ; double * U_gpu ; double * D_gpu ; double * T_gpu ; int nb ; double * work_gpu ; #endif double ** cache_M ; bool * cache_valid ; }; // Exported functions called from Fortran extern \"C\" { void cpp_gfun_init_ ( long * cpp_data , int * n , int * L , int * nWrap , int * fixw ); void cpp_gfun_computeg_ ( long * cpp_data , int * il , double * sgn , double * G , double * h , double * B , int * nOrth , double * det ); void cpp_gfun_free_ ( long * cpp_data ); void cpp_gfun_swapg_ ( long * cpp_data , double * B , double * Bi , double * h , double * G ); void cpp_gfun_invalid_cache_ ( long * cpp_data , int * j ); } void cpp_gfun_init_ ( long * cpp_data , int * n , int * L , int * nWrap , int * fixw ) { try { * cpp_data = ( long ) new gfun ( * n , * L , * nWrap , * fixw ); } catch ( std :: exception & e ) { std :: cerr << \"Error in C++ gfun_init: \" << e . what () << std :: endl ; exit ( 1 ); } } void cpp_gfun_computeg_ ( long * cpp_data , int * il , double * sgn , double * G , double * h , double * B , int * nOrth , double * det ) { try { (( gfun * ) * cpp_data ) -> computeg ( B , * nOrth , h , * il , G , sgn , det ); } catch ( std :: exception & e ) { std :: cerr << \"Error in C++ gfun_computeg: \" << e . what () << std :: endl ; exit ( 1 ); } } void cpp_gfun_free_ ( long * cpp_data ) { try { delete ( gfun * ) * cpp_data ; * cpp_data = 0 ; } catch ( std :: exception & e ) { std :: cerr << \"Error in C++ gfun_free: \" << e . what () << std :: endl ; exit ( 1 ); } } void cpp_gfun_swapg_ ( long * cpp_data , double * B , double * Bi , double * h , double * G ) { try { (( gfun * ) * cpp_data ) -> swapg ( B , Bi , h , G ); } catch ( std :: exception & e ) { std :: cerr << \"Error in C++ gfun_swapg: \" << e . what () << std :: endl ; exit ( 1 ); } } void cpp_gfun_invalid_cache_ ( long * cpp_data , int * j ) { try { (( gfun * ) * cpp_data ) -> invalid_cache ( * j ); } catch ( std :: exception & e ) { std :: cerr << \"Error in C++ gfun_invalid_cache: \" << e . what () << std :: endl ; exit ( 1 ); } } // Computes log(abs(det(M))) and sign(det(M)) from a LU decomposition void sgndet ( int n , double * M , int ldm , int * ipiv , double & sgn , double & det ) { sgn = 1.0 ; det = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ipiv [ i ] != ( i + 1 )) sgn = - sgn ; if ( M [ i * ldm + i ] < 0.0 ) { sgn = - sgn ; det += log ( - M [ i * ldm + i ]); } else { det += log ( M [ i * ldm + i ]); } } } // Computes M=B_{il+1}...B_1*B_L...B_{il+k} void compute_M ( int n , double * B , int L , double * h , int & il , int k , double * M , double * work ) { int l ; PROFILE_BEGIN (); il ++ ; if ( il >= L ) il = 0 ; SCALEROW ( n , h + il * n , B , M ); for ( l = 1 ; l < k ; l ++ ) { il ++ ; if ( il >= L ) il = 0 ; DGEMM ( \"NN\" , n , n , n , 1.0 , B , n , M , n , 0.0 , work , n ); SCALEROW ( n , h + il * n , work , M ); } PROFILE_END ( profile_computem , 0 ); } void gfun :: invalid_cache ( int j ) { if ( cache_valid ) { if ( j > 0 ) { if ( j > L ) throw ( std :: invalid_argument ( \"j > n\" )); cache_valid [ j - 1 ] = false ; } else { for ( int i = 0 ; i < L ; i ++ ) cache_valid [ i ] = false ; } } } void gfun :: compute_M_cache ( double * B , double * h , int & il , int k , double * M , double * work ) { if ( ! cache_M || k == 1 ) { // Don't use the cache compute_M ( n , B , L , h , il , k , M , work ); } else { int i = il ; bool valid = true ; for ( int l = 0 ; l < k && valid ; l ++ ) { i ++ ; if ( i >= L ) i = 0 ; valid = cache_valid [ i ]; } if ( valid ) { COPY ( M , cache_M [ il ], n * n * sizeof ( double )); il = i ; } else { i = il ; compute_M ( n , B , L , h , il , k , M , work ); if ( ! cache_M [ i ]) #ifdef DQMC_CUDA CUDACHECK ( cudaMalloc (( void ** )( cache_M + i ), n * n * sizeof ( double ))); #else cache_M [ i ] = new double [ n * n ]; #endif COPY ( cache_M [ i ], M , n * n * sizeof ( double )); for ( int l = 0 ; l < k ; l ++ ) { i ++ ; if ( i >= L ) i = 0 ; cache_valid [ i ] = true ; } } } } gfun :: gfun ( int n , int L , int nWrap , int fixw ) { this -> n = n ; this -> L = L ; this -> nOrth = -1 ; // mark as uninitialized this -> nWrap = nWrap ; this -> fixw = fixw ; #ifdef DQMC_CUDA // Start CUBLAS library gpu_init (); // Allocate buffers in the graphics memory CUDACHECK ( cudaMalloc (( void ** ) & B_gpu , n * n * sizeof ( double ))); CUDACHECK ( cudaMalloc (( void ** ) & Bi_gpu , n * n * sizeof ( double ))); B_fortran = Bi_fortran = NULL ; CUDACHECK ( cudaMalloc (( void ** ) & h_gpu , n * L * sizeof ( double ))); CUDACHECK ( cudaMalloc (( void ** ) & U_gpu , n * n * sizeof ( double ))); CUDACHECK ( cudaMalloc (( void ** ) & D_gpu , n * sizeof ( double ))); CUDACHECK ( cudaMalloc (( void ** ) & T_gpu , n * n * sizeof ( double ))); CUDACHECK ( cudaMalloc (( void ** ) & A , n * n * sizeof ( double ))); CUDACHECK ( cudaMalloc (( void ** ) & W , n * n * sizeof ( double ))); CUDACHECK ( cudaMalloc (( void ** ) & perm , n * sizeof ( int ))); #else // Allocate memory A = new double [ n * n ]; W = new double [ n * n ]; #endif U = new double [ n * n ]; D = new double [ n ]; T = new double [ n * n ]; tau = new double [ n ]; ipiv = new int [ n ]; Db = new double [ n ]; cache_M = NULL ; cache_valid = NULL ; // Allocate workspace for LAPACK double temp ; lapack_dgeqp3 ( n , n , U , n , ipiv , tau , & temp , -1 ); lwork = ( int ) temp ; lapack_dgeqrf ( n , n , U , n , tau , & temp , -1 ); if ( temp > lwork ) lwork = ( int ) temp ; lapack_dormqr ( \"RN\" , n , n , n , U , n , tau , A , n , & temp , -1 ); if ( temp > lwork ) lwork = ( int ) temp ; lapack_dorgqr ( n , n , n , U , n , tau , & temp , -1 ); if ( temp > lwork ) lwork = ( int ) temp ; work = new double [ lwork ]; #ifdef DQMC_CUDA // Allocate workspace for MAGMA nb = magma_get_dgeqrf_nb ( n ); CUDACHECK ( cudaMalloc (( void ** ) & work_gpu , ( 2 * n + ( n + 31 ) / 32 * 32 ) * nb * sizeof ( double ))); #endif } // Stratification loop void gfun :: stratification ( double * B , int k , double * h , int il , double * tau , double * Q , double * D , double * T ) { int i , l ; #ifdef DQMC_CUDA compute_M_cache ( B , h , il , k , Q , W ); // Q = B_1 gpu_getmatrix ( n , n , sizeof ( double ), Q , U ); for ( i = 0 ; i < n ; i ++ ) ipiv [ i ] = 0 ; lapack_dgeqp3 ( n , n , U , n , ipiv , tau , work , lwork ); // QRP for ( i = 0 ; i < n ; i ++ ) ipiv [ i ] -- ; gpu_setmatrix ( n , n , sizeof ( double ), U , Q ); gpu_setvector ( n , sizeof ( int ), ipiv , perm ); gpu_diag ( n , Q , D ); // D = diag(R) gpu_scalerowperm ( n , D , Q , perm , T ); // T = D&#94;-1*R*P lapack_dorgqr ( n , n , n , U , n , tau , work , lwork ); // build Q gpu_setmatrix ( n , n , sizeof ( double ), U , Q ); for ( l = 1 ; l < L / k ; l ++ ) { // Q = (B_l*Q)*D compute_M_cache ( B , h , il , k , W , A ); // W = B_l gpu_dgemm ( \"NN\" , n , n , n , 1.0 , W , n , Q , n , 0.0 , A , n ); // A = W * Q // A = A * D and compute the norm of each column gpu_normcol ( n , A , D , work_gpu ); // compute a permutation P that sorts the columns of A gpu_sort ( n , work_gpu , perm ); // apply the permutation gpu_permute ( n , perm , A , Q ); // standard QR gpu_dgeqrf ( n , n , Q , n , tau , work_gpu ); // built R COPY ( W , Q , n * n * sizeof ( double )); magmablas_dswapdblk ( n , nb , W , n , 1 , work_gpu + n * nb , nb , 0 ); gpu_diag ( n , W , D ); // D = diag(R) // T = D&#94;-1 * R * P * T gpu_scalerowperm ( n , D , W , perm , A ); // A = D&#94;-1*R*P gpu_dorgqr ( n , n , n , Q , n , tau , work_gpu , nb ); // build Q DGEMM ( \"NN\" , n , n , n , 1.0 , A , n , T , n , 0.0 , W , n ); // W = A * T COPY ( T , W , n * n * sizeof ( double )); // T = W } #else compute_M_cache ( B , h , il , k , Q , W ); // Q = B_1 for ( i = 0 ; i < n ; i ++ ) ipiv [ i ] = 0 ; lapack_dgeqp3 ( n , n , Q , n , ipiv , tau , work , lwork ); // QRP for ( i = 0 ; i < n ; i ++ ) ipiv [ i ] -- ; cpu_diag ( n , Q , D ); // D = diag(R) cpu_scalerowperm ( n , D , Q , ipiv , T ); // T = D&#94;-1*R*P for ( l = 1 ; l < L / k ; l ++ ) { // Q = (B_l*Q)*D compute_M_cache ( B , h , il , k , A , W ); // A = B_l lapack_dormqr ( \"RN\" , n , n , n , Q , n , tau , A , n , work , lwork ); // A = A * Q #if 0 // Original stratification method with QRP int j; for (j = 0; j < n; j++) for (i = 0; i < n; i++) Q[j * n + i] = A[j * n + i] * D[j]; for (i = 0; i < n; i++) ipiv[i] = 0; lapack_dgeqp3(n, n, Q, n, ipiv, tau, work, lwork); // QRP for (i = 0; i < n; i++) ipiv[i]--; #else // A = A * D and compute the norm of each column cpu_normcol ( n , A , D , Db ); // compute a permutation P that sorts the columns of A cpu_sort ( n , Db , ipiv ); // apply the permutation cpu_permute ( n , ipiv , A , Q ); // standard QR lapack_dgeqrf ( n , n , Q , n , tau , work , lwork ); #endif cpu_diag ( n , Q , D ); // D = diag(R) // T = D&#94;-1 * R * P * T cpu_scalerowperm ( n , D , Q , ipiv , A ); // A = D&#94;-1*R*P DGEMM ( \"NN\" , n , n , n , 1.0 , A , n , T , n , 0.0 , W , n ); // W = A * T COPY ( T , W , n * n * sizeof ( double )); // T = W } lapack_dorgqr ( n , n , n , Q , n , tau , work , lwork ); // build Q #endif } void gfun :: computeg ( double * B , int k , double * h , int il , double * G , double * psgn , double * pdet ) { if ( k != 1 ) { if ( nOrth == -1 ) { // Initialization of nOrth nOrth = k ; if ( L % nOrth ) throw ( std :: invalid_argument ( \"L must be a multiple of nOrth for prepivoting\" )); if ( nOrth == nWrap && fixw ) { // Allocate space for block cache cache_M = new double * [ L ]; cache_valid = new bool [ L ]; for ( int i = 0 ; i < L ; i ++ ) { cache_M [ i ] = NULL ; cache_valid [ i ] = false ; } } } else if ( k != nOrth ) throw ( std :: invalid_argument ( \"nOrth cannot change during simulation\" )); } // Compute G using the ASQRD algorithm PROFILE_ENABLE (); PROFILE_BEGIN (); int i ; // Build Q * D * T = B_L * B_L-1 * .. * B_1 #ifdef DQMC_CUDA if ( B != B_fortran ) { // Do not copy B if its pointer is the same as previous calls gpu_setmatrix ( n , n , sizeof ( double ), B , B_gpu ); B_fortran = B ; } gpu_setmatrix ( n , L , sizeof ( double ), h , h_gpu ); stratification ( B_gpu , k , h_gpu , il - 1 , tau , U_gpu , D_gpu , T_gpu ); gpu_getmatrix ( n , n , sizeof ( double ), U_gpu , U ); gpu_getvector ( n , sizeof ( double ), D_gpu , D ); gpu_getmatrix ( n , n , sizeof ( double ), T_gpu , T ); #else stratification ( B , k , h , il - 1 , tau , U , D , T ); #endif // compute G = (Db&#94;-1 * Q' + Ds * T)&#94;-1 * Db&#94;-1 * Q' // split D and compute det(Db) double sgn2 = 1.0 , det2 = 0.0 ; for ( i = 0 ; i < n ; i ++ ) if ( fabs ( D [ i ]) > 1 ) { Db [ i ] = D [ i ]; D [ i ] = 1.0 ; if ( Db [ i ] < 0.0 ) { sgn2 = - sgn2 ; det2 += log ( - Db [ i ]); } else { det2 += log ( Db [ i ]); } } else { Db [ i ] = 1.0 ; } // G = Db * Q' ; T = Db * Q' + Ds * T cpu_scalerowadd ( n , Db , U , D , T , G ); // G = T&#94;-1 * G lapack_dgetrf ( n , n , T , n , ipiv ); double sgn1 , det1 ; sgndet ( n , T , n , ipiv , sgn1 , det1 ); lapack_dgetrs ( \"N\" , n , n , T , n , ipiv , G , n ); // compute det(Q) double sgn3 = 1.0 ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( tau [ i ] != 0 ) sgn3 = - sgn3 ; * psgn = sgn1 * sgn2 * sgn3 ; * pdet = - det1 - det2 ; PROFILE_END ( profile_computeg , 0 ); PROFILE_DISABLE (); } gfun ::~ gfun () { // Free allocated memory #ifdef DQMC_CUDA CUDACHECK ( cudaFree ( B_gpu )); CUDACHECK ( cudaFree ( Bi_gpu )); CUDACHECK ( cudaFree ( h_gpu )); CUDACHECK ( cudaFree ( U_gpu )); CUDACHECK ( cudaFree ( D_gpu )); CUDACHECK ( cudaFree ( T_gpu )); CUDACHECK ( cudaFree ( A )); CUDACHECK ( cudaFree ( W )); CUDACHECK ( cudaFree ( work_gpu )); CUDACHECK ( cudaFree ( perm )); gpu_shutdown (); #else delete [] A ; delete [] W ; #endif delete [] U ; delete [] D ; delete [] T ; delete [] tau ; delete [] ipiv ; delete [] Db ; if ( cache_M ) { for ( int i = 0 ; i < L ; i ++ ) if ( cache_M [ i ]) #ifdef DQMC_CUDA CUDACHECK ( cudaFree ( cache_M [ i ])); #else delete [] cache_M [ i ]; #endif delete [] cache_M ; delete [] cache_valid ; } delete [] work ; } void gfun :: swapg ( double * B , double * Bi , double * h , double * G ) { // Computes G = h * B * G * Bi / h PROFILE_ENABLE (); PROFILE_BEGIN (); #ifdef DQMC_CUDA /* Do not copy B or Bi if their pointers are the same as previous calls */ if ( B != B_fortran ) { gpu_setmatrix ( n , n , sizeof ( double ), B , B_gpu ); B_fortran = B ; } if ( Bi != Bi_fortran ) { gpu_setmatrix ( n , n , sizeof ( double ), Bi , Bi_gpu ); Bi_fortran = Bi ; } gpu_setmatrix ( n , n , sizeof ( double ), G , T_gpu ); gpu_setvector ( n , sizeof ( double ), h , h_gpu ); // W = B * G DGEMM ( \"NN\" , n , n , n , 1.0 , B_gpu , n , T_gpu , n , 0.0 , W , n ); // G = W * Bi DGEMM ( \"NN\" , n , n , n , 1.0 , W , n , Bi_gpu , n , 0.0 , T_gpu , n ); // G = h * G / h SCALEROWCOL ( n , h_gpu , T_gpu ); gpu_getmatrix ( n , n , sizeof ( double ), T_gpu , G ); #else // W = B * G DGEMM ( \"NN\" , n , n , n , 1.0 , B , n , G , n , 0.0 , T , n ); // G = W * Bi DGEMM ( \"NN\" , n , n , n , 1.0 , T , n , Bi , n , 0.0 , G , n ); // G = h * G / h SCALEROWCOL ( n , h , G ); #endif PROFILE_END ( profile_swapg , 0 ); PROFILE_DISABLE (); }","tags":"","loc":"sourcefile/computeg.c++.html"},{"title":"dqmc_omp.h – Quest","text":"Source Code #define _OMPTDM","tags":"","loc":"sourcefile/dqmc_omp.h.html"},{"title":"kernel_cpu.h – Quest","text":"Source Code void cpu_diag ( int n , double * A , double * D ); void cpu_normcol ( int n , double * A , double * D , double * c ); void cpu_permute ( int n , int * ipiv , double * A , double * Q ); void cpu_scalerowperm ( int n , double * D , double * Q , int * ipiv , double * T ); void cpu_scalerow ( int n , double * h , double * B , double * M ); void cpu_scalerowcol ( int n , double * h , double * G ); void cpu_scalerowadd ( int n , double * Db , double * U , double * D , double * T , double * G ); void cpu_sort ( int n , double * Db , int * ipiv ); #ifndef DQMC_CUDA #define DGEMM blas_dgemm #define SCALEROW cpu_scalerow #define SCALEROWCOL cpu_scalerowcol #define COPY(d, o, s) memcpy(d, o, s) #endif","tags":"","loc":"sourcefile/kernel_cpu.h.html"},{"title":"profile.h – Quest","text":"Source Code #include <time.h> /* perfomance counters */ #ifdef DQMC_PROFILE #define PROFILE_MAX 10 #define PROFILE_ENABLE() profile_enabled = 1; #define PROFILE_DISABLE() profile_enabled = 0; #define PROFILE_BEGIN() if (profile_enabled) { \\ profile_count++; \\ profile_time[profile_count] = get_time(); \\ profile_flops[profile_count] = 0; } #define PROFILE_END(i, n) if (profile_enabled) { \\ profile[i].count++; \\ profile[i].time += get_time() - profile_time[profile_count]; \\ profile[i].flops += n + profile_flops[profile_count]; \\ profile_flops[profile_count - 1] += n + profile_flops[profile_count]; \\ profile_count--; } #define PROFILE_LWORK_BEGIN() PROFILE_BEGIN() #define PROFILE_LWORK_END(i, n) PROFILE_END(i, n) enum { profile_dcopy , profile_daxpy , profile_dscal , profile_ddot , profile_dgemv , profile_dgemm , profile_dtrmm , profile_dtrsm , profile_dsyev , profile_dgesv , profile_dgeqp3 , profile_dorgqr , profile_dormqr , profile_dgetrf , profile_dgetri , profile_dgetrs , profile_dgejsv , profile_dgerfsx , profile_dgeqrf , profile_dlarft , profile_scalerow , profile_scalerowcol , profile_normcol , profile_sort , profile_permute , profile_scalerowperm , profile_scalerowadd , profile_computeg , profile_computem , profile_swapg , profile_transfer , profile_last }; struct profile_item { const char * name ; int count ; double time ; double flops ; }; extern profile_item profile [ profile_last ]; extern int profile_enabled , profile_count ; extern double profile_time [ PROFILE_MAX ]; extern double profile_flops [ PROFILE_MAX ]; extern \"C\" { void profile_enable_ (); void profile_disable_ (); void profile_begin_ (); void profile_end_ ( int * i , int * n ); void profile_print_ (); void get_time_ ( double * t ); } inline double get_time () { struct timespec tv ; clock_gettime ( CLOCK_MONOTONIC , & tv ); return tv . tv_sec + tv . tv_nsec * 1e-9 ; } #else #define PROFILE_ENABLE() #define PROFILE_DISABLE() #define PROFILE_BEGIN() #define PROFILE_END(i, n) #define PROFILE_LWORK_BEGIN() #define PROFILE_LWORK_END(i, n) #endif","tags":"","loc":"sourcefile/profile.h.html"},{"title":"kernel_gpu.h – Quest","text":"Source Code #include <exception> #include <magma.h> class cuda_exception : public std :: exception { char message [ 100 ]; public : cuda_exception ( const char * file , int line , int code ); virtual const char * what () const throw (); }; #define CUDACHECK(a) { int code = (a); if (code) throw(cuda_exception(__FILE__, __LINE__, code)); } void gpu_init (); void gpu_shutdown (); void gpu_diag ( int n , double * A , double * D ); void gpu_normcol ( int n , double * A , double * D , double * c ); void gpu_permute ( int n , int * ipiv , double * A , double * Q ); void gpu_scalerowperm ( int n , double * D , double * Q , int * ipiv , double * T ); void gpu_scalerow ( int n , double * h , double * B , double * M ); void gpu_scalerowcol ( int n , double * h , double * G ); void gpu_dgemm ( const char * trans , int m , int n , int k , double alpha , double * a , int lda , double * b , int ldb , double beta , double * c , int ldc ); void gpu_dgeqrf ( int m , int n , double * dA , int ldda , double * tau , double * dT ); void gpu_dorgqr ( int m , int n , int k , double * da , int ldda , double * tau , double * dT , int nb ); void gpu_dgetrf ( int m , int n , double * dA , int ldda , int * ipiv ); void gpu_dgetrs ( const char * trans , int n , int nrhs , double * dA , int ldda , int * ipiv , double * dB , int lddb ); void gpu_setvector ( int n , int size , void * src , void * dst ); void gpu_getvector ( int n , int size , void * src , void * dst ); void gpu_setmatrix ( int m , int n , int size , void * src , void * dst ); void gpu_getmatrix ( int m , int n , int size , void * src , void * dst ); void gpu_copy ( void * dst , void * src , int size ); void gpu_sort ( int n , double * Db , int * ipiv ); #ifdef DQMC_CUDA #define DGEMM gpu_dgemm #define SCALEROW gpu_scalerow #define SCALEROWCOL gpu_scalerowcol #define COPY(d, o, s) gpu_copy(d, o, s) #endif","tags":"","loc":"sourcefile/kernel_gpu.h.html"},{"title":"dqmc_include.h – Quest","text":"Source Code ! ! DEFINITION OF SOME PRE_PROCESSOR ! ! ================================================== ! CKB means checker - board method for sparse matrix B . ! If it is defined , the program will use check - board ! method in B matrix multiplication . ! Otherwise , a dense matrix B will be formed ! explicitly . ! ================================================== ! #ifdef  _CKB #define _DQMC_MATB DQMC_CKB #else #define _DQMC_MATB DQMC_MATB #endif","tags":"","loc":"sourcefile/dqmc_include.h.html"},{"title":"profile.c++ – Quest","text":"Source Code #include <cstdio> #include \"profile.h\" #ifdef DQMC_PROFILE profile_item profile [ profile_last ] = { { \"DCOPY    \" , 0 , 0 , 0 }, { \"DAXPY    \" , 0 , 0 , 0 }, { \"DSCAL    \" , 0 , 0 , 0 }, { \"DDOT     \" , 0 , 0 , 0 }, { \"DGEMV    \" , 0 , 0 , 0 }, { \"DGEMM    \" , 0 , 0 , 0 }, { \"DTRMM    \" , 0 , 0 , 0 }, { \"DTRSM    \" , 0 , 0 , 0 }, { \"DSYEV    \" , 0 , 0 , 0 }, { \"DGESV    \" , 0 , 0 , 0 }, { \"DGEQP3   \" , 0 , 0 , 0 }, { \"DORGQR   \" , 0 , 0 , 0 }, { \"DORMQR   \" , 0 , 0 , 0 }, { \"DGETRF   \" , 0 , 0 , 0 }, { \"DGETRI   \" , 0 , 0 , 0 }, { \"DGETRS   \" , 0 , 0 , 0 }, { \"DGEJSV   \" , 0 , 0 , 0 }, { \"DGERFSX  \" , 0 , 0 , 0 }, { \"DGEQRF   \" , 0 , 0 , 0 }, { \"DLARFT   \" , 0 , 0 , 0 }, { \"ScaleRow \" , 0 , 0 , 0 }, { \"SRCol    \" , 0 , 0 , 0 }, { \"NormCol  \" , 0 , 0 , 0 }, { \"Sort     \" , 0 , 0 , 0 }, { \"Permute  \" , 0 , 0 , 0 }, { \"SRPerm   \" , 0 , 0 , 0 }, { \"SRAdd    \" , 0 , 0 , 0 }, { \"ComputeG \" , 0 , 0 , 0 }, { \"ComputeM \" , 0 , 0 , 0 }, { \"SwapG    \" , 0 , 0 , 0 }, { \"Transfer \" , 0 , 0 , 0 } }; int profile_enabled = 0 , profile_count = 0 ; double profile_time [ PROFILE_MAX ]; double profile_flops [ PROFILE_MAX ]; void profile_enable_ () { PROFILE_ENABLE (); } void profile_disable_ () { PROFILE_DISABLE (); } void profile_begin_ () { PROFILE_BEGIN (); } void profile_end_ ( int * i , int * n ) { PROFILE_END ( * i , * n ); } void profile_print_ () { fflush ( NULL ); for ( int i = 0 ; i < profile_last ; i ++ ) { if ( profile [ i ]. count ) printf ( \" %s %18i  %22.16f %10.2f \\n \" , profile [ i ]. name , profile [ i ]. count , profile [ i ]. time , profile [ i ]. time > 0.0 ? profile [ i ]. flops * 1e-6 / profile [ i ]. time : 0.0 ); } } void get_time_ ( double * t ) { * t = get_time (); } #endif","tags":"","loc":"sourcefile/profile.c++.html"},{"title":"blaslapack.h – Quest","text":"Source Code #include <exception> /* Interface to Fortran double precision BLAS and LAPACK with profiling */ extern \"C\" { void blas_dcopy_ ( int * n , double * sx , int * incx , double * sy , int * incy ); void blas_daxpy_ ( int * n , double * sa , double * sx , int * incx , double * sy , int * incy ); void blas_dscal_ ( int * n , double * sa , double * sx , int * incx ); double blas_ddot_ ( int * n , double * sx , int * incx , double * sy , int * incy ); void blas_dgemv_ ( const char * trans , int * m , int * n , double * alpha , double * a , int * lda , double * x , int * incx , double * beta , double * y , int * incy ); void blas_dgemm_ ( const char * transa , const char * transb , int * m , int * n , int * k , double * alpha , double * a , int * lda , double * b , int * ldb , double * beta , double * c , int * ldc ); void blas_dtrmm_ ( const char * side , const char * uplo , const char * transa , const char * diag , int * m , int * n , double * alpha , double * a , int * lda , double * b , int * ldb ); void blas_dtrsm_ ( const char * side , const char * uplo , const char * transa , const char * diag , int * m , int * n , double * alpha , double * a , int * lda , double * b , int * ldb ); void lapack_dsyev_ ( const char * jobz , const char * uplo , int * n , double * a , int * lda , double * w , double * work , int * lwork , int * info ); void lapack_dgesv_ ( int * n , int * nrhs , double * a , int * lda , int * ipiv , double * b , int * ldb , int * info ); void lapack_dgeqp3_ ( int * m , int * n , double * a , int * lda , int * jpvt , double * tau , double * work , int * lwork , int * info ); void lapack_dorgqr_ ( int * m , int * n , int * k , double * a , int * lda , double * tau , double * work , int * lwork , int * info ); void lapack_dormqr_ ( const char * side , const char * trans , int * m , int * n , int * k , double * a , int * lda , double * tau , double * c , int * ldc , double * work , int * lwork , int * info ); void lapack_dgetrf_ ( int * m , int * n , double * a , int * lda , int * ipiv , int * info ); void lapack_dgetri_ ( int * n , double * a , int * lda , int * ipiv , double * work , int * lwork , int * info ); void lapack_dgetrs_ ( const char * trans , int * n , int * nrhs , double * a , int * lda , int * ipiv , double * b , int * ldb , int * info ); void lapack_dgejsv_ ( const char * joba , const char * jobu , const char * jobv , const char * jobr , const char * jobt , const char * jobp , int * m , int * n , double * a , int * lda , double * sva , double * u , int * ldu , double * v , int * ldv , double * work , int * lwork , int * iwork , int * info ); void lapack_dgerfsx_ ( const char * trans , const char * equed , int * n , int * nrhs , double * a , int * lda , double * af , int * ldaf , int * ipiv , double * r , double * c , double * b , int * ldb , double * x , int * ldx , double * rcond , double * berr , int * n_err_bnds , double * err_bnds_norm , double * err_bnds_comp , int * nparams , double * params , double * work , int * iwork , int * info ); void lapack_dgeqrf_ ( int * m , int * n , double * a , int * lda , double * tau , double * work , int * lwork , int * info ); void lapack_dlarft_ ( const char * direct , const char * storev , int * n , int * k , double * v , int * ldv , double * tau , double * t , int * ldt ); double dlange_ ( const char * norm , int * m , int * n , double * a , int * lda , double * work ); } /* Stubs for easier C++ interface */ class lapack_exception : public std :: exception { char message [ 100 ]; public : lapack_exception ( const char * function , int info ); virtual const char * what () const throw (); }; inline void blas_dcopy ( int n , double * sx , int incx , double * sy , int incy ) { blas_dcopy_ ( & n , sx , & incx , sy , & incy ); } inline void blas_daxpy ( int n , double sa , double * sx , int incx , double * sy , int incy ) { blas_daxpy_ ( & n , & sa , sx , & incx , sy , & incy ); } inline void blas_dscal ( int n , double sa , double * sx , int incx ) { blas_dscal_ ( & n , & sa , sx , & incx ); } inline double blas_ddot ( int n , double * sx , int incx , double * sy , int incy ) { return blas_ddot_ ( & n , sx , & incx , sy , & incy ); } inline void blas_dgemv ( const char * trans , int m , int n , double alpha , double * a , int lda , double * x , int incx , double beta , double * y , int incy ) { blas_dgemv_ ( trans , & m , & n , & alpha , a , & lda , x , & incx , & beta , y , & incy ); } inline void blas_dgemm ( const char * tab , int m , int n , int k , double alpha , double * a , int lda , double * b , int ldb , double beta , double * c , int ldc ) { blas_dgemm_ ( tab , tab + 1 , & m , & n , & k , & alpha , a , & lda , b , & ldb , & beta , c , & ldc ); } inline void blas_dtrmm ( const char * sutd , int m , int n , double alpha , double * a , int lda , double * b , int ldb ) { blas_dtrmm_ ( sutd , sutd + 1 , sutd + 2 , sutd + 3 , & m , & n , & alpha , a , & lda , b , & ldb ); } inline void blas_dtrsm ( const char * sutd , int m , int n , double alpha , double * a , int lda , double * b , int ldb ) { blas_dtrmm_ ( sutd , sutd + 1 , sutd + 2 , sutd + 3 , & m , & n , & alpha , a , & lda , b , & ldb ); } inline void lapack_dgeqrf ( int m , int n , double * a , int lda , double * tau , double * work , int lwork ) { int info ; lapack_dgeqrf_ ( & m , & n , a , & lda , tau , work , & lwork , & info ); if ( info ) throw ( lapack_exception ( \"DGEQRF\" , info )); } inline void lapack_dorgqr ( int m , int n , int k , double * a , int lda , double * tau , double * work , int lwork ) { int info ; lapack_dorgqr_ ( & m , & n , & k , a , & lda , tau , work , & lwork , & info ); if ( info ) throw ( lapack_exception ( \"DORGQR\" , info )); } inline void lapack_dlarft ( const char * ds , int n , int k , double * v , int ldv , double * tau , double * t , int ldt ) { lapack_dlarft_ ( ds , ds + 1 , & n , & k , v , & ldv , tau , t , & ldt ); } inline void lapack_dgetrf ( int m , int n , double * a , int lda , int * ipiv ) { int info ; lapack_dgetrf_ ( & m , & n , a , & lda , ipiv , & info ); if ( info ) throw ( lapack_exception ( \"DGETRF\" , info )); } inline void lapack_dgetri ( int n , double * a , int lda , int * ipiv , double * work , int lwork ) { int info ; lapack_dgetri_ ( & n , a , & lda , ipiv , work , & lwork , & info ); if ( info ) throw ( lapack_exception ( \"DGETRI\" , info )); } inline void lapack_dgeqp3 ( int m , int n , double * a , int lda , int * jpvt , double * tau , double * work , int lwork ) { int info ; lapack_dgeqp3_ ( & m , & n , a , & lda , jpvt , tau , work , & lwork , & info ); if ( info ) throw ( lapack_exception ( \"DGEQP3\" , info )); } inline void lapack_dormqr ( const char * st , int m , int n , int k , double * a , int lda , double * tau , double * c , int ldc , double * work , int lwork ) { int info ; lapack_dormqr_ ( st , st + 1 , & m , & n , & k , a , & lda , tau , c , & ldc , work , & lwork , & info ); if ( info ) throw ( lapack_exception ( \"DORMQR\" , info )); } inline void lapack_dgetrs ( const char * trans , int n , int nrhs , double * a , int lda , int * ipiv , double * b , int ldb ) { int info ; lapack_dgetrs_ ( trans , & n , & nrhs , a , & lda , ipiv , b , & ldb , & info ); if ( info ) throw ( lapack_exception ( \"DGETRS\" , info )); } inline void lapack_dgejsv ( const char * job , int m , int n , double * a , int lda , double * sva , double * u , int ldu , double * v , int ldv , double * work , int lwork , int * iwork ) { int info ; lapack_dgejsv_ ( job , job + 1 , job + 2 , job + 3 , job + 4 , job + 5 , & m , & n , a , & lda , sva , u , & ldu , v , & ldv , work , & lwork , iwork , & info ); if ( info ) throw ( lapack_exception ( \"DGEJSV\" , info )); } inline void lapack_dsyev ( const char * ju , int n , double * a , int lda , double * w , double * work , int lwork ) { int info ; lapack_dsyev_ ( ju , ju + 1 , & n , a , & lda , w , work , & lwork , & info ); if ( info ) throw ( lapack_exception ( \"DSYEV\" , info )); } inline double lapack_dlange ( const char * norm , int m , int n , double * a , int lda , double * work ) { return dlange_ ( norm , & m , & n , a , & lda , work ); }","tags":"","loc":"sourcefile/blaslapack.h.html"},{"title":"kernel_gpu.cu – Quest","text":"Source Code // Implementation of the different kernels in the GPU using CUDA #include \"blaslapack.h\" #include \"profile.h\" #include \"kernel_gpu.h\" #include <cstdio> #include <cublas_v2.h> // Thread block size for all kernels #define K 64 #ifdef DQMC_PROFILE #define GPU_PROFILE_BEGIN() if (profile_enabled) cudaDeviceSynchronize(); \\ PROFILE_BEGIN() #define GPU_PROFILE_END(i, n) if (profile_enabled) cudaDeviceSynchronize(); \\ PROFILE_END(i, n) #else #define GPU_PROFILE_BEGIN() #define GPU_PROFILE_END(i, n) #endif cuda_exception :: cuda_exception ( const char * file , int line , int code ) { snprintf ( message , sizeof ( message ), \"CUDA error #%i at %s:%i \\n \" , code , file , line ); } const char * cuda_exception :: what () const throw () { return message ; } // static stuff for the CUBLAS library static cublasHandle_t handle = NULL ; void gpu_diag ( int n , double * A , double * D ) { GPU_PROFILE_BEGIN (); CUDACHECK ( cublasDcopy ( handle , n , A , n + 1 , D , 1 )); GPU_PROFILE_END ( profile_dcopy , 16.0 * n ); } __global__ void kernel_normcol ( int n , double * A , double * D , double * c ) { int i , tid = threadIdx . x , j = blockIdx . x * n ; // working column __shared__ volatile double shared [ K ]; double t , w = 0.0 , d = D [ blockIdx . x ]; double * p = A + j + tid ; for ( i = tid ; i < n ; i += K ) { // t = A[j + i] * d; t = * p * d ; // A[j + i] = t; * p = t ; w += t * t ; p += K ; } shared [ tid ] = w ; __syncthreads (); if ( K >= 512 ) { if ( tid < 256 ) { shared [ tid ] = w = w + shared [ tid + 256 ]; } __syncthreads (); } if ( K >= 256 ) { if ( tid < 128 ) { shared [ tid ] = w = w + shared [ tid + 128 ]; } __syncthreads (); } if ( K >= 128 ) { if ( tid < 64 ) { shared [ tid ] = w = w + shared [ tid + 64 ]; } __syncthreads (); } if ( tid < 32 ) { if ( K >= 64 ) shared [ tid ] = w = w + shared [ tid + 32 ]; if ( K >= 32 ) shared [ tid ] = w = w + shared [ tid + 16 ]; if ( K >= 16 ) shared [ tid ] = w = w + shared [ tid + 8 ]; if ( K >= 8 ) shared [ tid ] = w = w + shared [ tid + 4 ]; if ( K >= 4 ) shared [ tid ] = w = w + shared [ tid + 2 ]; if ( K >= 2 ) shared [ tid ] = w = w + shared [ tid + 1 ]; } if ( tid == 0 ) c [ blockIdx . x ] = w ; } void gpu_normcol ( int n , double * A , double * D , double * c ) { GPU_PROFILE_BEGIN (); kernel_normcol <<< n , K >>> ( n , A , D , c ); CUDACHECK ( cudaGetLastError ()); GPU_PROFILE_END ( profile_normcol , 2.0 * n * n ); } __global__ void kernel_permute ( int n , int * ipiv , double * A , double * Q ) { int i , j = blockIdx . x * n ; // working column int p = ipiv [ blockIdx . x ] * n ; double * pQ = Q + j + threadIdx . x ; double * pA = A + p + threadIdx . x ; for ( i = threadIdx . x ; i < n ; i += K ) { // Q[j + i] = A[p + i]; * pQ = * pA ; pQ += K ; pA += K ; } } void gpu_permute ( int n , int * ipiv , double * A , double * Q ) { GPU_PROFILE_BEGIN (); kernel_permute <<< n , K >>> ( n , ipiv , A , Q ); CUDACHECK ( cudaGetLastError ()); GPU_PROFILE_END ( profile_permute , 16.0 * n * n ); } __global__ void kernel_scalerowperm ( int n , double * D , double * Q , int * ipiv , double * T ) { int i , j = blockIdx . x ; // working column int p = ipiv [ j ] * n ; double * pT = T + p + threadIdx . x ; double * pQ = Q + j * n + threadIdx . x ; double * pD = D + threadIdx . x ; for ( i = threadIdx . x ; i <= j ; i += K ) { // T[p + i] = Q[j * n + i] / D[i]; // T = D&#94;-1*R*P * pT = * pQ / * pD ; pT += K ; pQ += K ; pD += K ; } for (; i < n ; i += K ) { // T[p + i] = 0; * pT = 0.0 ; pT += K ; } } void gpu_scalerowperm ( int n , double * D , double * Q , int * ipiv , double * T ) { GPU_PROFILE_BEGIN (); kernel_scalerowperm <<< n , K >>> ( n , D , Q , ipiv , T ); CUDACHECK ( cudaGetLastError ()); GPU_PROFILE_END ( profile_scalerowperm , 0.5 * n * n ); } __global__ void kernel_scalerow ( int n , double * h , double * B , double * M ) { int i , j = blockIdx . x * n ; // working column double * pM = M + j + threadIdx . x ; double * ph = h + threadIdx . x ; double * pB = B + j + threadIdx . x ; for ( i = threadIdx . x ; i < n ; i += K ) { // M[j + i] = h[i] * B[j + i]; * pM = * ph * * pB ; pM += K ; ph += K ; pB += K ; } } void gpu_scalerow ( int n , double * h , double * B , double * M ) { GPU_PROFILE_BEGIN (); kernel_scalerow <<< n , K >>> ( n , h , B , M ); CUDACHECK ( cudaGetLastError ()); GPU_PROFILE_END ( profile_scalerow , 1.0 * n * n ); } __global__ void kernel_scalerowcol ( int n , double * h , double * G ) { // G = diag(h) * G * diag(h)&#94;-1 int i , j = blockIdx . x * n ; // working column double t , f = 1.0 / h [ blockIdx . x ]; double * pG = G + j + threadIdx . x ; double * ph = h + threadIdx . x ; for ( i = threadIdx . x ; i < n ; i += K ) { // G[j + i] = h[i] * G[j + i] / f; t = * ph * * pG ; * pG = t * f ; pG += K ; ph += K ; } } void gpu_scalerowcol ( int n , double * h , double * G ) { GPU_PROFILE_BEGIN (); kernel_scalerowcol <<< n , K >>> ( n , h , G ); CUDACHECK ( cudaGetLastError ()); GPU_PROFILE_END ( profile_scalerowcol , 2.0 * n * n ); } void gpu_dgemm ( const char * trans , int m , int n , int k , double alpha , double * a , int lda , double * b , int ldb , double beta , double * c , int ldc ) { GPU_PROFILE_BEGIN (); cublasOperation_t transa = trans [ 0 ] == 'N' ? CUBLAS_OP_N : CUBLAS_OP_T ; cublasOperation_t transb = trans [ 1 ] == 'N' ? CUBLAS_OP_N : CUBLAS_OP_T ; CUDACHECK ( cublasDgemm ( handle , transa , transb , m , n , k , & alpha , a , lda , b , ldb , & beta , c , ldc )); GPU_PROFILE_END ( profile_dgemm , 2.0 * k * m * n ); } void gpu_dgeqrf ( int m , int n , double * dA , int ldda , double * tau , double * dT ) { int info ; GPU_PROFILE_BEGIN (); magma_dgeqrf3_gpu ( m , n , dA , ldda , tau , dT , & info ); if ( info ) throw ( lapack_exception ( \"GPU DGEQRF\" , info )); GPU_PROFILE_END ( profile_dgeqrf , 2.0 * m * n * n - 2.0 * n * n * n / 3.0 + m * n + n * n + 14.0 * n / 3.0 ); } void gpu_dorgqr ( int m , int n , int k , double * da , int ldda , double * tau , double * dT , int nb ) { int info ; GPU_PROFILE_BEGIN (); magma_dorgqr_gpu ( m , n , k , da , ldda , tau , dT , nb , & info ); if ( info ) throw ( lapack_exception ( \"GPU DORGQR\" , info )); GPU_PROFILE_END ( profile_dorgqr , 4.0 * m * n * k - 2.0 * ( m + n ) * k * k + 4.0 * k * k * k / 3.0 + 3.0 * n * k - m * k - k * k - 4.0 * k / 3.0 ); } void gpu_dgetrf ( int m , int n , double * dA , int ldda , int * ipiv ) { int info ; GPU_PROFILE_BEGIN (); magma_dgetrf_gpu ( m , n , dA , ldda , ipiv , & info ); if ( info ) throw ( lapack_exception ( \"GPU DGETRF\" , info )); GPU_PROFILE_END ( profile_dgetrf , m * n * n - n * n * n / 3.0 - n * n / 2.0 + 5.0 * n / 6.0 ); } void gpu_dgetrs ( const char * trans , int n , int nrhs , double * dA , int ldda , int * ipiv , double * dB , int lddb ) { int info ; GPU_PROFILE_BEGIN (); magma_dgetrs_gpu ( trans [ 0 ], n , nrhs , dA , ldda , ipiv , dB , lddb , & info ); if ( info ) throw ( lapack_exception ( \"GPU DGETRS\" , info )); GPU_PROFILE_END ( profile_dgetrs , nrhs * ( 2.0 * n * n - n )); } void gpu_setvector ( int n , int size , void * src , void * dst ) { GPU_PROFILE_BEGIN (); CUDACHECK ( cublasSetVector ( n , size , src , 1 , dst , 1 )); GPU_PROFILE_END ( profile_transfer , 2.0 * n * size ); } void gpu_getvector ( int n , int size , void * src , void * dst ) { GPU_PROFILE_BEGIN (); CUDACHECK ( cublasGetVector ( n , size , src , 1 , dst , 1 )); GPU_PROFILE_END ( profile_transfer , 2.0 * n * size ); } void gpu_setmatrix ( int m , int n , int size , void * src , void * dst ) { GPU_PROFILE_BEGIN (); CUDACHECK ( cublasSetMatrix ( m , n , size , src , m , dst , m )); GPU_PROFILE_END ( profile_transfer , 2.0 * m * n * size ); } void gpu_getmatrix ( int m , int n , int size , void * src , void * dst ) { GPU_PROFILE_BEGIN (); CUDACHECK ( cublasGetMatrix ( m , n , size , src , m , dst , m )); GPU_PROFILE_END ( profile_transfer , 2.0 * m * n * size ); } void gpu_copy ( void * dst , void * src , int size ) { GPU_PROFILE_BEGIN (); CUDACHECK ( cudaMemcpy ( dst , src , size , cudaMemcpyDeviceToDevice )) GPU_PROFILE_END ( profile_dcopy , 2.0 * size ); } __global__ void kernel_sort ( int length , double * val , int * ind ) { const unsigned int idx = blockIdx . x ; int i , tid = threadIdx . x ; __shared__ volatile int shared [ K ]; int w = 0 ; double myValue = val [ idx ]; for ( i = tid ; i < length ; i += K ) { if ( myValue < val [ i ] || ( val [ i ] == myValue && i > idx )) { w ++ ; } } shared [ tid ] = w ; __syncthreads (); if ( K >= 512 ) { if ( tid < 256 ) { shared [ tid ] = w = w + shared [ tid + 256 ]; } __syncthreads (); } if ( K >= 256 ) { if ( tid < 128 ) { shared [ tid ] = w = w + shared [ tid + 128 ]; } __syncthreads (); } if ( K >= 128 ) { if ( tid < 64 ) { shared [ tid ] = w = w + shared [ tid + 64 ]; } __syncthreads (); } if ( tid < 32 ) { if ( K >= 64 ) shared [ tid ] = w = w + shared [ tid + 32 ]; if ( K >= 32 ) shared [ tid ] = w = w + shared [ tid + 16 ]; if ( K >= 16 ) shared [ tid ] = w = w + shared [ tid + 8 ]; if ( K >= 8 ) shared [ tid ] = w = w + shared [ tid + 4 ]; if ( K >= 4 ) shared [ tid ] = w = w + shared [ tid + 2 ]; if ( K >= 2 ) shared [ tid ] = w = w + shared [ tid + 1 ]; } if ( tid == 0 ) ind [ w ] = idx ; } void gpu_sort ( int n , double * Db , int * ipiv ) { // GPU version int blocks = n / K ; if ( n % K ) blocks ++ ; GPU_PROFILE_BEGIN (); kernel_sort <<< n , K >>> ( n , Db , ipiv ); CUDACHECK ( cudaGetLastError ()); GPU_PROFILE_END ( profile_sort , 8.0 * n * n ); } void gpu_init () { if ( ! handle ) CUDACHECK ( cublasCreate ( & handle )); CUDACHECK ( cudaFuncSetCacheConfig ( kernel_normcol , cudaFuncCachePreferL1 )); CUDACHECK ( cudaFuncSetCacheConfig ( kernel_permute , cudaFuncCachePreferL1 )); CUDACHECK ( cudaFuncSetCacheConfig ( kernel_scalerowperm , cudaFuncCachePreferL1 )); CUDACHECK ( cudaFuncSetCacheConfig ( kernel_scalerow , cudaFuncCachePreferL1 )); CUDACHECK ( cudaFuncSetCacheConfig ( kernel_scalerowcol , cudaFuncCachePreferL1 )); CUDACHECK ( cudaFuncSetCacheConfig ( kernel_sort , cudaFuncCachePreferL1 )); } void gpu_shutdown () { if ( handle ) CUDACHECK ( cublasDestroy ( handle )); handle = NULL ; }","tags":"","loc":"sourcefile/kernel_gpu.cu.html"}]}